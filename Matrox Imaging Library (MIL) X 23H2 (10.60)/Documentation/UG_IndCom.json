[{
  "id": "UG_IndCom",
  "version": "2024020714",
  "title": "Industrial communication",
  "subTitles": null,
  "location": "MIL UG P09: Communication",
  "pageURL": "content\\UserGuide\\IndCom\\ChapterInformation.htm",
  "text": " Chapter 57: Industrial communication This chapter describes how to use the MIL Industrial Communication module to communicate information to other devices. Industrial communication overview Steps to perform industrial communication Basic concepts for the MIL Industrial Communication module Industrial communication with robots Calibration considerations Calibration by directly mapping the robot coordinate system to the pixel coordinate system Calibration by indirectly mapping the robot and pixel coordinate systems to the world coordinate system Communicating with a robot Orientation conventions Creating, configuring, and enabling the communication protocol service Industrial communication with PROFINET Setting up the environment Receiving and sending data to the controller Memory modules and their data fields Industrial communication with Modbus Setting up the environment to use the local computer as a Modbus slave Receiving and sending data to the controller as a Modbus slave Data tables and their data fields Setting up the environment to use the local computer as a Modbus controller Reading and writing to slave devices as a Modbus controller Industrial communication with EtherNet/IP Setting up the environment Receiving and sending data to the controller Assemblies and their data fields Explicit communication with another device on an EtherNet/IP network Industrial communication with CC-Link IE Field Basic Setting up the environment Receiving and sending data to the controller Data tables and their data fields ",
  "wordCount": 218,
  "subEntries": [
    {
      "id": "UG_IndCom_Industrial_communication_overview",
      "version": null,
      "title": "Industrial communication overview",
      "subTitles": null,
      "location": "MIL UG P09: Communication",
      "pageURL": "content\\UserGuide\\IndCom\\Industrial_communication_overview.htm",
      "text": " Industrial communication overview The MIL Industrial Communication module allows you to communicate information to other devices, such as robots, programmable logic controllers (PLCs), or I/O controllers. The Industrial Communication module allows you to send and receive data between such devices. For example, in the typical case for applications that communicate with robots, you would wait to receive the robot's current location, and then send a new location for it to move to. Industrial communication overview ",
      "wordCount": 77,
      "subEntries": []
    },
    {
      "id": "UG_IndCom_Steps_to_perform_industrial_communication",
      "version": null,
      "title": "Steps to perform industrial communication",
      "subTitles": null,
      "location": "MIL UG P09: Communication",
      "pageURL": "content\\UserGuide\\IndCom\\Steps_to_perform_industrial_communication.htm",
      "text": " Steps to perform industrial communication The following steps provide a basic methodology for using the MIL Industrial Communication module: For applications communicating with a robot, perform the following steps: Allocate an industrial communication context, using McomAlloc(). The industrial communication context allows you to specify with which type of robot you will be communicating. Wait to receive a request for a new position from the robot using McomWaitPositionRequest(). Perform some analysis and calculate a new position to send back to the robot. Send the new position to the robot using McomSendPosition(). For applications communicating in slave configuration with a controller that uses a communications protocol standard (such as PROFINET), perform the following steps: If required, configure the controller's software so that the controller recognizes the local computer (computer running the MIL application) with the appropriate number of data tables (such as modules, data tables, assemblies). Note that the local computer should have a static IP address. On the local computer, create, configure, and enable an instance of the industrial communication protocol service using the MILConfig utility's Communication item. For more information visit the Creating, configuring, and enabling the communication protocol service section later in this chapter. Allocate an industrial communication context, using McomAlloc(). The industrial communication context allows you to specify with which type of protocol you will be communicating. Read data received from the controller during its last write cycle using the same communications protocol standard (such as PROFINET) as the context, using McomRead(). Perform some analysis and calculate new data to write back to the controller. Write data to be read from the controller during its next read cycle, using McomWrite(). Free your industrial communication context, using McomFree(), unless M_UNIQUE_ID was specified during allocation. Note that if you are using the MIL application in a Modbus master configuration, the steps required to perform industrial communication are similar to that of a slave. To see the differences between the two, see the Setting up the environment to use the local computer as a Modbus controller and the Reading and writing to slave devices as a Modbus controller subsection of the Industrial communication with Modbus section later in this chapter. Note that industrial communication using PROFINET is only available when using a MIL system that has a hardware PROFINET engine (for example, a Matrox Indio system, a Matrox Iris GTX system, or a Host system running on a Zebra 4Sight EV6 or EV7). Steps to perform industrial communication ",
      "wordCount": 409,
      "subEntries": []
    },
    {
      "id": "UG_IndCom_Basic_concepts_for_the_MIL_industrial_communication_module",
      "version": null,
      "title": "Basic concepts for the MIL Industrial Communication module",
      "subTitles": null,
      "location": "MIL UG P09: Communication",
      "pageURL": "content\\UserGuide\\IndCom\\Basic_concepts_for_the_MIL_industrial_communication_module.htm",
      "text": " Basic concepts for the MIL Industrial Communication module The basic concepts and vocabulary conventions for the MIL Industrial Communication module are: Controller. A computer used for automation of industrial applications, such as controlling machinery on assembly lines. Data tables. A data table is the location in which data is stored from which the controller can read, or to which the controller can write data. For the PROFINET protocol, the data tables are known as modules. For the EtherNet/IP protocol, data tables are known as assemblies. For the Modbus protocol, the accepted term is data tables. EtherNet/IP. A communications protocol standard used in industrial applications which uses standard Ethernet technologies. Matrox automation device. The local computer running the MIL application. The controller will communicate with the local computer by reading from and writing to data tables in the local computer's memory. Modbus. A serial communications protocol standard used in industrial applications. PROFINET. A communications protocol standard used in industrial applications with Siemens PLCs. Quaternion. A mathematical notation for representing orientations and rotations of objects in three dimensions. Robot arm. An electromechanical device that consists of a mechanical arm that can typically move along six axes and the electronics that control its movement. Robot controller. A computer connected to the robot arm that sends electrical signals to move the robot arm to the correct location. Robot-side API files. Robot-specific files that need to be included on a robot controller to program the robot-side code necessary to communicate with MIL. Basic concepts for the MIL Industrial Communication module ",
      "wordCount": 257,
      "subEntries": []
    },
    {
      "id": "UG_IndCom_Industrial_communication_with_robots",
      "version": null,
      "title": "Industrial communication with robots",
      "subTitles": [
        "Calibration considerations",
        "Calibration by directly mapping the robot coordinate system to the pixel coordinate system",
        "Calibration by indirectly mapping the robot and pixel coordinate systems to the world coordinate system",
        "Communicating with a robot",
        "Orientation conventions"
      ],
      "location": "MIL UG P09: Communication",
      "pageURL": "content\\UserGuide\\IndCom\\Industrial_communication_with_robots.htm",
      "text": " Industrial communication with robots To communicate with an industrial robot controller, you must allocate an Industrial Communication context using McomAlloc() and specify the communication protocol of the robot controller. A robot controller will typically support multiple robot arm models. The following table outlines the robot controller brands and models supported and how to allocate an Industrial Communication context to communicate with the robot controller. Robot brand Supported robot controller models Allocate context using McomAlloc() with ABB IRC5 M_COM_PROTOCOL_ABB DENSO RC8 M_COM_PROTOCOL_DENSO Epson RC420+, RC520+ M_COM_PROTOCOL_EPSON Fanuc LRMate200iC, LRMate200iD M_COM_PROTOCOL_FANUC KUKA KR C2 M_COM_PROTOCOL_KUKA Staubli CS8, CS8C HP, CS9 M_COM_PROTOCOL_STAUBLI Before a MIL application can exchange information with a robot, you need to install the appropriate robot-side API files, located in the %MILINSTALLPATH%\\MIL\\Config\\Robots folder, on your robot controller. The robot-side API files provide the required functionality necessary to write specialized code to interface the robot controller with MIL. The commands are specific to the brand of robot controller that you have. For full documentation on how to install the robot-side API files on your robot controller, and an explanation of the Matrox commands to include in the robot-side code, see Matrox Robot-side Communication API. This documentation, along with the installation files and example code, are all found on your computer in the %MILINSTALLPATH%\\MIL\\Config\\Robots folder. Calibration considerations For a MIL application and a robot controller to properly exchange position information, a mapping between the pixel and robot coordinate systems (robot base coordinate system) must be made. To do so, you must perform a camera calibration. Robotic applications typically use one of two methods to provide camera calibration mappings. One method directly links the robot's coordinate system to the pixel coordinate system; the other method indirectly links the robot's coordinate system to the pixel coordinate system by linking each to the absolute coordinate system. Legend: Marker Description A Origin of the absolute coordinate system B Camera field of view C Origin of robot base coordinate system D Pixel coordinate system Calibration by directly mapping the robot coordinate system to the pixel coordinate system When there is little distortion in your images, it is typically most efficient to link the pixel coordinate system directly to the robot coordinate system. When using this method, you pass new positions to the robot controller directly in the robot coordinate system. You don't need to change the reference frame of the robot controller. In this case, you must know the position of your calibration points in the robot's coordinate system (and in the pixel coordinate system) and calibrate using McalList(). Legend: Marker Description A Origin of the absolute coordinate system B Camera field of view C Origin of robot base coordinate system D Pixel coordinate system A minimum of three to seven calibration points are required, depending on the camera calibration mode. Passing more calibration points than the minimum allows the camera calibration to compensate for non-linear robot travel across the work area (the robot moves to a specified point with repeatability, but that point might not be the exact point you wanted it to move to). Use the origin and axes of the robot coordinate system as the origin and axes of the absolute coordinate system. This means that when you specify your calibration points, you do so with respect to the robot coordinate system. The calibration points do not need to come from a camera calibration grid. You can use any set of known positions, as found on a reference work piece or jig for example. For best accuracy, include locations from the outer limits of the work area. For example, if the object or part is in a box, include the corners of the box as some of the calibration points. The following are the steps required to perform a camera calibration that directly links the robot and pixel coordinate systems: Establish a minimum of three to seven calibration points, depending on the camera calibration mode. Use the robot controller to move the robot to each point and note the coordinates that the robot controller returns for each point. Allocate a camera calibration context using McalAlloc(). Use McalList() to map each of the calibration points in pixel coordinates to robot coordinates. For more information about camera calibration using a list of coordinates, see the Calibrating using calibration points from a list section of Chapter 28: Calibrating your camera setup. The direction of the Y-axis and the Z-axis are automatically established from the specified calibration points. In instances where the camera is directly attached to the end point (tool) of the robot arm, you can use the 3D camera calibration mode (M_3D_ROBOTICS) to relate the pixel coordinate system to the robot base coordinate system without the latter being equivalent to the absolute coordinate system. When using this 3D camera calibration, you can pass positional and rotational data to the robot controller also in the tool coordinate system; however, there must be a rigid link between the camera and the tool. Legend: Marker Description A Origin of the absolute coordinate system. B Camera field of view from which image is captured C Origin of the relative coordinate system D Origin of the tool coordinate system E Origin of the camera coordinate system F Origin of robot base coordinate system G Pixel coordinate system For more information on calibrating using M_3D_ROBOTICS, see the Robotics mode subsection of the 3D camera calibration modes section of Chapter 28: Calibrating your camera setup. Calibration by indirectly mapping the robot and pixel coordinate systems to the world coordinate system When there is large distortion in your images, it is typically most efficient to map the pixel coordinate system to the robot coordinate system indirectly. When using this method, you pass new positions to the robot controller with respect to some other position, and you must displace the robot's reference frame to this new position. Legend: Marker Description A Origin of the absolute coordinate system B Camera field of view C Origin of robot base coordinate system D Pixel coordinate system When using this method, the camera and robot maintain independent mappings of the working area. You specify the location of the origin and axes of the absolute coordinate system both in the pixel coordinate system using MIL and in the robot coordinate system using the robot controller's software that defines its reference frame. This method is quick and easy to implement, but relies on the assumption that MIL and the robot controller return accurate coordinates in the working area. Use McalList() to calibrate using a list of at least three to seven calibration points, depending on the camera calibration mode. You can also use McalGrid() to calibrate using a grid. You should calibrate using a grid if there are distortions in your image. The following are the steps suggested to perform a camera calibration that indirectly links the robot and pixel coordinate systems using a grid: Grab an image of the camera calibration grid. This image must be representative of the work area to be calibrated. Allocate a camera calibration context using McalAlloc(). Calibrate the camera using McalGrid(). You can use McalGrid() with M_Y_AXIS_COUNTER_CLOCKWISE so that the Y-axis and the Z-axis are pointing up (unlike in the image above). For more information on how to calibrate using a grid, see the Calibrating using calibration points from a grid section of Chapter 28: Calibrating your camera setup. Move the robot arm to the dot selected to be the origin of the absolute coordinate system. Inquire the position of this origin point in the robot's coordinate system using the robot controller. Move the robot to the center of the next dot in the X-direction and record its position. Repeat for the adjacent dot in the Y-direction. Use the coordinate system definition tool of the robot controller to specify the new reference frame for the robot. As was previously mentioned, this method is the fastest way to calibrate when large distortions in your image play a factor, because a very large number of calibration points can be included. It is assumed that the robot can very accurately hit the center of any position on the grid based on its row and column position, and therefore this camera calibration method does not require you to collect and record the robot position for all the points. Communicating with a robot When communicating with a robot controller, your MIL application should typically wait for the robot controller to request a new position (for example, the location of the next item to pick up), using McomWaitPositionRequest(). When a request is received, your MIL application should grab an image of the item and perform the required analysis to establish the item's position. It should then send the new position to the robot controller using McomSendPosition(). A position for a robot controller consists of six values: X-position, Y-position, Z-position, rotation around X, rotation around Y, and rotation around Z. For more advanced applications involving multiple object-part types in the camera's field of view, the McomWaitPositionRequest() function can receive from the robot-side application a user-defined number (ObjectSpecifierPtr) that identifies the part or object that the MIL application should locate. Similarly, for applications where multiple occurrences of objects might be present in the field of view, your MIL application should send the robot-side application the user-defined number (ObjectSpecifier) that identifies the object for which it is sending the position. Orientation conventions The different rotations about positional axes are represented differently by the robot controllers of various robot manufacturers. The following table shows the notation used for each rotational axis by the robot controller when it displays positional information. Robot type Robot controller representation Rotation about the X-axis Rotation about the Y-axis Rotation about the Z-axis ABB The orientation is converted by the robot controller to a quaternion. DENSO Roll Pitch Yaw Epson W V U Fanuc W P R KUKA C B A Staubli Rx Ry Rz Industrial communication with robots Calibration considerations Calibration by directly mapping the robot coordinate system to the pixel coordinate system Calibration by indirectly mapping the robot and pixel coordinate systems to the world coordinate system Communicating with a robot Orientation conventions ",
      "wordCount": 1686,
      "subEntries": []
    },
    {
      "id": "UG_IndCom_Creating_configuring_and_enabling_the_communication_protocol_service",
      "version": null,
      "title": "Creating, configuring, and enabling the communication protocol service",
      "subTitles": null,
      "location": "MIL UG P09: Communication",
      "pageURL": "content\\UserGuide\\IndCom\\Creating_configuring_and_enabling_the_communication_protocol_service.htm",
      "text": " Creating, configuring, and enabling the communication protocol service The MIL Industrial Communication module allows one or more controllers to communicate with MIL applications running on a single computer. This is done by creating, configuring, and enabling instances of the industrial communication protocol service, along with creating and running the MIL applications. Typically, you have a single controller communicating with your local computer. In this case, you need to create, configure, and enable a single instance of the required industrial communication protocol service, using the Communication page of the MILConfig utility on the runtime platform. If you want multiple controllers communicating with MIL applications running on a single computer, you need to create, configure, and enable as many instances of the protocol service as controllers. To enable multiple Industrial Communication instances, repeat the steps to perform industrial communication as many times as required for each instance. To specify the instance with which your MIL application should communicate, pass the instance name to the DeviceDescription parameter of McomAlloc() when allocating the industrial communication context. Note that, industrial communication protocol instance names are case sensitive. Each instance of the protocol service has its own data tables and an interface setting that indicates the NIC or serial port (depending on the protocol) on which to communicate. Typically, each instance should use its own separate and unique network interface (NIC) or serial port. Note that some NICs have several interfaces (for example, Matrox Concord PoE). When using the EtherNet/IP and Modbus industrial protocols, it can be possible to use virtual NICs (virtual interfaces), with Microsoft Windows 10. In this case, you can create multiple virtual NICs on 1 physical NIC. You can then use a virtual NIC when specifying the interface for your instance. Note that, once you use the physical interface for an instance, you cannot then create virtual interfaces on that NIC. You should typically use the following settings depending on the industrial protocol: For EtherNet/IP, set the sizes of the Producer and Consumer assemblies to values higher than the highest address in your data map plus the size of that data field (for example, if your project will write a byte of data to the PLC at the address 92, set the Consumer assembly size to 93). The maximum assembly size supported is 1502. For PROFINET, set the sizes of the Input and Output modules to the next available value higher than the highest address in your data map plus the size of that data field (for example, if your project will write a byte of data to the PLC at the address 92, the minimum size required is 93 so you should set the Output module size to 128). For CC-Link, set the Number of stations to a value between 1 and 16, depending on your project setup. Once the protocol instance is added, the status of the protocol instance should be Ready. If the status is Waiting NIC, there is no cable connected to the NIC. Note that to enable multiple instances of the PROFINET protocol service on a computer, the computer requires a PROFINET engine (for example, a Matrox Indio board) for each Industrial Communication instance you enable. Creating, configuring, and enabling the communication protocol service ",
      "wordCount": 539,
      "subEntries": []
    },
    {
      "id": "UG_IndCom_Industrial_communication_with_Profinet",
      "version": null,
      "title": "Industrial communication with PROFINET",
      "subTitles": [
        "Setting up the environment",
        "Receiving and sending data to the controller",
        "Memory modules and their data fields"
      ],
      "location": "MIL UG P09: Communication",
      "pageURL": "content\\UserGuide\\IndCom\\Industrial_communication_with_Profinet.htm",
      "text": " Industrial communication with PROFINET MIL supports communication with the PROFINET industrial protocol. PROFINET is an industrial communication standard for connecting devices together, and it defines a communication protocol that allows interaction between devices used in industrial automation processes. Information is received or transmitted through the computer's (or smart camera's) Ethernet port that has access to a Matrox PROFINET Engine. When using this protocol with MIL, your Matrox PROFINET Engine is considered to be a slave in the network, while the PROFINET controller (for example, a PLC) is considered the master. Note that industrial communication using PROFINET is only available when using a MIL system that has a hardware PROFINET engine; for example, a Matrox Indio system, a Matrox Iris GTX system, or a Host system running on a Zebra 4Sight EV6 or EV7. Setting up the environment To use the PROFINET industrial communication protocol with your MIL application, you need to set up the environment on the PROFINET controller's side and on the local computer's side. You must configure your PROFINET controller to recognize the local computer as a Matrox PROFINET automation device. To do so, use the Siemens Totally Integrated Automation Portal (TIA) and specify the local computer's IP address. The local computer's IP address should be static. In addition, use the provided GSD file, and specify the number and size of input and output modules (data tables) that the PROFINET controller should expect your computer to have. The GSD file can be found in Matrox Imaging\\MIL\\Config\\Profinet of your installation directory. The PROFINET controller sends or receives data to/from the local computer through output and input modules in the computer's local memory, respectively. The default module size for the PROFINET implementation in MIL is 64 bytes. The required size is dependent on the information you intend to store in these modules. See the Memory modules and their data fields subsection of this section for more information. The designation of input and output modules is from the perspective of the PROFINET controller. The PROFINET protocol states that data which the PROFINET controller receives is stored in an input module, and data sent by a PROFINET controller is stored in an output module. Once the PROFINET controller has been configured to recognize the local computer as a Matrox PROFINET automation device, you must enable the PROFINET protocol service using the MILConfig utility's Communication item. Then, if the local computer has multiple network adapters with access to a Matrox PROFINET Engine, use the Interface item to specify which should be used. Now, when you reboot your PROFINET controller, it will recognize your local computer as a Matrox PROFINET automation device with the modules specified. Receiving and sending data to the controller To communicate with the PROFINET controller, allocate an Industrial Communication context using McomAlloc() with M_COM_PROTOCOL_PROFINET. To send data to the PROFINET controller, use the McomWrite() function and specify the M_COM_PROTOCOL_PROFINET Industrial Communication context that you have just allocated. In this case, this function actually writes to the local computer's memory the data to send to the PROFINET controller during the controller's next read cycle. To read data received from the PROFINET controller, use the McomRead() function and specify the M_COM_PROTOCOL_PROFINET Industrial Communication context. In this case, this function actually reads the local computer's memory for data received from a PROFINET controller during the PROFINET controller's last write cycle. So when you call McomWrite() / McomRead(), you must specify the module in which to write, or from which to read. PROFINET is a polling protocol and as such, it should be noted that whatever is written to an input module might not be read by the PROFINET controller if another McomWrite() operation occurs before the PROFINET controller's read cycle is completed. You can, for example, use McomRead() to receive a request from a PROFINET controller to grab and analyze an image, and then return the analysis results, necessary for the automation process, back to the PROFINET controller using McomWrite(). Memory modules and their data fields The MIL Industrial Communication module is very flexible, knowing that different applications need to send/receive different information to/from the PROFINET controller. As such, it allows you to establish the number of input/output modules to make available to the PROFINET controller, and how to divide these into different data fields (register fields). For example, you could specify in the Siemens TIA portal that there are 2 (PROFINET controller) input modules, and 2 (PROFINET controller) output modules, and organize your data in these modules as follows: Controller status output module (PLC writes to this module): PLC ready bit. The PLC should set this bit when it's ready for production. PLC error bit. The PLC should set this bit when it is in an error state. PLC reset bit. The PLC should set this bit when it is about to be reset. Application control output module (PLC writes to this module): Trigger bit. The PLC should set this bit when it wants the MIL application to initiate a grab and process operation. Result acknowledge bit. The PLC should set this bit when it acknowledges that it has received a result from a grab and process operation. Status input module (PLC reads from this module): Success bit. The MIL application should set this bit when the grab and processing was successful. Failure bit. The MIL application should set this bit when the grab and processing was not successful. Error bit. The MIL application should set this bit when there was an error in the grab and processing operations. Project running bit. The MIL application should set this bit while a grab and process operation is in progress. Success number bits. The MIL application should set these bits to identify the number of successful operations. Failure number bits. The MIL application should set these bits to identify the number of failed operations. Note that this is only an example of how you can organize your data in the modules. In addition, the software running on the PROFINET controller (for example, a ladder logic software) must be aware of how the data is organized in the modules. Industrial communication with PROFINET Setting up the environment Receiving and sending data to the controller Memory modules and their data fields ",
      "wordCount": 1037,
      "subEntries": []
    },
    {
      "id": "UG_IndCom_Industrial_communication_with_Modbus",
      "version": null,
      "title": "Industrial communication with Modbus",
      "subTitles": [
        "Setting up the environment to use the local computer as a Modbus slave",
        "Receiving and sending data to the controller as a Modbus slave",
        "Data tables and their data fields",
        "Setting up the environment to use the local computer as a Modbus controller",
        "Reading and writing to slave devices as a Modbus controller"
      ],
      "location": "MIL UG P09: Communication",
      "pageURL": "content\\UserGuide\\IndCom\\Industrial_communication_with_Modbus.htm",
      "text": " Industrial communication with Modbus MIL supports communication with the Modbus industrial communication protocol. Modbus is an industrial communication standard for connecting devices together, and it defines a communication protocol that allows interaction between devices used in industrial automation processes. This information is received or transmitted through the computer's (or smart camera's) 100 Mbit/1 Gbit Ethernet port or serial port (COM port). The MIL implementation of the Modbus protocol allows you to designate the local computer (or smart camera) running MIL as being either a master (Matrox Modbus automation controller) or a slave (Matrox Modbus automation device) in the network topology. Setting up the environment to use the local computer as a Modbus slave To use the Modbus industrial communication protocol with your MIL application, you need to set up the environment on the Modbus controller's side and on the local computer's side. You must configure the Modbus controller (using its appropriate software package) to recognize the local computer as a slave device. Configure the Modbus controller with a user-defined identifier for the local computer. The identifier that you select must be unique on the network (that is, does not conflict with another device's ID). If using Modbus TCP, also configure the Modbus controller with the local computer's IP address; the local computer's IP address should be static. Once the Modbus controller has been configured to recognize the local computer as a slave, you must enable and configure an instance of the Modbus protocol service using the MILConfig utility's Communication item. You must select the communication type for your network, and the mode in which the local computer will be running (in this case, slave). The Modbus types supported in the MIL implementation of the protocol are as follows, and should correspond to that used on the network: Modbus ASCII. Modbus Remote Terminal Unit (RTU). Modbus TCP. You must set the ID item to the user-defined identifier that you associated with the local computer when configuring the Modbus controller. If you select the communication type to be either ASCII or RTU, you must also select the serial port on the local computer from which to communicate (COM port), baud rate, parity (odd or even), stop bits (1 or 2), and the serial communication standard used (RS232 or RS485). If you select the communication type to be TCP, and you have multiple network adapters in your computer, you must also configure the Interface item, otherwise you can use the default selection. Receiving and sending data to the controller as a Modbus slave Once the instance of the Modbus communication protocol service has been enabled and configured using the MILConfig utility, you can allocate an Industrial Communication context for use with Modbus (McomAlloc() with M_COM_PROTOCOL_MODBUS) and use the McomWrite() and McomRead() functions to communicate with the Modbus controller. Note that when you set the local computer as a slave device, McomWrite() actually writes to data tables in local memory the data to send to the Modbus controller on its next read cycle. Similarly, as a slave device, McomRead() actually reads the data tables in local memory for data received from the Modbus controller during its last write cycle. So, when you call McomWrite() / McomRead(), you must specify the data table to write/read. The Modbus data tables are created in local memory when the Modbus service is enabled and configured to be in slave mode, using the MILConfig utility. The supported Modbus data tables are: M_COILS. M_DISCRETE_INPUT. M_HOLDING_REGISTER. M_INPUT_REGISTER. The coil and discrete input data tables support 1-bit data, while the input and holding register data tables support 16-bit data. The Modbus controller can write to either the coil or the holding register data tables, and can read from all the data tables. As such, you should expect new data received from the Modbus controller in the coil (M_COILS) and holding register (M_HOLDING_REGISTER) data tables. The local computer can write to any of the four data tables. You can, for example, use McomRead() to receive a request from a Modbus controller to grab and analyze an image, and then return the analysis results, necessary for the automation process, back to the Modbus controller using McomWrite(). Data tables and their data fields The MIL Industrial Communication module is very flexible, knowing that different applications need to send/receive different information to/from the Modbus controller. As such, it allows you to establish how to divide these data tables into different data fields (register fields). For example, you could organize your data as follows: Holding register data table (the controller writes to this module): PLC ready bit. The PLC should set this bit when it's ready for production. PLC error bit. The PLC should set this bit when it is in an error state. PLC reset bit. The PLC should set this bit when it is about to be reset. Trigger bit. The PLC should set this bit when it wants the MIL application to initiate a grab and process operation. Result acknowledge bit. The PLC should set this bit when it acknowledges that it has received a result from a grab and process operation. Input register data table (the controller reads from this module): Success bit. The MIL application should set this bit when the grab and processing was successful. Failure bit. The MIL application should set this bit when the grab and processing was not successful. Error bit. The MIL application should set this bit when there was an error in the grab and processing operations. Project running bit. The MIL application should set this bit while a grab and process operation is in progress. Success number bits. The MIL application should set these bits to identify the number of successful operations. Failure number bits. The MIL application should set these bits to identify the number of failed operations. Note that this is only an example of how you can organize your data in the data tables. In addition, the software running on the Modbus controller (for example, a ladder logic software) must be aware of how the data is organized in the data tables. Setting up the environment to use the local computer as a Modbus controller When the local computer running MIL is using the Modbus protocol in a master configuration that uses TCP, you must configure the Interface item in the MILConfig utility to the network adapter that should be used to communicate. For better performance, you can also specify all the devices on the Modbus network in the MILConfig utility; in this case, for every slave device on the Modbus network, specify their Slave IDs and their IP addresses in the MILConfig utility. When the local computer running MIL in a master configuration is not using the TCP protocol (that is, ASCII or RTU), you must select the serial port on the local computer from which to communicate (COM port), baud rate, parity (odd or even), stop bits (1 or 2), and the serial communication standard used (RS232 or RS485). Reading and writing to slave devices as a Modbus controller If the local computer is configured as a master device (controller), it can only write to a slave device's coils or holding registers. The local computer can read from any of the slave device's four data tables listed in the previous section. When reading or writing data to a slave device on a Modbus TCP network, you must specify both the device's slave ID and its IP address, along with the data table with which you intend to communicate. When reading or writing data to a slave device on a Modbus ASCII or RTU network, you must only specify the device's slave ID, along with the data table with which you intend to communicate. The function codes that MIL uses to read and write to a slave device, when the local computer is a controller, are as follows: Data table Read Write Coil 01 15 Discrete Input 02 N/A Input Register 04 N/A Holding Register 03 16 Industrial communication with Modbus Setting up the environment to use the local computer as a Modbus slave Receiving and sending data to the controller as a Modbus slave Data tables and their data fields Setting up the environment to use the local computer as a Modbus controller Reading and writing to slave devices as a Modbus controller ",
      "wordCount": 1385,
      "subEntries": []
    },
    {
      "id": "UG_IndCom_Industrial_communication_with_EthernetIP",
      "version": null,
      "title": "Industrial communication with EtherNet/IP",
      "subTitles": [
        "Setting up the environment",
        "Receiving and sending data to the controller",
        "Assemblies and their data fields",
        "Explicit communication with another device on an EtherNet/IP network"
      ],
      "location": "MIL UG P09: Communication",
      "pageURL": "content\\UserGuide\\IndCom\\Industrial_communication_with_EthernetIP.htm",
      "text": " Industrial communication with EtherNet/IP MIL supports communication with the EtherNet/IP industrial communication protocol. EtherNet/IP is an industrial communication standard for connecting devices together, and it defines a communication protocol that allows interaction between devices used in industrial automation processes. This information is received or transmitted through the computer's (or smart camera's) 100 Mbit/1 Gbit Ethernet port. When using this protocol with MIL, your local computer is considered to be an adapter (equivalent to slave) in the network, and the EtherNet/IP controller (typically a PLC) is typically considered to be the scanner (equivalent to master). Setting up the environment To use the EtherNet/IP industrial communication protocol with your MIL application, you need to set up the environment on the EtherNet/IP controller's side and on the local computer's side. You must configure the EtherNet/IP controller (using its appropriate software package) to recognize the local computer as a slave device. You must also configure the EtherNet/IP controller with the local computer's IP address; the local computer's IP address should be static. An EDS file is provided and can be found in Matrox Imaging\\MIL\\Config\\EthernetIP of your installation directory. Once the EtherNet/IP controller has been configured to recognize the local computer as an Matrox EtherNet/IP automation device, you must enable the EtherNet/IP protocol service using the MILConfig utility's Communication item. Then, if the local computer has multiple network adapters, use the Interface item to specify which should be used. The default assembly size on the local computer is 64 bytes, but can be changed in the MILConfig utility. Receiving and sending data to the controller To communicate with the EtherNet/IP controller, allocate an Industrial Communication context using McomAlloc() with M_COM_PROTOCOL_ETHERNETIP. To send data to the EtherNet/IP controller, use the McomWrite() function and specify the M_COM_PROTOCOL_ETHERNETIP Industrial Communication context that you have just allocated. The McomWrite() function actually writes to the local computer's assemblies the data to send to the EtherNet/IP controller on its next read cycle. To read data received from the EtherNet/IP controller, use the McomRead() function and specify the M_COM_PROTOCOL_ETHERNETIP Industrial Communication context. The McomRead() function actually reads the local computer's assemblies for data received from the EtherNet/IP controller during its last write cycle. So when you call McomWrite() / McomRead(), you must specify the assembly in which to write, or from which to read. The EtherNet/IP assemblies are created in local memory when the EtherNet/IP service is enabled and configured using the MILConfig utility. The supported assemblies on the local computer that can be accessed from the MIL application are: M_COM_ETHERNETIP_CONSUMER. M_COM_ETHERNETIP_PRODUCER. M_COM_ETHERNETIP_CONFIG. EtherNet/IP is a polling protocol (implicit producer) and as such, it should be noted that whatever is written to a local memory assembly (using McomWrite() with M_COM_ETHERNETIP_PRODUCER) might not be read by the EtherNet/IP controller if another McomWrite() operation occurs before the EtherNet/IP controller's read cycle is completed. You can, for example, use McomRead() to receive a request from a EtherNet/IP controller to grab and analyze an image, and then return the analysis results, necessary for the automation process, back to the EtherNet/IP controller using McomWrite(). Assemblies and their data fields The MIL Industrial Communication module is very flexible, knowing that different applications need to send/receive different information to/from the EtherNet/IP controller. As such, it allows you to establish how to divide the assemblies into different data fields (register fields). For example, you could organize data for your consumer and producer assemblies as follows: Consumer assembly: PLC ready bit. The PLC should set this bit when its ready for production. PLC error bit. The PLC should set this bit when it is in an error state. PLC reset bit. The PLC should set this bit when it is about to be reset. Trigger bit. The PLC should set this bit when it wants the MIL application to initiate a grab and process operation. Result acknowledge bit. The PLC should set this bit when it acknowledges that it has received a result from a grab and process operation. Producer assembly: Success bit. The MIL application should set this bit when the grab and processing was successful. Failure bit. The MIL application should set this bit when the grab and processing was not successful. Error bit. The MIL application should set this bit when there was an error in the grab and processing operations. Project running bit. The MIL application should set this bit while a grab and process operation is in progress. Success number bits. The MIL application should set these bits to identify the number of successful operations. Failure number bits. The MIL application should set these bits to identify the number of failed operations. Note that this is only an example of how you can organize your data in the assemblies. In addition, the software running on the EtherNet/IP controller (for example, a ladder logic software) must be aware of how the data is organized in the assemblies. Explicit communication with another device on an EtherNet/IP network The only time when the local computer needs to know the IP address of another device is when connecting as an Unconnected Message Manager (UCMM) to configure a setting of another EtherNet/IP device on the network. While explicit communication using TCP is supported, the EtherNet/IP standard intends for this type of connection to be used to configure other devices, and not as a primary method of consuming data from a producing device. To configure or read a setting of a device on the network, you must specify the following when calling McomWrite() / McomRead(): \"mcom://[RemoteIP/]AssemblyID\". In theory, you could explicitly consume data from another device by specifying its IP address and the device's relevant assembly ID, but this method will be slower than using implicit messaging. The EtherNet/IP protocol recommends to produce and consume data in an implicit manner. Implicit connections in EtherNet/IP are performed using the User Datagram Protocol (UDP). Industrial communication with EtherNet/IP Setting up the environment Receiving and sending data to the controller Assemblies and their data fields Explicit communication with another device on an EtherNet/IP network ",
      "wordCount": 1001,
      "subEntries": []
    },
    {
      "id": "UG_IndCom_Industrial_communication_with_CC_Link_IE_Field_Basic",
      "version": null,
      "title": "Industrial communication with CC-Link IE Field Basic",
      "subTitles": [
        "Setting up the environment",
        "Receiving and sending data to the controller",
        "Data tables and their data fields"
      ],
      "location": "MIL UG P09: Communication",
      "pageURL": "content\\UserGuide\\IndCom\\Industrial_communication_with_CC_Link_IE_Field_Basic.htm",
      "text": " Industrial communication with CC-Link IE Field Basic MIL supports communication with the CC-Link IE Field Basic industrial communication protocol. CC-Link IE Field Basic is an industrial communication standard for connecting devices together, and it defines a communication protocol that allows interaction between devices used in industrial automation processes. This information is received or transmitted through the computer's (or smart camera's) 100 Mbit/1 Gbit Ethernet port. When using this protocol with MIL, your local computer is considered to be a slave in the network, and the CC-Link IE Field Basic controller (typically a PLC) is considered to be the master. Setting up the environment To use the CC-Link IE Field Basic industrial communication protocol with your MIL application, you need to set up the environment on the CC-Link IE Field Basic controller's side and on the local computer's side. You must configure your CC-Link IE Field Basic controller to recognize the local computer as a slave device. To do so, use appropriate configuration software such as Mitsubishi GX Works and specify the local computer's IP address. The local computer's IP address should be static. In addition, you can use the provided CSPP profile, and specify the number of stations that your computer will occupy (this determines the size of the data tables you can read from and write to). The CSPP profile can be found as a ZIP file in Program Files\\Matrox Imaging\\MIL\\Config\\CCLink. The provided CSPP profiles are specific to your platform type, and the MIL version installed on your computer; if you later update your computer to use a new version of MIL, you must load the new CSPP profile for that version. The table below lists the ZIP file that stores the CSPP profile required for each platform: System type/Host platform ZIP file Matrox Iris GTX 0x0E0B_Iris_GTX_1.0.0_en.CSPP.zip Zebra 4Sight EV6 0x0E0B_4Sight_EV6_1.0.0_en.CSPP.zip Zebra 4Sight EV7 0x0E0B_4Sight_EV7_1.0.0_en.CSPP.zip Other PC 0x0E0B_Generic_PC_1.0.0_en.CSPP.zip Typically, you should not unzip the CSPP profile. Once the CC-Link IE Field Basic controller has been configured to recognize the local computer as a slave, you must enable and configure an instance of the CC-Link IE Field Basic protocol service using the MILConfig utility's Communication item. If the local computer has multiple network adapters, use the Interface item to specify which should be used. Use the Number of stations item to specify how many stations on the controller your application will use (if you are using the provided CSPP profile for your platform, you must set this to 4). Receiving and sending data to the controller To communicate with the CC-Link IE Field Basic controller, allocate an Industrial Communication context using McomAlloc() with M_COM_PROTOCOL_CCLINK. To send data to the CC-Link IE Field Basic controller, use the McomWrite() function and specify the M_COM_PROTOCOL_CCLINK Industrial Communication context that you have just allocated. The McomWrite() function actually writes the data to the local computer's data tables; the data stored in these tables is read by the CC-Link IE Field Basic controller on its next read cycle. To read data received from the CC-Link IE Field Basic controller, use the McomRead() function and specify the M_COM_PROTOCOL_CCLINK Industrial Communication context. The McomRead() function actually reads the data from the local computer's data tables; the data stored in these data tables is written by the CC-Link IE Field Basic controller during its write cycle. When you call McomWrite() / McomRead(), you must specify the data table in which to write, or from which to read. The CC-Link IE Field Basic data tables are created in local memory when an instance of the CC-Link IE Field Basic service is enabled using the MILConfig utility. The supported CC-Link IE Field Basic data tables are: M_COM_CCLINK_INPUT_FLAG. M_COM_CCLINK_INPUT_REGISTER. M_COM_CCLINK_OUTPUT_FLAG. M_COM_CCLINK_OUTPUT_REGISTER. The flag data tables support 1-bit data, while the register data tables support 16-bit data. CC-Link IE Field Basic is a polling protocol and as such, it should be noted that whatever is written to an input data table might not be read by the CC-Link controller if another McomWrite() operation occurs before the CC-Link IE Field Basic controller's read cycle is completed. Data tables and their data fields The MIL Industrial Communication module is very flexible, knowing that different applications need to send/receive different information to/from the CC-Link IE Field Basic controller. As such, it allows you to establish how to divide these data tables into different data fields. For example, you could organize your data as follows: Output flag data table (the controller writes to this data table): PLC ready bit. The PLC should set this bit when it is ready for production. PLC error bit. The PLC should set this bit when it is in an error state. PLC reset bit. The PLC should set this bit when it is about to be reset. Trigger bit. The PLC should set this bit when it wants the MIL application to initiate a grab and process operation. Result acknowledge bit. The PLC should set this bit when it acknowledges that it has received a result from a grab and process operation. Input flag data table (the controller reads from this module): Success bit. The MIL application should set this bit when the grab and processing was successful. Failure bit. The MIL application should set this bit when the grab and processing was not successful. Error bit. The MIL application should set this bit when there was an error in the grab and processing operations. Project running bit. The MIL application should set this bit while a grab and process operation is in progress. Success number bits. The MIL application should set these bits to identify the number of successful operations. Failure number bits. The MIL application should set these bits to identify the number of failed operations. Note that this is only an example of how you can organize your data in the data tables. In addition, the software running on the CC-Link IE Field Basic controller (for example, a ladder logic software) must be aware of how the data is organized in the data tables. Industrial communication with CC-Link IE Field Basic Setting up the environment Receiving and sending data to the controller Data tables and their data fields ",
      "wordCount": 1023,
      "subEntries": []
    }
  ]
}]
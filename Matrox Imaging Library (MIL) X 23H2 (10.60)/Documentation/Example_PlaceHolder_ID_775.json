[{
  "id": "Example_PlaceHolder_ID",
  "version": "2024020714",
  "title": "Example_PlaceHolder_Title",
  "wordCount": 0,
  "subEntries": [
    {
      "id": "Examples_Processing_PatternMatching_AgmLabelingTool_CPP_agmlabelingtool_cpp",
      "version": "2024020714",
      "title": "agmlabelingtool.cpp",
      "location": "Sample Code from MIL Examples",
      "text": " Top //************************************************************************************* // // File name: AgmLabelingTool.cpp // Location: See Matrox Example Launcher in the MIL Control Center // // // Synopsis: This program uses interactive MIL graphics to label images compatible // with the AGM training input format. // // // Copyright (C) Matrox Electronic Systems Ltd., 1992-2024. // All Rights Reserved //************************************************************************************* #include \"util.h\" #include \"buttons.h\" #include \"labelingtool.h\" #include \"labelingtoolcontroller.h\" // =========================================================================== // Input and output paths. // =========================================================================== static const MIL_STRING OUTPUT_FOLDER = MIL_TEXT(\".\\\\\"); static const MIL_STRING IMAGES_FOLDER = MIL_STRING(M_IMAGE_PATH) + MIL_TEXT(\"\\\\PhotometricStereoWithMotion\\\\\"); static const MIL_STRING IMAGE_FORMAT = MIL_TEXT(\"*.mim\"); static const MIL_STRING CONTAINER_PATH = OUTPUT_FOLDER + MIL_TEXT(\"TrainContainer.mbufc\"); static const MIL_STRING MODEL_PATH = OUTPUT_FOLDER + MIL_TEXT(\"Model.mim\"); // =========================================================================== // Tool description. // =========================================================================== void PrintHeader() { MosPrintf( MIL_TEXT(\"[EXAMPLE NAME]\\n\") MIL_TEXT(\"AgmLabelingTool\\n\\n\") MIL_TEXT(\"[SYNOPSIS]\\n\") MIL_TEXT(\"This interactive tool helps you label images according \\n\") MIL_TEXT(\"to the AGM training input.\\n\") MIL_TEXT(\"The first step allows you to select your model. \\n\") MIL_TEXT(\"The second step allows you to label the training images \\n\") MIL_TEXT(\"by adding positive (blue box) and negative (red box) samples \\n\") MIL_TEXT(\"with the same size as your selected model.\\n\") MIL_TEXT(\"To confirm the model selection or a labeling, press \\\"Validate\\\".\\n\\n\") MIL_TEXT(\"[INPUTS]\\n\") MIL_TEXT(\"A folder that contains all training images to label in the same file format (%s).\\n\\n\") MIL_TEXT(\"[OUTPUTS]\\n\") MIL_TEXT(\"1. A model.\\n\") MIL_TEXT(\"2. A container buffer with all labeled training images.\\n\\n\") MIL_TEXT(\"[MODULES USED]\\n\") MIL_TEXT(\"Modules used: Application, System, Display, Buffer, Graphics. \\n\\n\"), IMAGE_FORMAT.c_str()); } //=================================================================================== //! bool Press1ForFalseOr2ForTrue(MIL_CONST_TEXT_PTR Choice1, MIL_CONST_TEXT_PTR Choice2) { MosPrintf(MIL_TEXT(\"1. \")); MosPrintf(Choice1); MosPrintf(MIL_TEXT(\"\\n\\n\")); MosPrintf(MIL_TEXT(\"2. \")); MosPrintf(Choice2); MosPrintf(MIL_TEXT(\"\\n\\n\")); while(1) { char KeyVal = (char)MosGetch(); if(KeyVal == '1') { return false; } else if(KeyVal == '2') { return true; } else { MosPrintf(MIL_TEXT(\" Invalid option : Select '1' or '2'.\\n\\n\")); } } } //============================================================================== //! MIL_UNIQUE_BUF_ID SelectModelImage(MIL_ID MilSystem) { bool SelectNewModel {true}; MIL_INT ModelAlreadyExist {0}; MappFileOperation(M_DEFAULT, MODEL_PATH, M_NULL, M_NULL, M_FILE_EXISTS, M_DEFAULT, &amp;ModelAlreadyExist); if(ModelAlreadyExist == M_YES) { MosPrintf(MIL_TEXT(\"A model image already exists in the output folder &lt;%s&gt;\\n\"), OUTPUT_FOLDER.c_str()); MosPrintf(MIL_TEXT(\"Select an option: \\n\")); SelectNewModel = Press1ForFalseOr2ForTrue(MIL_TEXT(\"Use existing model image.\"), MIL_TEXT(\"Select a new model image.\")); } if(SelectNewModel) { return MIL_UNIQUE_BUF_ID {}; } else { return MbufRestore(MODEL_PATH, MilSystem, M_UNIQUE_ID); } } //============================================================================== //! std::vector&lt;SImage&gt; SelectImagesToLabel(MIL_ID MilSystem) { bool UseImageFiles {true}; MIL_INT ContainerAlreadyExist {0}; MappFileOperation(M_DEFAULT, CONTAINER_PATH, M_NULL, M_NULL, M_FILE_EXISTS, M_DEFAULT, &amp;ContainerAlreadyExist); if(ContainerAlreadyExist == M_YES) { MosPrintf(MIL_TEXT(\"A container already exists in the output folder &lt;%s&gt;\\n\"), OUTPUT_FOLDER.c_str()); MosPrintf(MIL_TEXT(\"Select an option: \\n\")); MIL_STRING UseImageFromFolderText = MIL_TEXT(\"Use images from folder &lt;\") + (IMAGES_FOLDER) + MIL_TEXT(\"&gt;\"); UseImageFiles = Press1ForFalseOr2ForTrue(MIL_TEXT(\"Use existing container.\"), UseImageFromFolderText.c_str()); } std::vector&lt;SImage&gt; Images; if(UseImageFiles) { std::vector&lt;MIL_STRING&gt; FilesInFolder = ListImagesInFolder(IMAGES_FOLDER + IMAGE_FORMAT); if(FilesInFolder.size() == 0) { MosPrintf(MIL_TEXT(\"No image was found in the input folder &lt;%s&gt; \\n\"), IMAGES_FOLDER.c_str()); MosPrintf(MIL_TEXT(\"Check the folder then restart the labeling tool.\\n\")); } for(MIL_INT i = 0; i &lt; (MIL_INT)FilesInFolder.size(); i++) { Images.emplace_back(MilSystem, IMAGES_FOLDER, FilesInFolder[i]); } } else { auto ExistingContainer = MbufRestore(CONTAINER_PATH, MilSystem, M_UNIQUE_ID); std::vector&lt;MIL_ID&gt; ImagesId; MbufInquireContainer(ExistingContainer, M_CONTAINER, M_COMPONENT_LIST, ImagesId); if(ImagesId.empty()) { MosPrintf(MIL_TEXT(\"No image was found in the container &lt;%s&gt; :\\n\"), CONTAINER_PATH.c_str()); MosPrintf(MIL_TEXT(\"Check the container then restart the labeling tool.\\n\")); } for(MIL_INT i = 0; i &lt; (MIL_INT)ImagesId.size(); i++) { MIL_STRING ImageName = MIL_TEXT(\"Component \") + M_TO_STRING(i); Images.emplace_back(MilSystem, ImagesId[i], ImageName); } } return Images; } // =========================================================================== // Main. // =========================================================================== int MosMain(void) { PrintHeader(); MosPrintf(MIL_TEXT(\"Press any key to continue.\\n\\n\")); MosGetch(); MIL_UNIQUE_APP_ID MilApplication = MappAlloc(M_NULL, M_DEFAULT, M_UNIQUE_ID); MIL_UNIQUE_SYS_ID MilSystem = MsysAlloc(MilApplication, MIL_TEXT(\"M_SYSTEM_HOST\"), M_DEFAULT, M_DEFAULT, M_UNIQUE_ID); auto ModelImage = SelectModelImage(MilSystem); auto Images = SelectImagesToLabel(MilSystem); CLabelingTool LabelingTool(MilSystem, Images, ModelImage); LabelingTool.SetSavedModelImagePath(MODEL_PATH); LabelingTool.SetSavedLabeledImagesPath(CONTAINER_PATH); CLabelingToolView View(LabelingTool); CLabelingToolController Controller(LabelingTool, View); do { MosPrintf(MIL_TEXT(\"Press &lt;Esc&gt; to exit\\n\")); } while((MosGetch() != 27)); return 0; } ",
      "wordCount": 568
    },
    {
      "id": "Examples_Processing_PatternMatching_AgmLabelingTool_CPP_labelingtool_cpp",
      "version": "2024020714",
      "title": "labelingtool.cpp",
      "location": "Sample Code from MIL Examples",
      "text": " Top //******************************************************************************* // // File name: labelingtool.cpp // Location: See Matrox Example Launcher in the MIL Control Center // // // Synopsis: This file implements the Model class of the Model-View-Controller // pattern. // // Copyright (C) Matrox Electronic Systems Ltd., 1992-2024. // All Rights Reserved //******************************************************************************* #include \"labelingtool.h\" //================================================================================================== //! static bool AreAllRegionsSameSizeAsModel(const std::vector&lt;SImage&gt;&amp; Images, MIL_ID ModelImage) { MIL_INT ModelSizeX = MbufInquire(ModelImage, M_SIZE_X, M_NULL); MIL_INT ModelSizeY = MbufInquire(ModelImage, M_SIZE_Y, M_NULL); for(const auto&amp; Image : Images) { auto ExtractedGraList = MgraAllocList(M_DEFAULT_HOST, M_DEFAULT, M_UNIQUE_ID); MbufSetRegion(Image.m_Id, ExtractedGraList, M_DEFAULT, M_EXTRACT, M_DEFAULT); MIL_INT NbGraphic = MgraInquireList(ExtractedGraList, M_LIST, M_DEFAULT, M_NUMBER_OF_GRAPHICS, M_NULL); for(MIL_INT i = 0; i &lt; NbGraphic; ++i) { MIL_INT GraType = MgraInquireList(ExtractedGraList, M_GRAPHIC_INDEX(i), M_DEFAULT, M_GRAPHIC_TYPE, M_NULL); if(GraType == M_GRAPHIC_TYPE_RECT) { MIL_INT GraLabel = MgraInquireList(ExtractedGraList, M_GRAPHIC_INDEX(i), M_DEFAULT, M_LABEL_VALUE, M_NULL); SdSize2D BoxSize; MgraInquireList(ExtractedGraList, M_GRAPHIC_LABEL(GraLabel), M_DEFAULT, M_RECTANGLE_WIDTH, &amp;BoxSize.x); MgraInquireList(ExtractedGraList, M_GRAPHIC_LABEL(GraLabel), M_DEFAULT, M_RECTANGLE_HEIGHT, &amp;BoxSize.y); if((BoxSize.x != ModelSizeX) || (BoxSize.y != ModelSizeY)) { MosPrintf(MIL_TEXT(\"Existing labeled occurrences must be the same size as the model image.\\n\")); return false; } } } } return true; } //================================================================================================== //! CLabelingTool::CLabelingTool(MIL_ID MilSystem, const std::vector&lt;SImage&gt;&amp; Images, MIL_ID ModelImage) : m_System(MilSystem) { if(ModelImage != M_NULL &amp;&amp; !AreAllRegionsSameSizeAsModel(Images, ModelImage)) { return; } for(const auto&amp; Image : Images) { SLabeledImage LabeledImage; LabeledImage.m_Id = MbufClone(Image.m_Id, m_System, M_DEFAULT, M_DEFAULT, M_DEFAULT, M_DEFAULT, M_COPY_SOURCE_DATA, M_UNIQUE_ID); LabeledImage.m_FileName = Image.m_FileName; auto ExtractedGraList = MgraAllocList(m_System, M_DEFAULT, M_UNIQUE_ID); MbufSetRegion(Image.m_Id, ExtractedGraList, M_DEFAULT, M_EXTRACT, M_DEFAULT); MIL_INT NbGraphic = MgraInquireList(ExtractedGraList, M_LIST, M_DEFAULT, M_NUMBER_OF_GRAPHICS, M_NULL); for(MIL_INT i = 0; i &lt; NbGraphic; ++i) { MIL_INT GraType = MgraInquireList(ExtractedGraList, M_GRAPHIC_INDEX(i), M_DEFAULT, M_GRAPHIC_TYPE, M_NULL); if(GraType == M_GRAPHIC_TYPE_RECT) { MIL_INT GraLabel = MgraInquireList(ExtractedGraList, M_GRAPHIC_INDEX(i), M_DEFAULT, M_LABEL_VALUE, M_NULL); SRectangle Box = CvtGraRectangle(ExtractedGraList, GraLabel); LabeledImage.m_Labels.push_back(Box); } } m_LabeledImages.push_back(std::move(LabeledImage)); } if(ModelImage != M_NULL) { m_ModelImage = MbufClone(ModelImage, m_System, M_DEFAULT, M_DEFAULT, M_DEFAULT, M_DEFAULT, M_COPY_SOURCE_DATA, M_UNIQUE_ID); } // Start with the first image. m_CurImageIndex = Images.empty() ? M_INVALID : 0; } //================================================================================================== //! MIL_ID CLabelingTool::GetSystemId() const { return m_System; } //================================================================================================== //! MIL_INT CLabelingTool::GetNbImage() const { return static_cast&lt;MIL_INT&gt;(m_LabeledImages.size()); } //================================================================================================== //! MIL_ID CLabelingTool::GetCurImageId() const { return (m_LabeledImages.empty() || !IsValidImageIndex(m_CurImageIndex)) ? M_NULL : m_LabeledImages[m_CurImageIndex].m_Id; } //================================================================================================== //! const std::vector&lt;SLabeledImage&gt;&amp; CLabelingTool::GetLabeledImages() const { return m_LabeledImages; } //================================================================================================== //! const MIL_INT CLabelingTool::GetCurImageIndex() const { return m_CurImageIndex; } //================================================================================================== //! bool CLabelingTool::IsValidImageIndex(MIL_INT Index) const { return (Index &gt;= 0) &amp;&amp; (Index &lt; GetNbImage()); } //================================================================================================== //! void CLabelingTool::SetCurImageIndex(MIL_INT Index) { if(IsValidImageIndex(Index)) { m_CurImageIndex = Index; } } //================================================================================================== //! MIL_ID CLabelingTool::GetModelImage() const { return m_ModelImage.get(); } //================================================================================================== //! SiSize2D CLabelingTool::GetModelSize() const { SiSize2D ModelSize {0, 0}; if(m_ModelImage != M_NULL) { ModelSize.x = MbufInquire(m_ModelImage, M_SIZE_X, M_NULL); ModelSize.y = MbufInquire(m_ModelImage, M_SIZE_Y, M_NULL); } return ModelSize; } //================================================================================================== //! void CLabelingTool::SetModelImageAt(const SRectangle&amp; Box) { MIL_ID CurImage = GetCurImageId(); if(CurImage != M_NULL) { SiPoint2D SrcTopLeft = CvtToIntBoxCorner(Box.TopLeft); SiSize2D ModelSize = Box.GetSize(); m_ModelImage = MbufAlloc2d(m_System, ModelSize.x, ModelSize.y, 8 + M_UNSIGNED, M_IMAGE + M_PROC, M_UNIQUE_ID); MbufCopyColor2d(CurImage, m_ModelImage, M_ALL_BANDS, SrcTopLeft.x, SrcTopLeft.y, M_ALL_BANDS, 0, 0, ModelSize.x, ModelSize.y); } } //============================================================================== //! static MIL_DOUBLE MoveToClosest05(MIL_DOUBLE Value) { return std::ceil(Value - 1.0) + 0.5; } //============================================================================== //! static SRectangle AlignWithPixelBorder(const SRectangle&amp; Box) { SRectangle AlignedBox = Box; AlignedBox.TopLeft.x = MoveToClosest05(Box.TopLeft.x); AlignedBox.TopLeft.y = MoveToClosest05(Box.TopLeft.y); AlignedBox.BottomRight.x = AlignedBox.TopLeft.x + Box.GetSize().x; AlignedBox.BottomRight.y = AlignedBox.TopLeft.y + Box.GetSize().y; return AlignedBox; } //================================================================================================== //! void CLabelingTool::AddLabel(const SRectangle&amp; LabeledBox) { if(IsValidImageIndex(m_CurImageIndex)) { auto AlignedBox = AlignWithPixelBorder(LabeledBox); m_LabeledImages[m_CurImageIndex].m_Labels.push_back(AlignedBox); } } //================================================================================================== //! void CLabelingTool::SaveLabeledImages() const { auto ContainerId = MbufAllocContainer(m_System, M_PROC | M_DISP, M_DEFAULT, M_UNIQUE_ID); for(MIL_INT i = 0; i &lt; GetNbImage(); ++i) { const auto&amp; LabeledImage = m_LabeledImages[i]; MbufCopyComponent(LabeledImage.m_Id, ContainerId, M_DEFAULT, M_APPEND, M_DEFAULT); MIL_ID CurComponentId; MbufInquireContainer(ContainerId, M_COMPONENT_BY_INDEX(i), M_COMPONENT_ID, &amp;CurComponentId); auto AllRegions = MgraAllocList(m_System, M_DEFAULT, M_UNIQUE_ID); for(MIL_INT BoxIdx = 0; BoxIdx &lt; (MIL_INT)LabeledImage.m_Labels.size(); ++BoxIdx) { const auto&amp; LabeledBox = LabeledImage.m_Labels[BoxIdx]; MgraRect(M_DEFAULT, AllRegions, LabeledBox.TopLeft.x, LabeledBox.TopLeft.y, LabeledBox.BottomRight.x, LabeledBox.BottomRight.y); MgraControlList(AllRegions, M_GRAPHIC_INDEX(BoxIdx), M_DEFAULT, M_COLOR, LabeledBox.Color); } MbufSetRegion(CurComponentId, AllRegions, M_DEFAULT, M_NO_RASTERIZE, M_DEFAULT); MbufControl(CurComponentId, M_REGION_USE, M_USE); } MbufSave(m_SavedContainerPath, ContainerId); } //================================================================================================== //! void CLabelingTool::SaveModelImage() const { if(m_ModelImage != M_NULL) { MbufSave(m_ModelImagePath, m_ModelImage); } } //================================================================================================== //! void CLabelingTool::DeleteLabel(MIL_INT LabelIndex) { if(IsValidImageIndex(m_CurImageIndex)) { auto&amp; CurLabels = m_LabeledImages[m_CurImageIndex].m_Labels; CurLabels.erase(CurLabels.begin() + LabelIndex); } } //================================================================================================== //! bool CLabelingTool::GetFirstLabeledBox(SRectangle* pBox) const { for(const auto&amp; Image : m_LabeledImages) { if(!Image.m_Labels.empty()) { *pBox = Image.m_Labels.front(); return true; } } return false; } ",
      "wordCount": 664
    },
    {
      "id": "Examples_Processing_PatternMatching_AgmLabelingTool_CPP_labelingtoolcontroller_cpp",
      "version": "2024020714",
      "title": "labelingtoolcontroller.cpp",
      "location": "Sample Code from MIL Examples",
      "text": " Top //******************************************************************************* // // File name: labelingtoolcontroller.cpp // Location: See Matrox Example Launcher in the MIL Control Center // // // Synopsis: This file implements the Controller class of the Model-View-Controller // pattern. // // Copyright (C) Matrox Electronic Systems Ltd., 1992-2024. // All Rights Reserved //******************************************************************************* #include \"labelingtoolcontroller.h\" #include \"labelingtool.h\" //============================================================================== //! CLabelingToolController::CLabelingToolController( CLabelingTool&amp; LabelingTool, CLabelingToolView&amp; View) : m_rLabelingTool(LabelingTool) , m_rLabelingToolView(View) { // Ensure there are images in the labeling tool. if(m_rLabelingTool.GetNbImage() == 0) { return; } m_rLabelingToolView.RegisterOnGraListEvent(this); if(m_rLabelingTool.GetModelImage() == M_NULL) { m_rLabelingToolView.ShowModelSelectionView(); m_rLabelingToolView.RegisterDisplaySizeOnBoxMovetEvent(this); } else { m_rLabelingToolView.ShowImageLabelingView(); m_rLabelingToolView.RegisterOverlayOnBoxMoveEvent(this); } } //============================================================================== //! void CLabelingToolController::NextImage() const { MIL_INT ImageIdx = m_rLabelingTool.GetCurImageIndex(); m_rLabelingTool.SetCurImageIndex(ImageIdx + 1); m_rLabelingToolView.UpdateAndRedrawSelectedBox(); } //============================================================================== //! void CLabelingToolController::PreviousImage() const { MIL_INT ImageIdx = m_rLabelingTool.GetCurImageIndex(); m_rLabelingTool.SetCurImageIndex(ImageIdx - 1); m_rLabelingToolView.UpdateAndRedrawSelectedBox(); } //============================================================================== //! void CLabelingToolController::LastImage() const { MIL_INT LastImageIdx = m_rLabelingTool.GetNbImage() - 1; m_rLabelingTool.SetCurImageIndex(LastImageIdx); m_rLabelingToolView.UpdateAndRedrawSelectedBox(); } //============================================================================== //! void CLabelingToolController::FirstImage() const { m_rLabelingTool.SetCurImageIndex(0); m_rLabelingToolView.UpdateAndRedrawSelectedBox(); } //============================================================================== //! void CLabelingToolController::AddPositiveLabel() const { m_rLabelingToolView.AddFloatingBox(M_COLOR_BLUE); m_rLabelingToolView.OverlayModel(); m_rLabelingToolView.DisableAllBoxExceptCurrent(); auto&amp; ButtonBar = m_rLabelingToolView.GetLabelingBar(); ButtonBar.m_AddNegativeButton.SetSelectableState(CButton::ESelectableState::eDisabled); ButtonBar.m_AddPositiveButton.SetSelectableState(CButton::ESelectableState::eDisabled); ButtonBar.m_SaveButton.SetSelectableState(CButton::ESelectableState::eDisabled); ButtonBar.m_ValidateButton.SetSelectableState(CButton::ESelectableState::eEnabled); ButtonBar.m_DeleteButton.SetSelectableState(CButton::ESelectableState::eEnabled); } //============================================================================== //! void CLabelingToolController::AddNegativeLabel() const { m_rLabelingToolView.AddFloatingBox(M_COLOR_RED); m_rLabelingToolView.OverlayModel(); m_rLabelingToolView.DisableAllBoxExceptCurrent(); auto&amp; ButtonBar = m_rLabelingToolView.GetLabelingBar(); ButtonBar.m_AddNegativeButton.SetSelectableState(CButton::ESelectableState::eDisabled); ButtonBar.m_AddPositiveButton.SetSelectableState(CButton::ESelectableState::eDisabled); ButtonBar.m_SaveButton.SetSelectableState(CButton::ESelectableState::eDisabled); ButtonBar.m_ValidateButton.SetSelectableState(CButton::ESelectableState::eEnabled); ButtonBar.m_DeleteButton.SetSelectableState(CButton::ESelectableState::eEnabled); } //============================================================================== //! void CLabelingToolController::Validate() const { SRectangle CurSelectedFloatingBox = m_rLabelingToolView.GetFloatingBox(); m_rLabelingTool.AddLabel(CurSelectedFloatingBox); m_rLabelingToolView.DeleteFloatingBox(); auto&amp; ButtonBar = m_rLabelingToolView.GetLabelingBar(); ButtonBar.m_AddNegativeButton.SetSelectableState(CButton::ESelectableState::eEnabled); ButtonBar.m_AddPositiveButton.SetSelectableState(CButton::ESelectableState::eEnabled); ButtonBar.m_SaveButton.SetSelectableState(CButton::ESelectableState::eEnabled); ButtonBar.m_ValidateButton.SetSelectableState(CButton::ESelectableState::eDisabled); ButtonBar.m_DeleteButton.SetSelectableState(CButton::ESelectableState::eDisabled); m_rLabelingToolView.Update(); } //============================================================================== //! void CLabelingToolController::Delete() const { m_rLabelingToolView.DeleteFloatingBox(); auto&amp; ButtonBar = m_rLabelingToolView.GetLabelingBar(); ButtonBar.m_AddNegativeButton.SetSelectableState(CButton::ESelectableState::eEnabled); ButtonBar.m_AddPositiveButton.SetSelectableState(CButton::ESelectableState::eEnabled); ButtonBar.m_SaveButton.SetSelectableState(CButton::ESelectableState::eEnabled); ButtonBar.m_ValidateButton.SetSelectableState(CButton::ESelectableState::eDisabled); ButtonBar.m_DeleteButton.SetSelectableState(CButton::ESelectableState::eDisabled); m_rLabelingToolView.EnableAllBox(); } //============================================================================== //! void CLabelingToolController::Save() const { m_rLabelingTool.SaveLabeledImages(); m_rLabelingToolView.GetLabelingBar().m_SaveButton.ChangeColor(M_COLOR_GRAY); MosSleep(100); m_rLabelingToolView.GetLabelingBar().m_SaveButton.ChangeColor(M_COLOR_BRIGHT_GRAY); } //============================================================================== //! void CLabelingToolController::SelectExistingLabel() const { m_rLabelingToolView.UpdateCurSelectedFloatingBoxLabel(); MIL_INT CurDisplayedBoxLabel = m_rLabelingToolView.GetCurSelectedFloatingBoxLabel(); MIL_INT IndexOfLabel = m_rLabelingToolView.GetIndexOf(CurDisplayedBoxLabel); m_rLabelingTool.DeleteLabel(IndexOfLabel); m_rLabelingToolView.UpdateAndRedrawSelectedBox(); m_rLabelingToolView.DisableAllBoxExceptCurrent(); m_rLabelingToolView.OverlayModel(); auto&amp; ButtonBar = m_rLabelingToolView.GetLabelingBar(); ButtonBar.m_AddNegativeButton.SetSelectableState(CButton::ESelectableState::eDisabled); ButtonBar.m_AddPositiveButton.SetSelectableState(CButton::ESelectableState::eDisabled); ButtonBar.m_SaveButton.SetSelectableState(CButton::ESelectableState::eDisabled); ButtonBar.m_ValidateButton.SetSelectableState(CButton::ESelectableState::eEnabled); ButtonBar.m_DeleteButton.SetSelectableState(CButton::ESelectableState::eEnabled); } //============================================================================== //! void CLabelingToolController::SelectModel() { SRectangle CurSelectedFloatingBox = m_rLabelingToolView.GetFloatingBox(); m_rLabelingTool.SetModelImageAt(CurSelectedFloatingBox); m_rLabelingTool.SaveModelImage(); SiSize2D ModelSize = m_rLabelingTool.GetModelSize(); SRectangle ModelBox(CurSelectedFloatingBox.GetCenter(), ModelSize); m_rLabelingTool.AddLabel(ModelBox); m_rLabelingToolView.DeleteFloatingBox(); m_rLabelingToolView.ShowImageLabelingView(); m_rLabelingToolView.UnRegisterDisplaySizeOnBoxMovetEvent(this); m_rLabelingToolView.RegisterOverlayOnBoxMoveEvent(this); } ",
      "wordCount": 291
    },
    {
      "id": "Examples_Processing_PatternMatching_AgmLabelingTool_CPP_labelingtoolview_cpp",
      "version": "2024020714",
      "title": "labelingtoolview.cpp",
      "location": "Sample Code from MIL Examples",
      "text": " Top //******************************************************************************* // // File name: labelingtoolview.cpp // Location: See Matrox Example Launcher in the MIL Control Center // // // Synopsis: This file implements the View class of the Model-View-Controller // pattern. // // Copyright (C) Matrox Electronic Systems Ltd., 1992-2024. // All Rights Reserved //******************************************************************************* #include \"labelingtoolview.h\" #include \"labelingtool.h\" #include \"labelingtoolcontroller.h\" static const MIL_INT ALPHA_VALUE = 50; static const MIL_INT SELECTION_RADIUS = 10; static const MIL_DOUBLE MAX_IMAGE_DISPLAY_SIZE = 800; //============================================================================== //! MIL_INT MFTYPE OnGraListClick(MIL_INT /*HookType*/, MIL_ID EventId, void* UserData) { CLabelingToolController&amp; Controller = *(CLabelingToolController*)UserData; CLabelingToolView&amp; View = Controller.GetLabelingToolView(); // Get the label of the selected graphic. MIL_INT GraphicSelected; MIL_INT GraphicList; MgraGetHookInfo(EventId, M_GRAPHIC_LABEL_VALUE, &amp;GraphicSelected); MgraGetHookInfo(EventId, M_GRAPHIC_LIST_ID, &amp;GraphicList); auto&amp; NavigationBar = View.GetNavigationBar(); auto&amp; LabelingBar = View.GetLabelingBar(); auto&amp; ModelSelectionBar = View.GetModelSelectionBar(); if(GraphicSelected == NavigationBar.m_NextImageButton.GetRectLabel()) { Controller.NextImage(); NavigationBar.m_NextImageButton.Unselect(); } else if(GraphicSelected == NavigationBar.m_PreviousImageButton.GetRectLabel()) { Controller.PreviousImage(); NavigationBar.m_PreviousImageButton.Unselect(); } else if(GraphicSelected == NavigationBar.m_LastImageButton.GetRectLabel()) { Controller.LastImage(); NavigationBar.m_LastImageButton.Unselect(); } else if(GraphicSelected == NavigationBar.m_FirstImageButton.GetRectLabel()) { Controller.FirstImage(); NavigationBar.m_FirstImageButton.Unselect(); } else if(GraphicSelected == ModelSelectionBar.m_ValidateButton.GetRectLabel()) { Controller.SelectModel(); } else if(GraphicSelected == LabelingBar.m_AddPositiveButton.GetRectLabel()) { Controller.AddPositiveLabel(); LabelingBar.m_AddPositiveButton.Unselect(); } else if(GraphicSelected == LabelingBar.m_AddNegativeButton.GetRectLabel()) { Controller.AddNegativeLabel(); LabelingBar.m_AddNegativeButton.Unselect(); } else if(GraphicSelected == LabelingBar.m_ValidateButton.GetRectLabel()) { Controller.Validate(); LabelingBar.m_ValidateButton.Unselect(); } else if(GraphicSelected == LabelingBar.m_DeleteButton.GetRectLabel()) { Controller.Delete(); LabelingBar.m_DeleteButton.Unselect(); } else if(GraphicSelected == LabelingBar.m_SaveButton.GetRectLabel()) { Controller.Save(); LabelingBar.m_SaveButton.Unselect(); } else if(View.IsExistingLabel(GraphicSelected)) // GraphicSelected is an existing movable bounding box. { Controller.SelectExistingLabel(); } else if(GraphicSelected == M_NO_LABEL)// Keep the current selected graphic active. { MIL_INT GraphicUnselected; MgraGetHookInfo(EventId, M_GRAPHIC_LABEL_VALUE_DESELECTED, &amp;GraphicUnselected); View.SelectBox(GraphicUnselected); } return 0; } //============================================================================== //! MIL_INT MFTYPE OverlayOnBoxMove(MIL_INT /*HookType*/, MIL_ID EventId, void* UserData) { CLabelingToolController&amp; Controller = *(CLabelingToolController*)UserData; CLabelingToolView&amp; View = Controller.GetLabelingToolView(); MIL_INT ControlType; MgraGetHookInfo(EventId, M_GRAPHIC_CONTROL_TYPE, &amp;ControlType); if(ControlType == M_GRAPHIC_INTERACTIVE) { View.OverlayModel(); } return 0; } //============================================================================== //! MIL_INT MFTYPE DisplaySizeOnBoxMove(MIL_INT /*HookType*/, MIL_ID EventId, void* UserData) { CLabelingToolController&amp; Controller = *(CLabelingToolController*)UserData; CLabelingToolView&amp; View = Controller.GetLabelingToolView(); MIL_INT ControlType; MgraGetHookInfo(EventId, M_GRAPHIC_CONTROL_TYPE, &amp;ControlType); if(ControlType == M_GRAPHIC_INTERACTIVE) { MthrWait(M_DEFAULT, M_THREAD_WAIT, M_NULL); // Wait for the bouding box to be modified before displaying its size. View.DisplayFloatingBoxSize(); if(View.IsFloatingBoxInsideImage()) { View.GetModelSelectionBar().m_ValidateButton.SetSelectableState(CButton::ESelectableState::eEnabled); } else { View.GetModelSelectionBar().m_ValidateButton.SetSelectableState(CButton::ESelectableState::eDisabled); } } return 0; } //============================================================================== //! static SdSize2D CmptMaxImageSize(const std::vector&lt;SLabeledImage&gt;&amp; Images) { SdSize2D MaxImageSize {0.0, 0.0}; for(const auto&amp; Image : Images) { MaxImageSize.x = std::max(MaxImageSize.x, (MIL_DOUBLE)MbufInquire(Image.m_Id, M_SIZE_X, M_NULL)); MaxImageSize.y = std::max(MaxImageSize.y, (MIL_DOUBLE)MbufInquire(Image.m_Id, M_SIZE_Y, M_NULL)); } return MaxImageSize; } //============================================================================== //! CLabelingToolView::CLabelingToolView(const CLabelingTool&amp; LabelingTool) : m_rLabelingTool(LabelingTool) { // Ensure there are images in the labeling tool. if(m_rLabelingTool.GetNbImage() == 0) { return; } m_System = LabelingTool.GetSystemId(); m_Display = MdispAlloc(m_System, M_DEFAULT, MIL_TEXT(\"M_DEFAULT\"), M_DEFAULT, M_UNIQUE_ID); m_GraCtx = MgraAlloc(m_System, M_UNIQUE_ID); m_GraList = MgraAllocList(m_System, M_DEFAULT, M_UNIQUE_ID); // Set up graphic list. MgraControlList(m_GraList, M_LIST, M_DEFAULT, M_SELECTION_RADIUS, SELECTION_RADIUS); MgraControlList(m_GraList, M_LIST, M_DEFAULT, M_ACTION_KEYS, M_ENABLE); MgraControlList(m_GraList, M_LIST, M_DEFAULT, M_MULTIPLE_SELECTION, M_DISABLE); // Set up graphic context. MgraControl(m_GraCtx, M_TEXT_ALIGN_VERTICAL, M_CENTER); MgraControl(m_GraCtx, M_TEXT_ALIGN_HORIZONTAL, M_CENTER); MgraControl(m_GraCtx, M_BACKGROUND_MODE, M_TRANSPARENT); MgraControl(m_GraCtx, M_ROTATABLE, M_DISABLE); MgraControl(m_GraCtx, M_RESIZABLE, M_DISABLE); // Set up MIL display. SdSize2D MaxImageSize = CmptMaxImageSize(m_rLabelingTool.GetLabeledImages()); MIL_DOUBLE MaxDim = std::max(MaxImageSize.x, MaxImageSize.y); m_ZoomFactor = (MaxDim &gt; MAX_IMAGE_DISPLAY_SIZE) ? (MAX_IMAGE_DISPLAY_SIZE / MaxDim) : 1.0; MdispControl(m_Display, M_GRAPHIC_LIST_INTERACTIVE, M_ENABLE); MdispControl(m_Display, M_ASSOCIATED_GRAPHIC_LIST_ID, m_GraList); MdispControl(m_Display, M_KEYBOARD_USE, M_DISABLE); MdispControl(m_Display, M_MOUSE_USE, M_DISABLE); MdispControl(m_Display, M_OVERLAY_OPACITY, ALPHA_VALUE); MIL_INT WindowX = (MIL_INT)std::max(MaxImageSize.x * m_ZoomFactor + 2 * MARGIN_W_SIZE, (W_SIZE + MARGIN_W_SIZE) * 5 + MARGIN_W_SIZE); MIL_INT WindowY = (MIL_INT)(MaxImageSize.y * m_ZoomFactor + LINES * (H_SIZE + MARGIN_H_SIZE) + MARGIN_H_SIZE); MdispControl(m_Display, M_WINDOW_INITIAL_SIZE_X, WindowX); MdispControl(m_Display, M_WINDOW_INITIAL_SIZE_Y, WindowY); MdispControl(m_Display, M_WINDOW_SIZE_AUTO_RESET, M_DISABLE); MdispZoom(m_Display, m_ZoomFactor, m_ZoomFactor); // Create buttons. m_pNavigationBar = std::make_unique&lt;SImageNavigationBar&gt;(m_GraList, m_GraCtx, m_ZoomFactor); m_pLabelingBar = std::make_unique&lt;SButtonsLabelTargetImages&gt;(m_GraList, m_GraCtx, m_ZoomFactor); m_pModelSelectionBar = std::make_unique&lt;SButtonsModelSelection&gt;(m_GraList, m_GraCtx, m_ZoomFactor); // Initialize overlay image. m_ModelOverlay.reset(MbufAlloc2d(m_System, (MIL_INT)MaxImageSize.x, (MIL_INT)MaxImageSize.y, 8+M_UNSIGNED, M_IMAGE+M_PROC, M_UNIQUE_ID).release()); // Display first image. MdispSelect(m_Display, m_rLabelingTool.GetLabeledImages()[0].m_Id); MdispPan(m_Display, -MARGIN_W_SIZE / m_ZoomFactor, -LINES * (H_SIZE + MARGIN_H_SIZE) / m_ZoomFactor); } //============================================================================== //! bool CLabelingToolView::IsValidGraLabel(MIL_INT GraLabel) const { return MgraInquireList(m_GraList, M_GRAPHIC_LABEL(GraLabel), M_DEFAULT, M_INDEX_VALUE, M_NULL) != M_INVALID; } //============================================================================== void CLabelingToolView::ClearLabels() { // A Label is a non-filled rectangle (as opposed to a button, which is a filled rectangle). MIL_INT NbGraphic = MgraInquireList(m_GraList, M_LIST, M_DEFAULT, M_NUMBER_OF_GRAPHICS + M_TYPE_MIL_INT, M_NULL); std::vector&lt;MIL_INT&gt; LabelToDeletes; for(MIL_INT i = 0; i &lt; NbGraphic; ++i) { MIL_INT GraphicType = MgraInquireList(m_GraList, M_GRAPHIC_INDEX(i), M_DEFAULT, M_GRAPHIC_TYPE, M_NULL); if(GraphicType == M_GRAPHIC_TYPE_RECT) { MIL_INT IsFilled = MgraInquireList(m_GraList, M_GRAPHIC_INDEX(i), M_DEFAULT, M_FILLED, M_NULL); if(IsFilled == M_FALSE) { MIL_INT CurLabel = MgraInquireList(m_GraList, M_GRAPHIC_INDEX(i), M_DEFAULT, M_LABEL_VALUE, M_NULL); LabelToDeletes.push_back(CurLabel); } } } for(MIL_INT Label : LabelToDeletes) { MgraControlList(m_GraList, M_GRAPHIC_LABEL(Label), M_DEFAULT, M_DELETE, M_DEFAULT); } m_LabelToIndexMap.clear(); } //============================================================================== //! void CLabelingToolView::DrawLabels() { MdispControl(m_Display, M_UPDATE_GRAPHIC_LIST, M_DISABLE); MIL_INT CurImageIndex = m_rLabelingTool.GetCurImageIndex(); const auto&amp; CurLabeledImage = m_rLabelingTool.GetLabeledImages()[CurImageIndex]; m_LabelToIndexMap.clear(); for(MIL_INT Index = 0; Index &lt; (MIL_INT)CurLabeledImage.m_Labels.size(); ++Index) { const auto&amp; Label = CurLabeledImage.m_Labels[Index]; MgraRect(m_GraCtx, m_GraList, Label.TopLeft.x, Label.TopLeft.y, Label.BottomRight.x, Label.BottomRight.y); MIL_INT LastBoxLabel {M_INVALID}; MgraInquireList(m_GraList, M_LIST, M_DEFAULT, M_LAST_LABEL, &amp;LastBoxLabel); MgraControlList(m_GraList, M_GRAPHIC_LABEL(LastBoxLabel), M_DEFAULT, M_COLOR, Label.Color); MgraControlList(m_GraList, M_GRAPHIC_LABEL(LastBoxLabel), M_DEFAULT, M_TRANSLATABLE, M_DISABLE); m_LabelToIndexMap.insert({LastBoxLabel, Index}); } MdispControl(m_Display, M_UPDATE_GRAPHIC_LIST, M_ENABLE); } //============================================================================== //! void CLabelingToolView::DisableAllBoxExceptCurrent() { MdispControl(m_Display, M_UPDATE_GRAPHIC_LIST, M_DISABLE); MIL_INT NbGraphic = MgraInquireList(m_GraList, M_LIST, M_DEFAULT, M_NUMBER_OF_GRAPHICS + M_TYPE_MIL_INT, M_NULL); for(MIL_INT i = 0; i &lt; NbGraphic; ++i) { MIL_INT CurLabel = MgraInquireList(m_GraList, M_GRAPHIC_INDEX(i), M_DEFAULT, M_LABEL_VALUE, M_NULL); if(IsExistingLabel(CurLabel) &amp;&amp; CurLabel != m_CurSelectedFloatingBoxLabel) { MgraControlList(m_GraList, M_GRAPHIC_LABEL(CurLabel), M_DEFAULT, M_SELECTABLE, M_DISABLE); } } MdispControl(m_Display, M_UPDATE_GRAPHIC_LIST, M_ENABLE); } //============================================================================== //! void CLabelingToolView::EnableAllBox() { MIL_INT NbGraphic = MgraInquireList(m_GraList, M_LIST, M_DEFAULT, M_NUMBER_OF_GRAPHICS + M_TYPE_MIL_INT, M_NULL); for(MIL_INT i = 0; i &lt; NbGraphic; ++i) { MIL_INT CurLabel = MgraInquireList(m_GraList, M_GRAPHIC_INDEX(i), M_DEFAULT, M_LABEL_VALUE, M_NULL); if(IsExistingLabel(CurLabel)) { MgraControlList(m_GraList, M_GRAPHIC_LABEL(CurLabel), M_DEFAULT, M_SELECTABLE, M_ENABLE); } } } //============================================================================== //! void CLabelingToolView::SelectBox(MIL_INT GraLabel) { if(IsValidGraLabel(GraLabel)) { MgraControlList(m_GraList, M_GRAPHIC_LABEL(GraLabel), M_DEFAULT, M_GRAPHIC_SELECTED, M_TRUE); } } //============================================================================== //! MIL_INT CLabelingToolView::GetIndexOf(MIL_INT DisplayedBoxLabel) const { if(m_LabelToIndexMap.find(DisplayedBoxLabel) != m_LabelToIndexMap.end()) { return m_LabelToIndexMap.at(DisplayedBoxLabel); } else { return M_INVALID; } } //============================================================================== //! void CLabelingToolView::OverlayModel() { if(m_rLabelingTool.GetModelImage() == M_NULL) { return; } SdPoint2D TopLeft; MgraInquireList(m_GraList, M_GRAPHIC_LABEL(m_CurSelectedFloatingBoxLabel), M_DEFAULT, M_CORNER_TOP_LEFT_X, &amp;TopLeft.x); MgraInquireList(m_GraList, M_GRAPHIC_LABEL(m_CurSelectedFloatingBoxLabel), M_DEFAULT, M_CORNER_TOP_LEFT_Y, &amp;TopLeft.y); MIL_ID CurImage = m_rLabelingTool.GetCurImageId(); MIL_ID MilOverlay = MdispInquire(m_Display, M_OVERLAY_ID, M_NULL); MbufCopy(CurImage, m_ModelOverlay); MimTranslate(m_rLabelingTool.GetModelImage(), m_ModelOverlay, TopLeft.x, TopLeft.y, M_BILINEAR + M_OVERSCAN_ENABLE); MbufCopy(m_ModelOverlay, MilOverlay); } //============================================================================== //! void CLabelingToolView::ShowModelSelectionView() { m_pLabelingBar-&gt;Disappear(); m_pModelSelectionBar-&gt;Appear(); m_pNavigationBar-&gt;m_StepTitle.SetText(MIL_TEXT(\"1) Select reference model\")); m_MustShowLabels = false; Update(); MIL_DOUBLE TargetCenterX = (MIL_DOUBLE)MbufInquire(m_rLabelingTool.GetCurImageId(), M_SIZE_X, M_NULL) / 2.0; MIL_DOUBLE TargetCenterY = (MIL_DOUBLE)MbufInquire(m_rLabelingTool.GetCurImageId(), M_SIZE_Y, M_NULL) / 2.0; SRectangle LabeledBox; if(m_rLabelingTool.GetFirstLabeledBox(&amp;LabeledBox)) { SdSize2D BoxSize = LabeledBox.GetSize(); LabeledBox = SRectangle({TargetCenterX, TargetCenterY}, BoxSize); AddFloatingBox(LabeledBox); } else { SdSize2D DefaultBoxSize {100.0, 100.0}; SRectangle DefaultBox = SRectangle({TargetCenterX, TargetCenterY}, DefaultBoxSize); DefaultBox.Resizable = M_ENABLE; AddFloatingBox(DefaultBox); DisplayFloatingBoxSize(); } } //============================================================================== //! void CLabelingToolView::ShowImageLabelingView() { m_pModelSelectionBar-&gt;Disappear(); m_pLabelingBar-&gt;Appear(); m_MustShowLabels = true; m_pNavigationBar-&gt;m_StepTitle.SetText(MIL_TEXT(\"2) Label images\")); Update(); } //============================================================================== //! bool CLabelingToolView::IsExistingLabel(MIL_INT Label) const { return (GetIndexOf(Label) == M_INVALID) ? false : true; } //============================================================================== //! void CLabelingToolView::DisplayFloatingBoxSize() { auto CurBox = GetFloatingBox(); SiSize2D ModelSizeInt = CurBox.GetSize(); MIL_STRING SizeModel = MIL_TEXT(\"Size : (\") + M_TO_STRING(ModelSizeInt.x) + MIL_TEXT(\",\") + M_TO_STRING(ModelSizeInt.y) + MIL_TEXT(\")\"); m_pModelSelectionBar-&gt;m_DispSizeButton.SetText(SizeModel); } //============================================================================== //! bool CLabelingToolView::IsFloatingBoxInsideImage() const { auto CurBox = GetFloatingBox(); SiPoint2D SrcTopLeft = CvtToIntBoxCorner(CurBox.TopLeft); SiPoint2D SrcBottomRight = CvtToIntBoxCorner(CurBox.BottomRight); MIL_INT ImageSizeX = MbufInquire(m_rLabelingTool.GetCurImageId(), M_SIZE_X, M_NULL); MIL_INT ImageSizeY = MbufInquire(m_rLabelingTool.GetCurImageId(), M_SIZE_Y, M_NULL); if(SrcTopLeft.x &gt;= 0 &amp;&amp; SrcTopLeft.y &gt;= 0 &amp;&amp; SrcBottomRight.x &lt; ImageSizeX &amp;&amp; SrcBottomRight.y &lt; ImageSizeY) { return true; } else { return false; } } //============================================================================== //! void CLabelingToolView::ResetOverlay() { MIL_ID MilOverlay = MdispInquire(m_Display, M_OVERLAY_ID, M_NULL); MbufCopy(m_rLabelingTool.GetCurImageId(), MilOverlay); } //============================================================================== //! void CLabelingToolView::UpdateAndRedrawSelectedBox() { SRectangle PreviousSelectedBox; if(m_CurSelectedFloatingBoxLabel != M_INVALID) { PreviousSelectedBox = GetFloatingBox(); } Update(); if(m_CurSelectedFloatingBoxLabel != M_INVALID) { AddFloatingBox(PreviousSelectedBox); OverlayModel(); DisableAllBoxExceptCurrent(); } } //============================================================================== //! void CLabelingToolView::Update() { MIL_INT CurImageIndex = m_rLabelingTool.GetCurImageIndex(); if(m_rLabelingTool.IsValidImageIndex(CurImageIndex)) { m_pNavigationBar-&gt;m_ImageNameButton.SetText(m_rLabelingTool.GetLabeledImages()[CurImageIndex].m_FileName); ResetOverlay(); m_pNavigationBar-&gt;DispCurrentImageIndex(CurImageIndex, m_rLabelingTool.GetNbImage()); ClearLabels(); if(m_MustShowLabels) { DrawLabels(); } MdispSelect(m_Display, m_rLabelingTool.GetCurImageId()); } } //============================================================================== //! void CLabelingToolView::RegisterOverlayOnBoxMoveEvent(CLabelingToolController* pController) { MgraHookFunction(m_GraList, M_GRAPHIC_MODIFIED, OverlayOnBoxMove, pController); } //============================================================================== //! void CLabelingToolView::RegisterOnGraListEvent(CLabelingToolController* pController) { MgraHookFunction(m_GraList, M_GRAPHIC_SELECTION_MODIFIED, OnGraListClick, pController); } //============================================================================== //! void CLabelingToolView::RegisterDisplaySizeOnBoxMovetEvent(CLabelingToolController* pController) { MgraHookFunction(m_GraList, M_GRAPHIC_MODIFIED, DisplaySizeOnBoxMove, pController); } //============================================================================== //! void CLabelingToolView::UnRegisterDisplaySizeOnBoxMovetEvent(CLabelingToolController* pController) { MgraHookFunction(m_GraList, M_GRAPHIC_MODIFIED + M_UNHOOK, DisplaySizeOnBoxMove, pController); } //============================================================================== //! Add floating box in the center of the current image. void CLabelingToolView::AddFloatingBox(MIL_INT Color) { MIL_INT CurImageIdx = m_rLabelingTool.GetCurImageIndex(); if(!m_rLabelingTool.IsValidImageIndex(CurImageIdx)) { return; } const auto&amp; CurImage = m_rLabelingTool.GetLabeledImages()[CurImageIdx]; MIL_DOUBLE TargetCenterX = (MIL_DOUBLE)MbufInquire(CurImage.m_Id, M_SIZE_X, M_NULL) / 2.0; MIL_DOUBLE TargetCenterY = (MIL_DOUBLE)MbufInquire(CurImage.m_Id, M_SIZE_Y, M_NULL) / 2.0; TargetCenterX += (MIL_DOUBLE)CurImage.m_Labels.size(); // to shift a bit for better visualization SiSize2D ModelSize = m_rLabelingTool.GetModelSize(); SRectangle Box(SdPoint2D{TargetCenterX, TargetCenterY}, ModelSize); Box.Color = Color; AddFloatingBox(Box); } //============================================================================== //! void CLabelingToolView::AddFloatingBox(const SRectangle&amp; Box) { MdispControl(m_Display, M_UPDATE_GRAPHIC_LIST, M_DISABLE); MgraRect(m_GraCtx, m_GraList, Box.TopLeft.x, Box.TopLeft.y, Box.BottomRight.x, Box.BottomRight.y); MIL_INT LastLabel {M_INVALID}; MgraInquireList(m_GraList, M_LIST, M_DEFAULT, M_LAST_LABEL, &amp;LastLabel); m_CurSelectedFloatingBoxLabel = LastLabel; MgraControlList(m_GraList, M_GRAPHIC_LABEL(LastLabel), M_DEFAULT, M_COLOR, Box.Color); MgraControlList(m_GraList, M_GRAPHIC_LABEL(LastLabel), M_DEFAULT, M_RESIZABLE, Box.Resizable); MgraControlList(m_GraList, M_GRAPHIC_LABEL(LastLabel), M_DEFAULT, M_TRANSLATABLE, M_ENABLE); MgraControlList(m_GraList, M_LIST, M_DEFAULT, M_SELECTED_COLOR, (Box.Color == M_COLOR_BLUE) ? M_COLOR_CYAN : M_COLOR_MAGENTA); MgraControlList(m_GraList, M_GRAPHIC_LABEL(LastLabel), M_DEFAULT, M_GRAPHIC_SELECTED, M_TRUE); MdispControl(m_Display, M_UPDATE_GRAPHIC_LIST, M_ENABLE); } //============================================================================== //! void CLabelingToolView::DeleteFloatingBox() { if(m_CurSelectedFloatingBoxLabel != M_INVALID) { MgraControlList(m_GraList, M_GRAPHIC_LABEL(m_CurSelectedFloatingBoxLabel), M_DEFAULT, M_DELETE, M_DEFAULT); ResetOverlay(); } m_CurSelectedFloatingBoxLabel = M_INVALID; } //============================================================================== //! MIL_INT CLabelingToolView::GetCurSelectedFloatingBoxLabel() const { return m_CurSelectedFloatingBoxLabel; } //============================================================================== //! void CLabelingToolView::UpdateCurSelectedFloatingBoxLabel() { m_CurSelectedFloatingBoxLabel = M_INVALID; MIL_INT NbGraphic = MgraInquireList(m_GraList, M_LIST, M_DEFAULT, M_NUMBER_OF_GRAPHICS, M_NULL); for(MIL_INT i = 0; i &lt; NbGraphic; ++i) { MIL_INT IsSelected = MgraInquireList(m_GraList, M_GRAPHIC_INDEX(i), M_DEFAULT, M_GRAPHIC_SELECTED, M_NULL); if(IsSelected == M_TRUE) { m_CurSelectedFloatingBoxLabel = MgraInquireList(m_GraList, M_GRAPHIC_INDEX(i), M_DEFAULT, M_LABEL_VALUE, M_NULL); } } } //============================================================================== //! SRectangle CLabelingToolView::GetFloatingBox() const { if(m_CurSelectedFloatingBoxLabel != M_INVALID) { return CvtGraRectangle(m_GraList, m_CurSelectedFloatingBoxLabel); } else { return SRectangle(); } } ",
      "wordCount": 1429
    },
    {
      "id": "Examples_Processing_PatternMatching_AgmLabelingTool_CPP_util_cpp",
      "version": "2024020714",
      "title": "util.cpp",
      "location": "Sample Code from MIL Examples",
      "text": " Top //*************************************************************************************** // // File name: util.cpp // Location: See Matrox Example Launcher in the MIL Control Center // // // Synopsis: Implements useful functions for the labeling tool. // // Copyright (C) Matrox Electronic Systems Ltd., 1992-2024. // All Rights Reserved //*************************************************************************************** #include \"util.h\" // =========================================================================== std::vector&lt;MIL_STRING&gt; ListImagesInFolder(const MIL_STRING&amp; FileToSearch) { MIL_INT NumberOfFiles; MappFileOperation(M_DEFAULT, FileToSearch, M_NULL, M_NULL, M_FILE_NAME_FIND + M_NB_ELEMENTS, M_DEFAULT, &amp;NumberOfFiles); std::vector&lt;MIL_STRING&gt; FilesInFolder(NumberOfFiles); for(MIL_INT i = 0; i &lt; NumberOfFiles; i++) { MIL_STRING Filename; MappFileOperation(M_DEFAULT, FileToSearch, M_NULL, M_NULL, M_FILE_NAME_FIND, i, Filename); FilesInFolder[i] = Filename; } return FilesInFolder; } // =========================================================================== SRectangle CvtGraRectangle(MIL_ID GraList, MIL_INT RectGraLabel) { SRectangle Box; MgraInquireList(GraList, M_GRAPHIC_LABEL(RectGraLabel), M_DEFAULT, M_CORNER_TOP_LEFT_X, &amp;Box.TopLeft.x); MgraInquireList(GraList, M_GRAPHIC_LABEL(RectGraLabel), M_DEFAULT, M_CORNER_TOP_LEFT_Y, &amp;Box.TopLeft.y); MgraInquireList(GraList, M_GRAPHIC_LABEL(RectGraLabel), M_DEFAULT, M_CORNER_BOTTOM_RIGHT_X, &amp;Box.BottomRight.x); MgraInquireList(GraList, M_GRAPHIC_LABEL(RectGraLabel), M_DEFAULT, M_CORNER_BOTTOM_RIGHT_Y, &amp;Box.BottomRight.y); MgraInquireList(GraList, M_GRAPHIC_LABEL(RectGraLabel), M_DEFAULT, M_COLOR + M_TYPE_MIL_INT, &amp;Box.Color); MgraInquireList(GraList, M_GRAPHIC_LABEL(RectGraLabel), M_DEFAULT, M_RESIZABLE + M_TYPE_MIL_INT, &amp;Box.Resizable); return Box; } ",
      "wordCount": 139
    }
  ]
}]
[{
  "id": "UG_bead",
  "version": "2024020714",
  "title": "Bead",
  "subTitles": null,
  "location": "MIL UG P03: 2D processing and analysis",
  "pageURL": "content\\UserGuide\\bead\\ChapterInformation.htm",
  "text": " Chapter 20: Bead This chapter explains how to use the MIL Bead module to measure and verify beads. MIL Bead module Steps to validate beads Basic concepts for the MIL Bead module Defining, training, and modifying bead templates Template type Foreground Template path Polyline that will be refined by a training image Fixed polyline Fixed circle or segment Template from a 2D graphics list Template width Automatically establishing the width Explicitly setting the width Training box of the template Smoothness and threshold General operations with a template Obtaining the closest template and vertex Training status When templates are not completely trained Input units Saving the training image Summary of the main training settings Verifying beads and retrieving results Score and acceptance Gaps Search box Fail warning Position and offset Width Angle Intensity Status and other results When you have a failing status Drawing Specifying the points When drawing with a bead context When drawing with a bead result Specifying the drawing operation Adjusting the templates and trained points with which to draw Bead example ",
  "wordCount": 176,
  "subEntries": [
    {
      "id": "UG_bead_MIL_Bead_module",
      "version": null,
      "title": "MIL Bead module",
      "subTitles": null,
      "location": "MIL UG P03: 2D processing and analysis",
      "pageURL": "content\\UserGuide\\bead\\MIL_Bead_module.htm",
      "text": " MIL Bead module A bead can be generally defined as a strip of malleable material, such as glue or lead. In many industries, such as manufacturing, beads can be used to, for example, bond objects together. In the following illustration, a bead of white glue has been applied to a mechanical part, and requires inspection. Using the MIL Bead module, you can inspect beads according to predefined specifications. For example, you can verify that a bead occurs at a required position, that its width falls within a certain range, that it does not have any missing sections (gaps), or that its gaps do not exceed a specified size. Beads are inspected with a template that represents a reusable model of a valid bead. To create a template, you can provide a set of points (vertices) along a path. If the path follows a circle or segment, you can just define the shape, rather than providing a set of points. You must then train the template, typically using a training image, to establish the points (trained points) required to validate the bead. Once the template is trained, you can use it to inspect and verify beads in a target image. The following animation illustrates bead template training. The MIL Bead module can inspect open or closed beads of any shape. If different beads are present in the training image, the module can inspect the beads against different templates simultaneously. You can perform many types of annotations with the MIL Bead module, either when training or verifying beads, such as drawing all of the bead sections that failed due to an insufficient width. After verification, you can ascertain the pass/fail status of the bead or of each bead point, according to the specifications of the template. You can also retrieve measurements, such as width and position values. The MIL Bead module also allows you to save your templates and operation settings from a file or memory stream and later restore them. Note that MIL extracts beads from images using processes based on the MIL Measurement module. Such processes use a one-dimensional analysis of differences in pixel intensities; it is typically quite fast and ideal for basic image characteristics often inherent in beads. For more information about this type of edge extraction, see the Search algorithm section of Chapter 19: Measurement. MIL Bead module ",
      "wordCount": 393,
      "subEntries": []
    },
    {
      "id": "UG_bead_Steps_to_validate_beads",
      "version": null,
      "title": "Steps to validate beads",
      "subTitles": null,
      "location": "MIL UG P03: 2D processing and analysis",
      "pageURL": "content\\UserGuide\\bead\\Steps_to_validate_beads.htm",
      "text": " Steps to validate beads The following steps provide a basic methodology for using the MIL Bead module: Allocate a bead context to hold your bead templates, using MbeadAlloc(). Allocate a bead result buffer to hold the results of the verification operation, using MbeadAllocResult(). Add a bead template to the bead context, using MbeadTemplate(). You can repeat this step to add multiple templates. Specify training settings, using MbeadControl(). Train the templates, using MbeadTrain(). If necessary, you can perform certain drawing operations based on the trained templates, using MbeadDraw(). Verify the training status of the templates in the context, using MbeadInquire() with M_STATUS. If the templates are not completely trained, you can use MbeadTemplate() and MbeadControl() to modify the templates and then re-call MbeadTrain(). Specify verification settings, using MbeadControl(). Verify beads in a target image against the bead templates, using MbeadVerify(). If necessary, you can perform certain drawing operations based on bead results, using MbeadDraw(). Retrieve the required bead results from the result buffer, using MbeadGetResult(). If necessary, you can use MbeadControl() to modify verification settings and then re-call MbeadVerify(). If necessary, save your bead context, using MbeadSave() or MbeadStream(). Once you save a bead context, you can later restore it, using MbeadRestore() or MbeadStream(). Restoring a bead context instead of creating it again can be more efficient, especially if the restored context requires no further modifications. You can save or restore a bead context to/from a file or memory stream. Free all your allocated bead objects, using MbeadFree(), unless M_UNIQUE_ID was specified during allocation. Steps to validate beads ",
      "wordCount": 259,
      "subEntries": []
    },
    {
      "id": "UG_bead_Basic_concepts",
      "version": null,
      "title": "Basic concepts for the MIL Bead module",
      "subTitles": null,
      "location": "MIL UG P03: 2D processing and analysis",
      "pageURL": "content\\UserGuide\\bead\\Basic_concepts.htm",
      "text": " Basic concepts for the MIL Bead module The basic concepts and vocabulary conventions for the MIL Bead module are: Bead. A strip of malleable material, such as glue or lead, typically used to bond objects together. Bead template. A reusable model of a bead. Edge. A curve that delineates a boundary, which can be established from intensity transitions in an image. Gap. Consecutive measured points that were expected but not found. Measured bead. A bead in a target image that MIL verifies. Measured point. A trained point's corresponding point found (or expected) on a measured bead. Path. The continuous sequence of positions that the bead follows. Point. A positional element along a bead. Search box. The region in the image in which to extract a point along the bead. The portion of the bead, corresponding to the search box of a point, can be referred to as a slice. Stripe. A bead consisting of two edges; the distance between the edges is the bead's width. Target image. The image in which to measure and validate beads during the verification phase. Trained bead. A template that has been trained (contains the trained points), which allows you to use it for the verification of a bead. Trained points. Points contained in a template, generated by the training phase, and used for the verification of a bead. Each trained point is associated with the width and height of the bead slice from which it was extracted (search box). Training (phase). The operation that uses all training specifications to generate the trained bead template(s). Training image. An ideal image of beads, which you can use during the training phase to train the templates and establish their trained points. Verification (phase). The operation that analyzes beads in the target image and validates whether they conform to the specified bead template. Vertices. Positional points added to a bead template to define its path. Basic concepts for the MIL Bead module ",
      "wordCount": 326,
      "subEntries": []
    },
    {
      "id": "UG_bead_Defining_training_and_modifying_templates",
      "version": null,
      "title": "Defining, training, and modifying bead templates",
      "subTitles": [
        "Template type",
        "Foreground",
        "Template path",
        "Polyline that will be refined by a training image",
        "Fixed polyline",
        "Fixed circle or segment",
        "Template from a 2D graphics list",
        "Template width",
        "Automatically establishing the width",
        "Explicitly setting the width",
        "Training box of the template",
        "Smoothness and threshold",
        "General operations with a template",
        "Obtaining the closest template and vertex",
        "Training status",
        "When templates are not completely trained",
        "Input units",
        "Saving the training image",
        "Summary of the main training settings"
      ],
      "location": "MIL UG P03: 2D processing and analysis",
      "pageURL": "content\\UserGuide\\bead\\Defining_training_and_modifying_templates.htm",
      "text": " Defining, training, and modifying bead templates After allocating a bead context using MbeadAlloc(), you can add bead templates to it using MbeadTemplate(). A bead template is a reusable model of a bead. To define a template, you can specify a variety of settings, such as its type, path, and width. For example, you can define a template that represents a bead stripe, follows a polyline path (according to specified vertices), and has a consistent nominal width. To establish a closed bead template, the first and last points in the path must be at the same position. Once you have specified the settings of your templates, you must train them using MbeadTrain(). During the training phase, MIL typically uses a training image to refine the template's path (that you initially specified) and establish the template's trained points. Once trained, a bead template contains all the information required to verify beads, such as the trained points. Template type A template's type refers to whether the template represents a bead that is an edge (edge-bead) or a stripe (stripe-bead). Templates that represent an edge indicate that the bead is essentially an outline, which has been delineated by a boundary established from intensity transitions in an image. In general, you should use an edge-bead to represent the skeletal border of an object. Templates that represent a stripe indicate that the bead has two edges separated by a width. In general, you should use a stripe-bead to represent a strip of some malleable material, such as glue or lead. By default, MIL assumes that you are using stripe-beads. To specify that the template represents a bead that is a stripe or an edge, use MbeadTemplate() with M_BEAD_STRIPE or M_BEAD_EDGE, respectively, when adding the template. Deciding whether your template should represent a stripe or an edge depends on the bead that you will be working with and the requirements of your application. Foreground By default, MIL assumes that the foreground of the measured bead is lighter than the background. For stripe-beads, this implies a light stripe-bead (for example, a white bead) on a dark background (for example, a black surface). To establish the foreground of an edge-bead, MIL considers the bead's direction, which is implied by the order of its vertices. Based on the direction, the foreground is on the left side of the edge-bead, when following the path of the bead in that direction; the background is on the right side. To set whether MIL considers the foreground to be lighter or darker than the background, use MbeadControl() with M_FOREGROUND_VALUE. Template path A template's path represents the continuous sequence of positions that the bead follows. To establish the path of a template, use MbeadControl() with M_TRAINING_PATH. You can specify that the template's path follows a: Polyline that you must refine with a training image (M_POLYLINE_SEED). Fixed polyline (M_POLYLINE). Fixed circle or segment (M_CIRCLE or M_SEGMENT). All paths are available with templates representing a bead that is either a stripe (M_BEAD_STRIPE) or an edge (M_BEAD_EDGE). Polyline that will be refined by a training image By default (M_POLYLINE_SEED), the template's path follows a polyline that you must specify with vertices, and that MIL must refine with a training image. If you use M_POLYLINE_SEED and do not specify a training image when calling MbeadTrain(), you will get an error. To define the polyline, you must specify the X- and Y-coordinates of its vertices when adding the template using MbeadTemplate() with M_ADD. The order of the vertices establishes the polyline's shape and direction. Typically, you will derive the positions of the vertices from the same image that you will use as your training image (which is usually a good version of a typical target image that you will use in the verification phase). A polyline path must have at least two vertices. Ideally, each vertex that you add with MbeadTemplate() should be at a position that corresponds to (or, is close to) a point along the corresponding bead in the training image. If there is an acute angle (0° to 90°), you should add a vertex at the angle's corner and on either side of the corner, to ensure that MIL properly establishes the path. Several operations are available for templates whose path is M_POLYLINE_SEED, such as inserting, removing, and modifying its vertices. For more information, see the General operations with a template subsection of this section. All templates in a bead context use the same training image. If you require multiple training images to refine the paths your templates must follow, use multiple bead contexts. Fixed polyline To specify a polyline path that is fixed, use M_POLYLINE. In this case, the trained position of the path will always follow the specified vertices (the path's position is not refined by a training image, even if you specify one). Typically, you should only use M_POLYLINE when your vertices define the exact path required to train the bead. Such points can, for example, come from a CAD file. To define a fixed polyline, you must specify its vertices using MbeadTemplate() with M_ADD, as explained in the Polyline that will be refined by a training image subsection of this section. Even when specifying a fixed polyline path, MIL creates trained points along the path by default. In this case, although the trained path will be the same as the path specified by the vertices, the number of trained points in the template will be greater than the number of vertices you specified (which can improve accuracy for the verification phase). If you want the trained points to be exactly the same as the vertices specified, you must disable the spacing control MIL uses to distribute the trained points by setting M_TRAINING_BOX_SPACING to M_DISABLE. For more information, see the Training box of the template subsection of this section. Fixed circle or segment To specify a path that follows a fixed circle or segment, use M_CIRCLE or M_SEGMENT. In this case, the trained position of the circle or segment path will always follow the specified path (the path's position is not refined by a training image, even if you specify one). Unlike paths that follow a polyline, you do not specify vertices to set paths that follow a circle or segment. Instead, once you have added the template with M_ADD, you must define the circle or segment path using MbeadControl() with M_TEMPLATE_CIRCLE_CENTER_X, M_TEMPLATE_CIRCLE_CENTER_Y, and M_TEMPLATE_CIRCLE_RADIUS for circles, or M_TEMPLATE_SEGMENT_START_X, M_TEMPLATE_SEGMENT_START_Y, M_TEMPLATE_SEGMENT_END_X, and M_TEMPLATE_SEGMENT_END_Y for segments. You can consider this as a quick way to create a circle or segment path, without having to provide multiple vertices to the template. The direction of fixed segments is from their start point to their end point, while the direction of fixed circles is counter-clockwise. MIL uses the direction to establish the bead's foreground. For more information, see the Foreground subsection of this section. Template from a 2D graphics list You can add a bead template based on the vertices of a polyline (or polygon) from a 2D graphics list, by calling MbeadTemplate() with M_ADD_FROM_GRAPHIC_LIST. The 2D graphics list must contain one polyline (or polygon) graphic, added with MgraLines() or MgraInteractive(). For more information about interactively adding graphics to a 2D graphics list, see the Creating graphics interactively subsection of the Creating and modifying graphics interactively section of Chapter 26: Generating graphics. MIL considers the specified vertices (MgraLines() or MgraInteractive()) as the template's vertices. Templates added with M_ADD_FROM_GRAPHIC_LIST behave the same as those added with M_ADD, and whose path is set to M_POLYLINE_SEED (default) or M_POLYLINE. For more information, see the Template path subsection of this section. Note that a polygon is simply a polyline that MIL automatically closes by connecting the final vertex to the first with a straight line. Any operation or setting in the MIL Bead module that applies to polylines also applies to polygons. Template width A template's width refers to how thick its bead is, from side to side, along its path. If a template represents a bead that is a stripe (M_BEAD_STRIPE), the width refers to the thickness between the stripe's two edges. If the template represents a bead that is an edge (M_BEAD_EDGE), the width refers to the thickness of the edge's intensity transition. To specify how to establish the width of the template's path, use MbeadControl() with M_WIDTH_NOMINAL_MODE. You can either establish the width automatically according to a training image, or you can explicitly set it. During training, MIL attempts to establish the best possible width (the trained width) using your width settings, and all other relevant template settings. For example, to establish the best trained width, MIL also considers the actual width of the bead in the training image (if one is used). To inquire the actual trained width of the bead template corresponding to each trained point along the bead template's path, use MbeadInquire() with M_TRAINED_INDIVIDUAL_WIDTH_NOMINAL. If the template's path follows a polyline, you can also inquire the width corresponding to each originally-specified vertex (before training), using M_INDIVIDUAL_WIDTH_NOMINAL. To inquire the trained nominal width of the bead template (that is, the average width of the bead template), use M_TRAINED_WIDTH_NOMINAL. Automatically establishing the width By default, MIL uses a training image to automatically establish an average width along the specified path (M_AUTO_UNIFORM); in this case, the trained bead width at each trained point is the same. To use a training image to establish a unique width at the position of each trained point, specify M_AUTO_CONTINUOUS. If you use M_AUTO_... and do not specify a training image, you will get an error. When using M_AUTO_... with a stripe-bead template, you can specify a range of valid bead widths. If the width established by the training phase is bigger or smaller than the specified range, the template will not be trained. To set the range of valid bead widths, you must set a nominal width using MbeadControl() with M_TRAINING_WIDTH_NOMINAL, and an upper and lower factor by which the nominal width can vary, using M_TRAINING_WIDTH_SCALE_MAX and M_TRAINING_WIDTH_SCALE_MIN. Explicitly setting the width To define an explicit nominal width for the path, you must set M_WIDTH_NOMINAL_MODE to M_USER_DEFINED, and then use M_WIDTH_NOMINAL to specify the value of the nominal width. The width set for M_WIDTH_NOMINAL applies to the entire path. If the template's path follows a polyline, you can also specify a unique width value for one or more of its vertices, using MbeadTemplate() with M_SET_WIDTH_NOMINAL. You should only set the width of a vertex when you know that it differs from the nominal width. MIL linearly interpolates the width between consecutive vertices. Training box of the template The training box specifies the area along the path in which to establish a trained point when you call MbeadTrain(). To define the training box, you must specify its height (M_TRAINING_BOX_HEIGHT) and width (M_TRAINING_BOX_WIDTH); you must also define the amount of space between the center of each training box along the path (M_TRAINING_BOX_SPACING). The spacing between the boxes affects the total number of trained points (one per box) along the path. MIL establishes trained points at regular intervals along the template's path and ensures that a trained point is at the start and end of paths that are not closed. The specified spacing is therefore adjusted accordingly, when you call MbeadTrain(). Similarly, MIL also modifies the specified height of the training box to achieve the best value based on all settings and the training image, if you are using one (note that MIL does not typically alter the specified training box width). To inquire the actual (trained) spacing, height, and width that MIL establishes, use MbeadInquire() with M_TRAINED_BOX_SPACING, M_TRAINED_BOX_HEIGHT and M_TRAINED_BOX_WIDTH. To inquire the position and number of trained points, use M_TRAINED_POSITION_X, M_TRAINED_POSITION_Y, and M_TRAINED_SIZE. To inquire the training values exactly as you specified them, use M_TRAINING_.... If your template follows a polyline path that MIL must refine with a training image (M_POLYLINE_SEED), the template can only be completely trained if the trained point expected for each training box is located in the training image. When using a polyline path that MIL refines with a training image, you should ensure that the training box is large enough to enclose the bead's width, otherwise MIL might not be able to completely train the template. For more information, see the Template width subsection of this section and the Training status subsection of this section. Smoothness and threshold When you are using a training image with questionable qualities, such as specular highlights and low contrast, and some expected trained points are not found, or you are finding unwanted points, you might consider modifying the default smoothness (M_SMOOTHNESS) and threshold (M_THRESHOLD_VALUE) settings that MIL uses to extract the bead. In general, the training image should be a good representation of the target images that you will use with MbeadVerify(). Smoothness is the noise reduction that MIL applies when extracting beads from an image. You can set the smoothness to a value between 0.0 (almost no noise reduction) and 100.0 (a very strong noise reduction). The default is 50.0, which is typically sufficient. If you experience shiny specular highlights on the bead causing unwanted points to be extracted, adjusting the smoothness can be useful. The threshold ranges from 0.0 to 100.0 and refers to the limit beneath which a grayscale variation within the image is not considered a part of the bead. 0.0 indicates that MIL considers all grayscale variations, while 100.0 indicates that MIL only considers the most extreme grayscale variations. The default is 10.0, which is typically sufficient. If your image has very low contrast, adjusting the threshold can be useful. Note that MIL extracts beads from images using processes based on the MIL Measurement module. For more information about this process, and how to affect it using smoothness and threshold settings, see the Search algorithm section of Chapter 19: Measurement. General operations with a template MbeadTemplate() allows you to perform general operations with a template, such as deleting any template in the context (M_DELETE). For templates whose path follows a polyline (M_POLYLINE_SEED or M_POLYLINE), there are also several other general operations available, allowing you to: Move a template (M_TRANSLATE_POINTS). Rotate a template around its origin (M_ROTATE_POINTS). Resize a template according to a scale factor (M_SCALE_POINTS). Remove a set of vertices from a template (M_DELETE). Add a set of vertices to a template (M_INSERT). Replace a set of vertices in a template with another set of vertices (M_REPLACE). After performing one of these operations, you must re-train the template before calling MbeadVerify(). Obtaining the closest template and vertex MbeadGetNeighbors() allows you to specify a source position, and to retrieve the label of the closest template, and the closest vertex within that template, to that position. You can also use this function to retrieve the closest vertex within a specified template, to the specified position. To set the maximum distance within which MIL considers a template or vertex to be the closest, use MbeadControl() with M_CLOSEST_POINT_MAX_DISTANCE. By default, there is no maximum distance. You can only use MbeadGetNeighbors() with templates whose path follows a polyline. Training status Once you have specified the required training settings and used MbeadTrain() to train the templates, you should inquire their training status using MbeadInquire() with M_STATUS. The status accounts for all the templates in the context and is based on the difference between the number of trained points established and the number of trained points expected, after the last call to MbeadTrain() (using the most current settings at that time). As previously discussed, a trained point is expected within each training box along the template's path. The possible values that MIL returns for M_STATUS are: M_COMPLETE. For a template to be completely trained, every trained point that was expected must have been established (found). MIL only returns M_COMPLETE when all templates in the context meet this requirement. M_PARTIAL. For a template to be partially trained, at least two trained points (but less than all) that were expected must have been established (found). MIL only returns M_PARTIAL when one or more templates in the context meet this requirement. M_NOT_TRAINED. For a template to be not-trained, no trained point (or only one) has been established (found). MIL only returns M_NOT_TRAINED when one or more templates in the context meet this requirement. M_NOT_TRAINED can indicate that you have not yet called MbeadTrain(). The following is a list of possible values that MIL returns for M_STATUS, given the specified condition of the templates in the context: A context with ten templates Possible values returned by M_STATUS In every template, MIL established a trained point for each that was expected. M_COMPLETE In nine of the templates, MIL established a trained point for all that were expected. In one of the templates, MIL established a trained point for all that were expected, except one (for example, it was not found in the training image). M_PARTIAL In eight of the templates, MIL established a trained point for each that was expected. In one of the templates, MIL established a trained point for each that was expected, except one. In one template, MIL was only able to establish one trained point that was expected. M_NOT_TRAINED When templates are not completely trained For the most part, templates that are not completely trained use a training image. Typically, such templates follow a polyline path that MIL must refine (M_POLYLINE_SEED). When such templates fail, it usually indicates that one or more points that MIL expects to be trained (given the template's settings) are not found in the training image. To help decipher why a template isn't completely trained, you can perform drawing operations on the template. For example, you can draw a cross at the position of all the trained points in the template that were expected but not found during the training phase. For more information, see the Drawing section later in this chapter. In general, you should only verify beads with templates that are completely trained. When they are not, you should re-call MbeadTrain() after modifying the relevant training settings discussed in this subsection. For example, you can try: Modifying the template's vertices with MbeadTemplate() to ensure that the template's path follows a polyline that replicates, as accurately as possible, the bead in the training image. To do so, you can try increasing the number or positional accuracy of your vertices. Adjusting the width of the template's path to encompass the width along the entire length of the bead in the training image. Ensure that the width of the path includes the largest possible width of the bead in the training image. Resizing the training box in which MIL finds the trained points. Ensure that the training box includes the largest possible width of the bead. You can also modify the spacing between the training boxes, which essentially alters the number of trained points expected. Improving the quality of the bead in the training image by adjusting the smoothness and threshold settings that MIL uses to extract the bead from the image. Templates that you do not train with a training image, such as those that follow a fixed path (M_POLYLINE, M_CIRCLE, M_SEGMENT) and whose width is explicitly set (M_WIDTH_NOMINAL), are less likely to fail training because their settings do not require MbeadTrain() to make significant preprocessing adjustments. For example, the first call to MbeadTrain() will always completely train a template with two or more vertices, whose path follows a fixed polyline, and whose width is user-defined. Input units Certain bead values relating to position and dimension (such as M_TRAINING_BOX_SPACING) can be interpreted in either pixel or world units. To set the units, use MbeadControl() with either M_TEMPLATE_INPUT_UNITS or M_TRAINING_BOX_INPUT_UNITS. This essentially establishes the input coordinate system to use. If you set the input units to M_PIXEL, related values are interpreted in pixel units (pixel coordinate system). If you use calibrated images and specify M_PIXEL, the specified pixel values will be internally converted to world values. If you set the input units to M_WORLD, related values are interpreted in world units (relative coordinate system). If you do not use calibrated images and specify M_WORLD, an error will be generated. To use a calibrated training image, you can either pass one to MbeadTrain(), or you can specify the camera calibration context to associate to the training image using MbeadControl() with M_ASSOCIATED_CALIBRATION. If both camera calibrations are available, MIL ignores the camera calibration set with M_ASSOCIATED_CALIBRATION. To retain the camera calibration when saving (MbeadSave() or MbeadStream()), you must use M_WITH_CALIBRATION. In this case, you must also use M_WITH_CALIBRATION when restoring the context (MbeadRestore() or MbeadStream()). If you do not save/restore the camera calibration, you must re-associate it after restoring the context. When you use M_WITH_CALIBRATION, the camera calibration is saved or restored in/from the same file as the bead context and cannot be managed independently from the bead context. When the bead context is freed, the camera calibration is automatically freed as well. For more information, see the Working with real-world units section of Chapter 28: Calibrating your camera setup. Saving the training image To store a copy of the training image with the bead context, use MbeadTrain() with M_SAVE_TRAINING_IMAGE. This is required if you want to draw the training image (MbeadDraw()), or if you want to save a training image with the bead context (MbeadSave() or MbeadStream()), and then use it when you restore the context (MbeadRestore() or MbeadStream()). Summary of the main training settings As described above, there are numerous settings for training your template. The following represents a global summary of the main settings, and how they interrelate. Set the bead's type (M_BEAD_STRIPE or M_BEAD_EDGE). Set the bead's path (M_TRAINING_PATH). A polyline that must be refined with a training image (M_POLYLINE_SEED). A fixed polyline (M_POLYLINE). A fixed circle or segment (M_CIRCLE or M_SEGMENT). Set the width of the bead's path (M_WIDTH_NOMINAL_MODE). Automatically establish the path's width from a training image (M_AUTO_UNIFORM or M_AUTO_CONTINUOUS). For stripe beads, set the range of valid widths (M_TRAINING_WIDTH_NOMINAL, M_TRAINING_WIDTH_SCALE_MAX, and M_TRAINING_WIDTH_SCALE_MIN). Explicitly set the path's width value (M_USER_DEFINED). Set the width value (M_WIDTH_NOMINAL). For polyline beads with varying widths, set the width to associate to the specified vertices (M_SET_WIDTH_NOMINAL). Set the training box (M_TRAINING_BOX_HEIGHT, M_TRAINING_BOX_WIDTH, and M_TRAINING_BOX_SPACING). Train the template (MbeadTrain()). Defining, training, and modifying bead templates Template type Foreground Template path Polyline that will be refined by a training image Fixed polyline Fixed circle or segment Template from a 2D graphics list Template width Automatically establishing the width Explicitly setting the width Training box of the template Smoothness and threshold General operations with a template Obtaining the closest template and vertex Training status When templates are not completely trained Input units Saving the training image Summary of the main training settings ",
      "wordCount": 3767,
      "subEntries": []
    },
    {
      "id": "UG_bead_Verifying_beads",
      "version": null,
      "title": "Verifying beads and retrieving results",
      "subTitles": [
        "Score and acceptance",
        "Gaps",
        "Search box",
        "Fail warning",
        "Position and offset",
        "Width",
        "Angle",
        "Intensity",
        "Status and other results",
        "When you have a failing status"
      ],
      "location": "MIL UG P03: 2D processing and analysis",
      "pageURL": "content\\UserGuide\\bead\\Verifying_beads.htm",
      "text": " Verifying beads and retrieving results Once you have successfully trained the bead templates, you can verify them against their corresponding measured beads in a target image, using MbeadVerify(). By default, to pass verification, each trained point in a template must have a corresponding measured point that was successfully found in its measured bead. After calling MbeadVerify(), the main result you will typically be interested in is M_STATUS, which returns whether MIL considers the measured beads (one or all) or the measured points (one or all) to have passed or failed verification. You can also retrieve more specific status results, such as whether a bead's width at a specific point has passed or failed the maximum width setting (M_STATUS_WIDTH_MAX). Such results can help you ascertain why the bead's general status (M_STATUS) is failing. For more information, see the Status and other results subsection of this section. You can affect the verification process and the results it calculates by modifying the verification settings using MbeadControl() before calling MbeadVerify(). For example, you can use M_ACCEPTANCE to lower the percentage of trained points that must have a corresponding measured point (found point) in the target image for the bead to have a passing status. Note that you can only modify foreground, smoothness, and threshold settings during the training phase; for more information, see the relevant subsections in the Defining, training, and modifying bead templates section earlier in this chapter. MIL interprets certain verification input values related to position and dimension type settings (such as M_OFFSET_MAX) in either pixel or world units. To set the units, use MbeadControl() with M_TEMPLATE_INPUT_UNITS. This essentially establishes the input coordinate system to use. If MIL interprets input settings in world units and you don't use a calibrated target image, MbeadVerify() generates an error. Score and acceptance The score refers to the percentage of trained points that have a corresponding measured point with a passing status (M_STATUS), relative to the total number of trained points in the template. For every measured point with a failing status (not found), MIL lowers the bead's score proportionally. For example, if a bead template has 100 trained points and 69 are found to have a passing status, MIL returns a score of 69% for the measured bead. Many reasons can cause a point to have a failing status. It can, for example, fall outside the boundaries of the search box, or its corresponding bead width can be lower than the specified value. To specify the minimum score you're willing to accept for the template's corresponding measured bead to have a passing status, use the M_ACCEPTANCE control. To retrieve whether the measured bead's score has itself passed (is greater than or equal to) or failed (is less than) the acceptance set, use M_STATUS_SCORE. If the requirements of M_ACCEPTANCE are not met or surpassed by the score of the measured bead, its main status result (M_STATUS) will fail, regardless of any other setting. To get the score of the template's corresponding measured bead, as well as the number of trained points that have a corresponding measured point, call MbeadGetResult() with M_SCORE and M_NUMBER_FOUND, respectively. Gaps A gap refers to a section of the measured bead that corresponds to a single trained point, or to a set of consecutive trained points, that were expected but not found during verification. By default, a measured bead is expected to be gap free. To manage the extent to which you are willing to accept gaps during verification, you can use MbeadControl() to set the: Maximum allowable length of any one gap in the measured bead (M_GAP_MAX_LENGTH). For a measured bead to have a passing status result (M_STATUS), it cannot have a gap that is longer than M_GAP_MAX_LENGTH, regardless of any other setting. To retrieve the actual length of the longest gap result, use M_GAP_MAX_LENGTH. Total allowable gap (all gaps together) in the measured bead (M_GAP_TOLERANCE). For a measured bead to have a passing status result (M_STATUS), the total combined length of all gaps in the measured bead, relative to the full length of the expected measured bead, must be less than M_GAP_TOLERANCE, regardless of any other setting. To retrieve the actual percentage of the total length of all gaps in the measured bead result, use M_GAP_COVERAGE. The following example illustrates two beads, each 50 units long. M_GAP_MAX_LENGTH is set to 10 units and M_GAP_TOLERANCE is set to 50%. The first bead fails because it has a gap with a length that is greater than 10 units. The second bead passes because there is no gap with a length greater than 10 units, and the total length of all gaps is less than 50% of the bead's length. To retrieve whether the gaps in the measured bead have themselves passed (are less than or equal to) or failed (are greater than) the gap constraints, use MbeadGetResult() with M_STATUS_GAP_MAX or M_STATUS_GAP_TOLERANCE. Search box The search box is the area along the bead in the target image in which to find each trained point's corresponding measured point, when you call MbeadVerify(). To retrieve whether MIL has found a trained point's associated measured point, use M_STATUS_FOUND. You can also use this result to retrieve whether the entire measured bead was found. For more information, see the Status and other results subsection of this section. MIL bases the search box's height, width, and spacing on the trained box established during training (MbeadInquire() with M_TRAINED_BOX_HEIGHT, M_TRAINED_BOX_WIDTH, and M_TRAINED_BOX_SPACING). For verification, you can increase the width of the search box by adding margins to the width of the trained box, using M_BOX_WIDTH_MARGIN. You must specify the margin as a percentage of the trained nominal width of the bead template, which you can inquire with M_TRAINED_WIDTH_NOMINAL. MIL calculates the width of the search box as: SearchBoxWidthForVerification = M_TRAINED_BOX_WIDTH + (M_TRAINED_WIDTH_NOMINAL x M_BOX_WIDTH_MARGIN). For example, if the trained box width (M_TRAINED_BOX_WIDTH) is 100 pixels, the trained nominal width (M_TRAINED_WIDTH_NOMINAL) is 60 pixels, and the specified margin (M_BOX_WIDTH_MARGIN) for the search box of the bead template is 50%, the width of the search box is 130 pixels (100 + (60 x 0.5)). The search box width is therefore 30 pixels (15 pixels on each side) wider than the width of the trained box. By default, the additional margin that MIL adds is half the trained nominal width of the bead template. For verification, the height and spacing of the search box is always the same as the height and spacing established for the trained box (M_TRAINED_BOX_HEIGHT and M_TRAINED_BOX_SPACING). For more information, see the Training box of the template subsection of the Defining, training, and modifying bead templates section earlier in this chapter. Fail warning Only trained points with a corresponding measured point that falls within its search box can be given a passing status result (M_STATUS). In some cases, you might want the measured point to fail verification, but you still want MIL to find it, if it is within a certain distance from the limits of its search box's margin. This can mark the difference between measured points that are truly not there (for example, missing glue along the path), versus measured points that are misplaced (for example, an unexpected bulge of glue protruding along the typical glue path). To specify an additional width for the search box in which a measured point can be found but have a failed status, use M_FAIL_WARNING_OFFSET. When a trained point's corresponding measured point falls inside its search box's fail-warning zone, you can still retrieve its results, such as its found position. These results are not possible for points that fall outside the fail-warning zone. If the width of the search box is greater than M_FAIL_WARNING_OFFSET, this setting has no effect. Position and offset Position refers to either the X- and Y-location of each trained point in the template (which you can retrieve using MbeadGetResult() with M_TRAINED_POSITION_X and M_TRAINED_POSITION_Y) or the X- and Y-location of each corresponding measured point in the measured bead (which you can retrieve using M_POSITION_X and M_POSITION_Y). The offset refers to the distance between these two sets of corresponding positions. Positions are taken at the center of the bead width. Using MbeadControl() with M_OFFSET_MAX, you can set the maximum allowable distance between the position of the trained points in the template and the position of their corresponding measured points in the target, for your results to have a passing status (M_STATUS). By default, MIL does not allow any offset. To retrieve whether the measured bead adheres to the specified offset condition, use MbeadGetResult() with M_STATUS_OFFSET. Keep in mind that measured points must always fall within the search box, otherwise they are not found and the offset constraint does not apply. The maximum offset should therefore fall within the search box. Depending on your settings, a measured point can be found within the search box (M_STATUS_FOUND), but still fail the position offset condition (M_STATUS_OFFSET). To retrieve the actual offset calculated between each trained point and its corresponding measured point, use M_OFFSET. To retrieve the greatest of these offsets, use M_OFFSET_MAX. To retrieve the index of the trained point that corresponds to the measured point that represents the greatest offset, use M_OFFSET_MAX_INDEX. To retrieve the coordinates of the points on the left and right edges of the bead, which are collinear with the measured point, you can use M_START_POS_X / M_START_POS_Y and M_END_POS_X / M_END_POS_Y, respectively. Note that left and right are established from the bead's direction, which follows the sequence of measured points in increasing order. You can only retrieve this information for stripe-beads. Width Width refers to the bead's thickness, from side to side, along its path. To retrieve the width of the measured bead at each of its measured points, use MbeadGetResult() with M_WIDTH_VALUE. You can also retrieve the average width of the measured bead (M_WIDTH_AVERAGE), its maximum (M_WIDTH_MAX) and minimum (M_WIDTH_MIN) width, as well as the index of the trained point that corresponds to the measured point representing the maximum (M_WIDTH_MAX_INDEX) and minimum (M_WIDTH_MIN_INDEX) width. By default, the width of the bead at each measured point must be the same as the width of the bead template at each corresponding trained point, to get a passing status result (M_STATUS), regardless of any other setting. For stripe-beads (MbeadTemplate() with M_BEAD_STRIPE), you can use MbeadControl() with M_WIDTH_DELTA_NEG and M_WIDTH_DELTA_POS to set a valid delta negative and delta positive tolerance between the width of the measured bead and the nominal width of the template. To retrieve whether width results adhere to (pass or fail) the specified width conditions, use M_STATUS_WIDTH_MAX and M_STATUS_WIDTH_MIN. Angle The angle of a bead refers to the angles represented by its points. For each point, an angle is established using a theoretical line that passes through that point, and is perpendicular to the tangent line that represents the bead within that point's training or search box. Using the M_ANGLE_ACCURACY_MAX_DEVIATION control type, you can set a maximum angular difference between the angle of the bead template at each of its trained points, and the angle of the corresponding measured bead at each of its measured points. By default, there can be no difference. If you do not specify an angular deviation, MIL considers the width of the bead at each measured point to be along the angle established at its corresponding trained point. By specifying an angular deviation, MIL can refine its width measurement accordingly. Typically, you should use M_ANGLE_ACCURACY_MAX_DEVIATION to specify a small value of only a few degrees to manage minor deviations in bead width due to some shifts in angle that can occur in certain target images during the verification phase. Large deviation values can lead to invalid results and longer processing times. To retrieve the angle of the measured bead at the position of its measured points, use MbeadGetResult() with M_ANGLE. Intensity Intensity can be seen as the brightness of the bead, which MIL establishes according to the grayscale value of its pixels. Since your training (MbeadTrain()) and target (MbeadVerify()) images must be 8-bit, the highest possible pixel value of a bead is 255 (brightest intensity), while the lowest possible pixel value is 0 (darkest intensity). MIL calculates the intensity for each point (measured point or trained point) at the center of its corresponding bead width. Intensity constraints and results only apply to stripe-beads (MbeadTemplate() with M_BEAD_STRIPE). To retrieve the intensity of the measured bead at each of its measured points, use MbeadGetResult() with M_INTENSITY. You can also retrieve the measured bead's maximum (M_INTENSITY_MAX) and minimum (M_INTENSITY_MIN) intensity, as well as the index of the trained point that corresponds to the measured point representing the maximum (M_INTENSITY_MAX_INDEX) and minimum (M_INTENSITY_MIN_INDEX) intensity. Provided that MIL is able to find the bead in the search box, there are no default restrictions for the intensity of the bead. You can however use MbeadControl() to set a nominal pixel intensity for the measured bead, and an acceptable maximum and minimum range within which the intensity of the bead must fall. To set intensity conditions, first use M_INTENSITY_NOMINAL_MODE to specify how MIL should establish the nominal intensity with which to validate the template's corresponding measured bead. By setting the nominal intensity mode to M_AUTO, MIL will establish the nominal intensity during the training phase (from the training image). By setting the nominal intensity mode to M_USER_DEFINED, you must explicitly set the nominal intensity using M_INTENSITY_NOMINAL. By setting the nominal intensity mode to M_DISABLE (same as M_DEFAULT), MIL will ignore all intensity conditions. Once you have established the nominal intensity, either from the training image (M_AUTO) or with an explicit value (M_INTENSITY_NOMINAL), you can use the following verification settings to specify a valid range within which the intensity of the measured bead must fall: M_INTENSITY_DELTA_NEG, which sets the lowest pixel intensity MIL considers valid for the measured bead, relative to the nominal intensity. That is, LowestValidIntensity = NominalIntensity - M_INTENSITY_DELTA_NEG. M_INTENSITY_DELTA_POS, which sets the highest pixel intensity MIL considers valid for the measured bead, relative to the nominal intensity. That is, HighestValidIntensity = NominalIntensity + M_INTENSITY_DELTA_POS. To retrieve whether the intensity results adhere to (pass or fail) the specified intensity conditions, use M_STATUS_INTENSITY_MAX and M_STATUS_INTENSITY_MIN. Status and other results As previously discussed, there are many different status results available for retrieval with MbeadGetResult(). Depending on the settings of this function's parameters, the same status can have different meanings. For example, the main status (M_STATUS) result can retrieve: Whether all measured beads corresponding to all bead templates in the bead context have passed or failed verification, when you set the LabelOrIndex and ResultIndex parameters to M_GENERAL. In this case, M_STATUS will pass only if all status results (M_STATUS_...) for all templates in the context return M_PASS. Whether the measured bead corresponding to a specific template has passed or failed verification, when you set the LabelOrIndex parameter to the label or index of the template and the ResultIndex parameter to M_GENERAL. In this case, M_STATUS will pass only if the template's corresponding measured bead has passed all of the following: M_STATUS_GAP_TOLERANCE, M_STATUS_GAP_MAX, and M_STATUS_SCORE. Whether the measured points corresponding to the specified trained points of a bead template have passed or failed verification, when you set the LabelOrIndex parameter to the label or index of a template and the ResultIndex parameter to a specific value (a trained point) or M_ALL (all trained points). In this case, M_STATUS will pass only if each trained point's corresponding measured point has passed all of the following: M_STATUS_SEARCH, M_STATUS_FOUND, M_STATUS_OFFSET, M_STATUS_WIDTH_MAX, M_STATUS_WIDTH_MIN, and M_STATUS_GAP_MAX. Some of the specific M_STATUS_... results are available for either the template's corresponding measured bead or the trained points' corresponding measured points. For example, if you are retrieving the M_STATUS_FOUND result, and you set the ResultIndex parameter to M_GENERAL, MIL returns M_PASS if all trained points have a corresponding measured point (all were found). Otherwise, MIL returns M_FAIL. However, if you set the ResultIndex parameter to M_ALL, MIL returns M_FAIL or M_PASS for each trained point, depending on whether its corresponding measured point was found. If you set the ResultIndex parameter to a specific trained point, MIL returns only the found status of its measured point. Although status results are typically the most crucial, you can also retrieve other results related to MIL's analysis of the measured bead or measured point. For example, you can retrieve the position of the training point's associated measured points (M_POSITION_X and M_POSITION_Y), the corresponding width of the measured bead at those points (M_WIDTH_VALUE), and whether the path of the measured bead ends where it began (M_CLOSURE). When you have a failing status To help decipher why you have a failing status (M_STATUS), you can try: Pin-pointing the root cause of the failure. For example, if the failing status is based on all the bead templates in the entire context, you should get the status of each individual template, and for the ones that are failing, you should get the status of each individual point. Keep in mind all the conditions upon which the status is based, and how failing just one causes M_STATUS to fail. For example, if you are retrieving whether a specific template has passed or failed verification, and that template's corresponding measured bead has failed the gap tolerance constraint (M_STATUS_GAP_TOLERANCE), M_STATUS will fail, even if there are enough measured points to pass the minimum score constraint (M_STATUS_SCORE). Once you have isolated the failing points, determine the cause of their failure by getting more specific status results about them (M_STATUS_...). For example, you can use M_STATUS_SEARCH to determine whether MIL considers it possible to establish the measured point, given the current settings. Note that, if the search box corresponding to a measured point falls outside the target image, M_STATUS_SEARCH returns M_FAIL since you can never establish a measured point that is beyond the boundaries of the image. Performing drawing operations to get a visual representation of the measured bead and its measured points. For example, you can draw a cross at the position of all the measured points that were expected but not found. For more information, see the Drawing section later in this chapter. Since verification uses trained templates, settings for the training phase have an indirect affect on the verification phase. If you are unable to successfully verify beads in a target image, and you are unwilling to accept missing measured points (for example, by lowering M_ACCEPTANCE or allowing for gaps), you might have to modify the template and re-call MbeadTrain() before calling MbeadVerify() again. Verifying beads and retrieving results Score and acceptance Gaps Search box Fail warning Position and offset Width Angle Intensity Status and other results When you have a failing status ",
      "wordCount": 3095,
      "subEntries": []
    },
    {
      "id": "UG_bead_Drawing",
      "version": null,
      "title": "Drawing",
      "subTitles": [
        "Specifying the points",
        "When drawing with a bead context",
        "When drawing with a bead result",
        "Specifying the drawing operation",
        "Adjusting the templates and trained points with which to draw"
      ],
      "location": "MIL UG P03: 2D processing and analysis",
      "pageURL": "content\\UserGuide\\bead\\Drawing.htm",
      "text": " Drawing By calling MbeadDraw(), you can perform drawing operations with a bead template and its points (when passing a bead context to the function), or with a measured bead and its points (when passing a bead result to the function). For example, when using a bead context, you can use M_DRAW_POSITION with M_TRAINED_PASS to draw a cross at the position of each trained point that has successfully passed the training phase. Similarly, when using a bead result, you can use M_DRAW_POSITION with M_PASS to draw a cross at the position of each trained point's corresponding measured point that has successfully passed the verification phase. You can perform drawings in either an image buffer or 2D graphics list, unless otherwise specified. To control the drawing color, you can use MbeadDraw() with a previously allocated 2D graphics context or with the default 2D graphics context. You can also choose to draw in the display's overlay buffer, which allows you to annotate an image non-destructively. For more information, see Chapter 26: Generating graphics and the Annotating the displayed image non-destructively section of Chapter 25: Displaying an image. When calling MbeadDraw() with a bead context (and using a calibrated training image) or with a bead result (and using a calibrated target image), the destination drawing buffer need not be calibrated to the same world. MIL draws according to the camera calibration context associated to either the training or verification image. Specifying the points When calling MbeadDraw(), you must specify the points with which to draw, by setting the DrawOption parameter. The settings available depend on whether you are calling MbeadDraw() with a bead context or result. When drawing with a bead context When drawing with a bead context, you can specify that MIL performs the drawing operation (M_DRAW_...) using one of the following: M_USER, which performs the drawing operation using the template's vertices. If the template's path (MbeadControl() with M_TRAINING_PATH) follows a polyline, M_USER refers to the template's polyline points (MbeadTemplate()). If the template's path follows a circle or segment, M_USER refers to the minimum critical points that MIL internally calculates based on the settings of the path. For a path that follows a segment, MIL calculates three critical points, according to the specified start and end of the segment (MbeadControl() with M_TEMPLATE_SEGMENT_...). For a path that follows a circle, MIL calculates five critical points, according to the specified center and radius of the circle (M_TEMPLATE_CIRCLE_...). M_TRAINED_FAIL, which performs the drawing operation using all the trained points that were expected but not established (found) during training (MbeadTrain()). In this case, the drawing operation uses the expected position of the trained point. Such drawings can be particularly useful when deciphering why a template isn't completely trained (MbeadInquire() with M_STATUS), especially if drawn on top of the training image (M_DRAW_TRAINING_IMAGE). M_TRAINED_PASS, which performs the drawing operation using all the trained points that were established (found) during training. M_TRAINED, which performs the drawing operation using all the trained points that were found (M_TRAINED_PASS) and all the trained points that were expected but not found (M_TRAINED_FAIL) during training. When drawing with a bead result When drawing with a bead result, you can specify that MIL performs the drawing operation (M_DRAW_...) using one of the following: M_FAIL, which performs the drawing operation using all the measured points that were expected but did not pass verification. In this case, the drawing operation uses the expected position of the measured point (based on its associated trained point). You can also draw using the measured points that failed for a more specific reason. For example, you can draw: the expected position of a measured point that was not found (M_FAIL_NOT_FOUND), the position of a measured point that was found but has failed because its position is not within the specified offset (M_FAIL_OFFSET), or the position of a measured point that was found but has failed because the width of the measured bead at that point is less than the specified minimum width (M_FAIL_WIDTH_MIN). Such drawings can be particularly useful when deciphering why MbeadGetResult() is returning a failed status (M_STATUS), especially when drawn on top of a target image. M_PASS, which performs the drawing operation using all the measured points that have passed verification. M_ALL, which performs the drawing operation using all the measured points (M_PASS and M_FAIL). Specifying the drawing operation Once you have selected the set of points, you should specify the type of drawing operation to perform on them. Using the selected set of points, MIL can draw: The index value of each point (M_DRAW_POSITION_INDEX). If you specify M_USER as your set of points, you can only perform this drawing operation for templates with a path that follows a polyline, otherwise you will get an error. You can also draw the index or label of the template that contains the selected set of points (M_DRAW_INDEX or M_DRAW_LABEL). A cross at the position of each point (M_DRAW_POSITION) or a line that connects all the points (M_DRAW_POSITION_POLYLINE). The area within which each point was established (M_DRAW_SEARCH_BOX) or an H-type line (|-|) indicating the width of the bead at that point (M_DRAW_WIDTH). In the following example, MIL has drawn: the width of the bead (in white) at each measured point that has a passing status (M_DRAW_WIDTH and M_PASS), the search box (in white) of the measured points that were expected but not found (M_DRAW_SEARCH_BOX and M_FAIL_NOT_FOUND), and the search box (in gray) of the measured points that were expected but failed because the corresponding bead width was too small (M_DRAW_SEARCH_BOX and M_FAIL_WIDTH_MIN). You can also call MbeadDraw() to draw a training image, using M_DRAW_TRAINING_IMAGE. Unlike other drawing operations, drawing a training image is not based on a specific set of points and it cannot be drawn in a 2D graphics list. Also, when drawing a training image, you must use MbeadDraw() with a bead context and you must have internally saved the training image with MbeadTrain(). Adjusting the templates and trained points with which to draw As previously discussed, MIL performs the drawing operation (DrawOperation) using the type of points selected (DrawOption), for either the bead context or result. Typically, you will want to perform the drawing operation on all points in all beads that meet the specified requirements. In this case, you must set the LabelOrIndex and Index parameters to M_ALL. You can however adjust these two parameter settings and specify that MIL should perform the drawing using a specific point in a specific template, or using one or all points in one or all templates. For example, you can draw search boxes for only one particular template in the context, or for only one particular point. You can also specify that MIL should base the drawing on the specified templates as a whole, by setting the Index parameter to M_GENERAL and the LabelOrIndex parameter to one or all templates. In this case, MIL performs the drawing for the entire template if it contains one or more points that meet the requirements of the DrawOption parameter setting. For example, if you are using bead results and specify M_DRAW_POSITION with M_PASS, and you set the Index parameter to M_GENERAL and the LabelOrIndex parameter to a specific template, MIL will draw the position of all the points related to that template as long as at least one of its trained point's corresponding measured point has passed verification. Given this high level of flexibility, you should be especially mindful of each parameter setting when calling MbeadDraw(). Drawing Specifying the points When drawing with a bead context When drawing with a bead result Specifying the drawing operation Adjusting the templates and trained points with which to draw ",
      "wordCount": 1273,
      "subEntries": []
    },
    {
      "id": "UG_bead_Bead_example",
      "version": null,
      "title": "Bead example",
      "subTitles": null,
      "location": "MIL UG P03: 2D processing and analysis",
      "pageURL": "content\\UserGuide\\bead\\Bead_example.htm",
      "text": " Bead example The bead example mbead.cpp shows you how to train a bead template using a training image, and how to use the trained template to verify a bead for defects in a target image. The example deals with bead paths that follow a polyline and a fixed circle. mbead.cpp To run this example, use the Matrox Example Launcher in the MIL Control Center. Bead example ",
      "wordCount": 68,
      "subEntries": []
    }
  ]
}]
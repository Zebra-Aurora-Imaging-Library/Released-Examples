[{
  "id": "UG_3D_Blob_analysis",
  "version": "2024020714",
  "title": "3D blob analysis",
  "subTitles": null,
  "location": "MIL UG P05: 3D processing and analysis",
  "pageURL": "content\\UserGuide\\3D_Blob_analysis\\ChapterInformation.htm",
  "text": " Chapter 36: 3D blob analysis This chapter describes how to use the 3D Blob Analysis module to segment a point cloud into blobs, calculate blob features, and select and sort for blobs of interest. MIL 3D Blob analysis module Steps to performing 3D blob analysis Basic concepts for the MIL 3D Blob Analysis module Calculating a blob segmentation Segmentation from the point cloud Segmentation using a label image Segmentation context control settings Calculating blob features Enabling features for calculation Moments Selecting, combining, and sorting blobs Selecting blobs Choosing a selection criterion Combining blobs Sorting blobs Retrieving and drawing results Possible results Drawing results 3D blob analysis example Segmenting a point cloud and identifying blobs based on blob features Continuous segmentation Segmentation bin picking ",
  "wordCount": 125,
  "subEntries": [
    {
      "id": "UG_3D_Blob_analysis_3D_Blob_analysis_overview",
      "version": null,
      "title": "MIL 3D Blob analysis module",
      "subTitles": null,
      "location": "MIL UG P05: 3D processing and analysis",
      "pageURL": "content\\UserGuide\\3D_Blob_analysis\\3D_Blob_analysis_overview.htm",
      "text": " MIL 3D Blob analysis module The 3D Blob Analysis module allows you to segment a point cloud into blobs, calculate blob features, and select and sort for blobs of interest. In 3D, blobs are, typically, subsets of neighboring points. MIL performs the segmentation based on distances between points in the point cloud or on other metrics such as the color distance between neighboring point data or the similarity of normal vector angles in a point neighborhood. Instead of subsets of neighboring points, you can use a label image to define the blob segmentation. Each pixel in a label image is set to a value that will identify corresponding points in a point cloud as belonging to a specific blob, using a label that is unique for each blob. Once you have defined a blob segmentation, you can use the 3D Blob Analysis module to calculate features of blobs, and select and sort for blobs of interest. For example, you can select blobs that meet a specified Feret size, and then sort the indices of these blobs so that they are ordered in the result buffer according to increasing or decreasing Feret size. You can calculate various blob features such as the bounding box of the blob, its planarity, linearity, and distance to the nearest neighboring blob. You can also calculate moments and principal component analysis (PCA) results. You can select which blobs meet a criterion and copy the corresponding blob identifying information and feature results into a new result buffer, so that only the selected blobs are recognized for future operations. You can also combine the blob identifying information and feature results from different result buffers, to perform compound selections (criterion 1 AND/OR criterion 2). You can retrieve results for individual blobs or all blobs. You can also copy blob feature results that correspond to geometries into a geometry object. In addition, you can copy results into an image buffer to create a label image, index image, or mask image. MIL 3D Blob analysis module ",
      "wordCount": 337,
      "subEntries": []
    },
    {
      "id": "UG_3D_Blob_analysis_Steps_to_performing_3D_blob_analysis",
      "version": null,
      "title": "Steps to performing 3D blob analysis",
      "subTitles": null,
      "location": "MIL UG P05: 3D processing and analysis",
      "pageURL": "content\\UserGuide\\3D_Blob_analysis\\Steps_to_performing_3D_blob_analysis.htm",
      "text": " Steps to performing 3D blob analysis The following steps provide a basic methodology for using the MIL 3D Blob Analysis module: Allocate a segmentation 3D blob analysis context, using M3dblobAlloc() with M_SEGMENTATION_CONTEXT. This context is used to specify how to segment a point cloud into blobs. Note that you can skip this step and use a predefined segmentation context instead. Allocate a 3D blob analysis result buffer, using M3dblobAllocResult() with M_SEGMENTATION_RESULT. The result buffer will hold the segmentation and any calculated feature results. If required, adjust global 3D blob analysis settings to fit your application, using successive calls to M3dblobControl(). If you are using a label image to define the blob segmentation, create the image (for example, using MblobLabel()). Perform the segmentation, using M3dblobSegment() with either a point cloud container or the label image. If feature calculations are required, allocate a calculate 3D blob analysis context, using M3dblobAlloc() with M_CALCULATE_CONTEXT. If required, calculate features and analyze the results. This involves the steps listed below. You can repeat these steps until you obtain all required results for the blobs of interest. Note that some blob features take longer to calculate (for example, minimum/maximum Feret diameter and nearest blob). Specifying fewer blobs when calculating these features can save time. Otherwise, it is often faster to calculate all the required features (except minimum/maximum Feret diameter and nearest blob) with a single call to M3dblobCalculate(), and then selecting for blobs of interest afterwards. Enable the features to calculate, using successive calls to M3dblobControl(). Calculate results for the features enabled for calculation, using M3dblobCalculate(). Optionally, pass the result buffer to M3dblobSelect() and M3dblobCombine() to create a result buffer that holds information only for blobs of interest. Optionally, sort the indices assigned to blobs based on their blob features, using M3dblobSort(). Retrieve required results from the 3D blob analysis result buffer, using M3dblobGetResult(). Note that trying to retrieve a result that is not available generates an error. If required, copy a group of 3D blob analysis results into an image buffer, a 3D geometry object, a transformation matrix object, or a 3D blob analysis result buffer, using M3dblobCopyResult(). For example, you can copy a blob's principal axis into a 3D geometry object to establish a unit-length 3D line geometry that marks the axis, and likewise for the second and third principal axes. If required, copy specified blobs to another container, using M3dblobExtract(). To draw blobs and/or blob features into a 3D graphics list, perform the following: Allocate a draw 3D blob analysis context, using M3dblobAlloc() with M_DRAW_3D_CONTEXT, to hold the settings for the draw. Note that you can skip this step and use a default context instead. Specify the draw operations and options for the draw, using M3dblobControlDraw(). Draw the blobs and/or blob features, using M3dblobDraw3d(). If required, save your 3D blob analysis context, using M3dblobSave() or M3dblobStream(). Free all your allocated objects using M3dblobFree(), unless M_UNIQUE_ID was specified during allocation. Steps to performing 3D blob analysis ",
      "wordCount": 493,
      "subEntries": []
    },
    {
      "id": "UG_3D_Blob_analysis_Basic_concepts",
      "version": null,
      "title": "Basic concepts for the MIL 3D Blob Analysis module",
      "subTitles": null,
      "location": "MIL UG P05: 3D processing and analysis",
      "pageURL": "content\\UserGuide\\3D_Blob_analysis\\Basic_concepts.htm",
      "text": " Basic concepts for the MIL 3D Blob Analysis module The basic concepts and vocabulary conventions for the MIL 3D Blob Analysis module are: Bounding box. The smallest axis-aligned box that contains all the points in a blob. Centroid. The center of gravity of a blob. Eigenvalue The amount of variance as measured along a principal component. The largest eigenvalue corresponds to the variance of the first principal component. Feret. The diameter of a blob at a given angle or position. Moment. The distribution of matter (in this case, 3D points) about a point or axis. PCA. Principal component analysis. The principal components of a dataset (in this case, 3D points distributed in a blob) are the directions along which there is the most variance, or spread, in the data. The first principal component (or principal axis) represents the maximum variance; the second principal component represents the second-most variance, perpendicular to the first; and the third principal component is perpendicular to the first two components. PCA-aligned bounding box. The smallest box containing all the points in a blob that is also aligned with the blob's three principal components (principal axes). Point cloud. A set of 3D points representing objects in a scene. Semi-oriented bounding box. The smallest box containing all the points in a blob that is axis-aligned in Z but not in X and Y. Working coordinate system. The implicit real world coordinate system used to express the coordinates of 3D points in a point cloud. Each point cloud container has its own working coordinate system. Basic concepts for the MIL 3D Blob Analysis module ",
      "wordCount": 267,
      "subEntries": []
    },
    {
      "id": "UG_3D_Blob_analysis_Calculating_a_blob_segmentation",
      "version": null,
      "title": "Calculating a blob segmentation",
      "subTitles": [
        "Segmentation from the point cloud",
        "Segmentation using a label image",
        "Segmentation context control settings"
      ],
      "location": "MIL UG P05: 3D processing and analysis",
      "pageURL": "content\\UserGuide\\3D_Blob_analysis\\Calculating_a_blob_segmentation.htm",
      "text": " Calculating a blob segmentation To analyze blobs, you must first segment the point cloud into separately identified blobs. You can calculate the blob segmentation from the point cloud itself (for example, using distances between points). Alternatively, you can define a blob segmentation using a label image, which has its pixels set to values that will identify corresponding points in a point cloud as belonging to a specific blob. Segmentation from the point cloud To calculate the blob segmentation from a point cloud, use M3dblobSegment() with an appropriate segmentation 3D blob analysis context. You can use a predefined context that counts all valid points as belonging to a single blob (M_SEGMENTATION_CONTEXT_WHOLE_IMAGE), or you can use a previously allocated context (M3dblobAlloc() with M_SEGMENTATION_CONTEXT), for which you can modify blob segmentation settings using M3dblobControl(). Note that you can still choose to treat the point cloud as a single blob when using a previously allocated context (M_SEGMENTATION_MODE set to M_WHOLE_IMAGE). Segmentation using a label image To define the blob segmentation using a label image, you must use M3dblobSegment() to copy the label image into a 3D blob analysis result buffer. When doing so, specify either M_SEGMENTATION_CONTEXT_LABEL_IMAGE (to use a predefined context) or specify a previously allocated context and set M_SEGMENTATION_MODE to M_LABEL_IMAGE using M3dblobControl(). The value of each pixel in the label image will identify corresponding points in a point cloud as belonging to a specific blob, using a label that is unique for each blob. Note that the location of each pixel in the label image corresponds to the point at the same location in the point cloud container. Pixels with a value of zero represent points that are not part of any blob. Invalid points must have a label of zero; otherwise, 3D blob functions that use the label (for example, M3dblobCalculate()) might try to operate on the invalid points, causing an error. To create a label image, you can use any binarized 2D version of the point cloud. For example, if your point cloud container is organized, you can use MblobCalculate() on its confidence component. Alternatively, you can binarize the reflectance component, or perform any strategy that gives binarized results for the points, and store the binarization in a component or buffer, before passing it to MblobCalculate(). If the point cloud is unorganized, you can pass the point cloud to M3dimProject() to generate a depth map, which you can then pass to MblobCalculate(). Finally, you can pass the resulting (2D) blob analysis result buffer to MblobLabel(), which creates the label image. You can also use MimLabel() to generate the label image, instead of using both MblobCalculate() and MblobLabel(), provided that the label image is all that you require (that is, you don't need to perform calculations on 2D blobs). Note that, when passing a depth map to MblobCalculate(), the depth map should be associated with an ROI that acts as the blob identifier image. Use MbufSetRegion() with M_RASTERIZE_DEPTH_MAP_VALID_PIXELS to associate an ROI with a depth map. For more information, see the Features related to depth maps section of Chapter 6: Blob analysis. Note that you can let MIL recompute the labels in the label image so that the labels are consecutive. To do so, call M3dblobSegment() with a previously allocated context, for which you have enabled M_RELABEL_CONSECUTIVE (using M3dblobControl()). Segmentation context control settings When not using a default context for the blob segmentation, you can use M3dblobControl() to modify segmentation criteria. Typically, you should leave M_SEGMENTATION_MODE set to its default (M_EUCLIDEAN), which allows you to specify settings for all other segmentation context control types. If segmenting in the whole image mode (M_WHOLE_IMAGE), only M_NUMBER_OF_POINTS_MIN and M_NUMBER_OF_POINTS_MAX are available. Similarly, if segmenting using a label image, only minimum/maximum number of points, as well as M_RELABEL_CONSECUTIVE, are available. To set the minimum or maximum number of points per blob, specify M_NUMBER_OF_POINTS_MIN or M_NUMBER_OF_POINTS_MAX, respectively. You can use these control types to remove blobs that correspond to a few isolated points, or to remove the background, which is often the largest blob. To distinguish between relatively flat regions, you can segment a point cloud into planar blobs. You can set a maximum angle between the normal of a point and a blob's average normal, for the point to be added to that blob with M_GLOBAL_NORMAL_DISTANCE_MAX. For example, consider a point cloud of the surfaces on a cube, with the normal vectors of each surface pointing outwards. A maximum angle of 45 degrees will segment the point cloud into six blobs (one for each surface). Similarly, for a hexagonal prism, a maximum angle of 30 degrees will segment the point cloud into one blob for each surface. In general, setting a smaller maximum angle forces the blobs into more planar (flatter) regions, allowing for less variation in each blob. Now consider that the normals of the top and bottom surfaces of the cube point in the same direction. To prevent these parallel surfaces from being merged into the same blob (due to having the same normal angle), you can set the maximum distance between planar blobs with M_GLOBAL_PLANE_DISTANCE_MAX. To separate the background from objects in your scene, you can also use M_COLOR_DISTANCE_MAX. This works well if your objects are similarly colored, and the background is distinct. M_COLOR_DISTANCE_MAX specifies the maximum difference between the color of two points for them to be considered neighbors (provided that a reflectance or intensity component exists in the point cloud container). Set how to calculate the distance with M_COLOR_DISTANCE_MODE. To distinguish between blobs that are touching, you can use the angle difference between point normal vectors (M_NORMAL_DISTANCE_MAX), since the normals of neighboring points will oppose each other if the points belong to separate blobs. Set how to calculate the angle difference with M_NORMAL_DISTANCE_MODE. Use M_DIRECTION (default) if you expect point normal vectors to be correctly oriented; use M_ORIENTATION if not (that is, you expect some normals to be flipped). Set the maximum distance within which two points are considered neighbors with M_MAX_DISTANCE. The control types M_NORMAL_DISTANCE_MAX and M_MAX_DISTANCE have no set maximum, by default. Typically, you should set one or both of these to an appropriate value for your source point cloud. Set the maximum number of neighboring points to consider at each point with M_MAXIMUM_NUMBER_NEIGHBORS; the default is 49 points. Typically, the speed of a segmentation operation is proportional to the number of neighbors at each point. If the maximum distance and the maximum angle difference between point normal vectors are well chosen, increasing the maximum number of neighbors will only slow down the M3dblobSegment() operation. Lowering it too much, however, will lead to oversegmentation (too many blobs). See the illustration below. All points (black and gray) belong to the same object. To belong to the same blob, all points must be neighbors or have neighbors in common. A lower maximum number of neighbors (inner ring) fails to include points to the right, so the black and gray points will be segmented to different blobs. A larger maximum number of neighbors (outer ring) includes more points than necessary; the extra included points are already considered part of the same blob because they have neighbors in common with points in the inner rings. The ideal maximum number (middle ring) includes both black and gray points, without taking extra time processing surplus points. If the objects that you need to segment are close together, adjust the maximum and normal distance settings. Calculating a blob segmentation Segmentation from the point cloud Segmentation using a label image Segmentation context control settings ",
      "wordCount": 1250,
      "subEntries": []
    },
    {
      "id": "UG_3D_Blob_analysis_Calculating_blob_features",
      "version": null,
      "title": "Calculating blob features",
      "subTitles": [
        "Enabling features for calculation"
      ],
      "location": "MIL UG P05: 3D processing and analysis",
      "pageURL": "content\\UserGuide\\3D_Blob_analysis\\Calculating_blob_features.htm",
      "text": " Calculating blob features Once you have defined a blob segmentation, you can calculate a variety of different blob measurements or features, such as the bounding box, centroid, linearity, and planarity of each blob. You can also calculate moments and principal component analysis (PCA) results, as well as the distance to the nearest neighboring blob. Although the M3dblobCalculate() function initiates the actual calculations, it is the specified context that determines which calculations are performed. To calculate features of blobs, allocate a calculate 3D blob analysis context (using M3dblobAlloc() with M_CALCULATE_CONTEXT). MIL stores results in the same result buffer that holds the blob segmentation. M3dblobAllocResult() with M_SEGMENTATION_RESULT). Enabling features for calculation To compute blob features, call M3dblobCalculate(). Before doing so, you must explicitly enable the features to calculate, using successive calls to M3dblobControl(). Note that you can specify to enable or disable the calculation of all features at once, using M3dblobControl() with M_ALL_FEATURES. However, it is not recommended to use M_ALL_FEATURES in your final application. This is because programs using M_ALL_FEATURES set to M_ENABLE might become slower when new MIL versions are released, if new features have been added. When you call M3dblobCalculate(), the function calculates the requested blob features. Even if only a few features are enabled for calculation, the overhead of performing calculations for some specified features can be considerable. Typically, it is more efficient to enable many features for calculation and make one call to M3dblobCalculate(), unless you are computing time-consuming features. For such features, select as few blobs as possible before calculation. In terms of cost to time, feature calculations can be grouped into three categories: Cheap: bounding box, centroid, PCA box, Feret general (and its contact points), as well as moments with an order less than or equal to 4, which includes linearity, planarity, and principal components. Medium: semi-oriented box and moments with an order greater than 4. Expensive: minimum/maximum Ferets (and their contact points), and nearest blob. Note, features that have already been calculated for the specified blobs are not recalculated if you call M3dblobCalculate() again, unless you have modified the container's range component. Note that if the range component has changed, M3dblobCalculate() removes all feature results from the result buffer and then calculates the features enabled in the context. Before enabling a feature for calculation, you should take the blob shapes into consideration. Some feature calculations are more appropriate for certain blob shapes than for others. For example, M_LINEARITY should be used for elongated blobs instead of flattened ones, in which case M_PLANARITY is more suitable. When trying to distinguish between two similar blobs, enabling certain features for calculation, rather than some other features that might also seem appropriate, might reveal a more notable difference. If two features allow you to come to the same conclusion, it is recommended that you enable the feature that is calculated more quickly. For example, minimum/maximum Feret diameters typically take longer to compute. Calculating blob features Enabling features for calculation ",
      "wordCount": 493,
      "subEntries": []
    },
    {
      "id": "UG_3D_Blob_analysis_Moments",
      "version": null,
      "title": "Moments",
      "subTitles": null,
      "location": "MIL UG P05: 3D processing and analysis",
      "pageURL": "content\\UserGuide\\3D_Blob_analysis\\Moments.htm",
      "text": " Moments Using the 3D Blob Analysis module, you can calculate moment-based features, such as a blob's centroid (first-order moment), and its linearity or planarity (second-order moments). To enable the calculation of a specified order, use M3dblobControl() with M_MOMENTS, and then set the order with M_MOMENT_ORDER (the default is 2). Note that MIL calculates all moments up to and including those of the specified order. Retrieve results using M3dblobGetResult(). First-order moment calculations reflect the center of mass of a blob (its centroid), while second-order moment calculations reflect the distribution of points around an axis. Accordingly, second-order features include principal component analysis (PCA) results and related eigenvalues, as well as the standard deviation of points, the covariance matrix, and a blob's linearity and planarity. If you only require a specific type of moment-based feature result, you can use M3dblobControl() to enable that calculation directly. For example, you can enable PCA feature calculations (M3dblobControl() with M_PCA), and then retrieve only those results (using M3dblobGetResult() with M_PRINCIPAL_AXIS_...). Otherwise, enabling M_MOMENTS with an order of at least 2 enables the calculation and eventual retrieval of all second-order moments, as well as first-order moments (the centroid). You can also use M3dblobGetResult() to retrieve moment-based feature results with respect to the origin of the working coordinate system (ordinary moments), or with respect to the blob's centroid (central moments); use the M_MOMENT_XYZ() and M_MOMENT_CENTRAL_XYZ() result types, respectively. When setting the moment order (M_MOMENT_ORDER) before calculating these results, note that the specified order must be a value that is greater than or equal to the sum of the powers in X, Y, and Z, according to the ordinary or central moment formula (see M3dblobGetResult()). For example, to retrieve only third, second, and first-order moment results, PowerX + PowerY + PowerZ must not exceed 3. Moments ",
      "wordCount": 298,
      "subEntries": []
    },
    {
      "id": "UG_3D_Blob_analysis_Selecting_combining_and_sorting_blobs",
      "version": null,
      "title": "Selecting, combining, and sorting blobs",
      "subTitles": [
        "Selecting blobs",
        "Choosing a selection criterion",
        "Combining blobs",
        "Sorting blobs"
      ],
      "location": "MIL UG P05: 3D processing and analysis",
      "pageURL": "content\\UserGuide\\3D_Blob_analysis\\Selecting_combining_and_sorting_blobs.htm",
      "text": " Selecting, combining, and sorting blobs Once you have calculated all required blob results, you can select, combine, and sort the results to better suit your needs, such as preparing a subset of blobs for which to make further calculations. Selecting blobs Using M3dblobSelect(), you can select which blobs meet a criterion and copy the corresponding blob identifying information and feature results into a new result buffer, so that only the selected blobs are recognized for future operations. Note that you can use in-place processing, and specify the same result buffer for the source and the destination. Non-selected data is deleted from the result buffer when selecting in-place. Also note that the points that make up all blobs (whether selected or not) are still held in the corresponding point cloud container. To populate a container only with blobs of interest, use M3dblobExtract(). Choosing a selection criterion You can choose any calculated feature result upon which to base a selection, provided the result is not an array. Note that you can base the selection on whether or not the specified feature result is available in the source result buffer. Once you have specified a selection criterion, you must then set a condition that the criterion must satisfy. For example, if your selection is based on the longest Feret of a blob (M_FERET_MAX_DIAMETER), you can set a condition that limits the Feret's acceptable length to within a specified range (M_IN_RANGE), and then set the necessary lower and upper limits for the range. In general, conditions use an inclusive range, an exclusive range, or specify that the selection criterion's value must be equal to, not equal to, above, or below a specified limit. Alternatively, you can specify to select for feature results that are available or not available. Combining blobs The M3dblobCombine() function allows you to perform compound selections from results that you have selected and saved to separate result buffers. For example, to select blobs that meet criterion 1 OR criterion 2, first call M3dblobSelect() twice with two different destination 3D blob analysis result buffers: once to select for criterion 1, and then a second time to select for criterion 2 (the source buffer is the same for each call). Then, combine the resulting two sets of blob identifying information and feature results using M3dblobCombine() with M_OR. Note that different feature results for the same blob in two source result buffers are combined and assigned to that same blob in the destination result buffer. For example, if source 1 has blob 42's maximum Feret result and source 2 has blob 42's centroid result, then the destination result buffer will have both maximum Feret and centroid results for blob 42 (provided the specified combine operation doesn't exclude blob 42). An error is reported if both sources contain results for the same feature, but the feature's values are different. The following illustration shows separate results for the same blob combined into a single result buffer using M3dblobCombine() with M_OR. If you just want to treat two blobs as one blob, combining different result buffers is not required. To merge two blobs into one blob (when the blobs are identified in a single result buffer) use M3dblobControl() with M_MERGE. Sorting blobs Using M3dblobSort(), you can sort the indices assigned to blobs based on their blob features. You can specify up to three features with which to sort. If the blob comparison is indeterminate using the first feature, the function tries the comparison using the second and, if necessary, the third feature. For each specified feature, you can set the sorting order, either ascending (default) or descending. To do so, add the respective combination value M_UP or M_DOWN when specifying the feature. For example, to sort primarily for blobs that are linear (long and straight in form), you can specify the sorting features as follows: M_LINEARITY + M_DOWN, M_FERET_MAX_DIAMETER + M_DOWN, and then M_FERET_MIN_DIAMETER + M_UP. This approach uses a blob's linearity as the first sorting feature and its longest Feret length as the second sorting feature. If neither of the first two features provides a difference, the third sorting feature (shortest Feret) can break the tie. Note the sort order (M_UP or M_DOWN) in the example. For M_LINEARITY, adding the M_DOWN combination value specifies to put the blob index of the most linear blob at the front of the list. This agrees with how MIL computes the linearity, since the most linear blob receives the largest calculated feature value, and M_DOWN specifies a descending sort order. Selecting, combining, and sorting blobs Selecting blobs Choosing a selection criterion Combining blobs Sorting blobs ",
      "wordCount": 767,
      "subEntries": []
    },
    {
      "id": "UG_3D_Blob_analysis_Retrieving_and_drawing_results",
      "version": null,
      "title": "Retrieving and drawing results",
      "subTitles": [
        "Possible results",
        "Drawing results"
      ],
      "location": "MIL UG P05: 3D processing and analysis",
      "pageURL": "content\\UserGuide\\3D_Blob_analysis\\Retrieving_and_drawing_results.htm",
      "text": " Retrieving and drawing results After successfully segmenting your point cloud and calculating blob features, you can retrieve the required results from your 3D blob analysis result buffer using M3dblobGetResult(). To draw the blobs and/or blob features, use M3dblobDraw3d(). Possible results The 3D Blob Analysis module produces several types of results that provide information on the make-up of the blobs in your context. You can retrieve general results such as: Whether the segmentation was successful, or why the segmentation failed (M_STATUS). The number of blobs (M_NUMBER). The total number of points across all blobs (M_TOTAL_NUMBER_OF_POINTS). The maximum label value of the blobs (M_MAX_LABEL_VALUE). With a successful blob segmentation, you can retrieve for each blob: Its index (M_INDEX_VALUE). Its label (M_LABEL_VALUE). The number of points in the blob (M_NUMBER_OF_POINTS). The components of the blob's average normal vector (M_AVERAGE_NORMAL_...), if the vector was used during segmentation. Information about the blob's stored location in the container's 2D grid organization (or the equivalent information in the label image), such as the X- and Y-coordinates of the stored location (M_PIXEL_X, M_PIXEL_Y, or M_PIXEL_PACKED). Calculated feature results include for each blob (if the features were enabled for calculation): Its bounding box. You can retrieve the axis-aligned bounding box, the semi-oriented bounding box, or the PCA-aligned bounding box, depending on which type(s) were calculated. Related results are also available, including the bounding box's Feret diameters and its center coordinates. Its centroid. Its Feret diameters. Its linearity and planarity. Moments. The label of its nearest neighboring blob, and the minimum distance to that blob. PCA (principal component analysis) results. Note that if you specify to retrieve results from all blobs (M_ALL_BLOBS), results are returned in an array. Also note that trying to retrieve a result that is not available generates an error. Drawing results The M3dblobControlDraw() function provides several operations for drawing results into a 3D graphics list; for each blob, you can draw: Its points. Its bounding box (axis-aligned, semi-oriented, or PCA-aligned). Its Feret diameters (maximum, minimum, or custom Feret). Its principal components. Excluded points. By default, MIL draws the points inside each blob. To draw most other blob features, you must explicitly enable the relevant draw operation (using M3dblobControlDraw()). You can also specify how to draw the blob graphics. For example, you can set the color and thickness of most features. For a bounding box, you can specify to draw it as a solid, a wireframe, a solid with wireframe, or as points. Note that each blob point's thickness is its length, in pixels, along each side when displayed. The default is one pixel. For a complete description of all possible options for the draw, refer to the description of M3dblobControlDraw() in the MIL Reference. To perform a draw operation, you typically allocate a draw 3D blob analysis context to hold the settings for the draw, using M3dblobAlloc() with M_DRAW_3D_CONTEXT. You then specify draw operations and options for the draw with successive calls to M3dblobControlDraw(). Finally, you call M3dblobDraw3d() to perform the draw. Alternatively, you can skip allocating a draw 3D blob analysis context and instead use a predefined draw 3D blob analysis context with default draw settings. To do so, directly call M3dblobDraw3d() with M_DEFAULT. Note that the default settings specify to draw the points of the specified blob(s), with a default thickness of one pixel. Retrieving and drawing results Possible results Drawing results ",
      "wordCount": 560,
      "subEntries": []
    },
    {
      "id": "UG_3D_Blob_analysis_3D_Blob_analysis_example",
      "version": null,
      "title": "3D blob analysis example",
      "subTitles": [
        "Segmenting a point cloud and identifying blobs based on blob features",
        "Continuous segmentation",
        "Segmentation bin picking"
      ],
      "location": "MIL UG P05: 3D processing and analysis",
      "pageURL": "content\\UserGuide\\3D_Blob_analysis\\3D_Blob_analysis_example.htm",
      "text": " 3D blob analysis example The following MIL examples illustrate some applications of the 3D Blob Analysis module. The first example shows segmenting a point cloud into blobs and then identifying blobs using their calculated features. The second example demonstrates using the 3D Blob Analysis module to count objects on a moving conveyor. Finally, the third example shows a segmentation followed by identification and picking of objects in a bin. To run these examples, use the Matrox Example Launcher in the MIL Control Center. Segmenting a point cloud and identifying blobs based on blob features The example below segments a point cloud into several blobs, and further identifies blobs using their calculated linearity and planarity features. m3dblob.cpp Continuous segmentation The example below performs continuous segmentation to count rocks on a conveyor. continuous3dsegmentation.cpp Segmentation bin picking The example below performs segmentation to identify and pick up objects in a bin. segmentationbinpicking.cpp 3D blob analysis example Segmenting a point cloud and identifying blobs based on blob features Continuous segmentation Segmentation bin picking ",
      "wordCount": 171,
      "subEntries": []
    }
  ]
}]
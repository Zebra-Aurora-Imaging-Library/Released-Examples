[{
  "id": "Example_PlaceHolder_ID",
  "version": "2024020714",
  "title": "Example_PlaceHolder_Title",
  "wordCount": 0,
  "subEntries": [
    {
      "id": "Examples_IndustrialCommunication_PLC_CCLinkIEFieldBasic_Slave_CPP_cclinkslave_cpp",
      "version": "2024020714",
      "title": "cclinkslave.cpp",
      "location": "Sample Code from MIL Examples",
      "text": " Top /******************************************************************************/ /* * File name: CclinkSlave.cpp * Location: See Matrox Example Launcher in the MIL Control Center * * * Synopsis: This program allocates a MIL application and system. * Then allocate a MIL industrial communication context to an * CC-Link IE Field Basic Slave instance. * * Notes: This example is only available if you have the MIL Industrial Communication package, * or another relevant update installed. * * Copyright (C) Matrox Electronic Systems Ltd., 1992-2024. * All Rights Reserved */ #include \"CclinkSlave.h\" CclinkSlave::CclinkSlave(const MIL_ID SystemId) { _systemId = SystemId; } CclinkSlave::~CclinkSlave() { } bool CclinkSlave::isSlaveStopped() { unsigned int state; McomInquire(_systemId, M_COM_GET_CONNECTION_STATE, &amp;state); return !state; } void CclinkSlave::WriteRegister(const MIL_INT deviceNumber, const MIL_UINT16 value) { McomWrite(_systemId, M_COM_CCLINK_INPUT_REGISTER, deviceNumber, 1, &amp;value); } MIL_UINT16 CclinkSlave::ReadRegister(const MIL_INT deviceNumber) { auto value = MIL_UINT16(0); McomRead(_systemId, M_COM_CCLINK_OUTPUT_REGISTER, deviceNumber, 1, &amp;value); return value; } void CclinkSlave::SetFlag(const MIL_INT deviceNumber) { WriteFlag(deviceNumber, true); } void CclinkSlave::ClearFlag(const MIL_INT deviceNumber) { WriteFlag(deviceNumber, false); } void CclinkSlave::WriteFlag(const MIL_INT deviceNumber, const MIL_BOOL value) { McomWrite(_systemId, M_COM_CCLINK_INPUT_FLAG, deviceNumber, 1, &amp;value); } MIL_BOOL CclinkSlave::ReadFlag(const MIL_INT deviceNumber) { auto state = MIL_BOOL(false); McomRead(_systemId, M_COM_CCLINK_OUTPUT_FLAG, deviceNumber, 1, &amp;state); return state; } ",
      "wordCount": 188
    },
    {
      "id": "Examples_IndustrialCommunication_PLC_CCLinkIEFieldBasic_Slave_CPP_mcomcclinkslave_cpp",
      "version": "2024020714",
      "title": "mcomcclinkslave.cpp",
      "location": "Sample Code from MIL Examples",
      "text": " Top /******************************************************************************/ /* * File name: McomCclink.cpp * Location: See Matrox Example Launcher in the MIL Control Center * * * Synopsis: This program allocates a MIL application and system. * Then allocate a MIL industrial communication context to an * CC-Link IE Field Basic Slave instance. * * Notes: This example is only available if you have the MIL Industrial Communication package, * or another relevant update installed. * * Copyright (C) Matrox Electronic Systems Ltd., 1992-2024. * All Rights Reserved */ #include &lt;mil.h&gt; #include \"CclinkSlave.h\" const MIL_INT TO_PLC_DATA_READY_FLAG(0); const MIL_INT TO_PLC_DATA_REGISTER(0); const MIL_INT FROM_PLC_TRIGGER_FLAG(0); const MIL_INT FROM_PLC_DATA_ACKNOWLEDGE_FLAG(1); const MIL_INT FROM_PLC_DATA_REGISTER(0); MIL_UINT16 _internalProcessingValue(0); static MIL_INT WaitForTriggerFromPLC(CclinkSlave &amp;slave); static MIL_UINT16 DoProcessing(void); static void WriteResultToPLC(CclinkSlave &amp;slave, const MIL_UINT16 result); int MosMain(void) { MIL_ID MilApplication(M_NULL); /* Application identifier. */ MIL_ID MilSystem(M_NULL); /* System identifier. */ MIL_ID MilCom(M_NULL); /* Industrial communication identifier. */ MIL_UINT16 processingResult(0); /* Allocate a default MIL application, system, display and image. */ MappAllocDefault(M_DEFAULT, &amp;MilApplication, &amp;MilSystem, M_NULL, M_NULL, M_NULL); McomAlloc(MilSystem, M_COM_PROTOCOL_CCLINK, MIL_TEXT(\"M_DEFAULT\"), M_DEFAULT, M_DEFAULT, &amp;MilCom); /* Create a CC-Link Slave */ auto slave = CclinkSlave(MilCom); if (slave.isSlaveStopped()) { MosPrintf(MIL_TEXT(\"Please start CC-Link Master Cyclic Transmission\\n\")); MosPrintf(MIL_TEXT(\"Aborting sample code\\n\")); goto abort; } /* Wait for a key press. */ MosPrintf(MIL_TEXT(\"Press any key to end loop.\\n\")); /* Set the data to the initial values. */ slave.ClearFlag(TO_PLC_DATA_READY_FLAG); slave.WriteRegister(TO_PLC_DATA_REGISTER, 0); while (!MosKbhit()) { /* Wait that the PLC set the trigger bit */ /* The return value will confirm is a key has been pressed to terminate the loop */ if (!WaitForTriggerFromPLC(slave)) { /* Do the requested processing */ processingResult = DoProcessing(); /* Write the result back to the PLC*/ WriteResultToPLC(slave, processingResult); } } /* Set the data to the initial values. */ slave.ClearFlag(TO_PLC_DATA_READY_FLAG); slave.WriteRegister(TO_PLC_DATA_REGISTER, 0); /* Free MIL objects*/ abort: McomFree(MilCom); MappFreeDefault(MilApplication, MilSystem, M_NULL, M_NULL, M_NULL); return 0; } MIL_INT WaitForTriggerFromPLC(CclinkSlave &amp;slave) { auto _isTriggerSet = MIL_BOOL(false); auto _KeyHit = MIL_INT(0); MosPrintf(MIL_TEXT(\"Waiting for trigger from PLC.\\n\")); do { /* Wait for the trigger from the PLC */ _isTriggerSet = slave.ReadFlag(FROM_PLC_TRIGGER_FLAG); MosSleep(10); _KeyHit = MosKbhit(); } while (!_isTriggerSet &amp;&amp; !_KeyHit); if (!_KeyHit) MosPrintf(MIL_TEXT(\"Received Trigger from PLC!\\n\")); return _KeyHit; } MIL_UINT16 DoProcessing(void) { /* Do what need to be done when PLC send the trigger. */ MosPrintf(MIL_TEXT(\"Computing new data value\\n\")); _internalProcessingValue++; return _internalProcessingValue; } void WriteResultToPLC(CclinkSlave &amp;slave, const MIL_UINT16 result) { auto _isResultRead = MIL_BOOL(false); auto _KeyHit = MIL_INT(0); /* Set the Result Ready Flag and result value */ slave.WriteRegister(TO_PLC_DATA_REGISTER, result); slave.SetFlag(TO_PLC_DATA_READY_FLAG); /* Wait that the PLC acknowledge the result */ MosPrintf(MIL_TEXT(\"Waiting fo PLC to acknowledge the data.\\n\")); do { _isResultRead = slave.ReadFlag(FROM_PLC_DATA_ACKNOWLEDGE_FLAG); MosSleep(10); _KeyHit = MosKbhit(); } while (!_isResultRead &amp;&amp; !_KeyHit); if (!_KeyHit) { auto valueFromPLC = slave.ReadRegister(FROM_PLC_DATA_REGISTER); MosPrintf(MIL_TEXT(\"Received result ACK! Value:%d CopyBack:%d\\n\"), result, valueFromPLC); /* Clear the DATA Ready Flag */ slave.ClearFlag(TO_PLC_DATA_READY_FLAG); } } ",
      "wordCount": 452
    }
  ]
}]
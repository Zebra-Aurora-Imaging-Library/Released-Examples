[{
  "id": "Readme_milRadienteVCL",
  "version": "2023100322",
  "title": "milRadienteVCL",
  "wordCount": 0,
  "subEntries": [
    {
      "id": "Readme_milRadienteVCL_milRadienteVCL",
      "title": "milRadienteVCL",
      "location": "MIL Release Notes",
      "pageURL": "\\milRadienteVCL\\milRadienteVCL.htm",
      "text": "Topplaceholder Matrox Imaging Library (MIL) X Update 147 Matrox Radient eV-CL release notes September 2023 (c) Copyright Matrox Electronic Systems Ltd., 1992-2023. &nbsp; This document outlines what is new with the MIL X driver for the Matrox Radient eV-CL and explains the current limitations and particularities. It also presents last-minute information that did not make it into the manual or on-line help. Note that this help file serves to complement your manual. The information found in this file overrides your formally documented material. Contents 1. MIL X driver for Matrox Radient eV-CL 1.1 Whats new in MIL X Update 147 1.1.1 Standards compliance 1.1.2 Summary of new features 1.1.3 API enhancements 1.1.4 Software bug fixes 1.1.5 Known limitations and particularities 1.2 Whats new in MIL X Update 107 1.2.1 Standards compliance 1.2.2 Summary of new features 1.2.3 Software bug fixes 1.3 Whats new in MIL 10 Update 74 1.3.1 Standards compliance 1.3.2 Summary of new features 1.3.3 Known limitations and particularities 1.3.4 Software bug fixes 1.3.5 Firmware bug fixes 1.3.6 Behavior changes 1.4 Whats new in MIL 10 Update 49 1.4.1 Standards compliance 1.4.2 Summary of new features 1.4.3 API enhancements 1.4.4 Known limitations and particularities 1.4.5 Software bug fixes 1.4.6 Firmware bug fixes 1.4.7 Behavior changes 1.5 Whats new in MIL 10 Update 27 1.5.1 Standards compliance 1.5.2 Summary of new features 1.5.3 API enhancements 2. Location of examples (in the help file) &nbsp; 1.&nbsp;&nbsp; MIL X driver for Matrox Radient eV-CL 1.1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Whats new in MIL X Update 147 MIL X Update 147 is a cumulative update, including all content from MIL Update 107, 74, 49 and 27. MIL X Update 147 requires MIL X Service Pack 6 (SP6) and was validated using MIL(-Lite) X Version 22H1.&nbsp; 1.1.1&nbsp;&nbsp; Standards compliance The MIL X driver for Matrox Radient eV-CL supports the following standards: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Camera Link version 2.1. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GenICam GenApi version 3.4.0. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GenICam GenCP Camera Link Module version 1.3. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GenICam for Camera Link (CLProtocol) version 1.2. Note that this requires a third-party CLProtocol communication library (DLL) which is supplied by the camera vendor. 1.1.2&nbsp;&nbsp; Summary of new features &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Added support for Matrox Radient eV-CL (Single-Base) frame grabber. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Added support for updating the firmware without power-cycling. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Added support for the 2 taps 10-bit RGB and 6 taps 10-bit mono. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Added support for RGB 10/12 bits Gain and Offset. See M_SHADING_CORRECTION. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Data latches are now available on all acquisition paths. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Added support for Matrox Radient eV-CL PCIe x4 COM port in Camera Link DLL Serial API. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Added support to change the timer duration while a grab is in progress. 1.1.3&nbsp;&nbsp; &nbsp;API enhancements &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Additions to MdigControl()/MdigInquire(): M_IO_DEBOUNCE_TIME+ (M_AUX_IOn) Sets the amount of time that the specified auxiliary input signal is debounced. A maximum of 4 inputs can have a debounce set. You must specify a combination value to set the I/O signal to affect. &nbsp; 0 &lt;=&nbsp;Value&nbsp;&lt;=&nbsp;8300000 Specifies the minimum amount of time to ignore any additional signal transitions after accepting a signal transition, in nsec. &nbsp; 1.1.4&nbsp;&nbsp; Software bug fixes &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Fixed M_GRAB_DIRECTION_X and M_GRAB_DIRECTION_Y for various Camera Link configurations. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Fixed issue where information given by the data latch auxiliary I/O was incorrect. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Fixed a thread contention issue with a UART pending call when two threads each allocate a Matrox Radient eV-CL system. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Fixed an issue with Bayer white balancing. Saturation is now adjusted to the grab size bit. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Fixed Bayer artifacts caused by block transfers within a frame. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Fixed an issue when Matrox Radient eV-CL PCIe x4 booted on golden firmware. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Fixed a grab issue on host buffers with a smaller height than the DCF. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Fixed an issue where a missed frame would not be detected. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Fixed an issue that can occur under heavy COM port usage. 1.1.5&nbsp;&nbsp; Known limitations and particularities &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; The timer duration and delay does not take the division factor into consideration when setting their respective values (despite the division being applied). &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; The clock generator on Matrox Radient eV-CL (Single-Base) frame grabber is limited to a base clock frequency range from 9 to 97 MHz. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Data latches are not supported on Matrox Radient eV-CL (Single-Base). &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Shading correction is not supported on Matrox Radient eV-CL (Single-Base). 1.2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Whats new in MIL X Update 107 Note that MIL X Update 107 is a cumulative update, including all content from MIL Update 74, 49 and 27. MIL X Update 107 requires MIL X Service Pack 4 (SP4). 1.2.1&nbsp;&nbsp; Standards compliance The MIL X driver for Matrox Radient eV-CL supports the following standards: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Camera Link version 2.1, except for the following: o&nbsp;&nbsp;&nbsp; 2 taps 10-bit RGB. o&nbsp;&nbsp;&nbsp; 6 taps 10-bit mono. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GenICam GenApi version 3.2.0. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GenICam GenCP Camera Link Module version 1.3. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GenICam for Camera Link (CLProtocol) version 1.2. Note that this requires a third-party CLProtocol communication library (DLL) which is supplied by the camera vendor. 1.2.2&nbsp;&nbsp; Summary of new features Added support for Matrox Radient eV-CL (Single-Full and Dual-Base) PCIe x4 frame grabber. 1.2.3&nbsp;&nbsp; Software bug fixes &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Increased the supported hardware Bayer conversion maximum line width from 8192 to 16364 bytes. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Fixed issue when performing hardware Bayer conversion with child buffers. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Fixed system instability issues when board temperature is over the maximum limit. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Fixed condition where hardware frame missed detection could have been deactivated. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Optimized programming of hardware LUT. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Improved camera-link deserialization process to improve signal with long cables. 1.3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Whats new in MIL 10 Update 74 Note that MIL 10 Update 74 is a cumulative update, including all content from MIL Update 49 and 27. 1.3.1&nbsp;&nbsp; Standards compliance The MIL 10 driver for Matrox Radient eV-CL supports the following standards: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Camera Link version 2.0. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GenICam GenApi version 3.1.0 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GenICam GenCP Camera Link Module version 1.2. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GenICam for Camera Link (CLProtocol) version 1.1. Note that this requires a third-party CLProtocol communication library (DLL) which is supplied by the camera vendor. 1.3.2&nbsp;&nbsp; Summary of new features &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Added support for firmware updates on Version &gt;= 300 of the dual-Base and single-Full boards, and Version &gt;= 008 of the quad-Base and dual-Full boards (PCB Y7469-03). 1.3.3&nbsp;&nbsp; Known limitations and particularities &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Installing this update removes Matrox Intellicams support for the Matrox CronosPlus, Matrox Vio and IEEE 1394 IIDC devices. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Building the MIL examples using Visual Studio 2015 or 2017 also requires the presence of Windows SDK version 8.1, which is installed from the Visual Studio setup. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; When using JAI cameras, the Camera Link Camera Control bits on the Matrox Radient eV-CL must be activated in order for the communication with the camera (either with JAI or Matrox software) to be stable. They can be activated using Intellicam in the Other tab in the DCF dialog. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Editing a DCF for Camera Link within Matrox Intellicam will close an open Feature Browser window. Whats more, re-opening a Feature Browser window may be subject to a noticeable delay due to camera initialization. To avoid this behavior, uncheck the Automatically compute registers checkbox from the Preferences Register Compute menu tab. However, a manual DCF compute from DCF Compute Registers will be required thereafter. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Minimizing the Feature Browser window hides it from view but it can be re-opened for viewing by clicking on the Feature Browser icon. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DCFs with manually edited register values for OPTO_AUX_IN0, OPTO_AUX_IN1, LVDS_AUX_IN2, LVDS_AUX_IN3, TTL_AUX_IO_4, TTL_AUX_IO_5, TTL_AUX_IO_6, OPTO_AUX_IN8, OPTO_AUX_IN9, LVDS_AUX_IN10, LVDS_AUX_IN11, TTL_AUX_IO_12, TTL_AUX_IO_13, TTL_AUX_IO_14 will need to have these values adjusted by adding 0x1000 (ex. 0x64 becomes 0x1064). 1.3.4&nbsp;&nbsp; Software bug fixes &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MdigInquireFeature(): Fixed incomplete string issue when inquiring a feature as a MIL_STRING. Features such as DeviceTemperature can change between the inquire of its string size and of its string data. For example, when we inquire the size, the temperature is 50 degrees, and when we inquire the data, the temperature becomes 50.1. The string size changed between the 2 inquires (size and data), which results in missing characters. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Fixed issue when setting a common grab or timer trigger using a custom DCF. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Fixed possible application crash when performing a firmware update. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Fixed issue when setting MdigControl(M_IO_MODE, M_OUTPUT) of an LVDS signal. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Fixed issue when setting MdigControl(M_IO_SOURCE) to M_DISABLE (LVDS signals become tri-state). &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Fixed issue with a DCF using tap reversal on the 8th and 9th tap in Camera Link deca mode. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Fixed issue where the default values of the Camera Link Camera Control bits were not properly reset when freeing the digitizer. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Fixed issue when setting MdigControl(M_ROTARY_ENCODER_POSITION_TRIGGER_DOUBLE) with M_ROTARY_ENCODERn (where n is a number between 1 and 4). &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Fixed precision issue when using quadrature encoders with fractional values. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Fixed possible crash when using data latch when internal buffer could not be allocated. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MILConfig: Fixed issue with the Max Temperature Recorded value in the Radient eV-CL page (it was returning the current temperature). 1.3.5&nbsp;&nbsp; Firmware bug fixes &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; When using the second acquisition path of the Radient eV-CL dual-Full, the quadrature encoder inputs now use those from the AUX I/O B connector to be compatible with the Radient eCL. 1.3.6&nbsp;&nbsp; Behavior changes &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; When allocating a color grab buffer without specifying if it is packed or planar, it will now be planar. 1.4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Whats new in MIL 10 Update 49 Note that MIL 10 Update 49 is a cumulative update, including all content from MIL Update 27. 1.4.1&nbsp;&nbsp; Standards compliance The MIL 10 driver for Matrox Radient eV-CL supports the following standards: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Camera Link version 2.0. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GenICam standard version 3.0.1. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GenICam for Camera Link (CLProtocol). Note that this requires a third-party CLProtocol communication library (DLL) which is supplied by the camera vendor. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GenICam GenCP Camera Link Module version 1.0. 1.4.2&nbsp;&nbsp; Summary of new features The following features are new for this release: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Added support for Teledyne DALSA Linea and Teledyne e2v Eliixa line-scan color cameras. The missing red or blue value of a destination pixel is interpolated from the left and right values in the source; whereas the green value of a destination pixel is used as is from the source. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Added support for hardware gain and offset correction per pixel; see M_SHADING_CORRECTION below. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Added support to debounce any of the auxiliary input signals (the default is the same as Update 27 but can be configured using a DCF). &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Added a pulse signal multiplier on all auxiliary input signals (configured using a DCF). &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Added new control types to deal with triggers that happen while the grab and timers are active; see M_GRAB_TRIGGER_OVERLAP and M_TIMER_TRIGGER_OVERLAP below. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Added new control types that allow the rotary decoder to start generating triggers only upon reaching a set counter value and then to generate a trigger at a set interval (change) in counter value; see M_ROTARY_ENCODER_* below. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Added a timer trigger divider; see M_TIMER_TRIGGER_RATE_DIVIDER below. 1.4.3&nbsp;&nbsp; &nbsp;API enhancements &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Additions to MdigControl()/MdigInquire(): M_SHADING_CORRECTION Sets whether to perform a gain and offset correction per pixel. When grabbing to a buffer in Host memory, your digitizer performs the shading correction operation using following equation: (Grab Image x M_SHADING_CORRECTION_GAIN_ID) + M_SHADING_CORRECTION_OFFSET_ID Each row of gain and offset values is applied to the equivalent row of the grabbed image. To set the gain and provide an offset for shading correction, use M_SHADING_CORRECTION_OFFSET_ID and M_SHADING_CORRECTION_GAIN_ID, respectively. &nbsp; M_ENABLE Enables shading correction. M_DISABLE Disables shading correction. M_SHADING_CORRECTION_GAIN_ID Sets the buffer containing the gain values that your digitizer should use when it performs a shading correction. To enable on-board shading correction and provide an offset, use M_SHADING_CORRECTION and M_SHADING_CORRECTION_OFFSET_ID, respectively. &nbsp; M_NULL Specifies to not apply a gain when performing a shading correction. ShadingCorrectionGainID Specifies the identifier of an M_IMAGE buffer containing the gain values. The buffer must be allocated as a single-band unsigned 8-bit or unsigned 16-bit buffer. It is interpreted as a fixed point buffer with 2-bits for the numerical part. Use M_SHADING_CORRECTION_GAIN_FIXED_POINT to set the number of bits for the fractional part. It can have an X-size of up to 16384 pixels and a Y-size equal to the size of the DCF. M_SHADING_CORRECTION_GAIN_FIXED_POINT Sets the number of bits for the fraction part of the fixed point gain value that your digitizer should use when it performs a shading correction. To enable on-board shading correction and provide an offset, use M_SHADING_CORRECTION, M_SHADING_CORRECTION_GAIN_ID, and M_SHADING_CORRECTION_OFFSET_ID, respectively. &nbsp; 0&lt;= Value &lt;16 Specifies the fractional part of the fixed point gain value. M_SHADING_CORRECTION_OFFSET_ID Sets the buffer containing the offset values that your digitizer should use when it performs a shading correction. To enable on-board shading correction and provide a gain, use M_SHADING_CORRECTION and M_SHADING_CORRECTION_GAIN_ID, respectively. &nbsp; M_NULL Specifies to not apply an offset when performing a shading correction. ShadingCorrectionOffsetID Specifies the identifier of an M_IMAGE buffer containing the offset values. The buffer must be allocated as a signed 8-bit or signed 16-bit buffer. M_GRAB_TRIGGER_OVERLAP Sets how to deal with a new trigger that occurs while a grab is in progress. &nbsp; M_DEFAULT Same as M_RESET or value specified in DCF. M_PREVIOUS_FRAME Specifies that a trigger received, while the grab is in progress, will be latched (stored). As soon as the current grab finishes, a new grab will be started. M_OFF Specifies that a new trigger is ignored. M_RESET Specifies that the current grab will be immediately stopped and a new grab will be started. M_ROTARY_ENCODER_POSITION_START_TRIGGER (+ M_ROTARY_ENCODERn) Sets the rotary decoder's counter value upon which to start generating triggers, when M_ROTARY_ENCODER_OUTPUT_MODE is set to M_POSITION_TRIGGER_MULTIPLE. If it is not set to this value, then M_ROTARY_ENCODER_POSITION_START_TRIGGER is ignored. &nbsp; 0 &lt; Value &lt;= 0xFFFFFFFF Specifies the value of the counter upon which to start generating triggers. M_ROTARY_ENCODER_OUTPUT_MODE (+ M_ROTARY_ENCODERn) Sets the rotary decoder's counter value and/or the direction of movement upon which the rotary decoder should output a pulse. additional control values found in references M_POSITION_TRIGGER_MULTIPLE Specifies to start triggering only when the counter value set with M_ROTARY_ENCODER_POSITION_START_TRIGGER is reached and then to generate a trigger at a set interval (change) in counter value. Set the interval with M_ROTARY_ENCODER_POSITION_TRIGGER. M_ROTARY_ENCODER_POSITION_TRIGGER (+ M_ROTARY_ENCODERn) Sets the rotary decoder's counter value at which a trigger is generated. &nbsp; 0 &lt; Value &lt;= 0xFFFFFFFF Specifies the counter value or change in counter value at which to generate a trigger. If M_ROTARY_ENCODER_OUTPUT_MODE is set to M_POSITION_TRIGGER_MULTIPLE, this will specify the change in counter value at which to generate a trigger, beginning at the counter value specified by M_ROTARY_ENCODER_POSITION_START_TRIGGER. If M_ROTARY_ENCODER_OUTPUT_MODE is set to M_POSITION_TRIGGER, this will specify the counter value at which to generate a trigger each time this value is reached. If M_POSITION_TRIGGER is set to any other control value, this value will be ignored. M_TIMER_TRIGGER_OVERLAP + M_TIMERn Sets how to deal with a new trigger that occurs while the associated timer has not yet expired (both its delay and duration). &nbsp; M_DEFAULT Same as M_RESET or value specified in DCF. M_LATCH Specifies that a trigger received, while the associated timer has not expired, will be latched (stored). As soon as the current timer expires, a new trigger is issued. M_OFF Specifies that a new trigger is ignored. M_RESET Specifies that a new trigger automatically resets the timer (regardless of whether it is in its delay or active period) and then restarts the timer. This process will repeat for each new trigger received. M_TIMER_TRIGGER_RATE_DIVIDER Sets the frequency to accept trigger pulses (for example, if set to 2, the first trigger pulse is ignored and the second is accepted). &nbsp; M_DEFAULT Specifies the default value; the default value is 1. &nbsp; 1 &lt;= Value &lt;= 255 Specifies the frequency with which to accept a trigger out of a series of trigger pulses. Note that, if set to 1, all trigger pulses are accepted. Example 1 In the following code snippet, an encoder is used to trigger a grab when a certain position is reached. 20 frames of 1000 lines each, or 20000 lines, are grabbed at which point the grab moves slightly to the right and repeats the process in reverse. The LinearEncoderScan animation, found on the RadienteVCLAnimation page in this section of the help file, illustrates this example. /* The camera must be set to trigger the acquisition of a line on the rising edge of the timer output signal. */ &nbsp; /* Reset the decoder counter to 0. */ MdigControl(MilDigitizer, M_ROTARY_ENCODER_POSITION, 0); &nbsp; /* Program the timer to trigger on a decoder signal. */ MdigControl(MilDigitizer, M_TIMER_CLOCK_SOURCE, M_SYSCLK); MdigControl(MilDigitizer, M_TIMER_DELAY, timerDelayInUs); MdigControl(MilDigitizer, M_TIMER_DURATION, timerDurationInUs); MdigControl(MilDigitizer, M_TIMER_TRIGGER_SOURCE, M_ROTARY_ENCODER); MdigControl(MilDigitizer, M_TIMER_STATE, M_ENABLE); &nbsp; /* Program the decoder to start triggering when position 1000 is reached &nbsp;&nbsp;&nbsp;then continue triggering at a multiple of '1'. */ MdigControl(MilDigitizer, M_ROTARY_ENCODER_OUTPUT_MODE, M_POSITION_TRIGGER_MULTIPLE); MdigControl(MilDigitizer, M_ROTARY_ENCODER_POSITION_START_TRIGGER, 1000); MdigControl(MilDigitizer, M_ROTARY_ENCODER_POSITION_TRIGGER, 1); &nbsp; /* Start MdigProcess to grab a sequence (strip) of 20 frames of 1000 lines each for &nbsp;&nbsp;&nbsp;a total of 20000 lines (bufferingSize == 20). */ MdigProcess(MilDigitizer, MilGrabBufferList, bufferingSize, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;M_SEQUENCE, M_SYNCHRONOUS, ProcessingFunction, &amp;UserHookData); &nbsp; /* Once the end of sequence is reached, the stage will start scanning in the &nbsp;&nbsp;&nbsp;other direction (the decoder counter will decrement). */ /* Program the decoder to start triggering when counter value 21000 is reached &nbsp;&nbsp;&nbsp;then continue triggering at a multiple of '1'. */ MdigControl(MilDigitizer, M_ROTARY_ENCODER_POSITION_START_TRIGGER, 21000); &nbsp; /* Start MdigProcess to grab a sequence of 20 frames of 1000 lines each for &nbsp;&nbsp;&nbsp;a total of 20000 lines (bufferingSize == 20). */ MdigProcess(MilDigitizer, MilGrabBufferList, bufferingSize, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;M_SEQUENCE, M_SYNCHRONOUS, ProcessingFunction, &amp;UserHookData); &nbsp; Example 2 &nbsp; In the following code snippet, the boards decoder is set to trigger a pulse only when a linear stage is moving forward. The counter decrements when the stage moves in reverse. The grab is only triggered when the counter hits a new positive value; as such, no line that was already grabbed will be grabbed again. The RotaryLogScan animation, found on the RadienteVCLAnimation2 page in this section of the help file, illustrates this example. /* The camera must be set to trigger the acquisition of a line on the rising edge of the timer output signal. */ &nbsp; /* Set the rotary decoder to send a trigger only when the stage is moving forward. */ MdigControl(MilDigitizer, M_ROTARY_ENCODER_DIRECTION, M_FORWARD); &nbsp; /* Specifies to set the counter to 0xFFFFFFFF upon a decrement. */ MdigControl(MilDigitizer, M_ROTARY_ENCODER_FORCE_VALUE_SOURCE, M_STEP_BACKWARD_WHILE_POSITIVE); &nbsp; /* Specifies to output a pulse upon a rotary decoder counter increment, only if the counter value is in the range of 0x0 to 0x7FFFFFFF before the increment occurs; when interpreting the counter value as signed, this would be the positive counter value range. */ MdigControl(MilDigitizer, M_ROTARY_ENCODER_OUTPUT_MODE, M_STEP_FORWARD_WHILE_POSITIVE); &nbsp; /* Set the rotary decoder counter to 0. */ MdigControl(MilDigitizer, M_ROTARY_ENCODER_POSITION_TRIGGER, 0); &nbsp; /* Set the signal that the timer should output at every rotary decoder trigger. */ MdigControl(MilDigitizer, M_TIMER_DELAY, timerDelayInUs); MdigControl(MilDigitizer, M_TIMER_DURATION, timerDelayInUs); &nbsp; /* Specifies to use the output (set with M_ROTARY_ENCODER_OUTPUT_MODE) of the default rotary decoder as the trigger source. */ MdigControl(MilDigitizer, M_TIMER_TRIGGER_SOURCE, M_ROTARY_ENCODER); &nbsp; /* The trigger rate divider can be used to reduce the trigger rate. */ MdigControl(MilDigitizer, M_TIMER_TRIGGER_RATE_DIVIDER, 1); /* Enable the timer. */ MdigControl(MilDigitizer, M_TIMER_STATE, M_ENABLE); &nbsp; /* Start the processing. The processing function is called with every frame grabbed. */ MdigProcess(MilDigitizer, MilGrabBufferList, MilGrabBufferListSize, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; M_START, M_DEFAULT, ProcessingFunction, &amp;UserHookData); &nbsp; 1.4.4&nbsp;&nbsp; Known limitations and particularities &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; The Bayer conversion hardware supports a maximum line width of 8192 bytes. 1.4.5&nbsp;&nbsp; Software bug fixes &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Fixed issues with M_DATA_LATCH_* and M_GRAB_FRAME_BURST_* when grabbing from digitizer devices other than device 0. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Fixed an issue with M_GRAB_FRAME_MISSED when used with MdigProcess() and M_TRIGGER_FOR_FIRST_GRAB. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Fixed an issue when performing a Bayer conversion from a multi-tap with adjacent-Y line scan camera. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Fixed an issue with MdigHookFunction(M_GRAB_START) when grabbing with MdigGrabContinuous(). &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Fixed an issue when grabbing from an interlaced camera. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Fixed issues when grabbing in frame bursts with multi-tap cameras. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; The default value of M_GRAB_FRAME_BURST_MAX_TIME is now M_INFINITE. 1.4.6&nbsp;&nbsp; Firmware bug fixes &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Fixed a potential freeze on computers with an Intel Xeon Processor E5-2600 series. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Fixed a case where a missed frame could be erroneously reported. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Fixed a case where more then one trigger could be detected when triggering on a falling edge. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Modified the default PoCL (Power-over CameraLink) drop-out time from 80 ms to 160 ms. Note that the CameraLink specification requires 100 ms. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Fixed a clock domain crossing issue when using an auxiliary signal to end a grab frame burst (using MdigControl() with M_GRAB_FRAME_BURST_END_TRIGGER_SOURCE). 1.4.7&nbsp;&nbsp; Behavior changes &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; When dealing with a DCF for a multi-tap camera that divides its image into multiple regions, if the camera sends multiple adjacent pixels per region along the Y-axis, the ordering of the regions and adjacent pixels has changed. Instead of enumerating the regions along the X-axis before the adjacent pixels along the Y-axis, the adjacent pixels along the Y-axis are enumerated before regions along the X-axis. To revert to the previous behaviour, load the DCF in Matrox Intellicam and adjust the enumeration of regions and adjacent pixels on the Tap Configuration tab of the DCF dialog. When dealing with a DCF that does not fit the above-mentioned requirement, the order has not changed. For example, when dealing with a 4-tap DCF with the following configuration: &nbsp; 1.5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Whats new in MIL 10 Update 27 1.5.1&nbsp;&nbsp; Standards compliance The MIL 10 driver for Matrox Radient eV-CL supports the following standards: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Camera Link version 2.0. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GenICamTM standard version 2.3.1. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GenICam for Camera Link (CLProtocol). Note that this requires a third party CLProtocol communication DLL provided by the camera vendor. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GenICam GenCP Camera Link Module version 1.0. 1.5.2&nbsp;&nbsp; Summary of new features The following features are new for this release: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Added support for all Camera Link Full 80-bit modes, including 10-tap 8-bit and 8-tap 10-bit cameras. These DCFs are produced using Matrox Intellicam. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Added automatic hardware Bayer conversion from 8-bit or 10-bit Bayer cameras to packed or planar buffers in Host memory. The maximum line width is 8192 pixels in 8-bit and 4096 pixels in 10-bit. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; New API to latch information for each grabbed frame. See M_DATA_LATCH_* in the online help. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; New API to grab multiple frames for each grab command. This is useful when grabbing at very high frame rates. See M_GRAB_FRAME_BURST_* below. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Added a second pulse for timer signals. See M_TIMER_DURATION2 and M_TIMER_DELAY2 below. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Added Deserializer Setup tool in MILConfig. This tool is used to find and save in the DCF the values needed for the deserializer alignment process. It is only recommended to use this tool when using cables longer than 7 meters. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Added the following MIL hardware-specific examples: o&nbsp;&nbsp;&nbsp; DataLatch.cpp. This example is located in ...\\examples\\board-specific\\DataLatch\\c++. It demonstrates how the Data Latch API latches information at each grabbed frame (such as, timestamps and quadrature encoder positions). o&nbsp;&nbsp;&nbsp; FrameBurst.cpp. This example is located in \\examples\\board-specific\\FrameBurst\\c++. It demonstrates how the frame burst API can be used to aggregate multiple frames into each grab command. o&nbsp;&nbsp;&nbsp; Clprotocol.cpp. This is a Matrox Radient eV-CL specific example. It demonstrates the use of GenICam for Camera Link CLProtocol and enables the use of MdigControlFeature() and MdigInquireFeature() to control camera features (parameters), as well as enabling the use of the feature browser dialog window. o&nbsp;&nbsp;&nbsp; Enumfeatures.cpp. This is a GenICam-specific example. It demonstrates how to enumerate all the features in your GenICam compliant device in a MIL application. The example is located in ...\\examples\\board-specific\\enumfeatures\\c++. 1.5.3&nbsp;&nbsp; API enhancements &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Additions to MdigControlFeature()/MdigInquireFeature(): o&nbsp;&nbsp;&nbsp; M_FEATURE_ENUM_ENTRY_DISPLAY_NAME + n. Inquires the display name of the specified enumeration entry of the specified feature, where n is the index of the enumerated list. See M_FEATURE_ENUM_ENTRY_NAME in the MIL documentation. o&nbsp;&nbsp;&nbsp; M_STRING_ARRAY_SIZE(). Specifies that the feature value is expressed as a string of a specified size. The M_STRING_ARRAY_SIZE() macro passes the size of the user-allocated buffer (first passed to the MdigInquireFeature's UserVarPtr parameter). See M_STRING_ARRAY_SIZE() in the MIL documentation. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Additions to MdigControl()/MdigInquire(): v&nbsp; Note that the control types that can be combined with M_TIMERn are marked below. For information about M_TIMERn, refer to MdigControl() /MdigInquire(). M_TIMER_DELAY2 + M_TIMERn Sets the delay between the end of the first active portion of the timer output signal and the start of the second pulse. &nbsp; M_DEFAULT Specifies the default value. This is the same as specified in the DFC or, if not specified in the DCF, 0. Value &gt; 0 Specifies the delay, in nsec. M_TIMER_DURATION2 + M_TIMERn Sets the duration for the active portion of the second pulse of the timer output signal. &nbsp; M_DEFAULT Specifies the default value. This is the same as specified in the DFC or, if not specified in the DCF, 0. Value &gt; 0 Specifies the duration of the active portion of the second pulse of the timer output signal, in nsec. M_GRAB_FRAME_BURST_SIZE Specifies the number of frames grabbed into the same buffer at each grab command. The size Y of the grab buffer must be equal to (height of the frame * M_GRAB_FRAME_BURST_SIZE). &nbsp; M_DEFAULT Same as 1. 1 &lt;= Value &lt;= 1023 Sets the number of frames grabbed. M_GRAB_FRAME_BURST_MAX_TIME Specifies the maximum amount of time to wait for all the frames to be grabbed in the multi-frame buffer. The timer starts when the first frame is grabbed. The number of frames in the buffer can be inquired using MdigGetHookInfo() with M_GRAB_FRAME_BURST_COUNT. This is useful when the camera stops sending frames and the multi-frame buffer is only partially full. &nbsp; M_DEFAULT Same as M_INFINITE. 0.000008 &lt;= Value &lt;= 1.000000 Specifies the maximum amount of time to wait, in sec. M_INFINITE Specifies to wait indefinitely. M_GRAB_FRAME_BURST_END_TRIGGER_SOURCE &nbsp; Specifies the signal from which a rising edge signals the end of a multi-frame sequence. This is useful to force a partially completed multi-frame buffer to complete. &nbsp; M_DEFAULT Same as M_AUX_IO0. M_AUX_IOn Specifies to use auxiliary input signal n as the trigger source, where n is the number of the auxiliary signal. Note that the specified auxiliary signal can also be a bidirectional signal set to input (using M_IO_MODE set to M_INPUT). M_GRAB_FRAME_BURST_END_TRIGGER_STATE Enables the M_GRAB_FRAME_BURST_END_TRIGGER_SOURCE source. &nbsp; M_DEFAULT Same as M_DISABLE. M_DISABLE Disables the grab frame burst end trigger source. M_ENABLE Enables the grab frame burst end trigger source. &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Additions to MdigHookFunction(): o&nbsp;&nbsp;&nbsp; You can now hook to a GenICam feature change event. o&nbsp;&nbsp;&nbsp; M_GC_FEATURE_CHANGE. Hooks the function to the event that occurs when a GenICam feature value is changed on your camera. This usually occurs when a feature or a dependent feature is written. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Additions to MdigGetHookInfo(): The following allows you to retrieve information about a GenICam SFNC-compliant event. The following information types are only available if MdigGetHookInfo() was called from a function hooked to a GenICam event using M_GC_EVENT + M_GC_FEATURE_CHANGE. In addition, the GenICam event must be enabled using MdigControlFeature(), and the message channel must be supported by your camera. o&nbsp;&nbsp;&nbsp; M_GC_FEATURE_CHANGE_NAME. Retrieves the name of the GenICam feature that changed. The UserVarPtr must point to a user allocated array of type MIL_TEXT_CHAR. o&nbsp;&nbsp;&nbsp; M_GC_FEATURE_CHANGE_NAME_SIZE. Retrieves the size of the name of the GenICam feature that changed. The UserVarPtr must point to a MIL_INT. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Additions to MdigGetHookInfo(): The following allows you to retrieve information about a GenICam SFNC-compliant event. The following information types are only available if MdigGetHookInfo() was called from a function hooked to a GenICam event using M_GC_EVENT + M_GC_FEATURE_CHANGE. In addition, the GenICam event must be enabled using MdigControlFeature(), and the message channel must be supported by your camera. o&nbsp;&nbsp;&nbsp; M_GC_FEATURE_CHANGE_NAME. Retrieves the name of the GenICam feature that changed. The UserVarPtr must point to a user allocated array of type MIL_TEXT_CHAR. o&nbsp;&nbsp;&nbsp; M_GC_FEATURE_CHANGE_NAME_SIZE. Retrieves the size of the name of the GenICam feature that changed. The UserVarPtr must point to a MIL_INT that is the required string length +1. &nbsp; The following allows you to retrieve information about grab frame burst events. Unless otherwise specified, you can retrieve these information types if you call this function from within a function hooked to any digitizer event using MdigHookFunction() or MdigProcess(). M_GRAB_FRAME_BURST_COUNT Retrieves the number of frames grabbed in the multi-frame buffer. &nbsp; Value &gt; 0 Specifies the number of frames grabbed. M_GRAB_FRAME_BURST_END_SOURCE Retrieves the type of event that generated the end of the frame burst. Multiple events can be set at the same time. Bitwise operators must be used to verify the presence of a specific returned value. Possible return values are: &nbsp; M_BURST_TRIGGER Specifies that trigger signal generates the end of the burst sequence. To specify the source signal, use MdigControl() with M_GRAB_FRAME_BURST_END_TRIGGER_SOURCE. M_BURST_MAX_TIME Specifies that the frame burst has taken as much time to complete as the maximum frame burst time. To specify the maximum time for a frame burst to complete, use MdigControl with M_GRAB_FRAME_BURST_MAX_TIME. M_BURST_COUNT Specifies the number of frames that have been grabbed. To specify the number of frames in a frame burst, use MdigControl() with M_GRAB_FRAME_BURST_SIZE. The following allows you to retrieve information from a data latch. These information types are only available if MdigGetHookInfo() was called from a function hooked to an end of grabbed frame event using MdigHookFunction() with M_GRAB_FRAME_END or from the hook-handler function (callback function) of MdigProcess(). In addition, you must have enabled the data latch to store this information, using MdigControl() with M_DATA_LATCH_STATE. v&nbsp; Note that you can only use data latches in association with the MIL digitizer allocated using MdigAlloc() with M_DEV0. The following values require that you pass the UserVarPtr parameter the address of a MIL_INT64. M_DATA_LATCH_VALUE + M_LATCHn + M_VALUE_INDEX(i) Retrieves the stored data of the specified data latch. If there are multiple instances of this data (for example, your data latch is triggered at the end of each grabbed line), use + M_VALUE_INDEX(i). &nbsp; Value Specifies the stored data. M_DATA_LATCH_VALUE_ALL Retrieves all the stored data of the specified data latch. &nbsp; Value Specifies all the stored data. M_DATA_LATCH_VALUE_COUNT Counts the number of items stored inside a data latch. Note that a data latch is reset at every frame event. &nbsp; Value Specifies the number of instances. Note that a data latch is reset at every frame event. &nbsp; Combination constant for M_DATA_LATCH_VALUE. You can add the following value to the above-mentioned value to specify the instance of the stored information to retrieve. M_VALUE_INDEX( MIL_INT64 IndexValue ) &nbsp; Specifies the instance of stored information to retrieve. IndexValue: Sets the instance of stored information. For example, to read the information latched when the last line finishes being grabbed for a frame, with 1024 lines, the instance would be 1023. &nbsp; 2.&nbsp;&nbsp; Location of examples (in the help file) In the help file, the location information written at the top of examples might not be up-to-date. Use MIL Example Launcher to find an example on disk. ",
      "wordCount": 5088,
      "subEntries": []
    },
    {
      "id": "Readme_milRadienteVCL_RadienteVCLAnimation",
      "title": "RadienteVCLAnimation",
      "location": "MIL Release Notes",
      "pageURL": "\\milRadienteVCL\\RadienteVCLAnimation.htm",
      "text": " Matrox Imaging Library (MIL) 10 Update 49 Matrox Radient eV-CL Release Notes September 2017 &nbsp;(c) Copyright Matrox Electronic Systems Ltd., 1992-2017. In the following animation, an encoder is used to trigger a grab when a certain position is reached. 20 frames of 1000 lines each, or 20000 lines, are grabbed at which point the grab moves slightly to the right and repeats the process in reverse. For more information, see the Example 1 code snippet, found on the milRadienteVCL page in this section of the help file. ",
      "wordCount": 89,
      "subEntries": []
    },
    {
      "id": "Readme_milRadienteVCL_RadienteVCLAnimation2",
      "title": "RadienteVCLAnimation2",
      "location": "MIL Release Notes",
      "pageURL": "\\milRadienteVCL\\RadienteVCLAnimation2.htm",
      "text": " Matrox Imaging Library (MIL) 10 Update 49 Matrox Radient eV-CL Release Notes September 2017 &nbsp;(c) Copyright Matrox Electronic Systems Ltd., 1992-2017. In the following animation, the board's decoder is set to trigger a pulse only when a linear stage is moving forward. The counter decrements when the stage moves in reverse. The grab is only triggered when the counter hits a new positive value; as such, no line that was already grabbed will be grabbed again. For more information, see the Example 2 code snippet, found on the milRadienteVCL page in this section of the help file. ",
      "wordCount": 99,
      "subEntries": []
    },
    {
      "id": "milRadienteVCL_files",
      "wordCount": 0
    }
  ]
}]
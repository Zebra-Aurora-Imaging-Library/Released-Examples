[{
  "id": "Example_PlaceHolder_ID",
  "version": "2024020714",
  "title": "Example_PlaceHolder_Title",
  "wordCount": 0,
  "subEntries": [
    {
      "id": "Examples_Processing_Optimization_MultiProcessing_CPP_dispatcher_cpp",
      "version": "2024020714",
      "title": "dispatcher.cpp",
      "location": "Sample Code from MIL Examples",
      "text": " Top //***************************************************************************************/ // // File name: Dispatcher.cpp // Location: See Matrox Example Launcher in the MIL Control Center // // // Synopsis: Implements the CDispatcher class. // // Copyright (C) Matrox Electronic Systems Ltd., 1992-2024. // All Rights Reserved #include \"common.h\" //******************************************************************************* // Constructor. Allocates and initializes the dispatcher //******************************************************************************* CDispatcher::CDispatcher(MIL_ID MilSystem, PROC_FUNCTION_PTR ProcessingFunctionPtr, void* DataPtr) : m_MilSystem(MilSystem), m_ProcessingFunctionPtr(ProcessingFunctionPtr), m_DataPtr(DataPtr), m_ThreadStarted(false), m_DispatchRunning(false), m_FrameRate(0.0) { } //******************************************************************************* // Destructor. Frees the dispatcher objects. //******************************************************************************* CDispatcher::~CDispatcher() { StopThread(); } //******************************************************************************* // StartThread. Start the dispatcher thread. Initially the thread is paused. //******************************************************************************* void CDispatcher::StartThread() { if (!m_ThreadStarted) { //Allocate the dispatcher thread and events MthrAlloc (m_MilSystem, M_EVENT, M_NOT_SIGNALED+M_AUTO_RESET, M_NULL, M_NULL, &amp;m_MilEvents[enRun]); MthrAlloc (m_MilSystem, M_EVENT, M_NOT_SIGNALED+M_AUTO_RESET, M_NULL, M_NULL, &amp;m_MilEvents[enKill]); MthrAlloc (m_MilSystem, M_EVENT, M_NOT_SIGNALED+M_AUTO_RESET, M_NULL, M_NULL, &amp;m_MilDispatchStoppedEvent); //Allocate a thread, it is initially paused. MthrAlloc (m_MilSystem, M_THREAD, M_DEFAULT, &amp;DispatchFunction, (void*)this, &amp;m_MilDispatchThread); m_ThreadStarted = true; } } //******************************************************************************* // StopThread. Stop the thread and free related events. //******************************************************************************* void CDispatcher::StopThread() { if (m_ThreadStarted) { //Stop the thread Pause(); MthrControl(m_MilEvents[enKill], M_EVENT_SET, M_SIGNALED); //Free related objects MthrWait(m_MilDispatchThread, M_THREAD_END_WAIT, M_NULL); MthrFree(m_MilEvents[enRun]); MthrFree(m_MilEvents[enKill]); MthrFree(m_MilDispatchStoppedEvent); MthrFree(m_MilDispatchThread); m_ThreadStarted = false; } } //******************************************************************************* // Run. Runs the processing in the dispatch thread. //******************************************************************************* void CDispatcher::Run() { if (!m_DispatchRunning &amp;&amp; m_ThreadStarted) { m_DispatchRunning = true; //Signal to start processing MthrControl(m_MilEvents[enRun], M_EVENT_SET, M_SIGNALED); } } //******************************************************************************* // Pause. Pauses the processing in the dispatch thread. //******************************************************************************* void CDispatcher::Pause() { if (m_DispatchRunning) { //Signal to stop the processing m_DispatchRunning = false; //Wait for the dispatching to stop MthrWait(m_MilDispatchStoppedEvent, M_EVENT_WAIT, M_NULL); m_FrameRate = 0.0; } } //******************************************************************************* // RunDispatcher. Function called in DispatchFunction to copy the buffer and // manage the call to the user function. //******************************************************************************* void CDispatcher::RunDispatcher() { const MIL_INT UpdateInterval = 2; MIL_DOUBLE EndTime; MIL_INT NumFrames=0; MIL_DOUBLE TotalTime; MIL_DOUBLE PreviousUpdateTime = 0.0; m_FrameRate = 0; //Wait for an event while ( MthrWaitMultiple(m_MilEvents, NUM_EVENTS, M_EVENT_WAIT, M_NULL) != (MIL_INT)enKill ) { MappTimer(M_TIMER_READ, &amp;PreviousUpdateTime); //Call and benchmark the processing function while the stop signal has not been received while (m_DispatchRunning) { //Call the processing function m_ProcessingFunctionPtr(m_DataPtr); MthrWait(M_DEFAULT, M_THREAD_WAIT, M_NULL); //Time the processing and calculate the FPS NumFrames++; MappTimer(M_TIMER_READ, &amp;EndTime); if ((EndTime-PreviousUpdateTime)&gt;UpdateInterval) { TotalTime = EndTime-PreviousUpdateTime; m_FrameRate = NumFrames / TotalTime; NumFrames = 0; PreviousUpdateTime=EndTime; } } //Signal that the dispatcher has stopped MthrControl(m_MilDispatchStoppedEvent, M_EVENT_SET, M_SIGNALED); } } //******************************************************************************* // DispatchFunction. Call back function for the dispatch thread. //******************************************************************************* MIL_UINT32 MFTYPE CDispatcher::DispatchFunction(void *UserDataPtr) { CDispatcher* Dispatcher = (CDispatcher*)UserDataPtr; //Run the dispatcher Dispatcher-&gt;RunDispatcher(); return 0; } ",
      "wordCount": 401
    },
    {
      "id": "Examples_Processing_Optimization_MultiProcessing_CPP_mpmenu_cpp",
      "version": "2024020714",
      "title": "mpmenu.cpp",
      "location": "Sample Code from MIL Examples",
      "text": " Top //***************************************************************************************/ // // File name: Menu.cpp // Location: See Matrox Example Launcher in the MIL Control Center // // // Synopsis: Implements the CMPMenu class. // // Copyright (C) Matrox Electronic Systems Ltd., 1992-2024. // All Rights Reserved #include \"common.h\" //***************************************************************************** // Constants. //***************************************************************************** //Button size static const MIL_INT BUTTON_SIZE_X = 125; static const MIL_INT BUTTON_SIZE_Y = 25; static const MIL_INT SMALL_BUTTON_SIZE_X = 60; static const MIL_INT LARGE_BUTTON_SIZE_X = 180; //Button position static const MIL_INT LINKED_BUTTON_GAP = 20; static const MIL_INT BUTTON_GAP = 6; static const MIL_INT BUTTON_START_X_POS = 240; static const MIL_INT BUTTON_START_Y_POS = BUTTON_GAP; static const MIL_INT SECTION_GAP = 16; //Text position static const MIL_INT TEXT_START_X = 15; static const MIL_INT TEXT_OFFSET_Y = 8; //Update information static const MIL_INT UPDATE_INFO_TIME_DELAY = 1000; //Menu static const MIL_INT MENU_SIZE_X = 650; static const MIL_INT INITIAL_MENU_SIZE_Y = 520; static const MIL_INT CORE_ROW_SIZE = BUTTON_SIZE_Y + BUTTON_GAP; static const MIL_INT MAX_CORES_PER_ROW = 8; static const MIL_DOUBLE BACKGROUND_COLOR = M_RGB888(255, 255, 255); //FPS information text static const MIL_DOUBLE INFO_COLOR = M_COLOR_DARK_BLUE; static const MIL_INT INFO_TEXT_SIZE = 350; static const MIL_INT TOTAL_FPS_GAP = 5; static const MIL_INT PROC_FPS_SIZE = BUTTON_GAP*3; //Other static const MIL_INT APPLY_TO_ALL_THREADS_ADJUSTMENT = -2; static const MIL_INT CORE_AFFINITY_GAP = BUTTON_GAP*5; //***************************************************************************** // Constructor. Allocates and intializes the menu. //***************************************************************************** CMPMenu::CMPMenu(MIL_INT ProcessingArraySize, CMPProcessing** Processing) : m_ProcessingArraySize(ProcessingArraySize) { //Allocate memory to contain the processing objects m_Processing = new CMPProcessing*[m_ProcessingArraySize]; //Get the number of cores available for the whole process MappInquireMp(M_DEFAULT, M_CORE_NUM_PROCESS, M_DEFAULT, M_DEFAULT, &amp;m_NumberOfProcessorCores); m_NumberOfProcessorCores = (m_NumberOfProcessorCores&lt;=MAX_CORES)?m_NumberOfProcessorCores:MAX_CORES; //Get the cores that are available for the process MIL_INT CoreAffinityMaskArraySize; MappInquireMp(M_DEFAULT, M_CORE_AFFINITY_MASK_ARRAY_SIZE, M_DEFAULT, M_DEFAULT, &amp;CoreAffinityMaskArraySize); m_CoreAffinityMaskProcess = new MIL_UINT64[CoreAffinityMaskArraySize]; MappInquireMp(M_DEFAULT, M_CORE_AFFINITY_MASK_PROCESS, M_DEFAULT, M_DEFAULT, m_CoreAffinityMaskProcess); //Set the number of cores to 1 if MP is disabled in MILConfig. if (MappInquireMp(M_DEFAULT, M_MP_FORCED_DISABLE, M_DEFAULT, M_DEFAULT, M_NULL)==M_YES) m_NumberOfProcessorCores = 1; m_MPIsOff = (m_NumberOfProcessorCores&lt;MIN_MP_CORES); MIL_INT NumCoreRows = (MIL_INT)ceil((MIL_DOUBLE)m_NumberOfProcessorCores/MAX_CORES_PER_ROW); m_MenuSizeY = INITIAL_MENU_SIZE_Y + ((NumCoreRows)*CORE_ROW_SIZE); //Initialize the number of memory banks m_NumMemoryBank = MappInquireMp(M_DEFAULT, M_MEMORY_BANK_NUM, M_DEFAULT, M_DEFAULT, M_NULL); //Keep a copy of the processing object pointers for (MIL_INT i=0; i&lt;m_ProcessingArraySize; i++) { m_Processing[i] = Processing[i]; } m_CurrentProcessing = 0; m_CurrentProcessingNum = 0; m_UpdateInfoStarted = false; //Set the initial state of the processing objects and run them if (m_MPIsOff) { //If there is no MP, disable it in the thread and run the processing. m_Processing[m_CurrentProcessingNum]-&gt;StartThread(); m_Processing[m_CurrentProcessingNum]-&gt;SetMP(false); //Select and run the display m_Processing[m_CurrentProcessingNum]-&gt;DisplaySelect(); m_Processing[m_CurrentProcessingNum]-&gt;RunDisplay(true); m_Processing[m_CurrentProcessingNum]-&gt;Run(); //There is one processing thead m_CurrentProcessingNum = 1; } else { MIL_INT RunningThreadsNum = 0; MIL_INT NumCoresAssigned = 0; //Initially we have a maximum of two threads if there are at least 4 cores. Otherwise, //run one thread and assign the cores to the thread because MP requires a minumum of two. if (m_NumberOfProcessorCores &lt; 4) { RunningThreadsNum = 1; NumCoresAssigned = m_NumberOfProcessorCores; } else { RunningThreadsNum = 2; NumCoresAssigned = m_NumberOfProcessorCores&gt;&gt;1; } for (m_CurrentProcessingNum=0; m_CurrentProcessingNum&lt;RunningThreadsNum; m_CurrentProcessingNum++) { //Start the threads m_Processing[m_CurrentProcessingNum]-&gt;StartThread(); //Initialize the state of MP and assign half of available cores to each processing thread InitProcessingMP(NumCoresAssigned, m_Processing[m_CurrentProcessingNum]); //Select and run the display m_Processing[m_CurrentProcessingNum]-&gt;DisplaySelect(); m_Processing[m_CurrentProcessingNum]-&gt;RunDisplay(true); //Run the processing m_Processing[m_CurrentProcessingNum]-&gt;Run(); } } //Create the menu Create(); //Start updating FPS info UpdateTotalFPS(); UpdateCurProcFPS(); for (MIL_INT i=0; i&lt;m_ProcessingArraySize; i++) { //Start updating information on processing if any of the processing are running if (m_Processing[i]-&gt;IsRunning() &amp;&amp; !m_UpdateInfoStarted) { StartUpdateInfo(); } } //Update menu information so that it corresponds to the current processing state UpdateMenu(); } //***************************************************************************** // Destructor. Frees the menu objects. //***************************************************************************** CMPMenu::~CMPMenu() { //Destroy the menu and free allocated memory Destroy(); delete [] m_Processing; delete [] m_CoreAffinityMaskProcess; } //***************************************************************************** // Create. Create the menu and show it. //***************************************************************************** void CMPMenu::Create() { //Allocate host system for the menu MsysAlloc(M_DEFAULT, M_SYSTEM_HOST, M_DEFAULT, M_DEFAULT, &amp;m_MilMenuSystem); //Allocate MIL display for menu options MdispAlloc(m_MilMenuSystem, M_DEFAULT, MIL_TEXT(\"M_DEFAULT\"), M_WINDOWED, &amp;m_MilMenuDisplay); //Allocate the buffer MbufAllocColor(m_MilMenuSystem, 3, MENU_SIZE_X, m_MenuSizeY, 8+M_UNSIGNED, M_IMAGE+M_PROC+M_DISP, &amp;m_MilMenuBuffer); MbufClear(m_MilMenuBuffer, BACKGROUND_COLOR); //Setup graphics context for menu text MgraAlloc(m_MilMenuSystem, &amp;m_MilMenuGraphicsContext); MgraControl(m_MilMenuGraphicsContext, M_BACKGROUND_MODE, M_TRANSPARENT); MgraControl(m_MilMenuGraphicsContext, M_COLOR, INFO_COLOR); //Setup graphics context for showing frames per second on the menu MgraAlloc(m_MilMenuSystem, &amp;m_MilInfoGraphicsContext); MgraControl(m_MilInfoGraphicsContext, M_BACKGROUND_MODE, M_TRANSPARENT); MgraControl(m_MilInfoGraphicsContext, M_FONT_SIZE, SMALL_FONT); MgraFont(m_MilInfoGraphicsContext, NORMAL_FONT_TYPE); MgraControl(m_MilInfoGraphicsContext, M_COLOR, INFO_COLOR); //Setup the menu options CreateMenu(); //Setup the display of the menu MdispControl(m_MilMenuDisplay, M_KEYBOARD_USE, M_DISABLE); MdispControl(m_MilMenuDisplay, M_MOUSE_USE, M_DISABLE); MdispControl(m_MilMenuDisplay, M_WINDOW_RESIZE, M_DISABLE); #if M_MIL_USE_WINDOWS MdispControl(m_MilMenuDisplay, M_WINDOW_SYSBUTTON, M_DISABLE); #endif MdispControl(m_MilMenuDisplay, M_TITLE, MIL_TEXT(\"Multiprocessing\")); MdispControl(m_MilMenuDisplay, M_WINDOW_TITLE_BAR_CHANGE, M_DISABLE); MdispControl(m_MilMenuDisplay, M_WINDOW_OVERLAP, M_DISABLE); //Allocate the thread that updates FPS MthrAlloc (m_MilMenuSystem, M_EVENT, M_NOT_SIGNALED+M_AUTO_RESET, M_NULL, M_NULL, &amp;m_MilInfoEvents[enRun]); MthrAlloc (m_MilMenuSystem, M_EVENT, M_NOT_SIGNALED+M_AUTO_RESET, M_NULL, M_NULL, &amp;m_MilInfoEvents[enKill]); MthrAlloc (m_MilMenuSystem, M_THREAD, M_DEFAULT, &amp;UpdateInfoFunction, (void*)this, &amp;m_MilInfoThread); MthrAlloc (m_MilMenuSystem, M_EVENT, M_NOT_SIGNALED+M_AUTO_RESET, M_NULL, M_NULL, &amp;m_MilUpdateInfoStoppedEvent); } //***************************************************************************** // Destroy. Destroy the allocated menu objects. //***************************************************************************** void CMPMenu::Destroy() { //Pause the processing for (MIL_INT i=0; i&lt;m_ProcessingArraySize; i++) m_Processing[i]-&gt;Pause(); //Stop and kill the update info thread StopUpdateInfo(); MthrControl(m_MilInfoEvents[enKill], M_EVENT_SET, M_SIGNALED); MthrWait(m_MilInfoThread, M_THREAD_END_WAIT, M_NULL); //Free all menu objects MthrFree(m_MilInfoEvents[enRun]); MthrFree(m_MilInfoEvents[enKill]); MthrFree(m_MilInfoThread); MthrFree(m_MilUpdateInfoStoppedEvent); //Unhook the function from the menu display MdispHookFunction(m_MilMenuDisplay, M_MOUSE_LEFT_BUTTON_UP+M_UNHOOK, MenuHookFct, (void*)this); //Deselect the display MdispSelect(m_MilMenuDisplay, M_NULL); //Free the rest of the menu objects for (MIL_INT i=FIRST_INFO; i&lt;=LAST_INFO; i++) { MbufFree(m_InfoRegions[i].MilRectBuffer); } for (MIL_INT i=FIRST_BUTTON; i&lt;=LAST_BUTTON; i++) { m_Buttons[i].Destroy(); } MbufFree(m_MilMenuBuffer); MdispFree(m_MilMenuDisplay); MgraFree(m_MilInfoGraphicsContext); MgraFree(m_MilMenuGraphicsContext); MsysFree(m_MilMenuSystem); } //****************************************************************************************** // SetupMenu. Write the menu options in the buffer and associate the options to functions. //****************************************************************************************** void CMPMenu::CreateMenu() { MIL_INT ButtonStartX = BUTTON_START_X_POS; MIL_INT ButtonStartY = BUTTON_START_Y_POS; //Create the section with general application settings such as number of threads //and whether or not to show the displays. CreateApplicationControlSection(ButtonStartX, ButtonStartY); //Create the section with thread selection and configuration CreateUserThreadsSection(ButtonStartX, ButtonStartY); //Create the section with MP configuration CreateMPSection(ButtonStartX, ButtonStartY); //Hook functions to mouse events MdispHookFunction(m_MilMenuDisplay, M_MOUSE_LEFT_BUTTON_UP, MenuHookFct, (void*)this); } //****************************************************************************************** // CreateApplicationControlSection. Setup the user thread control menu options. //****************************************************************************************** void CMPMenu::CreateApplicationControlSection(MIL_INT&amp; ButtonStartX, MIL_INT&amp; ButtonStartY) { //Set the section heading MgraControl(m_MilMenuGraphicsContext, M_FONT_SIZE, LARGE_FONT); MgraFont(m_MilMenuGraphicsContext, M_FONT_DEFAULT); MappControl(M_DEFAULT, M_ERROR, M_PRINT_DISABLE); MgraFont(m_MilMenuGraphicsContext, BOLD_FONT_TYPE); MappControl(M_DEFAULT, M_ERROR, M_PRINT_ENABLE); MgraText(m_MilMenuGraphicsContext, m_MilMenuBuffer, TEXT_START_X, ButtonStartY, MIL_TEXT(\"Application Control\")); MoveXY(ButtonStartX, ButtonStartY, 0, SECTION_GAP); //Create menu buttons MgraControl(m_MilMenuGraphicsContext, M_FONT_SIZE, SMALL_FONT); MgraFont(m_MilMenuGraphicsContext, M_FONT_DEFAULT); MgraFont(m_MilMenuGraphicsContext, NORMAL_FONT_TYPE); MgraText(m_MilMenuGraphicsContext, m_MilMenuBuffer, TEXT_START_X, ButtonStartY+TEXT_OFFSET_Y, MIL_TEXT(\"Number of User Threads\")); MIL_INT LinkedStartX = ButtonStartX; MIL_INT LinkedStartY = ButtonStartY; CreateButton(enTotalThreadsLeft, LinkedStartX, LinkedStartY, SMALL_BUTTON_SIZE_X, BUTTON_SIZE_Y, MIL_TEXT(\" &lt;&lt;\"), false); MoveXY(LinkedStartX, LinkedStartY, SMALL_BUTTON_SIZE_X+LINKED_BUTTON_GAP, 0); MIL_TEXT_CHAR ButtonText[STRING_SIZE]=MIL_TEXT(\"\"); CreateButton(enTotalThreads, LinkedStartX, LinkedStartY, SMALL_BUTTON_SIZE_X, BUTTON_SIZE_Y, GetButtonText(m_CurrentProcessing, enTotalThreads, ButtonText), false); MoveXY(LinkedStartX, LinkedStartY, SMALL_BUTTON_SIZE_X+LINKED_BUTTON_GAP, 0); CreateButton(enTotalThreadsRight, LinkedStartX, ButtonStartY, SMALL_BUTTON_SIZE_X, BUTTON_SIZE_Y, MIL_TEXT(\" &gt;&gt;\"), false); MoveXY(ButtonStartX, ButtonStartY, 0, BUTTON_SIZE_Y+BUTTON_GAP); MgraText(m_MilMenuGraphicsContext, m_MilMenuBuffer, TEXT_START_X, ButtonStartY+TEXT_OFFSET_Y, MIL_TEXT(\"Show Displays\")); CreateButton(enShowDisplay, ButtonStartX, ButtonStartY, BUTTON_SIZE_X, BUTTON_SIZE_Y, GetButtonText(m_CurrentProcessing, enShowDisplay, ButtonText), true); MoveXY(ButtonStartX, ButtonStartY, 0, BUTTON_SIZE_Y+BUTTON_GAP); //Create region for total FPS m_InfoRegions[enTotalFPS].StartX = TEXT_START_X; m_InfoRegions[enTotalFPS].StartY = ButtonStartY + TOTAL_FPS_GAP-1; m_InfoRegions[enTotalFPS].EndX = m_InfoRegions[enTotalFPS].StartX + INFO_TEXT_SIZE-1; m_InfoRegions[enTotalFPS].EndY = m_InfoRegions[enTotalFPS].StartY + PROC_FPS_SIZE-1; MbufChild2d(m_MilMenuBuffer, m_InfoRegions[enTotalFPS].StartX, m_InfoRegions[enTotalFPS].StartY, m_InfoRegions[enTotalFPS].EndX-m_InfoRegions[enTotalFPS].StartX+1, m_InfoRegions[enTotalFPS].EndY-m_InfoRegions[enTotalFPS].StartY+1, &amp;m_InfoRegions[enTotalFPS].MilRectBuffer); ButtonStartY = m_InfoRegions[enTotalFPS].EndY + TOTAL_FPS_GAP-1; MgraRectFill(m_MilMenuGraphicsContext, m_MilMenuBuffer, TEXT_START_X, ButtonStartY, MENU_SIZE_X-TEXT_START_X, ButtonStartY+2); MoveXY(ButtonStartX, ButtonStartY, 0, SECTION_GAP); } //****************************************************************************************** // CreateUserThreadsSection. Setup the menu options related to the main processing thread. //****************************************************************************************** void CMPMenu::CreateUserThreadsSection(MIL_INT&amp; ButtonStartX, MIL_INT&amp; ButtonStartY) { //Set the section heading MgraControl(m_MilMenuGraphicsContext, M_FONT_SIZE, LARGE_FONT); MgraFont(m_MilMenuGraphicsContext, M_FONT_DEFAULT); MappControl(M_DEFAULT, M_ERROR, M_PRINT_DISABLE); MgraFont(m_MilMenuGraphicsContext, BOLD_FONT_TYPE); MappControl(M_DEFAULT, M_ERROR, M_PRINT_ENABLE); MgraText(m_MilMenuGraphicsContext, m_MilMenuBuffer, TEXT_START_X, ButtonStartY, MIL_TEXT(\"User Thread Selection\")); MoveXY(ButtonStartX, ButtonStartY, 0, SECTION_GAP); //Create menu buttons MgraControl(m_MilMenuGraphicsContext, M_FONT_SIZE, SMALL_FONT); MgraFont(m_MilMenuGraphicsContext, M_FONT_DEFAULT); MgraFont(m_MilMenuGraphicsContext, NORMAL_FONT_TYPE); MgraText(m_MilMenuGraphicsContext, m_MilMenuBuffer, TEXT_START_X, ButtonStartY+TEXT_OFFSET_Y, MIL_TEXT(\"Thread Index\")); MIL_INT LinkedStartX = ButtonStartX; MIL_INT LinkedStartY = ButtonStartY; CreateButton(enProcThreadLeft, LinkedStartX, LinkedStartY, SMALL_BUTTON_SIZE_X, BUTTON_SIZE_Y, MIL_TEXT(\" &lt;&lt;\"), false); MoveXY(LinkedStartX, LinkedStartY, SMALL_BUTTON_SIZE_X+LINKED_BUTTON_GAP, 0); MIL_TEXT_CHAR ButtonText[STRING_SIZE]=MIL_TEXT(\"\"); CreateButton(enProcThread, LinkedStartX, LinkedStartY, SMALL_BUTTON_SIZE_X, BUTTON_SIZE_Y, GetButtonText(m_CurrentProcessing, enProcThread, ButtonText), false); MoveXY(LinkedStartX, LinkedStartY, SMALL_BUTTON_SIZE_X+LINKED_BUTTON_GAP, 0); CreateButton(enProcThreadRight, LinkedStartX, ButtonStartY, SMALL_BUTTON_SIZE_X, BUTTON_SIZE_Y, MIL_TEXT(\" &gt;&gt;\"), false); MoveXY(LinkedStartX, ButtonStartY, 0, BUTTON_SIZE_Y+BUTTON_GAP); MgraRectFill(m_MilMenuGraphicsContext, m_MilMenuBuffer, TEXT_START_X, ButtonStartY, MENU_SIZE_X-TEXT_START_X, ButtonStartY+1); MoveXY(LinkedStartX, ButtonStartY, 0, BUTTON_GAP); MgraControl(m_MilMenuGraphicsContext, M_FONT_SIZE, LARGE_FONT); MgraFont(m_MilMenuGraphicsContext, M_FONT_DEFAULT); MappControl(M_DEFAULT, M_ERROR, M_PRINT_DISABLE); MgraFont(m_MilMenuGraphicsContext, BOLD_FONT_TYPE); MappControl(M_DEFAULT, M_ERROR, M_PRINT_ENABLE); MgraText(m_MilMenuGraphicsContext, m_MilMenuBuffer, TEXT_START_X, ButtonStartY, MIL_TEXT(\"Selected Thread Control\")); MoveXY(ButtonStartX, ButtonStartY, 0, APPLY_TO_ALL_THREADS_ADJUSTMENT); CreateButton(enApplyToAllThreads, LinkedStartX, ButtonStartY, LARGE_BUTTON_SIZE_X, BUTTON_SIZE_Y, GetButtonText(m_CurrentProcessing, enApplyToAllThreads, ButtonText), true); MoveXY(ButtonStartX, ButtonStartY, 0, BUTTON_SIZE_Y+BUTTON_GAP); MgraControl(m_MilMenuGraphicsContext, M_FONT_SIZE, SMALL_FONT); MgraFont(m_MilMenuGraphicsContext, NORMAL_FONT_TYPE); MgraText(m_MilMenuGraphicsContext, m_MilMenuBuffer, TEXT_START_X, ButtonStartY+TEXT_OFFSET_Y, MIL_TEXT(\"Run Processing\")); CreateButton(enRunProcessing, ButtonStartX, ButtonStartY, BUTTON_SIZE_X, BUTTON_SIZE_Y, GetButtonText(m_CurrentProcessing, enRunProcessing, ButtonText), true); MoveXY(ButtonStartX, ButtonStartY, 0, BUTTON_SIZE_Y+BUTTON_GAP); MgraText(m_MilMenuGraphicsContext, m_MilMenuBuffer, TEXT_START_X, ButtonStartY+TEXT_OFFSET_Y, MIL_TEXT(\"Refresh Display\")); CreateButton(enRunDisplay, ButtonStartX, ButtonStartY, BUTTON_SIZE_X, BUTTON_SIZE_Y, GetButtonText(m_CurrentProcessing, enRunDisplay, ButtonText), true); MoveXY(ButtonStartX, ButtonStartY, 0, BUTTON_SIZE_Y+BUTTON_GAP); } //****************************************************************************************** // CreateBufferSection. Setup the menu options related to buffer allocation. //****************************************************************************************** void CMPMenu::CreateBufferSection(MIL_INT&amp; ButtonStartX, MIL_INT&amp; ButtonStartY) { MIL_TEXT_CHAR ButtonText[STRING_SIZE]=MIL_TEXT(\"\"); //Set information on memory bank MgraControl(m_MilMenuGraphicsContext, M_FONT_SIZE, SMALL_FONT); MgraFont(m_MilMenuGraphicsContext, NORMAL_FONT_TYPE); MgraText(m_MilMenuGraphicsContext, m_MilMenuBuffer, TEXT_START_X, ButtonStartY+TEXT_OFFSET_Y, MIL_TEXT(\"Memory Bank Affinity\")); //Create memory bank buttons MIL_INT LinkedStartX = ButtonStartX; MIL_INT LinkedStartY = ButtonStartY; CreateButton(enMemoryBankLeft, LinkedStartX, LinkedStartY, SMALL_BUTTON_SIZE_X, BUTTON_SIZE_Y, MIL_TEXT(\" &lt;&lt;\"), false); MoveXY(LinkedStartX, LinkedStartY, SMALL_BUTTON_SIZE_X+LINKED_BUTTON_GAP, 0); CreateButton(enMemoryBank, LinkedStartX, LinkedStartY, BUTTON_SIZE_X, BUTTON_SIZE_Y, GetButtonText(m_CurrentProcessing, enMemoryBank, ButtonText), false); if (m_MPIsOff) m_Buttons[enMemoryBank].Disable(MIL_TEXT(\"n/a\")); MoveXY(LinkedStartX, LinkedStartY, BUTTON_SIZE_X + LINKED_BUTTON_GAP, 0); CreateButton(enMemoryBankRight, LinkedStartX, ButtonStartY, SMALL_BUTTON_SIZE_X, BUTTON_SIZE_Y, MIL_TEXT(\" &gt;&gt;\"), false); MoveXY(LinkedStartX, ButtonStartY, 0, BUTTON_SIZE_Y+BUTTON_GAP); } //****************************************************************************************** // CreateMPSection. Setup the options related to MP control. //****************************************************************************************** void CMPMenu::CreateMPSection(MIL_INT&amp; ButtonStartX, MIL_INT&amp; ButtonStartY) { MIL_INT LinkedStartX = 0; MIL_INT LinkedStartY = 0; MIL_TEXT_CHAR ButtonText[STRING_SIZE]=MIL_TEXT(\"\"); //Set multiprocessing information and buttons MgraControl(m_MilMenuGraphicsContext, M_FONT_SIZE, SMALL_FONT); MgraFont(m_MilMenuGraphicsContext, NORMAL_FONT_TYPE); MgraText(m_MilMenuGraphicsContext, m_MilMenuBuffer, TEXT_START_X, ButtonStartY+TEXT_OFFSET_Y, MIL_TEXT(\"Use Multiprocessing\")); CreateButton(enMP, ButtonStartX, ButtonStartY, BUTTON_SIZE_X, BUTTON_SIZE_Y, GetButtonText(m_CurrentProcessing, enMP, ButtonText), true); MoveXY(ButtonStartX, ButtonStartY, 0, BUTTON_SIZE_Y+BUTTON_GAP+SECTION_GAP); if (m_MPIsOff) m_Buttons[enMP].Disable(MIL_TEXT(\"n/a\")); MgraControl(m_MilMenuGraphicsContext, M_FONT_SIZE, MEDIUM_FONT); MgraFont(m_MilMenuGraphicsContext, M_FONT_DEFAULT); MappControl(M_DEFAULT, M_ERROR, M_PRINT_DISABLE); MgraFont(m_MilMenuGraphicsContext, BOLD_FONT_TYPE); MappControl(M_DEFAULT, M_ERROR, M_PRINT_ENABLE); MgraText(m_MilMenuGraphicsContext, m_MilMenuBuffer, TEXT_START_X, ButtonStartY, MIL_TEXT(\"Multiprocessing Control\")); MoveXY(ButtonStartX, ButtonStartY, 0, SECTION_GAP); MgraControl(m_MilMenuGraphicsContext, M_FONT_SIZE, SMALL_FONT); MgraFont(m_MilMenuGraphicsContext, NORMAL_FONT_TYPE); MgraText(m_MilMenuGraphicsContext, m_MilMenuBuffer, TEXT_START_X, ButtonStartY+TEXT_OFFSET_Y, MIL_TEXT(\"Maximum Cores\")); LinkedStartX = ButtonStartX; LinkedStartY = ButtonStartY; CreateButton(enCoreMaxLeft, LinkedStartX, LinkedStartY, SMALL_BUTTON_SIZE_X, BUTTON_SIZE_Y, MIL_TEXT(\" &lt;&lt;\"), false); MoveXY(LinkedStartX, LinkedStartY, SMALL_BUTTON_SIZE_X+LINKED_BUTTON_GAP, 0); CreateButton(enCoreMax, LinkedStartX, LinkedStartY, SMALL_BUTTON_SIZE_X, BUTTON_SIZE_Y, GetButtonText(m_CurrentProcessing, enCoreMax, ButtonText), false); if (m_MPIsOff) m_Buttons[enCoreMax].Disable(MIL_TEXT(\"n/a\")); MoveXY(LinkedStartX, LinkedStartY, SMALL_BUTTON_SIZE_X+LINKED_BUTTON_GAP, 0); CreateButton(enCoreMaxRight, LinkedStartX, ButtonStartY, SMALL_BUTTON_SIZE_X, BUTTON_SIZE_Y, MIL_TEXT(\" &gt;&gt;\"), false); MoveXY(ButtonStartX, ButtonStartY, 0, BUTTON_SIZE_Y+BUTTON_GAP); MgraText(m_MilMenuGraphicsContext, m_MilMenuBuffer, TEXT_START_X, ButtonStartY+TEXT_OFFSET_Y, MIL_TEXT(\"Core Sharing\")); CreateButton(enCoreSharing, ButtonStartX, ButtonStartY, BUTTON_SIZE_X, BUTTON_SIZE_Y, GetButtonText(m_CurrentProcessing, enCoreSharing, ButtonText), true); MoveXY(ButtonStartX, ButtonStartY, 0, BUTTON_SIZE_Y+BUTTON_GAP); if (m_MPIsOff) m_Buttons[enCoreSharing].Disable(MIL_TEXT(\"n/a\")); MgraText(m_MilMenuGraphicsContext, m_MilMenuBuffer, TEXT_START_X, ButtonStartY+TEXT_OFFSET_Y, MIL_TEXT(\"Priority\")); LinkedStartX = ButtonStartX; LinkedStartY = ButtonStartY; CreateButton(enMPPriorityLeft, LinkedStartX, LinkedStartY, SMALL_BUTTON_SIZE_X, BUTTON_SIZE_Y, MIL_TEXT(\" &lt;&lt;\"), false); MoveXY(LinkedStartX, LinkedStartY, SMALL_BUTTON_SIZE_X+LINKED_BUTTON_GAP, 0); CreateButton(enMPPriority, LinkedStartX, LinkedStartY, BUTTON_SIZE_X, BUTTON_SIZE_Y, GetButtonText(m_CurrentProcessing, enMPPriority, ButtonText), false); if (m_MPIsOff) m_Buttons[enMPPriority].Disable(MIL_TEXT(\"n/a\")); MoveXY(LinkedStartX, LinkedStartY, BUTTON_SIZE_X+LINKED_BUTTON_GAP, 0); CreateButton(enMPPriorityRight, LinkedStartX, ButtonStartY, SMALL_BUTTON_SIZE_X, BUTTON_SIZE_Y, MIL_TEXT(\"&gt;&gt;\"), false); MoveXY(ButtonStartX, ButtonStartY, 0, BUTTON_SIZE_Y+BUTTON_GAP); //Create section for buffer memory banks CreateBufferSection(ButtonStartX, ButtonStartY); //Create the core affinity buttons MgraText(m_MilMenuGraphicsContext, m_MilMenuBuffer, TEXT_START_X, ButtonStartY+TEXT_OFFSET_Y, MIL_TEXT(\"Core Affinity: (Core Index, Local Memory Bank Index)\")); MoveXY(ButtonStartX, ButtonStartY, 0, CORE_AFFINITY_GAP); LinkedStartX = TEXT_START_X; ButtonStartX = LinkedStartX; LinkedStartY = ButtonStartY; //Create one button for each core for (MIL_INT i=FIRST_CORE, Count=0; (i-FIRST_CORE)&lt;m_NumberOfProcessorCores; i++, Count++) { CreateButton((MPButtons)i, LinkedStartX, LinkedStartY, SMALL_BUTTON_SIZE_X, BUTTON_SIZE_Y, GetButtonText(m_CurrentProcessing, (MPButtons)i, ButtonText), true); if (m_MPIsOff) m_Buttons[(MPButtons)i].Disable(MIL_TEXT(\"n/a\")); LinkedStartX = ButtonStartX + ( ((Count+1)%MAX_CORES_PER_ROW) * (SMALL_BUTTON_SIZE_X + LINKED_BUTTON_GAP) ); LinkedStartY = ButtonStartY + ( ((Count+1)/MAX_CORES_PER_ROW) * (BUTTON_GAP + BUTTON_SIZE_Y)); } //Create region for FPS update information ButtonStartX = BUTTON_START_X_POS; MoveXY(ButtonStartX, ButtonStartY, 0, BUTTON_GAP + SECTION_GAP); m_InfoRegions[enCurProcFPS].StartX = TEXT_START_X; m_InfoRegions[enCurProcFPS].StartY = m_MenuSizeY - PROC_FPS_SIZE; m_InfoRegions[enCurProcFPS].EndX = m_InfoRegions[enCurProcFPS].StartX + INFO_TEXT_SIZE-1; m_InfoRegions[enCurProcFPS].EndY = m_InfoRegions[enCurProcFPS].StartY + PROC_FPS_SIZE-1; MbufChild2d(m_MilMenuBuffer, m_InfoRegions[enCurProcFPS].StartX, m_InfoRegions[enCurProcFPS].StartY, m_InfoRegions[enCurProcFPS].EndX-m_InfoRegions[enCurProcFPS].StartX+1, m_InfoRegions[enCurProcFPS].EndY-m_InfoRegions[enCurProcFPS].StartY+1, &amp;m_InfoRegions[enCurProcFPS].MilRectBuffer); } //******************************************************************************* // CreateButton. Setup menu button with given information. //******************************************************************************* void CMPMenu::CreateButton(MPButtons ButtonType, MIL_INT StartX, MIL_INT StartY, MIL_INT ButtonSizeX, MIL_INT ButtonSizeY, MIL_CONST_TEXT_PTR ButtonText, bool IsToggle) { RectStruct ButtonRect; //Define the button rectangle ButtonRect.StartX = StartX; ButtonRect.EndX = ButtonRect.StartX + ButtonSizeX-1; ButtonRect.StartY = StartY; ButtonRect.EndY = ButtonRect.StartY + ButtonSizeY-1; //Create the button on the menu buffer m_Buttons[ButtonType].Create(ButtonText, m_MilMenuBuffer, ButtonRect, IsToggle); } //******************************************************************************* // MoveXY. Move the provided x,y positions by the given offsets. //******************************************************************************* void CMPMenu::MoveXY(MIL_INT&amp; StartX, MIL_INT&amp; StartY, MIL_INT OffsetX, MIL_INT OffsetY) { StartX += OffsetX; StartY += OffsetY; } //******************************************************************************* // Run. Run the menu //******************************************************************************* void CMPMenu::Run() { //Show the menu MdispSelect(m_MilMenuDisplay, m_MilMenuBuffer); } //******************************************************************************* // GetButton. Return the button that corresponds to the given x,y position //******************************************************************************* CMPMenu::MPButtons CMPMenu::GetButton(MIL_INT PositionX, MIL_INT PositionY) { MPButtons Button= (MPButtons)-1; for (MIL_INT i=FIRST_BUTTON; i&lt;=LAST_BUTTON; i++) { //Get the button index that falls within the region the user just clicked on if ( (m_Buttons[i].GetRect().StartX&lt;=PositionX) &amp;&amp; (m_Buttons[i].GetRect().EndX&gt;=PositionX) &amp;&amp; (m_Buttons[i].GetRect().StartY&lt;=PositionY) &amp;&amp; (m_Buttons[i].GetRect().EndY&gt;=PositionY) ) { Button = (MPButtons)i; break; } } return Button; } //******************************************************************************* // ProcessingButtonClick. Defines start/stop button operation. //******************************************************************************* void CMPMenu::ProcessingButtonClick() { MIL_TEXT_CHAR ButtonText[STRING_SIZE]=MIL_TEXT(\"\"); //Pause or run the button depending on the current state if (m_Processing[m_CurrentProcessing]-&gt;IsRunning()) { m_Processing[m_CurrentProcessing]-&gt;Pause(); StopUpdateInfo(); } else { m_Processing[m_CurrentProcessing]-&gt;Run(); StartUpdateInfo(); } //Update the button and the menu m_Buttons[enRunProcessing].Push(GetButtonText(m_CurrentProcessing, enRunProcessing, ButtonText)); UpdateMenu(); } //******************************************************************************* // MPButtonClick. Defines MP button operation. //******************************************************************************* void CMPMenu::MPButtonClick() { MIL_TEXT_CHAR ButtonText[STRING_SIZE]=MIL_TEXT(\"\"); //Set current MP status and update the button if (m_Processing[m_CurrentProcessing]-&gt;MPEnabled()) { m_Processing[m_CurrentProcessing]-&gt;SetMP(false); } else { m_Processing[m_CurrentProcessing]-&gt;SetMP(true); } m_Buttons[enMP].Push(GetButtonText(m_CurrentProcessing, enMP, ButtonText)); } //******************************************************************************* // CoreMaxButtonClick. Defines core maximum add button operation. //******************************************************************************* void CMPMenu::CoreMaxButtonClick(bool Add) { MIL_TEXT_CHAR ButtonText[STRING_SIZE]=MIL_TEXT(\"\"); MIL_INT CurrentCoreMax = m_Processing[m_CurrentProcessing]-&gt;GetCoreMax(); //Increase or reduce the maximum cores for currently selected processing if (Add &amp;&amp; (CurrentCoreMax &lt; m_NumberOfProcessorCores)) { CurrentCoreMax++; } else if (!Add &amp;&amp; (CurrentCoreMax&gt;2)) { CurrentCoreMax--; } m_Processing[m_CurrentProcessing]-&gt;SetCoreMax(CurrentCoreMax); m_Buttons[enCoreMax].Push(GetButtonText(m_CurrentProcessing, enCoreMax, ButtonText)); } //******************************************************************************* // CoreSharingButtonClick. Defines core sharing button operation. //******************************************************************************* void CMPMenu::CoreSharingButtonClick() { MIL_TEXT_CHAR ButtonText[STRING_SIZE]=MIL_TEXT(\"\"); //Enable or disable core sharing if (m_Processing[m_CurrentProcessing]-&gt;CoreSharingEnabled()) { m_Processing[m_CurrentProcessing]-&gt;SetCoreSharing(false); } else { m_Processing[m_CurrentProcessing]-&gt;SetCoreSharing(true); } m_Buttons[enCoreSharing].Push(GetButtonText(m_CurrentProcessing, enCoreSharing, ButtonText)); } //******************************************************************************* // MPPriorityButtonClick. Defines MP priority button operation. //******************************************************************************* void CMPMenu::MPPriorityButtonClick(bool Next) { MIL_TEXT_CHAR ButtonText[STRING_SIZE]=MIL_TEXT(\"\"); MIL_INT MPPriority = m_Processing[m_CurrentProcessing]-&gt;GetMPPriority(); //Set the priority for the currently selected processing thread switch (MPPriority) { case M_ABOVE_NORMAL: if (Next) MPPriority=M_BELOW_NORMAL; break; case M_BELOW_NORMAL: if (Next) MPPriority=M_HIGHEST; else MPPriority=M_ABOVE_NORMAL; break; case M_HIGHEST: if (Next) MPPriority=M_IDLE; else MPPriority=M_BELOW_NORMAL; break; case M_IDLE: if (Next) MPPriority=M_LOWEST; else MPPriority=M_HIGHEST; break; case M_LOWEST: if (Next) MPPriority=M_NORMAL; else MPPriority=M_IDLE; break; case M_NORMAL: if (Next) MPPriority=M_TIME_CRITICAL; else MPPriority=M_LOWEST; break; case M_TIME_CRITICAL: if (!Next) MPPriority=M_NORMAL; break; default: break; } m_Processing[m_CurrentProcessing]-&gt;SetMPPriority(MPPriority); m_Buttons[enMPPriority].Push(GetButtonText(m_CurrentProcessing, enMPPriority, ButtonText)); } //******************************************************************************* // ProcessingThreadButtonClick. Select the processing thread to control. //******************************************************************************* void CMPMenu::ProcessingThreadButtonClick(bool Next) { MIL_TEXT_CHAR ButtonText[STRING_SIZE]=MIL_TEXT(\"\"); //Select the requested processing thread and update information on the menu //accordingly if (Next &amp;&amp; (m_CurrentProcessing &lt; m_CurrentProcessingNum-1)) { m_CurrentProcessing++; } else if (!Next &amp;&amp; (m_CurrentProcessing &gt; 0)) { m_CurrentProcessing--; } m_Buttons[enProcThread].Push(GetButtonText(m_CurrentProcessing, enProcThread, ButtonText)); UpdateMenu(); } //******************************************************************************* // ApplyToAllThreadsButtonClick. Apply current thread settings to all threads //******************************************************************************* void CMPMenu::ApplyToAllThreadsButtonClick() { //Apply current processing configuration to all threads MIL_INT ThreadIndex; bool UseMemoryBank = m_Processing[m_CurrentProcessing]-&gt;UseMemoryBank(); MIL_INT64 MemoryBank = m_Processing[m_CurrentProcessing]-&gt;GetCurrentMemoryBank(); for (MIL_INT i=1; i&lt;m_CurrentProcessingNum; i++) { ThreadIndex = (m_CurrentProcessing+i)%(m_CurrentProcessingNum); if (m_Processing[m_CurrentProcessing]-&gt;IsRunning()) m_Processing[ThreadIndex]-&gt;Run(); else m_Processing[ThreadIndex]-&gt;Pause(); m_Processing[ThreadIndex]-&gt;RunDisplay(m_Processing[m_CurrentProcessing]-&gt;DisplayRunning()); m_Processing[ThreadIndex]-&gt;SetMP(m_Processing[m_CurrentProcessing]-&gt;MPEnabled()); m_Processing[ThreadIndex]-&gt;SetCoreMax(m_Processing[m_CurrentProcessing]-&gt;GetCoreMax()); m_Processing[ThreadIndex]-&gt;SetCoreSharing(m_Processing[m_CurrentProcessing]-&gt;CoreSharingEnabled()); m_Processing[ThreadIndex]-&gt;SetMPPriority(m_Processing[m_CurrentProcessing]-&gt;GetMPPriority()); m_Processing[ThreadIndex]-&gt;SetCoreAffinity(m_Processing[m_CurrentProcessing]-&gt;GetCoreAffinity()); m_Processing[ThreadIndex]-&gt;SetCurrentMemoryBank(MemoryBank, UseMemoryBank); } //For visual effect, push the button twice. MIL_TEXT_CHAR ButtonText[STRING_SIZE]=MIL_TEXT(\"\"); m_Buttons[enApplyToAllThreads].Push(ButtonText); MosSleep(50); GetButtonText(m_CurrentProcessing, enApplyToAllThreads, ButtonText); m_Buttons[enApplyToAllThreads].Push(GetButtonText(m_CurrentProcessing, enApplyToAllThreads, ButtonText)); } //******************************************************************************* // NumberOfThreadsButtonClick. Select the number of processing threads. //******************************************************************************* void CMPMenu::NumberOfThreadsButtonClick(bool Next) { MIL_TEXT_CHAR ButtonText[STRING_SIZE]=MIL_TEXT(\"\"); //Increase or reduce the number of processing threads if (Next &amp;&amp; (m_CurrentProcessingNum &lt; m_ProcessingArraySize)) { m_CurrentProcessingNum++; //Start and configure the thread m_Processing[m_CurrentProcessingNum-1]-&gt;StartThread(); if (m_Processing[m_CurrentProcessing]-&gt;DisplaySelected()) { m_Processing[m_CurrentProcessingNum-1]-&gt;DisplaySelect(); m_Processing[m_CurrentProcessingNum-1]-&gt;RunDisplay(true); } else { m_Processing[m_CurrentProcessingNum-1]-&gt;RunDisplay(false); } InitProcessingMP(m_NumberOfProcessorCores, m_Processing[m_CurrentProcessingNum-1]); m_Processing[m_CurrentProcessingNum-1]-&gt;Run(); m_CurrentProcessing = m_CurrentProcessingNum-1; StartUpdateInfo(); } else if (!Next &amp;&amp; (m_CurrentProcessingNum &gt; 1)) { //Stop the thread m_Processing[m_CurrentProcessingNum-1]-&gt;DisplayDeselect(); m_Processing[m_CurrentProcessingNum-1]-&gt;StopThread(); m_CurrentProcessingNum--; if (m_CurrentProcessing == m_CurrentProcessingNum) m_CurrentProcessing = m_CurrentProcessingNum-1; StopUpdateInfo(); } //Update button and menu accordingly m_Buttons[enTotalThreads].Push(GetButtonText(m_CurrentProcessing, enTotalThreads, ButtonText)); UpdateMenu(); } //******************************************************************************* // CurrentThreadDisplayButtonClick. Defines selected thread display button operation. //******************************************************************************* void CMPMenu::CurrentThreadDisplayButtonClick() { MIL_TEXT_CHAR ButtonText[STRING_SIZE]=MIL_TEXT(\"\"); //Set whether to run or stop the display update of the currently selected //processing thread. if (m_Processing[m_CurrentProcessing]-&gt;DisplayRunning()) { m_Processing[m_CurrentProcessing]-&gt;RunDisplay(false); } else { m_Processing[m_CurrentProcessing]-&gt;RunDisplay(true); } m_Buttons[enRunDisplay].Push(GetButtonText(m_CurrentProcessing, enRunDisplay, ButtonText)); } //******************************************************************************* // AllThreadsDisplayButtonClick. Defines display button operation for all // threads. //******************************************************************************* void CMPMenu::AllThreadsDisplayButtonClick() { //Either show or remove all currently allocated threads if (m_Processing[m_CurrentProcessing]-&gt;DisplaySelected()) { for (MIL_INT i=0; i&lt;m_CurrentProcessingNum; i++) { //Pause the display if it is running if (m_Processing[i]-&gt;DisplayRunning()) m_Processing[i]-&gt;RunDisplay(false); //Deselect the display m_Processing[i]-&gt;DisplayDeselect(); } } else { for (MIL_INT i=0; i&lt;m_CurrentProcessingNum; i++) { //Run the display m_Processing[i]-&gt;RunDisplay(true); //Select the display m_Processing[i]-&gt;DisplaySelect(); } } UpdateMenu(); } //******************************************************************************* // MemoryBankButtonClick. Select the memory bank to allocate processing buffers // on. //******************************************************************************* void CMPMenu::MemoryBankButtonClick(bool Next) { //Set the current memory bank to use. Initially, no memory bank is specified. if ( (!m_Processing[m_CurrentProcessing]-&gt;UseMemoryBank() &amp;&amp; Next) &amp;&amp; (m_NumMemoryBank&gt;0) ) { m_Processing[m_CurrentProcessing]-&gt;SetCurrentMemoryBank(M_MEMORY_BANK_0, true); } else if (m_Processing[m_CurrentProcessing]-&gt;UseMemoryBank()) { bool ValidBank = false; MIL_INT64 NewMemoryBank = m_Processing[m_CurrentProcessing]-&gt;GetMemoryBank(Next, ValidBank); if (ValidBank) { switch(NewMemoryBank) { case M_MEMORY_BANK_0: if (!Next &amp;&amp; (m_Processing[m_CurrentProcessing]-&gt;GetCurrentMemoryBank()==M_MEMORY_BANK_0)) { m_Processing[m_CurrentProcessing]-&gt;SetCurrentMemoryBank(0, false); } else if (!Next) { m_Processing[m_CurrentProcessing]-&gt;SetCurrentMemoryBank(M_MEMORY_BANK_0, true); } break; case M_MEMORY_BANK_1: m_Processing[m_CurrentProcessing]-&gt;SetCurrentMemoryBank(M_MEMORY_BANK_1, true); break; case M_MEMORY_BANK_2: m_Processing[m_CurrentProcessing]-&gt;SetCurrentMemoryBank(M_MEMORY_BANK_2, true); break; case M_MEMORY_BANK_3: m_Processing[m_CurrentProcessing]-&gt;SetCurrentMemoryBank(M_MEMORY_BANK_3, true); break; case M_MEMORY_BANK_4: m_Processing[m_CurrentProcessing]-&gt;SetCurrentMemoryBank(M_MEMORY_BANK_4, true); break; case M_MEMORY_BANK_5: m_Processing[m_CurrentProcessing]-&gt;SetCurrentMemoryBank(M_MEMORY_BANK_5, true); break; case M_MEMORY_BANK_6: m_Processing[m_CurrentProcessing]-&gt;SetCurrentMemoryBank(M_MEMORY_BANK_6, true); break; default: break; } } } //Update the button text MIL_TEXT_CHAR ButtonText[STRING_SIZE]=MIL_TEXT(\"\"); m_Buttons[enMemoryBank].Push(GetButtonText(m_CurrentProcessing, enMemoryBank, ButtonText)); } //******************************************************************************* // CoreAffinityButtonClick. Set or remove an affinity to the given core index. //******************************************************************************* void CMPMenu::CoreAffinityButtonClick(MIL_INT CoreIndex) { MIL_UINT64 CurrentCoreAffinity = m_Processing[m_CurrentProcessing]-&gt;GetCoreAffinity(); MIL_UINT64 CoreAffinityMask = 0x00000001; //Set the mask on the position that represents the index of the real core CoreAffinityMask = CoreAffinityMask &lt;&lt; GetRealCoreIndex(CoreIndex); MIL_TEXT_CHAR ButtonText[STRING_SIZE]=MIL_TEXT(\"\"); if (m_Buttons[CoreIndex+FIRST_CORE].IsPressed()) { //remove affinity m_Processing[m_CurrentProcessing]-&gt;SetCoreAffinity(CurrentCoreAffinity&amp;~CoreAffinityMask); } else { //set affinity m_Processing[m_CurrentProcessing]-&gt;SetCoreAffinity(CurrentCoreAffinity|CoreAffinityMask); } m_Buttons[CoreIndex+FIRST_CORE].Push(GetButtonText(m_CurrentProcessing, (MPButtons)(CoreIndex+FIRST_CORE), ButtonText)); } //******************************************************************************* // UpdateMenu. Updated the status of all the buttons and info if processing // thread has changed. //******************************************************************************* void CMPMenu::UpdateMenu() { MIL_TEXT_CHAR ButtonText[STRING_SIZE]=MIL_TEXT(\"\"); //Make sure the display selection is consistent with the show display button if ( (m_Processing[m_CurrentProcessing]-&gt;DisplaySelected() &amp;&amp; !m_Buttons[enShowDisplay].IsPressed()) || (!m_Processing[m_CurrentProcessing]-&gt;DisplaySelected() &amp;&amp; m_Buttons[enShowDisplay].IsPressed()) ) { m_Buttons[enShowDisplay].Push(GetButtonText(m_CurrentProcessing, enShowDisplay, ButtonText)); } //Update the currently selected processing index m_Buttons[enProcThread].Push(GetButtonText(m_CurrentProcessing, enProcThread, ButtonText)); //Update whether it is running or not and it's associated FPS if (m_Processing[m_CurrentProcessing]-&gt;IsRunning() &amp;&amp; !m_Buttons[enRunProcessing].IsPressed()) { m_Buttons[enRunProcessing].Push(GetButtonText(m_CurrentProcessing, enRunProcessing, ButtonText)); } else if (!m_Processing[m_CurrentProcessing]-&gt;IsRunning()) { UpdateCurProcFPS(); if (m_Buttons[enRunProcessing].IsPressed()) m_Buttons[enRunProcessing].Push(GetButtonText(m_CurrentProcessing, enRunProcessing, ButtonText)); } //Clear total FPS if none of the threads are processing MIL_INT i=0; for (i=0; i&lt;m_CurrentProcessingNum; i++) { if (m_Processing[i]-&gt;IsRunning()) break; } if (i==m_CurrentProcessingNum) UpdateTotalFPS(); //Update the update display button if ( (m_Processing[m_CurrentProcessing]-&gt;DisplayRunning() &amp;&amp; !m_Buttons[enRunDisplay].IsPressed()) || (!m_Processing[m_CurrentProcessing]-&gt;DisplayRunning() &amp;&amp; m_Buttons[enRunDisplay].IsPressed()) ) { m_Buttons[enRunDisplay].Push(GetButtonText(m_CurrentProcessing, enRunDisplay, ButtonText)); } if (!m_MPIsOff) { //Update the MP button if ( (!m_Processing[m_CurrentProcessing]-&gt;MPEnabled() &amp;&amp; m_Buttons[enMP].IsPressed()) || (m_Processing[m_CurrentProcessing]-&gt;MPEnabled() &amp;&amp; !m_Buttons[enMP].IsPressed()) ) { m_Buttons[enMP].Push(GetButtonText(m_CurrentProcessing, enMP, ButtonText)); } //Update maximum cores button m_Buttons[enCoreMax].Push(GetButtonText(m_CurrentProcessing, enCoreMax, ButtonText)); //Update MP thread Priority m_Buttons[enMPPriority].Push(GetButtonText(m_CurrentProcessing, enMPPriority, ButtonText)); //Update Memory bank button m_Buttons[enMemoryBank].Push(GetButtonText(m_CurrentProcessing, enMemoryBank, ButtonText)); //Update Core sharing button if ( (!m_Processing[m_CurrentProcessing]-&gt;CoreSharingEnabled() &amp;&amp; m_Buttons[enCoreSharing].IsPressed()) || (m_Processing[m_CurrentProcessing]-&gt;CoreSharingEnabled() &amp;&amp; !m_Buttons[enCoreSharing].IsPressed()) ) { m_Buttons[enCoreSharing].Push(GetButtonText(m_CurrentProcessing, enCoreSharing, ButtonText)); } //Update Core affinity buttons MIL_UINT64 CurrentCoreAffinity = m_Processing[m_CurrentProcessing]-&gt;GetCoreAffinity(); for (MIL_INT i=FIRST_CORE; (i-FIRST_CORE)&lt;m_NumberOfProcessorCores; i++) { bool AffinityIsSet = (CurrentCoreAffinity&amp;((MIL_UINT64)1&lt;&lt;GetRealCoreIndex(i-FIRST_CORE))) != 0x00000000; if (AffinityIsSet != m_Buttons[i].IsPressed()) { m_Buttons[i].Push(GetButtonText(m_CurrentProcessing, (MPButtons)i, ButtonText)); } } } } //******************************************************************************* // UpdateInfo. Update information such as FPS the menu display. //******************************************************************************* void CMPMenu::UpdateInfo() { //Wait for an event while ( MthrWaitMultiple(m_MilInfoEvents, NUM_EVENTS, M_EVENT_WAIT, M_NULL) != (MIL_INT)enKill ) { while (m_UpdateInfoStarted) { //Update total frames per second UpdateTotalFPS(); //Update frames per second for the currently selected thread if (m_Processing[m_CurrentProcessing]-&gt;GetFrameRate()&gt;0) UpdateCurProcFPS(); MosSleep(UPDATE_INFO_TIME_DELAY); } //Signal that the information is no longer being updated MthrControl(m_MilUpdateInfoStoppedEvent, M_EVENT_SET, M_SIGNALED); } } //******************************************************************************* // UpdateTotalFPS. Update Total FPS on the menu //******************************************************************************* void CMPMenu::UpdateTotalFPS() { MIL_DOUBLE FrameRate = 0; //Get the sum of frames per second of all threads for (MIL_INT i=0; i&lt;m_CurrentProcessingNum; i++) { if (m_Processing[i]-&gt;IsRunning()) FrameRate += m_Processing[i]-&gt;GetFrameRate(); } //Update total FPS MosSprintf(m_InfoString, STRING_SIZE, MIL_TEXT(\"%.1f Total Frames per Second\"), FrameRate); MdispControl(m_MilMenuDisplay, M_UPDATE, M_DISABLE); MbufClear(m_InfoRegions[enTotalFPS].MilRectBuffer, BACKGROUND_COLOR); MgraText(m_MilInfoGraphicsContext, m_InfoRegions[enTotalFPS].MilRectBuffer, 0, 0, m_InfoString); MdispControl(m_MilMenuDisplay, M_UPDATE, M_ENABLE); } //******************************************************************************* // UpdateFPS. Update current processing FPS on the menu //******************************************************************************* void CMPMenu::UpdateCurProcFPS() { //Update current processing FPS MosSprintf(m_InfoString, STRING_SIZE, MIL_TEXT(\"%.1f Frames per Second\"), m_Processing[m_CurrentProcessing]-&gt;GetFrameRate()); MdispControl(m_MilMenuDisplay, M_UPDATE, M_DISABLE); MbufClear(m_InfoRegions[enCurProcFPS].MilRectBuffer, BACKGROUND_COLOR); MgraText(m_MilInfoGraphicsContext, m_InfoRegions[enCurProcFPS].MilRectBuffer, 0, 0, m_InfoString); MdispControl(m_MilMenuDisplay, M_UPDATE, M_ENABLE); } //******************************************************************************* // StartUpdateInfo. Indicate to start updating FPS //******************************************************************************* void CMPMenu::StartUpdateInfo() { //Set the even to start updating frames per second m_UpdateInfoStarted = true; MthrControl(m_MilInfoEvents[enRun], M_EVENT_SET, M_SIGNALED); } //******************************************************************************* // StopUpdateInfo. Indicate to stop updating FPS //******************************************************************************* void CMPMenu::StopUpdateInfo() { MIL_INT i=0; //Look for a running thread for (i=0; i&lt;m_ProcessingArraySize; i++) { if (m_Processing[i]-&gt;IsRunning()) break; } //Only stop updating the info if none of the processing are started if ((i==m_ProcessingArraySize) &amp;&amp; m_UpdateInfoStarted) { m_UpdateInfoStarted = false; //Wait until the information on the menu has stopped updating MthrWait(m_MilUpdateInfoStoppedEvent, M_EVENT_WAIT, M_NULL); } } //***************************************************************************** // GetButtonText. Centralizes the management of the text written on buttons. //***************************************************************************** MIL_TEXT_CHAR* CMPMenu::GetButtonText(MIL_INT ProcessingIndex, MPButtons ButtonType, MIL_TEXT_CHAR* ButtonText) { bool UseMemoryBank = false; MIL_INT64 CurrentMemoryBank = 0; MIL_UINT64 CoreMask = 0x00000001; //Get the text for the given button type and the currently selected user thread switch (ButtonType) { case enTotalThreads: MosSprintf(ButtonText, STRING_SIZE, MIL_TEXT(\"%d\"), m_CurrentProcessingNum); break; case enShowDisplay: if (m_Processing[m_CurrentProcessing]-&gt;DisplaySelected()) MosSprintf(ButtonText, STRING_SIZE, MIL_TEXT(\"%s\"), MIL_TEXT(\"Yes\")); else MosSprintf(ButtonText, STRING_SIZE, MIL_TEXT(\"%s\"), MIL_TEXT(\"No\")); break; case enProcThread: MosSprintf(ButtonText, STRING_SIZE, MIL_TEXT(\"%d\"), m_CurrentProcessing); break; case enApplyToAllThreads: MosSprintf(ButtonText, STRING_SIZE, MIL_TEXT(\"%s\"), MIL_TEXT(\"Apply to All Threads\")); break; case enRunProcessing: if (m_Processing[ProcessingIndex]-&gt;IsRunning()) MosSprintf(ButtonText, STRING_SIZE, MIL_TEXT(\"%s\"), MIL_TEXT(\"Yes\")); else MosSprintf(ButtonText, STRING_SIZE, MIL_TEXT(\"%s\"), MIL_TEXT(\"No\")); break; case enRunDisplay: if (m_Processing[ProcessingIndex]-&gt;DisplayRunning()) MosSprintf(ButtonText, STRING_SIZE, MIL_TEXT(\"%s\"), MIL_TEXT(\"Yes\")); else MosSprintf(ButtonText, STRING_SIZE, MIL_TEXT(\"%s\"), MIL_TEXT(\"No\")); break; case enMemoryBank: CurrentMemoryBank = m_Processing[m_CurrentProcessing]-&gt;GetCurrentMemoryBank(); if (m_Processing[m_CurrentProcessing]-&gt;UseMemoryBank()) { switch(CurrentMemoryBank) { case M_MEMORY_BANK_0: MosSprintf(ButtonText, STRING_SIZE, MIL_TEXT(\"%s\"), MIL_TEXT(\"Bank 0\")); break; case M_MEMORY_BANK_1: MosSprintf(ButtonText, STRING_SIZE, MIL_TEXT(\"%s\"), MIL_TEXT(\"Bank 1\")); break; case M_MEMORY_BANK_2: MosSprintf(ButtonText, STRING_SIZE, MIL_TEXT(\"%s\"), MIL_TEXT(\"Bank 2\")); break; case M_MEMORY_BANK_3: MosSprintf(ButtonText, STRING_SIZE, MIL_TEXT(\"%s\"), MIL_TEXT(\"Bank 3\")); break; case M_MEMORY_BANK_4: MosSprintf(ButtonText, STRING_SIZE, MIL_TEXT(\"%s\"), MIL_TEXT(\"Bank 4\")); break; case M_MEMORY_BANK_5: MosSprintf(ButtonText, STRING_SIZE, MIL_TEXT(\"%s\"), MIL_TEXT(\"Bank 5\")); break; case M_MEMORY_BANK_6: MosSprintf(ButtonText, STRING_SIZE, MIL_TEXT(\"%s\"), MIL_TEXT(\"Bank 6\")); break; default: break; } } else { MosSprintf(ButtonText, STRING_SIZE, MIL_TEXT(\"%s\"), MIL_TEXT(\"No Affinity\")); } break; case enMP: if (m_Processing[ProcessingIndex]-&gt;MPEnabled()) MosSprintf(ButtonText, STRING_SIZE, MIL_TEXT(\"%s\"), MIL_TEXT(\"Yes\")); else MosSprintf(ButtonText, STRING_SIZE, MIL_TEXT(\"%s\"), MIL_TEXT(\"No\")); break; case enCoreMax: MosSprintf(ButtonText, STRING_SIZE, MIL_TEXT(\"%d\"), m_Processing[m_CurrentProcessing]-&gt;GetCoreMax()); break; case enCoreSharing: if (m_Processing[ProcessingIndex]-&gt;CoreSharingEnabled()) MosSprintf(ButtonText, STRING_SIZE, MIL_TEXT(\"%s\"), MIL_TEXT(\"Enabled\")); else MosSprintf(ButtonText, STRING_SIZE, MIL_TEXT(\"%s\"), MIL_TEXT(\"Disabled\")); break; case enMPPriority: switch (m_Processing[ProcessingIndex]-&gt;GetMPPriority()) { case M_ABOVE_NORMAL: MosSprintf(ButtonText, STRING_SIZE, MIL_TEXT(\"Above Normal\")); break; case M_BELOW_NORMAL: MosSprintf(ButtonText, STRING_SIZE, MIL_TEXT(\"Below Normal\")); break; case M_HIGHEST: MosSprintf(ButtonText, STRING_SIZE, MIL_TEXT(\"Highest\")); break; case M_IDLE: MosSprintf(ButtonText, STRING_SIZE, MIL_TEXT(\"Idle\")); break; case M_LOWEST: MosSprintf(ButtonText, STRING_SIZE, MIL_TEXT(\"Lowest\")); break; case M_NORMAL: MosSprintf(ButtonText, STRING_SIZE, MIL_TEXT(\"Normal\")); break; case M_TIME_CRITICAL: MosSprintf(ButtonText, STRING_SIZE, MIL_TEXT(\"Time Critical\")); break; default: break; } break; case enCore0:case enCore1:case enCore2:case enCore3: case enCore4:case enCore5:case enCore6:case enCore7: case enCore8:case enCore9:case enCore10:case enCore11: case enCore12:case enCore13:case enCore14:case enCore15: case enCore16:case enCore17:case enCore18:case enCore19: case enCore20:case enCore21:case enCore22:case enCore23: case enCore24:case enCore25:case enCore26:case enCore27: case enCore28:case enCore29:case enCore30:case enCore31: MosSprintf(ButtonText, STRING_SIZE, MIL_TEXT(\"%d, %d\"), GetRealCoreIndex(ButtonType-FIRST_CORE), MappInquireMp(M_DEFAULT, M_CORE_MEMORY_BANK, M_DEFAULT, GetRealCoreIndex(ButtonType-FIRST_CORE), M_NULL)); break; default: break; } return ButtonText; } //***************************************************************************** // InitProcessingMP. Initializes the state of MP of the given processing // object. //***************************************************************************** void CMPMenu::InitProcessingMP(MIL_INT NumCores, CMPProcessing* Processing) { //Set the initial MP state of the given processing object Processing-&gt;SetMP(true); Processing-&gt;SetCoreMax(NumCores); Processing-&gt;SetCoreSharing(false); Processing-&gt;SetMPPriority(M_NORMAL); Processing-&gt;SetCoreAffinity(0x00000000); Processing-&gt;SetCurrentMemoryBank(0, false); } //***************************************************************************** // GetRealCoreIndex. Get the real (physical) index of the core specified by // the rank. If, for example, a core affinity has been set on the process the // physical core indices can be different. //***************************************************************************** MIL_INT CMPMenu::GetRealCoreIndex(MIL_INT Rank) { MIL_INT i=0; MIL_INT AvailableCoresCount = 0; for (i=0; i&lt;MAX_MP_CORES; i++) { if (m_CoreAffinityMaskProcess[0]&amp;((MIL_UINT64)1&lt;&lt;i)) AvailableCoresCount++; if (AvailableCoresCount==Rank+1) break; } return i; } //***************************************************************************** // MenuHookFct. Manages the interaction with the menu. //***************************************************************************** MIL_INT MFTYPE CMPMenu::MenuHookFct(MIL_INT HookType, MIL_ID MilEvent, void *UserDataPtr) { CMPMenu* MenuPtr = (CMPMenu*)UserDataPtr; MIL_INT PositionX = 0; MIL_INT PositionY = 0; MIL_UINT64 CoreMask = 0x00000001; //Get the position of the button click MdispGetHookInfo(MilEvent, M_MOUSE_POSITION_X, &amp;PositionX); MdispGetHookInfo(MilEvent, M_MOUSE_POSITION_Y, &amp;PositionY); //Get the button type MPButtons ButtonType = MenuPtr-&gt;GetButton(PositionX, PositionY); //Call the click handler function according to the button type switch (ButtonType) { case enTotalThreadsLeft: MenuPtr-&gt;NumberOfThreadsButtonClick(false); break; case enTotalThreadsRight: MenuPtr-&gt;NumberOfThreadsButtonClick(true); break; case enShowDisplay: MenuPtr-&gt;AllThreadsDisplayButtonClick(); break; case enProcThreadLeft: MenuPtr-&gt;ProcessingThreadButtonClick(false); break; case enProcThreadRight: MenuPtr-&gt;ProcessingThreadButtonClick(true); break; case enApplyToAllThreads: MenuPtr-&gt;ApplyToAllThreadsButtonClick(); break; case enRunProcessing: MenuPtr-&gt;ProcessingButtonClick(); break; case enRunDisplay: MenuPtr-&gt;CurrentThreadDisplayButtonClick(); break; case enMemoryBankLeft: if (MenuPtr-&gt;m_NumberOfProcessorCores&gt;=MIN_MP_CORES) MenuPtr-&gt;MemoryBankButtonClick(false); break; case enMemoryBankRight: if (MenuPtr-&gt;m_NumberOfProcessorCores&gt;=MIN_MP_CORES) MenuPtr-&gt;MemoryBankButtonClick(true); break; case enMP: if (MenuPtr-&gt;m_NumberOfProcessorCores&gt;=MIN_MP_CORES) MenuPtr-&gt;MPButtonClick(); break; case enCoreMaxLeft: if (MenuPtr-&gt;m_NumberOfProcessorCores&gt;=MIN_MP_CORES) MenuPtr-&gt;CoreMaxButtonClick(false); break; case enCoreMaxRight: if (MenuPtr-&gt;m_NumberOfProcessorCores&gt;=MIN_MP_CORES) MenuPtr-&gt;CoreMaxButtonClick(true); break; case enCoreSharing: if (MenuPtr-&gt;m_NumberOfProcessorCores&gt;=MIN_MP_CORES) MenuPtr-&gt;CoreSharingButtonClick(); break; case enMPPriorityLeft: if (MenuPtr-&gt;m_NumberOfProcessorCores&gt;=MIN_MP_CORES) MenuPtr-&gt;MPPriorityButtonClick(false); break; case enMPPriorityRight: if (MenuPtr-&gt;m_NumberOfProcessorCores&gt;=MIN_MP_CORES) MenuPtr-&gt;MPPriorityButtonClick(true); break; //Core affinity handling case enCore0:case enCore1:case enCore2:case enCore3: case enCore4:case enCore5:case enCore6:case enCore7: case enCore8:case enCore9:case enCore10:case enCore11: case enCore12:case enCore13:case enCore14:case enCore15: case enCore16:case enCore17:case enCore18:case enCore19: case enCore20:case enCore21:case enCore22:case enCore23: case enCore24:case enCore25:case enCore26:case enCore27: case enCore28:case enCore29:case enCore30:case enCore31: if (MenuPtr-&gt;m_NumberOfProcessorCores&gt;=MIN_MP_CORES) MenuPtr-&gt;CoreAffinityButtonClick(ButtonType-FIRST_CORE); break; default: break; }; return 0; } //***************************************************************************** // UpdateInfoFunction. Function that updates FPS //***************************************************************************** MIL_UINT32 MFTYPE CMPMenu::UpdateInfoFunction(void* DataPtr) { CMPMenu* Menu = (CMPMenu*)DataPtr; Menu-&gt;UpdateInfo(); return 0; } ",
      "wordCount": 3786
    },
    {
      "id": "Examples_Processing_Optimization_MultiProcessing_CPP_mpmenubutton_cpp",
      "version": "2024020714",
      "title": "mpmenubutton.cpp",
      "location": "Sample Code from MIL Examples",
      "text": " Top //***************************************************************************************/ // // File name: MenuButton.cpp // Location: See Matrox Example Launcher in the MIL Control Center // // // Synopsis: Implements the CMPMenuButton class. // // Copyright (C) Matrox Electronic Systems Ltd., 1992-2024. // All Rights Reserved #include \"common.h\" #if M_MIL_USE_LINUX #include &lt;stdlib.h&gt; #endif static const MIL_INT TEXT_GAP_UNPRESSED = 8; static const MIL_INT TEXT_GAP_PRESSED = 10; static MIL_CONST_TEXT_PTR const NORMAL_UNPRESSED_BUTTON = EXAMPLE_IMAGE_PATH MIL_TEXT(\"NormalButtonUnpressed.mim\"); static MIL_CONST_TEXT_PTR const NORMAL_PRESSED_BUTTON = EXAMPLE_IMAGE_PATH MIL_TEXT(\"NormalButtonPressed.mim\"); static MIL_CONST_TEXT_PTR const SMALL_UNPRESSED_BUTTON = EXAMPLE_IMAGE_PATH MIL_TEXT(\"SmallButtonUnpressed.mim\"); static MIL_CONST_TEXT_PTR const SMALL_PRESSED_BUTTON = EXAMPLE_IMAGE_PATH MIL_TEXT(\"SmallButtonPressed.mim\"); //******************************************************************************* // Constructor. Allocates and initializes the menu button //******************************************************************************* CMPMenuButton::CMPMenuButton() : m_MilButtonBuffer(0), m_MilGraphicsContext(0), m_IsToggle(true), m_IsPressed(true), m_IsDisabled(false), m_MilPressedButton(0), m_MilUnpressedButton(0) { } //******************************************************************************* // Destructor. Deallocates the menu button //******************************************************************************* CMPMenuButton::~CMPMenuButton() { //Destroy the button Destroy(); } //******************************************************************************* // Create. Creates the menu button //******************************************************************************* void CMPMenuButton::Create(MIL_CONST_TEXT_PTR Text, MIL_ID MilParentBuffer, RectStruct Rect, bool IsToggle) { //Allocate and configure graphics context for menu text MbufInquire(MilParentBuffer, M_OWNER_SYSTEM, &amp;m_MilButtonSystem); MgraAlloc(m_MilButtonSystem, &amp;m_MilGraphicsContext); MgraControl(m_MilGraphicsContext, M_BACKGROUND_MODE, M_TRANSPARENT); MgraControl(m_MilGraphicsContext, M_COLOR, M_COLOR_DARK_BLUE); MgraControl(m_MilGraphicsContext, M_FONT_SIZE, SMALL_FONT); MgraFont(m_MilGraphicsContext, NORMAL_FONT_TYPE); //Decide which button image to use MIL_INT NormalButtonSizeX = MbufDiskInquire(NORMAL_PRESSED_BUTTON, M_SIZE_X, M_NULL); MIL_INT SmallButtonSizeX = MbufDiskInquire(SMALL_PRESSED_BUTTON, M_SIZE_X, M_NULL); MIL_INT UserRectSizeX = Rect.EndX-Rect.StartX+1; MIL_INT UserRectSizeY = Rect.EndY-Rect.StartY+1; if (abs((MIL_INT32)(UserRectSizeX-NormalButtonSizeX)) &lt; abs((MIL_INT32)(UserRectSizeX-SmallButtonSizeX))) { //Choose normal button MbufRestore(NORMAL_PRESSED_BUTTON, m_MilButtonSystem, &amp;m_MilPressedButton); MbufRestore(NORMAL_UNPRESSED_BUTTON, m_MilButtonSystem, &amp;m_MilUnpressedButton); } else { //Choose small button MbufRestore(SMALL_PRESSED_BUTTON, m_MilButtonSystem, &amp;m_MilPressedButton); MbufRestore(SMALL_UNPRESSED_BUTTON, m_MilButtonSystem, &amp;m_MilUnpressedButton); } m_IsPressed = true; //Create the button on the menu buffer MbufChild2d(MilParentBuffer, Rect.StartX, Rect.StartY, UserRectSizeX, UserRectSizeY, &amp;m_MilButtonBuffer); m_ButtonRect.StartX = Rect.StartX; m_ButtonRect.EndX = Rect.EndX; m_ButtonRect.StartY = Rect.StartY; m_ButtonRect.EndY = Rect.EndY; m_IsToggle = IsToggle; Push(Text); } //******************************************************************************* // Destroy. Destroy the menu button //******************************************************************************* void CMPMenuButton::Destroy() { //Free contexts and buffers if (m_MilGraphicsContext) { MgraFree(m_MilGraphicsContext); m_MilGraphicsContext = 0; } if (m_MilButtonBuffer) { MbufFree(m_MilButtonBuffer); m_MilButtonBuffer=0; } if (m_MilPressedButton) { MbufFree(m_MilPressedButton); m_MilPressedButton=0; } if (m_MilUnpressedButton) { MbufFree(m_MilUnpressedButton); m_MilUnpressedButton=0; } } //******************************************************************************* // Push. Push the button //******************************************************************************* void CMPMenuButton::Push(MIL_CONST_TEXT_PTR Text) { if (m_MilButtonBuffer &amp;&amp; !m_IsDisabled) { m_IsPressed = !m_IsPressed &amp;&amp; m_IsToggle; //Load the appropriate image according to whether the button is pushed or not if (m_IsPressed) { //Load pressed button image MimResize(m_MilPressedButton, m_MilButtonBuffer, M_FILL_DESTINATION, M_FILL_DESTINATION, M_BILINEAR); MgraText(m_MilGraphicsContext, m_MilButtonBuffer, TEXT_GAP_PRESSED, TEXT_GAP_PRESSED, Text); } else { //Load unpressed button image MimResize(m_MilUnpressedButton, m_MilButtonBuffer, M_FILL_DESTINATION, M_FILL_DESTINATION, M_BILINEAR); MgraText(m_MilGraphicsContext, m_MilButtonBuffer, TEXT_GAP_UNPRESSED, TEXT_GAP_UNPRESSED, Text); } } } //***************************************************************************** // Disable. Disables the button, it can no longer be pushed unless it is // reenabled. //***************************************************************************** void CMPMenuButton::Disable(MIL_CONST_TEXT_PTR Text) { m_IsDisabled = true; if (m_MilButtonBuffer) { MimResize(m_MilPressedButton, m_MilButtonBuffer, M_FILL_DESTINATION, M_FILL_DESTINATION, M_BILINEAR); MgraText(m_MilGraphicsContext, m_MilButtonBuffer, TEXT_GAP_PRESSED, TEXT_GAP_PRESSED, Text); } } //***************************************************************************** // Enable. Enables the button. The button can be pushed once it is enabled. //***************************************************************************** void CMPMenuButton::Enable(MIL_CONST_TEXT_PTR Text) { m_IsDisabled = false; if (m_MilButtonBuffer) { if (m_IsPressed) { //Load pressed button image if it is pressed MimResize(m_MilPressedButton, m_MilButtonBuffer, M_FILL_DESTINATION, M_FILL_DESTINATION, M_BILINEAR); MgraText(m_MilGraphicsContext, m_MilButtonBuffer, TEXT_GAP_PRESSED, TEXT_GAP_PRESSED, Text); } else { //Load unpressed button image MimResize(m_MilUnpressedButton, m_MilButtonBuffer, M_FILL_DESTINATION, M_FILL_DESTINATION, M_BILINEAR); MgraText(m_MilGraphicsContext, m_MilButtonBuffer, TEXT_GAP_UNPRESSED, TEXT_GAP_UNPRESSED, Text); } } } ",
      "wordCount": 472
    },
    {
      "id": "Examples_Processing_Optimization_MultiProcessing_CPP_mpprocessing_cpp",
      "version": "2024020714",
      "title": "mpprocessing.cpp",
      "location": "Sample Code from MIL Examples",
      "text": " Top //***************************************************************************************/ // // File name: MPProcessing.cpp // Location: See Matrox Example Launcher in the MIL Control Center // // // Synopsis: Implements the CMPProcessing class. // // Copyright (C) Matrox Electronic Systems Ltd., 1992-2024. // All Rights Reserved #include \"common.h\" static const MIL_INT DISPLAY_OFFSET_X = 40; static const MIL_INT MAX_DISPLAY_OFFSET_X = 600; //***************************************************************************** // Constructor. Allocates and initializes the processing objects. //***************************************************************************** CMPProcessing::CMPProcessing(MIL_CONST_TEXT_PTR Title, MIL_INT DisplayBufferSizeX, MIL_INT DisplayBufferSizeY, MIL_INT DisplayBufferType, MIL_INT DisplayBufferSizeBand, MIL_INT ProcessingIndex) : m_DisplayBufferSizeX(DisplayBufferSizeX), m_DisplayBufferSizeY(DisplayBufferSizeY), m_DisplayBufferType(DisplayBufferType), m_DisplayBufferSizeBand(DisplayBufferSizeBand), m_ProcessingIndex(ProcessingIndex) { //Allocate processing objects Alloc(Title); } //***************************************************************************** // Destructor. Frees the processing objects. //***************************************************************************** CMPProcessing::~CMPProcessing() { //Free processing objects Free(); } //***************************************************************************** // StartThread. Starts the processing thread. //***************************************************************************** void CMPProcessing::StartThread() { //Start the dispatching thread m_Dispatcher-&gt;StartThread(); } //***************************************************************************** // StopThread. Stops the processing thread. //***************************************************************************** void CMPProcessing::StopThread() { //Stop the dispatching thread m_Dispatcher-&gt;StopThread(); UpdateDisplayTitle(); } //***************************************************************************** // Run. Runs the processing. //***************************************************************************** void CMPProcessing::Run() { //Run the dispatcher m_Dispatcher-&gt;Run(); } //***************************************************************************** // Pause. Pauses the processing. //***************************************************************************** void CMPProcessing::Pause() { //Pause the dispatcher if (m_Dispatcher-&gt;IsRunning()) { m_Dispatcher-&gt;Pause(); UpdateDisplayTitle(); } } //***************************************************************************** // SetMP. Sets the state of MP (enable or disable). //***************************************************************************** void CMPProcessing::SetMP(bool Enable) { //Set whether or not MP is enabled m_MPEnable = Enable; MthrControlMp(m_Dispatcher-&gt;GetThreadId(), M_MP_USE, M_DEFAULT, (m_MPEnable)?M_ENABLE:M_DISABLE, M_NULL); } //***************************************************************************** // RunDisplay. Sets the state of the display (running or paused). //***************************************************************************** void CMPProcessing::RunDisplay(bool Run) { //Set whether or not the display is running. m_DisplayRunning = Run; } //***************************************************************************** // SetCoreMax. Sets the maxixum number of cores to be used by MP. //***************************************************************************** void CMPProcessing::SetCoreMax(MIL_INT Max) { //Set the maximum cores to use for this processing thread m_CoreMax=Max; MthrControlMp(m_Dispatcher-&gt;GetThreadId(), M_CORE_MAX, M_DEFAULT, m_CoreMax, M_NULL); } //***************************************************************************** // SetCoreSharing. Sets the state of core sharing in MP. //***************************************************************************** void CMPProcessing::SetCoreSharing(bool Enable) { //Set whether core sharing is enabled or not m_CoreSharing=Enable; MthrControlMp(m_Dispatcher-&gt;GetThreadId(), M_CORE_SHARING, M_DEFAULT, (m_CoreSharing)?M_ENABLE:M_DISABLE, M_NULL); } //***************************************************************************** // SetMPPriority. Sets the processing priority in MP. //***************************************************************************** void CMPProcessing::SetMPPriority(MIL_INT Priority) { //Set the thread priority m_MPPriority = Priority; MthrControlMp(m_Dispatcher-&gt;GetThreadId(), M_MP_PRIORITY, M_DEFAULT, m_MPPriority, M_NULL); } //***************************************************************************** // SetCoreAffinity. Sets the affinity to the given core. //***************************************************************************** void CMPProcessing::SetCoreAffinity(MIL_UINT64 AffinityMask) { //Set the core affinity of this thread m_CoreAffinityMask[0]=AffinityMask; MthrControlMp(m_Dispatcher-&gt;GetThreadId(), M_CORE_AFFINITY_MASK, M_DEFAULT, M_USER_DEFINED, m_CoreAffinityMask); } //***************************************************************************** // SetCurrentMemoryBank. Sets the current memory bank. //***************************************************************************** void CMPProcessing::SetCurrentMemoryBank(MIL_INT64 MemoryBank, bool UseBank) { //Set the memory bank to use for buffers used in this thread m_CurrentMemoryBank = MemoryBank; m_UseMemoryBank = UseBank; } //***************************************************************************** // GetMemoryBank. Gets the next memory bank available. //***************************************************************************** MIL_INT64 CMPProcessing::GetMemoryBank(bool Next, bool&amp; ValidBank) const { MIL_INT64 NewMemoryBank=0; ValidBank = false; if (Next) { //Get the next memory bank MIL_INT NextBankIndex = GetMemoryBankIndex(m_CurrentMemoryBank); if ( (NextBankIndex&gt;=0) &amp;&amp; (NextBankIndex&lt;m_NumMemoryBank-1)) NextBankIndex++; NewMemoryBank = GetMemoryBank(NextBankIndex, ValidBank); } else { //Get the previous memory bank MIL_INT PreviousBankIndex = GetMemoryBankIndex(m_CurrentMemoryBank); if (PreviousBankIndex&gt;=1) PreviousBankIndex = PreviousBankIndex--;; NewMemoryBank = GetMemoryBank(PreviousBankIndex, ValidBank); } return NewMemoryBank; } //***************************************************************************** // Alloc. Allocate processing objects. //***************************************************************************** void CMPProcessing::Alloc(MIL_CONST_TEXT_PTR Title) { // Allocate MIL objects. MsysAlloc(M_DEFAULT, M_SYSTEM_HOST, M_DEFAULT, M_DEFAULT, &amp;m_MilSystem); MdispAlloc(m_MilSystem, M_DEFAULT, MIL_TEXT(\"M_DEFAULT\"), M_WINDOWED, &amp;m_MilDisplay); #if M_MIL_USE_WINDOWS MdispControl(m_MilDisplay, M_WINDOW_SYSBUTTON, M_DISABLE); #endif //Change the display window title MosSprintf(m_DisplayTitle, STRING_SIZE, MIL_TEXT(\"%s\"), Title); MdispControl(m_MilDisplay, M_TITLE, m_DisplayTitle); //Allocate the dispatcher m_Dispatcher = new CDispatcher(m_MilSystem, (PROC_FUNCTION_PTR)&amp;ProcessingFunction, (void*)this); m_DisplayRunning = false; m_DisplaySelected = false; m_MPEnable = false; m_CoreMax = -1; m_CoreSharing = false; m_MPPriority = -1; //Initialize core affinity information MIL_INT CoreAffinityMaskArraySize = 0; MappInquireMp(M_DEFAULT, M_CORE_AFFINITY_MASK_ARRAY_SIZE, M_DEFAULT, M_DEFAULT, &amp;CoreAffinityMaskArraySize); m_CoreAffinityMask = new MIL_UINT64 [CoreAffinityMaskArraySize]; for (MIL_INT i=0; i&lt;CoreAffinityMaskArraySize; i++) { m_CoreAffinityMask[i]=0; } //Initialize memory bank affinity information m_CurrentMemoryBank = 0; m_UseMemoryBank = false; //Create array of available memory banks MIL_INT MemoryBankAffinityArraySize = 0; MappInquireMp(M_DEFAULT, M_MEMORY_BANK_AFFINITY_MASK_ARRAY_SIZE, M_DEFAULT, M_DEFAULT, &amp;MemoryBankAffinityArraySize); MIL_UINT64* MemoryBankAffinityMask = new MIL_UINT64 [MemoryBankAffinityArraySize]; for (MIL_INT i=0; i&lt;MemoryBankAffinityArraySize; i++) { MemoryBankAffinityMask[i]=0; } MappInquireMp(M_DEFAULT, M_MEMORY_BANK_AFFINITY_MASK, M_LOCAL, M_DEFAULT, MemoryBankAffinityMask); //All possible memory banks static const MIL_INT NUM_MAX_MEMORY_BANK = 7; static const MIL_INT64 ALL_MEMORY_BANKS[NUM_MAX_MEMORY_BANK] = { M_MEMORY_BANK_0, M_MEMORY_BANK_1, M_MEMORY_BANK_2, M_MEMORY_BANK_3, M_MEMORY_BANK_4, M_MEMORY_BANK_5, M_MEMORY_BANK_6 }; //Initialize the number of memory banks (maximum is 7 for this example) m_NumMemoryBank = 0; m_AvailableMemoryBanks = M_NULL; MIL_INT MaxNumMemoryBanks = MappInquireMp(M_DEFAULT, M_MEMORY_BANK_NUM, M_DEFAULT, M_DEFAULT, M_NULL); if (MaxNumMemoryBanks &gt; 0) { m_AvailableMemoryBanks = new MIL_INT64[MaxNumMemoryBanks]; //Put the memory bank constants (corresponding to the affinity mask) inside the array. for (MIL_INT i=0; i&lt;NUM_MAX_MEMORY_BANK; i++) { if ((MemoryBankAffinityMask[0] &amp; ((MIL_UINT64)1 &lt;&lt; i)) != 0) { m_AvailableMemoryBanks[m_NumMemoryBank++] = ALL_MEMORY_BANKS[i]; } } } delete [] MemoryBankAffinityMask; //Allocate and clear the display buffer MbufAllocColor(m_MilSystem, m_DisplayBufferSizeBand, m_DisplayBufferSizeX, m_DisplayBufferSizeY, m_DisplayBufferType, M_IMAGE+M_PROC+M_DISP, &amp;m_MilDisplayBuffer); MbufClear(m_MilDisplayBuffer, 0.0); } //***************************************************************************** // Free. Free processing objects. //***************************************************************************** void CMPProcessing::Free() { //Deallocate memory delete m_Dispatcher; delete [] m_CoreAffinityMask; m_Dispatcher = M_NULL; m_CoreAffinityMask = M_NULL; //Free MIL objects MbufFree(m_MilDisplayBuffer); MdispFree(m_MilDisplay); MsysFree(m_MilSystem); delete [] m_AvailableMemoryBanks; } //***************************************************************************** // UpdateDisplayTitle. Updates the processing display title //***************************************************************************** void CMPProcessing::UpdateDisplayTitle() { //Update FPS in the display title MIL_TEXT_CHAR TitleText[STRING_SIZE] = MIL_TEXT(\"\"); MosSprintf(TitleText, STRING_SIZE, MIL_TEXT(\"%s %.1f frames per second\"), m_DisplayTitle, m_Dispatcher-&gt;GetFrameRate()); MdispControl(m_MilDisplay, M_TITLE, TitleText); } //***************************************************************************** // DisplaySelect. Select the buffer on the display //***************************************************************************** void CMPProcessing::DisplaySelect() { //Select the buffer on the display if (!m_DisplaySelected) { //Set an x offset so we can see a part of all displays MdispControl(m_MilDisplay, M_WINDOW_INITIAL_POSITION_X, (m_ProcessingIndex*DISPLAY_OFFSET_X) % MAX_DISPLAY_OFFSET_X); MdispControl(m_MilDisplay, M_WINDOW_INITIAL_POSITION_Y, 0); MdispSelect(m_MilDisplay, m_MilDisplayBuffer); m_DisplaySelected = true; } } //***************************************************************************** // DisplayDeselect. Select the buffer on the display //***************************************************************************** void CMPProcessing::DisplayDeselect() { //Deslect the buffer on the display if (m_DisplaySelected) { MdispSelect(m_MilDisplay, M_NULL); m_DisplaySelected = false; } } //***************************************************************************** // GetMemoryBank. Returns the memory bank define associated to the index. // It returns 0 if the memory bank is not valid. //***************************************************************************** MIL_INT64 CMPProcessing::GetMemoryBank(MIL_INT Index, bool&amp; ValidBank) const { //Get the memory bank associated to the given index MIL_INT64 ReturnValue = 0; ValidBank = false; if ( (Index&gt;=0) &amp;&amp; (Index&lt;m_NumMemoryBank) ) { ReturnValue = m_AvailableMemoryBanks[Index]; ValidBank = true; } return ReturnValue; } //***************************************************************************** // UpdateDisplay. Copies the given image to the display if it is not disabled // and updates the information in the display title. //***************************************************************************** void CMPProcessing::UpdateDisplay(MIL_ID ImageToDisplay) { //Copy the result to the display if it is not disabled if (m_DisplaySelected &amp;&amp; m_DisplayRunning) MbufCopy(ImageToDisplay, m_MilDisplayBuffer); //Update the information in the display title UpdateDisplayTitle(); } //***************************************************************************** // GetMemoryBankIndex. Returns the index of the memory bank (place in array) //**************************************************************************f *** MIL_INT CMPProcessing::GetMemoryBankIndex(MIL_INT64 MemoryBank) const { MIL_INT BankIndex=-1; if (m_NumMemoryBank &gt; 0) { //Get the index of the given memory bank for (BankIndex=0; BankIndex&lt;m_NumMemoryBank; BankIndex++) { if (m_AvailableMemoryBanks[BankIndex]==MemoryBank) break; } } return (BankIndex); } //***************************************************************************** // ProcessingFunction. Function that calls the processing to do. //***************************************************************************** long CMPProcessing::ProcessingFunction(void* DataPtr) { CMPProcessing* Processing = (CMPProcessing*)DataPtr; //Get the index of the CPU memory bank that has been selected. 0 is the index //where no memory bank was specified during allocation. MIL_INT ProcessingObjectIndex = 0; if (Processing-&gt;UseMemoryBank()) ProcessingObjectIndex = Processing-&gt;GetMemoryBankIndex(Processing-&gt;GetCurrentMemoryBank())+1; //Run the processing Processing-&gt;Process(ProcessingObjectIndex); return 0; } ",
      "wordCount": 1087
    },
    {
      "id": "Examples_Processing_Optimization_MultiProcessing_CPP_mprotateprocessing_cpp",
      "version": "2024020714",
      "title": "mprotateprocessing.cpp",
      "location": "Sample Code from MIL Examples",
      "text": " Top //***************************************************************************************/ // // File name: MPRotateProcessing.cpp // Location: See Matrox Example Launcher in the MIL Control Center // // // Synopsis: Implements the CMPRotateProcessing class. // // Copyright (C) Matrox Electronic Systems Ltd., 1992-2024. // All Rights Reserved #include \"common.h\" static MIL_CONST_TEXT_PTR const ROTATE_PROCESSING_IMAGE = EXAMPLE_IMAGE_PATH MIL_TEXT(\"LargeWafer.mim\"); static const MIL_DOUBLE ROTATION_INCREMENT = 8.0; //***************************************************************************** // Constructor. //***************************************************************************** CMPRotateProcessing::CMPRotateProcessing(MIL_CONST_TEXT_PTR Title, MIL_INT ProcessingIndex) : CMPProcessing(Title, MbufDiskInquire(ROTATE_PROCESSING_IMAGE, M_SIZE_X, M_NULL), MbufDiskInquire(ROTATE_PROCESSING_IMAGE, M_SIZE_Y, M_NULL), MbufDiskInquire(ROTATE_PROCESSING_IMAGE, M_TYPE, M_NULL), MbufDiskInquire(ROTATE_PROCESSING_IMAGE, M_SIZE_BAND, M_NULL), ProcessingIndex) { //Allocate the structure which will contain all processing object information. m_ProcessingElements = new RotateProcessingStruct[GetNumMemoryBank()+1]; bool ValidBank=false; MIL_INT64 MemoryBank = 0; for (MIL_INT i=0; i&lt;=GetNumMemoryBank(); i++) { MemoryBank = GetMemoryBank(i-1, ValidBank); //Allocate required buffers for processing MbufAllocColor(GetSystemID(), GetBufferSizeBand(), GetBufferSizeX(), GetBufferSizeY(), GetBufferType(), M_IMAGE+M_PROC+M_HOST_MEMORY+MemoryBank, &amp;m_ProcessingElements[i].MilSourceBuffer); MbufAllocColor(GetSystemID(), GetBufferSizeBand(), GetBufferSizeX(), GetBufferSizeY(), GetBufferType(), M_IMAGE+M_PROC+M_HOST_MEMORY+MemoryBank, &amp;m_ProcessingElements[i].MilDest1Buffer); MbufAllocColor(GetSystemID(), GetBufferSizeBand(), GetBufferSizeX(), GetBufferSizeY(), GetBufferType(), M_IMAGE+M_PROC+M_HOST_MEMORY+MemoryBank, &amp;m_ProcessingElements[i].MilDest2Buffer); MbufAllocColor(GetSystemID(), GetBufferSizeBand(), GetBufferSizeX(), GetBufferSizeY(), GetBufferType(), M_IMAGE+M_PROC+M_HOST_MEMORY+MemoryBank, &amp;m_ProcessingElements[i].MilDest3Buffer); MbufAlloc2d(GetSystemID(), 3, 3, 32+M_FLOAT, M_STRUCT_ELEMENT+M_HOST_MEMORY+MemoryBank, &amp;m_ProcessingElements[i].MilStructElement); //Clear the buffers to initialize them MbufClear(m_ProcessingElements[i].MilSourceBuffer, 0.0); MbufClear(m_ProcessingElements[i].MilDest1Buffer, 0.0); MbufClear(m_ProcessingElements[i].MilDest2Buffer, 0.0); MbufClear(m_ProcessingElements[i].MilDest3Buffer, 0.0); MbufClear(m_ProcessingElements[i].MilStructElement, 0.0); //Load the source image MbufLoad(ROTATE_PROCESSING_IMAGE, m_ProcessingElements[i].MilSourceBuffer); //Initialize rotation information m_ProcessingElements[i].RotationAngle = ROTATION_INCREMENT; m_ProcessingElements[i].BufferCenterX = (MIL_DOUBLE)(GetBufferSizeX()/2); m_ProcessingElements[i].BufferCenterY = (MIL_DOUBLE)(GetBufferSizeY()/2); } } //***************************************************************************** // Destructor. //***************************************************************************** CMPRotateProcessing::~CMPRotateProcessing() { //Stop the thread StopThread(); //Free the processing objects for (MIL_INT i=0; i&lt;=GetNumMemoryBank(); i++) { // Free MIL objects. MbufFree(m_ProcessingElements[i].MilSourceBuffer); MbufFree(m_ProcessingElements[i].MilDest1Buffer); MbufFree(m_ProcessingElements[i].MilDest2Buffer); MbufFree(m_ProcessingElements[i].MilDest3Buffer); MbufFree(m_ProcessingElements[i].MilStructElement); } //Free the memory for the processing elements structure delete [] m_ProcessingElements; } //***************************************************************************** // Process. Do the processing. //***************************************************************************** void CMPRotateProcessing::Process(MIL_INT ProcessingObjectIndex) { //Do processing using the buffers allocated on the specified memory location. //Get the contours MimMorphic(m_ProcessingElements[ProcessingObjectIndex].MilSourceBuffer, m_ProcessingElements[ProcessingObjectIndex].MilDest1Buffer, m_ProcessingElements[ProcessingObjectIndex].MilStructElement, M_DILATE, 1, M_GRAYSCALE); MimMorphic(m_ProcessingElements[ProcessingObjectIndex].MilSourceBuffer, m_ProcessingElements[ProcessingObjectIndex].MilDest2Buffer, m_ProcessingElements[ProcessingObjectIndex].MilStructElement, M_ERODE, 1, M_GRAYSCALE); MimArith(m_ProcessingElements[ProcessingObjectIndex].MilDest1Buffer, m_ProcessingElements[ProcessingObjectIndex].MilDest2Buffer, m_ProcessingElements[ProcessingObjectIndex].MilDest3Buffer, M_SUB); //Do the rotation MimRotate( m_ProcessingElements[ProcessingObjectIndex].MilDest3Buffer, m_ProcessingElements[ProcessingObjectIndex].MilDest2Buffer, -m_ProcessingElements[ProcessingObjectIndex].RotationAngle, m_ProcessingElements[ProcessingObjectIndex].BufferCenterX, m_ProcessingElements[ProcessingObjectIndex].BufferCenterY, m_ProcessingElements[ProcessingObjectIndex].BufferCenterX, m_ProcessingElements[ProcessingObjectIndex].BufferCenterY, M_BILINEAR+M_OVERSCAN_CLEAR); //Prepare the rotation angle for next call. m_ProcessingElements[ProcessingObjectIndex].RotationAngle += ROTATION_INCREMENT; if (m_ProcessingElements[ProcessingObjectIndex].RotationAngle &gt; 360.0) m_ProcessingElements[ProcessingObjectIndex].RotationAngle = ROTATION_INCREMENT; //Make the image brighter to make the result more visible const MIL_INT PixelAdjustmentFactor = 3; MimArith(m_ProcessingElements[ProcessingObjectIndex].MilDest2Buffer, PixelAdjustmentFactor, m_ProcessingElements[ProcessingObjectIndex].MilDest3Buffer, M_MULT_CONST); //Copy the result to the display if it is not disabled and Update the information in the display title UpdateDisplay(m_ProcessingElements[ProcessingObjectIndex].MilDest3Buffer); } ",
      "wordCount": 337
    },
    {
      "id": "Examples_Processing_Optimization_MultiProcessing_CPP_mpwarpprocessing_cpp",
      "version": "2024020714",
      "title": "mpwarpprocessing.cpp",
      "location": "Sample Code from MIL Examples",
      "text": " Top //***************************************************************************************/ // // File name: MPWarpProcessing.cpp // Location: See Matrox Example Launcher in the MIL Control Center // // // Synopsis: Implements the CMPWarpProcessing class. // // Copyright (C) Matrox Electronic Systems Ltd., 1992-2024. // All Rights Reserved #include \"common.h\" static MIL_CONST_TEXT_PTR const WARP_PROCESSING_IMAGE = EXAMPLE_IMAGE_PATH MIL_TEXT(\"LargeWafer.mim\"); static const MIL_INT WARP_INCREMENT = 40; static const MIL_INT MAX_INCREMENT = 20; //***************************************************************************** // Constructor. //***************************************************************************** CMPWarpProcessing::CMPWarpProcessing(MIL_CONST_TEXT_PTR Title, MIL_INT ProcessingIndex) : CMPProcessing(Title, MbufDiskInquire(WARP_PROCESSING_IMAGE, M_SIZE_X, M_NULL), MbufDiskInquire(WARP_PROCESSING_IMAGE, M_SIZE_Y, M_NULL), MbufDiskInquire(WARP_PROCESSING_IMAGE, M_TYPE, M_NULL), MbufDiskInquire(WARP_PROCESSING_IMAGE, M_SIZE_BAND, M_NULL), ProcessingIndex) { m_IncrementCount = 0; m_Direction = enWarpRight; //Setup the warp 4 corner parameters. //Move left m_FourCorners[0] = -(MAX_INCREMENT*WARP_INCREMENT)/2; m_FourCorners[1] = 0.0f; m_FourCorners[2] = (MIL_FLOAT)GetBufferSizeX()-1-(MAX_INCREMENT*WARP_INCREMENT)/2; m_FourCorners[3] = 0.0f; m_FourCorners[4] = (MIL_FLOAT)GetBufferSizeX()-1+(MAX_INCREMENT*WARP_INCREMENT)/2; m_FourCorners[5] = (MIL_FLOAT)GetBufferSizeY()-1; m_FourCorners[6] = (MAX_INCREMENT*WARP_INCREMENT)/2; m_FourCorners[7] = (MIL_FLOAT)GetBufferSizeY()-1; //Tilt back m_FourCorners[0] += (MAX_INCREMENT*WARP_INCREMENT)/2; m_FourCorners[1] += (MAX_INCREMENT*WARP_INCREMENT)/2; m_FourCorners[2] -= (MAX_INCREMENT*WARP_INCREMENT)/2; m_FourCorners[3] += (MAX_INCREMENT*WARP_INCREMENT)/2; m_FourCorners[4] += (MAX_INCREMENT*WARP_INCREMENT)/2; m_FourCorners[5] -= (MAX_INCREMENT*WARP_INCREMENT)/2; m_FourCorners[6] -= (MAX_INCREMENT*WARP_INCREMENT)/2; m_FourCorners[7] -= (MAX_INCREMENT*WARP_INCREMENT)/2; m_FourCorners[8] = 0.0f; m_FourCorners[9] = 0.0f; m_FourCorners[10] = (MIL_FLOAT)GetBufferSizeX()-1; m_FourCorners[11] = (MIL_FLOAT)GetBufferSizeY()-1; //Allocate the structure which will contain all processing object information. m_ProcessingElements = new WarpProcessingStruct[GetNumMemoryBank()+1]; bool ValidBank = false; MIL_INT64 MemoryBank = 0; for (MIL_INT i=0; i&lt;=GetNumMemoryBank(); i++) { MemoryBank = GetMemoryBank(i-1, ValidBank); //Allocate required buffers for processing MbufAllocColor(GetSystemID(), GetBufferSizeBand(), GetBufferSizeX(), GetBufferSizeY(), GetBufferType(), M_IMAGE+M_PROC+M_HOST_MEMORY+MemoryBank, &amp;m_ProcessingElements[i].MilSourceBuffer); MbufAllocColor(GetSystemID(), GetBufferSizeBand(), GetBufferSizeX(), GetBufferSizeY(), GetBufferType(), M_IMAGE+M_PROC+M_HOST_MEMORY+MemoryBank, &amp;m_ProcessingElements[i].MilDest1Buffer); MbufAllocColor(GetSystemID(), GetBufferSizeBand(), GetBufferSizeX(), GetBufferSizeY(), GetBufferType(), M_IMAGE+M_PROC+M_HOST_MEMORY+MemoryBank, &amp;m_ProcessingElements[i].MilDest2Buffer); MbufAllocColor(GetSystemID(), GetBufferSizeBand(), GetBufferSizeX(), GetBufferSizeY(), GetBufferType(), M_IMAGE+M_PROC+M_HOST_MEMORY+MemoryBank, &amp;m_ProcessingElements[i].MilDest3Buffer); MbufAlloc2d(GetSystemID(), 3, 3, 32+M_FLOAT, M_STRUCT_ELEMENT+M_HOST_MEMORY+MemoryBank, &amp;m_ProcessingElements[i].MilStructElement); MbufAlloc1d(GetSystemID(), 12, 32+M_FLOAT, M_ARRAY+M_HOST_MEMORY+MemoryBank, &amp;m_ProcessingElements[i].MilFourCornerBuffer); MbufAlloc2d(GetSystemID(), 3, 3, 32+M_FLOAT, M_ARRAY+M_HOST_MEMORY+MemoryBank, &amp;m_ProcessingElements[i].MilCoefficientsBuffer); //Clear the buffers to initialize them MbufClear(m_ProcessingElements[i].MilSourceBuffer, 0.0); MbufClear(m_ProcessingElements[i].MilDest1Buffer, 0.0); MbufClear(m_ProcessingElements[i].MilDest2Buffer, 0.0); MbufClear(m_ProcessingElements[i].MilDest3Buffer, 0.0); MbufClear(m_ProcessingElements[i].MilStructElement, 0.0); MbufClear(m_ProcessingElements[i].MilFourCornerBuffer, 0.0); MbufClear(m_ProcessingElements[i].MilCoefficientsBuffer, 0.0); //Load the source image MbufLoad(WARP_PROCESSING_IMAGE, m_ProcessingElements[i].MilSourceBuffer); //Generate the coefficients buffer for warping GenerateCoefficientsBuffer(i); } } //***************************************************************************** // Destructor. //***************************************************************************** CMPWarpProcessing::~CMPWarpProcessing() { //Stop the thread StopThread(); for (MIL_INT i=0; i&lt;=GetNumMemoryBank(); i++) { // Free MIL objects. MbufFree(m_ProcessingElements[i].MilSourceBuffer); MbufFree(m_ProcessingElements[i].MilDest1Buffer); MbufFree(m_ProcessingElements[i].MilDest2Buffer); MbufFree(m_ProcessingElements[i].MilDest3Buffer); MbufFree(m_ProcessingElements[i].MilStructElement); MbufFree(m_ProcessingElements[i].MilFourCornerBuffer); MbufFree(m_ProcessingElements[i].MilCoefficientsBuffer); } //Free processing information structure delete [] m_ProcessingElements; } //***************************************************************************** // Process. Do the processing. //***************************************************************************** void CMPWarpProcessing::Process(MIL_INT ProcessingObjectIndex) { //Do processing using the buffers allocated on the requested memory bank. //Get the contours MimMorphic(m_ProcessingElements[ProcessingObjectIndex].MilSourceBuffer, m_ProcessingElements[ProcessingObjectIndex].MilDest1Buffer, m_ProcessingElements[ProcessingObjectIndex].MilStructElement, M_DILATE, 1, M_GRAYSCALE); MimMorphic(m_ProcessingElements[ProcessingObjectIndex].MilSourceBuffer, m_ProcessingElements[ProcessingObjectIndex].MilDest2Buffer, m_ProcessingElements[ProcessingObjectIndex].MilStructElement, M_ERODE, 1, M_GRAYSCALE); MimArith(m_ProcessingElements[ProcessingObjectIndex].MilDest1Buffer, m_ProcessingElements[ProcessingObjectIndex].MilDest2Buffer, m_ProcessingElements[ProcessingObjectIndex].MilDest3Buffer, M_SUB); //Warp the image MimWarp( m_ProcessingElements[ProcessingObjectIndex].MilDest3Buffer, m_ProcessingElements[ProcessingObjectIndex].MilDest2Buffer, m_ProcessingElements[ProcessingObjectIndex].MilCoefficientsBuffer, M_NULL, M_WARP_POLYNOMIAL, M_BILINEAR+M_OVERSCAN_CLEAR); //Make the image brighter to make the result more visible const MIL_INT PixelAdjustmentFactor = 3; MimArith(m_ProcessingElements[ProcessingObjectIndex].MilDest2Buffer, PixelAdjustmentFactor, m_ProcessingElements[ProcessingObjectIndex].MilDest3Buffer, M_MULT_CONST); //Update the warp coefficients UpdateWarpCoefficients(ProcessingObjectIndex); //Copy the result to the display if it is not disabled and Update the information in the display title UpdateDisplay(m_ProcessingElements[ProcessingObjectIndex].MilDest3Buffer); } //***************************************************************************** // UpdateWarpArray. Updates the warp array used for processing. //***************************************************************************** void CMPWarpProcessing::UpdateWarpCoefficients(MIL_INT ProcessingObjectIndex) { m_IncrementCount = (m_IncrementCount+1) % MAX_INCREMENT; //Setup the 4 corners according to the current direction. switch(m_Direction) { case enWarpRight: //Move the top to the right and the bottom towards the left. m_FourCorners[0] += WARP_INCREMENT; m_FourCorners[2] += WARP_INCREMENT; m_FourCorners[4] -= WARP_INCREMENT; m_FourCorners[6] -= WARP_INCREMENT; //Change direction if the increment has reached the maximum m_Direction = (m_IncrementCount==0)?enWarpFront:enWarpRight; break; case enWarpLeft: //Move the top to the left and the bottom to the right m_FourCorners[0] -= WARP_INCREMENT; m_FourCorners[2] -= WARP_INCREMENT; m_FourCorners[4] += WARP_INCREMENT; m_FourCorners[6] += WARP_INCREMENT; //Change direction if the increment has reached the maximum m_Direction = (m_IncrementCount==0)?enWarpBack:enWarpLeft; break; case enWarpFront: //Move the top to the front and the bottom to the back m_FourCorners[0] -= WARP_INCREMENT; if (m_IncrementCount&lt;MAX_INCREMENT/2) m_FourCorners[1] -= WARP_INCREMENT; else m_FourCorners[1] += WARP_INCREMENT; m_FourCorners[2] += WARP_INCREMENT; if (m_IncrementCount&lt;MAX_INCREMENT/2) m_FourCorners[3] -= WARP_INCREMENT; else m_FourCorners[3] += WARP_INCREMENT; m_FourCorners[4] -= WARP_INCREMENT; if (m_IncrementCount&lt;MAX_INCREMENT/2) m_FourCorners[5] += WARP_INCREMENT; else m_FourCorners[5] -= WARP_INCREMENT; m_FourCorners[6] += WARP_INCREMENT; if (m_IncrementCount&lt;MAX_INCREMENT/2) m_FourCorners[7] += WARP_INCREMENT; else m_FourCorners[7] -= WARP_INCREMENT; //Change direction if the increment has reached the maximum m_Direction = (m_IncrementCount==0)?enWarpLeft:enWarpFront; break; case enWarpBack: //Move the top to the back and the bottom to the front m_FourCorners[0] += WARP_INCREMENT; if (m_IncrementCount&lt;MAX_INCREMENT/2) m_FourCorners[1] -= WARP_INCREMENT; else m_FourCorners[1] += WARP_INCREMENT; m_FourCorners[2] -= WARP_INCREMENT; if (m_IncrementCount&lt;MAX_INCREMENT/2) m_FourCorners[3] -= WARP_INCREMENT; else m_FourCorners[3] += WARP_INCREMENT; m_FourCorners[4] += WARP_INCREMENT; if (m_IncrementCount&lt;MAX_INCREMENT/2) m_FourCorners[5] += WARP_INCREMENT; else m_FourCorners[5] -= WARP_INCREMENT; m_FourCorners[6] -= WARP_INCREMENT; if (m_IncrementCount&lt;MAX_INCREMENT/2) m_FourCorners[7] += WARP_INCREMENT; else m_FourCorners[7] -= WARP_INCREMENT; //Change direction if the increment has reached the maximum m_Direction = (m_IncrementCount==0)?enWarpRight:enWarpBack; break; default: break; } //Generate the coefficients buffer for warping GenerateCoefficientsBuffer(ProcessingObjectIndex); } //***************************************************************************** // GenerateCoefficientsBuffer. Generates the coefficients buffer for warping. //***************************************************************************** void CMPWarpProcessing::GenerateCoefficientsBuffer(MIL_INT ProcessingObjectIndex) { MbufPut(m_ProcessingElements[ProcessingObjectIndex].MilFourCornerBuffer, m_FourCorners); MgenWarpParameter(m_ProcessingElements[ProcessingObjectIndex].MilFourCornerBuffer, m_ProcessingElements[ProcessingObjectIndex].MilCoefficientsBuffer, M_NULL, M_WARP_4_CORNER_REVERSE, M_DEFAULT, M_NULL, M_NULL); } ",
      "wordCount": 705
    },
    {
      "id": "Examples_Processing_Optimization_MultiProcessing_CPP_multiprocessing_cpp",
      "version": "2024020714",
      "title": "multiprocessing.cpp",
      "location": "Sample Code from MIL Examples",
      "text": " Top //*************************************************************************** // // File name: Multiprocessing.cpp // Location: See Matrox Example Launcher in the MIL Control Center // // // Synopsis: This example demonstrates the usage of Multiprocessing in MIL. // // Copyright (C) Matrox Electronic Systems Ltd., 1992-2024. // All Rights Reserved #include \"common.h\" //**************************************************************************** // Example description. //**************************************************************************** void PrintHeader() { MosPrintf(MIL_TEXT(\"[EXAMPLE NAME]\\n\") MIL_TEXT(\"Multiprocessing\\n\\n\") MIL_TEXT(\"[SYNOPSIS]\\n\") MIL_TEXT(\"This example demonstrates the usage of multi-processing in MIL.\\n\") MIL_TEXT(\"The menu allows you to interactively modify the number of user processing \\n\") MIL_TEXT(\"threads and the multi-processing controls for each one. This allows for\\n\") MIL_TEXT(\"the comparison of various multi-processing modes.\\n\") MIL_TEXT(\"\\n\\n\") MIL_TEXT(\"[MODULES USED]\\n\") MIL_TEXT(\"Modules used: application, system, display, buffer, graphic,\\n\") MIL_TEXT(\"image processing, multi-processing, multi-threading.\\n\\n\")); } //***************************************************************************** // Main. //***************************************************************************** int MosMain(void) { MIL_INT NumCoresAvailable; CMPMenu* Menu; CMPProcessing** Processing; MIL_TEXT_CHAR Title[STRING_SIZE]; MIL_ID MilApplication; //Allocate MIL objects MappAlloc(M_NULL, M_DEFAULT, &amp;MilApplication); MappInquireMp(M_DEFAULT, M_CORE_NUM_PROCESS, M_DEFAULT, M_DEFAULT, &amp;NumCoresAvailable); //If Multiprocessing is disabled in MILConfig, the number of available cores is 1 if (MappInquireMp(M_DEFAULT, M_MP_FORCED_DISABLE, M_DEFAULT, M_DEFAULT, M_NULL)==M_YES) NumCoresAvailable=1; MosPrintf(MIL_TEXT(\"Multiprocessing:\\n\")); MosPrintf(MIL_TEXT(\"---------------------------------------\\n\\n\")); PrintHeader(); MosPrintf(MIL_TEXT(\"Loading menu...\\n\\n\")); //Allocate the processing objects. There are as many as there are available cores. Processing = new CMPProcessing* [NumCoresAvailable]; const MIL_INT NumberOfProcessingTypes = 2; for (MIL_INT i=0; i&lt;NumCoresAvailable; i++) { MosSprintf(Title, STRING_SIZE, MIL_TEXT(\"Thread %d\"), i); switch (i%NumberOfProcessingTypes) { case 0: Processing[i] = new CMPRotateProcessing(Title, i); break; case 1: default: Processing[i] = new CMPWarpProcessing(Title, i); break; } } //Allocate and run the menu Menu = new CMPMenu(NumCoresAvailable, Processing); Menu-&gt;Run(); //Wait for user input to end the example MosPrintf(MIL_TEXT(\"Press any key to exit.\\n\\n\")); MosGetch(); MosPrintf(MIL_TEXT(\"Ending example...\\n\")); //Free allocated objects delete Menu; for (MIL_INT i=0; i&lt;NumCoresAvailable; i++) { delete Processing[i]; } delete [] Processing; MappFree(MilApplication); return 0; } ",
      "wordCount": 271
    }
  ]
}]
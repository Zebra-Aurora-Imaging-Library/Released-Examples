[{
  "id": "UG_ocr",
  "version": "2024020714",
  "title": "Optical character recognition",
  "subTitles": null,
  "location": "MIL UG P03: 2D processing and analysis",
  "pageURL": "content\\UserGuide\\ocr\\ChapterInformation.htm",
  "text": " Chapter 13: Optical character recognition This chapter presents the features of the Optical Character Recognition (OCR) module, which performs template-based character recognition. MIL OCR module Steps to reading or verifying a string in an image Basic concepts for the MIL OCR module Guidelines for choosing context types General OCR font context type Constrained OCR font context type Switching between the two Deciding which OCR font context type to use OCR font User-defined MIL OCR fonts Existing MIL OCR fonts SEMI fonts Using a SEMI font Creating a SEMI font Quality and scale are important Visualizing Erasing characters Defining the target strings Calibrating your font Automatic font calibration Manual font calibration Setting appropriate processing controls Blanks Broken characters Morphological filtering Thickness and dots Touching characters Specifying other string information Number of strings String lengths Angle Positional variation Constraints Locating your text Determining what is a match Acceptance levels Unrecognized characters Retrieving and analyzing the results A character A string A text Understanding odd results Hooking functions Improving search speed Optical character recognition example ",
  "wordCount": 174,
  "subEntries": [
    {
      "id": "UG_ocr_MIL_OCR_module",
      "version": null,
      "title": "MIL OCR module",
      "subTitles": null,
      "location": "MIL UG P03: 2D processing and analysis",
      "pageURL": "content\\UserGuide\\ocr\\MIL_OCR_module.htm",
      "text": " MIL OCR module Many types of industries require the analysis of character strings in images. For example, the semiconductor industry requires serial numbers, printed on wafers, to be read for tracking purposes. The pharmaceutical industry requires analysis of medicine bottle labels to ensure, for example, that expiry dates are properly printed. The MIL Optical Character Recognition (OCR) module is template-based and provides a powerful and easy to use function set for reading and verifying mechanically generated character strings in 8-bit grayscale images, providing results such as quality (match) scores and validity flags. The module is especially designed to operate on character strings in degraded images, with up to ± 180° of rotation in the target string. The OCR module can be used in conjunction with other MIL functions to develop hardware independent OCR programs for machine vision applications. The module offers the choice of loading a set of grayscale character representations from a MIL font file, or gathering the needed grayscale character representations from image buffers and/or other files to create a MIL font. Each character in the string to be read (target string) is compared to each character representation in this font. The representation with the closest match is chosen and its ASCII value is returned. You can adjust the value at which this match is considered a success by setting the acceptance level. A read operation yields a string of ASCII characters, a confidence score for each character, and its position in the target string, as well as a confidence score for the whole string. A verify operation also provides a validity flag for each character. For applications requiring custom font types, the OCR module supports the creation of custom MIL fonts that can be saved to disk and restored as needed. Two predefined MIL font files are provided to read and verify semiconductor wafer serial numbers of standard SEMI font character types. The module also supports user-specified character constraints, the automatic resizing of a font to better match the target characters (automatic font calibration), and the reading of texts that span multiple lines. To ensure recognition accuracy, checksum calculations are performed when analyzing standard SEMI font character strings. For strings of custom font types, user-defined functions can validate the read character string automatically (for example, using custom checksum functions). Note that if the strings you must read are made up of dot-matrix characters, use the MIL SureDotOCR module. MIL OCR module ",
      "wordCount": 406,
      "subEntries": []
    },
    {
      "id": "UG_ocr_Steps_to_reading_or_verifying_a_string_in_an_image",
      "version": null,
      "title": "Steps to reading or verifying a string in an image",
      "subTitles": null,
      "location": "MIL UG P03: 2D processing and analysis",
      "pageURL": "content\\UserGuide\\ocr\\Steps_to_reading_or_verifying_a_string_in_an_image.htm",
      "text": " Steps to reading or verifying a string in an image The following steps provide a basic methodology for using the MIL Optical Character Recognition module: Create a custom OCR font context using MocrAllocFont() and then use either MocrCopyFont() or MocrImportFont() to add character representations to the OCR font context. If necessary, specify the type of characters (alphabetic, numeric, or other) that should appear at specific positions in the string, using MocrSetConstraint(). With custom fonts, you can hook a custom validation check function to the read/verify operations using MocrHookFunction(). After checking character constraints on a found string, the validity function will be executed. If using an OCR font context allocated for a semi font, checksum calculations are performed automatically. If necessary, adjust general processing controls to fit your application, using successive calls to MocrControl(). Calibrate the OCR font context automatically to match the target image's character size and spacing, using MocrCalibrateFont(). Alternatively, you can set these values manually using MocrControl(). To physically modify the polarity and sizing of the font of an OCR font context, use MocrModifyFont(). Preprocess the OCR font context with MocrPreprocess() once all the constraints and processing controls are set. Allocate a result buffer using MocrAllocResult(). This buffer will be used to store subsequent read or verify result values. Acquire or load a target image. Optionally, limit the area to be read or verified using either a child buffer, allocated using MbufChild...(), or by defining a rectangular M_VECTOR or M_VECTOR_AND_RASTER ROI, set using MbufSetRegion(). In addition, you can improve the quality of the image using the functions of some other MIL module (such as the MIL image processing function MimMorphic() with M_TOP_HAT or M_BOTTOM_HAT). Note that OCR can only process 8-bit unsigned buffers. The cleaner the background of a target image, the better the results of a read/verify operation. Read or verify the string in the target image, using MocrReadString() or MocrVerifyString(), respectively. These functions are performed according to the defined character constraints and processing controls. Obtain the OCR results using MocrGetResult(). Free all your allocated OCR objects using MocrFree(), unless M_UNIQUE_ID was specified during allocation. In general, the first five steps are performed once, while steps 6 to 10 are repeated as required. Since you can save the font calibration results, character constraints, and processing controls with the character representations (with MocrSaveFont() or MocrStream()), steps 1 to 5 can be replaced by a single step which loads an OCR font context from disk using MocrRestoreFont(). Before performing a read/verify operation, if any font-specific control or target constraint changes, the OCR font context should be preprocessed. Use MocrInquire() to establish if the OCR font context requires preprocessing. Steps to reading or verifying a string in an image ",
      "wordCount": 451,
      "subEntries": []
    },
    {
      "id": "UG_ocr_Basic_concepts",
      "version": null,
      "title": "Basic concepts for the MIL OCR module",
      "subTitles": null,
      "location": "MIL UG P03: 2D processing and analysis",
      "pageURL": "content\\UserGuide\\ocr\\Basic_concepts.htm",
      "text": " Basic concepts for the MIL OCR module The basic concepts and vocabulary conventions for the MIL OCR module are: Acceptance level. The user-defined level against which the match score is compared to determine if the match is valid. Character representations. The grayscale bitmap (image) or ASCII representation (drawing) of a character used by MIL OCR. Entire text. One or many strings contained within the target image. Fixed size font. A series of character representations that have same character Y size and character X size. Characters of a fixed size font tend to be all upper-case. Match score. The result of a read/verify operation that shows the level of correlation between the character representations in the OCR font and the characters found within the image, taking into account character constraints. OCR font. The MIL OCR font contains the character representations. OCR font context. A MIL object that stores the OCR font information, target image character size and spacing, constraints, and processing controls. Target string(s). The text to be found within the target image. This can be as little as a single character or multiple lines of characters. Basic concepts for the MIL OCR module ",
      "wordCount": 195,
      "subEntries": []
    },
    {
      "id": "UG_ocr_Guidelines_for_choosing_context_types",
      "version": null,
      "title": "Guidelines for choosing context types",
      "subTitles": [
        "General OCR font context type",
        "Constrained OCR font context type",
        "Switching between the two",
        "Deciding which OCR font context type to use"
      ],
      "location": "MIL UG P03: 2D processing and analysis",
      "pageURL": "content\\UserGuide\\ocr\\Guidelines_for_choosing_context_types.htm",
      "text": " Guidelines for choosing context types An OCR font context is a MIL object that stores the OCR font information, target image character size and spacing, constraints, and processing controls. When allocating your font context (using MocrAllocFont()), you can choose 1 of 2 types: The M_GENERAL OCR font context type. The M_CONSTRAINED OCR font context type. General OCR font context type The M_GENERAL OCR font context type requires less information about the target string but works best on clean target images. If you need to specify the location of the string to eliminate erroneous results, use a child buffer to create a smaller area in which to search, using MbufChild...(). When using an M_GENERAL OCR font context, you should keep in mind the following conditions: The target image should have a clearly visible threshold (binarization) between the characters and their background. The threshold must preserve the shape of the characters. Broken and/or touching characters can degrade the results. A clean background of the target image. The cleaner the background, the better the results of a search. The backgrounds should not have blobs of similar size and intensity as the characters. If you are using clean target images but they are complex, have lighting variations, or require better binarization, you might consider trying the MIL String Reader module, which is more suitable for these cases. Note that under the correct conditions, OCR is typically faster. The following MocrControl() control types are available only when using an M_GENERAL OCR font context: Enabling blank character recognition (use M_BLANK_CHARACTERS). Finding the string length automatically (use M_STRING_CHAR_NUMBER with M_ANY). Finding the character width automatically (use M_TARGET_CHAR_SIZE_X with M_SAME) when using a fixed size font. Finding the character height automatically (use M_TARGET_CHAR_SIZE_Y with M_SAME) when using a fixed size font. Finding the inter-character spacing automatically (use M_TARGET_CHAR_SPACING with M_SAME if it is the same between characters or M_ANY if it differs between characters). An example image best suited to using an M_GENERAL OCR font context is: If your image is greatly degraded or if you know a lot about the location of your target string(s), it is recommended to use the M_CONSTRAINED font context type. Constrained OCR font context type The M_CONSTRAINED OCR font context type works well with degraded target images. This type of context requires more information about the target string, but provides a more robust search. M_CONSTRAINED is best used when all the details are known about the target string. Especially, the more known about the target string's location and the size and spacing of its characters, the better the results of a search. Since more precise information is required to calibrate your font with that of the target string, you can automatically calibrate the font with the target string using MocrCalibrateFont(). Note that the automatic calibration of a font can only be done when using an M_CONSTRAINED OCR font context type. An example image best suited to using an M_CONSTRAINED OCR font context is: If your image contains a string comprised of unevenly spaced characters or a string that has blanks or broken characters, it is recommended to use the M_GENERAL OCR font context type. Switching between the two Defining a good OCR font context takes time. Modifying an existing OCR font context is faster than creating a new OCR font context from scratch. When dealing with two sets of images, for example, with similar OCR font requirements with regards to character representation, but differing in some other aspect (for example, sizing, spacing, processing controls, and/or quality), it might be faster to switch OCR font context types, reset the required constraints and controls, preprocess, and then read the new images. You can switch the type of context using the MocrControl() function with M_CONTEXT_CONVERT. For example, after reading a series of images with an evenly spaced font (depicted below), to read a group of images where the font is not equally spaced, requires a switch from M_CONSTRAINED to M_GENERAL. Note, when you switch between context types, any unsupported setting is reset to its default. Deciding which OCR font context type to use The following decision tree should help you decide when you should use an M_GENERAL or an M_CONSTRAINED OCR font context type. Note that, if a question does not apply to your situation, skip to the next question in the list. Can the target image be thresholded? That is, can a clear distinction be made between the background of the target image and the characters to be read? Yes. Use an M_GENERAL OCR font context. No. Use an M_CONSTRAINED OCR font context. Does the target image have intensity problems; that is, does it have reflections or uneven lighting, or is it so heavily degraded that bits of the string are difficult to read with the naked eye? Yes. Use an M_CONSTRAINED OCR font context. No. Use an M_GENERAL OCR font context. Is the target string made up of characters that vary in size? Does the target string contain variable spacing? Yes. Use an M_GENERAL OCR font context. No. Use an M_CONSTRAINED OCR font context. Note that variable spacing does not include \"jitter\", which refers to tiny variations in the position of the target characters relative to the expected character position. Jitter can be corrected by calibrating your OCR font context (with MocrCalibrateFont()) to match the target string. Set TargetCharSizeXMin and TargetCharSizeYMin to measure to the clearest edge of the target characters to be read. Set TargetCharSizeXMax and TargetCharSizeYMax to measure to the faintest edge of the target character to be read - just before the shading (if any) matches the background color. Are any of the characters to be read broken? When there are broken characters, the best way to determine which OCR font context to use is to try both the M_GENERAL and the M_CONSTRAINED contexts. In a specific situation, one or the other can produce better results. If using an M_GENERAL OCR font context, use MocrControl() with M_BROKEN_CHAR set to M_ENABLE. Are any of the characters to be read touching? When there are touching characters, the best way to determine which OCR font context to use is to try both the M_GENERAL and the M_CONSTRAINED contexts. In a specific situation, one or the other can produce better results. If using an M_GENERAL OCR font context, use MocrControl() with M_TOUCHING_CHAR set to M_ENABLE. If your answers were a combination of both M_GENERAL and M_CONSTRAINED OCR font contexts, use the OCR font context most often recommended. You will have to further manipulate your target image, or your OCR font (mostly using MocrControl()), to improve results. Guidelines for choosing context types General OCR font context type Constrained OCR font context type Switching between the two Deciding which OCR font context type to use ",
      "wordCount": 1121,
      "subEntries": []
    },
    {
      "id": "UG_ocr_OCR_font",
      "version": null,
      "title": "OCR font",
      "subTitles": [
        "User-defined MIL OCR fonts",
        "Existing MIL OCR fonts",
        "SEMI fonts",
        "Using a SEMI font",
        "Creating a SEMI font",
        "Quality and scale are important",
        "Visualizing",
        "Erasing characters"
      ],
      "location": "MIL UG P03: 2D processing and analysis",
      "pageURL": "content\\UserGuide\\ocr\\OCR_font.htm",
      "text": " OCR font You must specify the MIL OCR font to read/verify the character strings in target images. MIL uses fonts (or typesets) to specify the style and size of characters in the images to be read or verified. An OCR font contains the following information: The grayscale representations of the characters. Codes identifying each character (ASCII codes for the characters). The number of characters in the OCR font. Character dimensions. The above information can be calibrated (with MocrCalibrateFont() or MocrControl()), modified (with MocrModifyFont()), and saved (with MocrSaveFont()) for later restoration. User-defined MIL OCR fonts Unless using one of the two provided predefined OCR fonts, you must define a custom OCR font. You can create a user-defined OCR font from scratch, or make minor modifications to an existing OCR font, already saved to disk. To create a custom font: Allocate an OCR font context, using MocrAllocFont(). When allocating an OCR font context, you must specify the maximum number of characters that can be stored in the font, and the dimensions of the font's character representations and their character cells. Grab/create the grayscale character representations of the font in a MIL image buffer and then copy them from the image buffer to the OCR font context, using MocrCopyFont(). Alternatively, you can import grayscale character representations from a text file or an image file (for example, a TIFF) into an OCR font context using MocrImportFont(). You can use the MIL OCR Reader utility or an interactive graphics tool, such as Matrox Inspector, to create new characters to add to an existing font. When importing, or copying, character representations to the OCR font context, the OCR font context must have sufficient space to hold the representations of all the specified characters. You can use MocrInquire() to determine the maximum number of characters that can be stored in the font and the size of each character. Once copied or imported into an OCR font context, the entire OCR font context can be saved on disk using MocrSaveFont(), and then later restored using MocrRestoreFont(). The following is an example of a character in its MIL OCR font character cell and the dimensions that you will have to specify during OCR font context allocation. Values are to be specified in pixels. Each square in the grid represents one pixel. The parameters CharCellSizeX, CharCellSizeY, CharOffsetX, CharOffsetY, CharSizeX, and CharSizeY of MocrAllocFont() must comply with the following restrictions: 2* CharOffsetX + CharSizeX &lt;= CharCellSizeX. 2* CharOffsetY + CharSizeY &lt;= CharCellSizeY. CharCellSizeY, CharCellSizeX, CharSizeY, CharSizeX must be &gt;= 6 pixels and &lt;= 256 pixels. When the characters in a font do not have a uniform width or height, CharSizeX should specify the width of the widest character in the font and CharSizeY should specify the height of the tallest character in the font. Also, to be able to search for a string over a range of angles, the font context's character size must be greater than 16x16. You can use the MIL OCRReader utility, or an interactive graphics tool, such as Matrox Inspector, to determine font character widths and heights. When copying the character representations from an image buffer, or importing them from an image file, the characters must have the dimensions specified during OCR font context allocation. The following is an example of how to create a user-defined MIL OCR font using a font definition image and MocrCopyFont(). In this case, the CharImageForFontDefinition.mim file contains the grayscale character representations. The image is loaded into an image buffer and then the character representations are copied to an allocated OCR font context using MocrCopyFont(). /* Define a font from an image using MocrCopyFont */ MIL_ID TheFontDefinitionImage; MbufRestore(MIL_TEXT(\"CharImageForFontDefinition.mim\"), MilSystem, &amp;TheFontDefinitionImage); MIL_ID TheFont; /* Allocate an OCR font context */ MocrAllocFont(MilSystem, M_DEFAULT, 6, 21, 33, 3, 3, 15, 27, 3, 6, M_FOREGROUND_BLACK, &amp;TheFont); /* Copy font characters from the image to the font context */ MocrCopyFont(TheFontDefinitionImage, TheFont, M_COPY_TO_FONT, MIL_TEXT(\"ABC123\")); /* Save the OCR font context to disk */ MocrSaveFont(MIL_TEXT(\"TheFontMocrCopyFont.mfo\"), M_SAVE, TheFont); MocrFree(TheFont); MbufFree(TheFontDefinitionImage); The following is an example of how to create a user-defined MIL OCR font directly from a font definition image file, using MocrImportFont(). In this case, the CharImageForFontDefinition.mim file contains the grayscale character representations. which are imported into an allocated OCR font context using MocrImportFont(). MocrImportFont() imports into an allocated OCR font context. /* Define a font directly from an image file using MocrImportFont */ MIL_ID TheFont; /* Allocate an OCR font context */ MocrAllocFont(MilSystem, M_DEFAULT, 6, 21, 33, 3, 3, 15, 27, 3, 6, M_FOREGROUND_BLACK, &amp;TheFont); /* Import character representations from the font definition image */ MocrImportFont(MIL_TEXT(\"CharImageForFontDefinition.mim\"), M_MIL_TIFF, M_LOAD_CHARACTER, MIL_TEXT(\"ABC123\"), TheFont); /* Save the OCR font context to disk */ MocrSaveFont(MIL_TEXT(\"TheFontMocrImportFont.mfo\"), M_SAVE, TheFont); MocrFree(TheFont); When importing the character representations from an ASCII file, font character representations must be presented as follows: Note that in this format, 'pixels' are delimited by a blank space. So '00' counts as one pixel. This information breaks down into the following: Row Description 01 Specifies ASCII file format. 02 Blank row. 03 Specifies the start of a new character representation and its associated (generally ASCII) character. 04 to 36 Specifies the alpha-numerical representation of the character. 37 Blank row. 38 Specifies the start of a new character representation and its associated (generally ASCII) character. 39 to 71 Specifies the alpha-numerical representation of the character. etc. This pattern is repeated for every character in the font. The following is an example of how to create a user-defined MIL OCR font using character representations from an ASCII file, using MocrImportFont(). In this case, the AsciiFileForFontDefinition.txt file contains the ASCII character representations, in the format above. The character representations are imported into an allocated OCR font context using MocrImportFont(). /* Define a font from an ASCII file using MocrImportFont */ MIL_ID TheFont; /* Allocate an OCR font context */ MocrAllocFont(MilSystem, M_DEFAULT, 6, 21, 33, 3, 3, 15, 27, 3, 6, M_FOREGROUND_BLACK, &amp;TheFont); /* Import character representations from the font definition ASCII file */ MocrImportFont(MIL_TEXT(\"AsciiFileForFontDefinition.txt\"), M_FONT_ASCII, M_LOAD_CHARACTER, M_NULL, TheFont); /* Save the OCR font context to disk */ MocrSaveFont(MIL_TEXT(\"TheFontMocrImportFromASCIIFile.mfo\"), M_SAVE, TheFont); MocrFree(TheFont); Existing MIL OCR fonts Once created, a MIL OCR font can be saved and restored as needed. Restoring this information (using MocrRestoreFont()) rather than creating the MIL OCR font from scratch saves time, especially if the restored font requires no further modifications. Note that the entire OCR font context is restored when restoring the font using MocrRestoreFont(). MIL comes with three predefined Semi fonts; for more information, see the next subsection. SEMI fonts MIL OCR comes with two ISO compatible SEMI fonts (M_SEMI_M12_92 or M_SEMI_M13_88) and one generic SEMI font that has no constraints and no checksum (SEMI.mfo). These can be used directly or modified to suit your needs. Using a SEMI font To use a SEMI font directly, restore it using MocrRestoreFont() with the FileName parameter set to \"SEMI_M12-92.mfo\", \"SEMI-M13-88.mfo\", or \"SEMI.mfo\". These files are located in directory \"\\contexts\\\" under the MIL installation folder. Once restored, the font can be modified using the MIL OCR functions. Creating a SEMI font To create a new font based on a SEMI font: Create an OCR font context using MocrAllocFont() with: The FontType parameter set to either M_SEMI_M12_92 or M_SEMI_M13_88. The StringLength parameter set to 12 when using M_SEMI_M12_92 and 18 when using M_SEMI_M13_88. The CharNumber parameter set to 38. This allows for capital letters (A-Z), digits (0-9), hyphen (-), and period (.). Use either MocrCopyFont() or MocrImportFont() to add character representations from an existing SEMI font. Quality and scale are important Using high-quality character representations will produce the best results. OCR processing relies on using the cleanest font characters possible. When using an M_GENERAL OCR font context, broken characters and spaces, even if expected in the target string, should not be defined in the font. Instead, you should enable the ability to read broken characters using MocrControl() with M_BROKEN_CHAR, and/or enable the ability to read spaces using MocrControl() with M_BLANK_CHARACTERS. When using an M_GENERAL font context type, the threshold between the characters and the background must preserve the shape of the characters and have a clearly-visible point of differentiation (binarization). If the characters in the target image are brighter than the background (for example, white on black), then the character representations included in your font must also be of characters that are brighter than the background. The foreground is specified at context allocation time (MocrAllocFont()) and can be changed later using MocrModifyFont() with M_INVERT. This changes both the character representations and the setting specified at allocation time. If the size of the character representations in the font is not the same as those in the target string, you can calibrate the font (discussed later). Alternatively, when the physical size of the character representations of the OCR font differ from those in the target image, changing the size of the character representations of the OCR font could improve the robustness of the search. To change the size, use MocrModifyFont() with M_RESIZE. Changing the size of the font permanently in the OCR font can be faster than resizing the font before each read/verify operation, as is done when the font is calibrated. Visualizing It might be necessary, at some point during application development, to display the character representations of your MIL OCR font. To do so, use MocrCopyFont() to copy the character representations to a displayable image buffer. Erasing characters To remove a character from the OCR font, use MocrControl() with M_CHAR_ERASE and specify the ASCII code associated with the character representation to remove. An OCR font can contain a limited number of characters; this number is set during OCR font context allocation. Removing unused or erroneously added characters is the easiest way to assure that these characters will not be used when looking for matches in the target string and that there is space for new characters to be added. OCR font User-defined MIL OCR fonts Existing MIL OCR fonts SEMI fonts Using a SEMI font Creating a SEMI font Quality and scale are important Visualizing Erasing characters ",
      "wordCount": 1662,
      "subEntries": []
    },
    {
      "id": "UG_ocr_Defining_the_target_string",
      "version": null,
      "title": "Defining the target strings",
      "subTitles": [
        "Calibrating your font",
        "Automatic font calibration",
        "Manual font calibration",
        "Setting appropriate processing controls",
        "Blanks",
        "Broken characters",
        "Morphological filtering",
        "Thickness and dots",
        "Touching characters",
        "Specifying other string information",
        "Number of strings",
        "String lengths",
        "Angle",
        "Positional variation",
        "Constraints"
      ],
      "location": "MIL UG P03: 2D processing and analysis",
      "pageURL": "content\\UserGuide\\ocr\\Defining_the_target_string.htm",
      "text": " Defining the target strings Define the target strings in the following ways: Calibrating your font helps to match the characters in the target image to those within the MIL OCR font. Setting the appropriate processing controls and string information helps better define the search criteria for best results. Constraints allow you to limit the search to specific characters within the MIL OCR font. Calibrating your font You should either manually or automatically calibrate your MIL OCR font to better match the size of the characters and the inter-character spacing in the target image. The more MIL OCR knows about your target image, the faster it can search for the required string(s) and the more robust the results. Note that in some cases, it might be more efficient to change the size of the actual font than to calibrate. Automatic font calibration Automatic font calibration is only available when you are using an M_CONSTRAINED OCR font context. Use MocrCalibrateFont() with a small, given range of sizes in which to search, and it will test all the possible sizes in that range, returning the best match of the width, the height, and the spacing of the characters in your sample target image. The sample target image should be the best possible image with an angle, string length, and number of strings that are representative of the target images. Automatic font calibration is always performed using only the first string with the highest match score found in the sample target image. To calibrate multiple strings, create a child buffer around each. If the string cannot be located in the image, an error is generated. Skipping the string locator step (using MocrControl() with M_SKIP_STRING_LOCATION) might produce undesirable results. This is discussed later in this chapter. When you are dealing with long strings, the spacing in your target image should be as accurate as possible. Automatic font calibration resets values set during a manual font calibration. Manual font calibration Manual font calibration can be done for either M_GENERAL or M_CONSTRAINED OCR font context types. With an M_GENERAL OCR font context type, manual font calibration does not require exact numbers. Use MocrControl() to manually set the width (M_TARGET_CHAR_SIZE_X), the height (M_TARGET_CHAR_SIZE_Y), and spacing (M_TARGET_CHAR_SPACING) of the target image characters, in pixels. If the exact measurements are known, manually setting the size of the target characters is faster than an automatic font calibration. When using an M_GENERAL OCR font context with a fixed size font and reading a string that has the same spacing between characters, but the size of the spacing is unknown, use MocrControl() with M_TARGET_CHAR_SPACING set to M_SAME. If the spacing is unknown and/or not the same between characters, use MocrControl() with M_TARGET_CHAR_SPACING set to M_ANY. Note that the scale factors between target character sizes and font character sizes must be between 0.25 and 4.0, inclusive. The following restrictions apply: TargetCharSizeXMin /( CharSizeX ) &gt;= 0.25. TargetCharSizeYMin /( CharSizeY ) &gt;= 0.25. TargetCharSizeXMax /( CharSizeX ) &lt;= 4.0. TargetCharSizeYMax /( CharSizeY ) &lt;= 4.0. Setting appropriate processing controls Each of the following controls can improve the robustness of the search. Note, however, that these controls increase the complexity of the operation and reduce its overall speed. Blanks By default, MIL OCR ignores blanks in the target image. When using an M_GENERAL OCR font context type, you can use MocrControl() with M_BLANK_CHARACTERS to enable the ability to read blank characters. Blank characters should not be included in your MIL OCR font. Once enabled, you must modify your string length to include the number of blanks that you expect in the target image. Blanks before the target string are not counted. A blank space will have the same size and inter-character spacing as all other characters in the MIL OCR font, unless M_TARGET_CHAR_SPACING is set to M_ANY. Note that M_BLANK_CHARACTERS is available only when using an M_GENERAL OCR font context. In addition, blank characters cannot be verified (using MocrVerifyString()) and will cause a MIL error. Broken characters If the target image contains characters that contain scratches or breaks, the target image contains a broken character. To force MIL OCR to identify these characters as a possible match of the characters within the MIL OCR font, use MocrControl() with M_BROKEN_CHAR enabled. This will reduce the speed of subsequent read/verify operations but can increase robustness. Broken characters should not be included in a MIL OCR font. Note that, when using an M_GENERAL OCR font context, M_BROKEN_CHAR must be enabled to read a broken character. In an M_CONSTRAINED OCR font context, MIL OCR will automatically try to identify broken characters. Morphological filtering When the difference between the foreground and the background is so slight that it causes read or verification errors, increase or decrease the value for morphological filtering, using MocrControl() with M_MORPHOLOGIC_FILTERING, to improve MIL OCR's chances of finding and identifying the characters within the target string. Experimentation is required to determine the exact number that should be passed to this control. Thickness and dots You can thicken the target characters using MocrControl() with M_THICKEN_CHAR when reading thin characters made up of dots to make the characters easier to find and identify. Touching characters If characters in the target image touch each other, or if they are connected to blobs of a similar intensity, enable touching characters, using MocrControl() with M_TOUCHING_CHAR. This will improve MIL OCR's chances of finding and identifying these characters. This will reduce the speed of subsequent read/verify operations but can increase robustness. Note that, when using an M_GENERAL OCR font context, M_TOUCHING_CHAR must be enabled to read touching characters. When using an M_CONSTRAINED OCR font context, MIL OCR will automatically try to identify touching characters. Specifying other string information In some cases, additional information about the target string is required. For example, to search for multiple strings, or to search at an angle, certain control types should be set. In other cases, additional information will increase the robustness of the search. Number of strings You can set the search to find multiple strings using MocrControl() with M_STRING_NUMBER. Multiple strings can only be found if each string resides on a different line within the target image and each line of text does not overlap the previous. Note that, for best results, all strings in an image should be of similar length, have a consistent inter-line spacing, and should start at a similar location along the X-axis. Identifying the number of strings to read/verify is important when dealing with a target image containing multiple lines. It does not have to be specified for single-string images since the default value is 1. String lengths You should specify the length of the strings to be read, to receive reliable results using MIL OCR. The maximum string length must be set at the time of OCR font context allocation. With an M_GENERAL OCR font context type, the maximum string length can be set to M_ANY. Note, however, that this increases the processing time since the OCR module must then try to calculate the string length based on successful matches between the target image and the MIL OCR font. The default string length is set to the maximum string length of the OCR font context. When the OCR font context constraints are set (discussed later), specifying a string length can also improve the speed of a following read/verify operation. Note that if M_SEMI_M12_92 is used, the string length must be 12. If M_SEMI_M13_88 is used, the string length must be 18. If the entire text of the target image contains one or more strings that differ significantly in length, use an M_GENERAL OCR font context for fast results. For more robust results, allocate separate M_CONSTRAINED OCR font contexts for each line of text to be read/verified. Experimentation with both OCR font context types is the only way to determine which provides the best solution for each case. Often, when using an M_CONSTRAINED OCR font context, errors in string length result in unpredictable results. Angle You can search for the strings within the target image at a specific angle, or through an angular range. The angle of the search is used to locate the string or strings before a read/verify operation. If individual lines in the target image are set at different angles, create a child buffer containing each string at a different angle and read them using a different OCR font context. These child buffers should not overlap. For each OCR font context, you can specify the nominal angle of the search using MocrControl() with M_STRING_ANGLE. By default, the search angle is 0.0°. To search through an angular range, use MocrControl() with M_STRING_ANGLE_DELTA_POS to specify the positive range and/or M_STRING_ANGLE_DELTA_NEG to specify the negative range in which to search. A search for a string within the target image through an angular range always starts at the nominal angle of the string, specified with M_STRING_ANGLE. Note that the range in which to search, either in the positive or negative direction, should never be greater than 180°. If you were searching for a string at approximately 25°, you might want to search between 40° and 10°. To do this, you would set M_STRING_ANGLE to 25°, and both M_STRING_ANGLE_DELTA_POS and M_STRING_ANGLE_DELTA_NEG to 15°. This results in a 30° arc that will be searched for your string. Searching through a range of angles is enabled only if at least one of the M_STRING_ANGLE_DELTA... control types are set to a value greater than or equal to 1°. Once enabled, the font context's character size must be greater than 16x16 to avoid a MIL error when calling MocrReadString(), MocrVerifyString() or MocrCalibrateFont(). Note that, after setting M_STRING_ANGLE..., you must call MocrPreprocess() before calling MocrReadString() or MocrVerifyString(). Positional variation If the inter-character spacing is not even, you can increase the robustness of the search by specifying the maximum variation in position of the characters. The position variation increases the area being searched for characters within the target image (using MocrControl() with M_CHAR_POSITION_VARIATION_X and M_CHAR_POSITION_VARIATION_Y). These values are relative to the expected position of each character. Constraints The read operation compares each character in the target image to each character in the font to find the best match. You might know beforehand that certain characters (or types of characters) should appear at specific positions in the string. If this is the case, you can speed up and increase the robustness of the read operation by restricting the comparison to only those characters in the font. The following types of constraints can be set for each character in the string, using MocrSetConstraint(): A digit (M_DIGIT): ASCII codes 48 to 57. A letter (M_LETTER): ASCII codes 65 to 90 and 97 to 122. An uppercase letter (M_LETTER + M_UPPERCASE): ASCII characters 65 to 90. A lowercase letter (M_LETTER + M_LOWERCASE): ASCII characters 97 to 122. A character from a specific list of characters, for example A, 1, b, 2. This includes special characters and punctuations, for example ampersand (&amp;), hyphen (-), ellipsis (...). Note that MIL OCR will search for the number of characters specified by the target string length. For best results, the number of characters to be found in your target image should match your string length. The constraints are stored with the OCR font context as part of its information set and can be inquired, using MocrInquire(). The following is an example of how character constraints are set. For example, the character in the first position should be the letter K and the character in the second position should be any upper or lowercase letter. /* Set character constraints for each position of the string to read. */ MocrSetConstraint(OcrFont, 0, M_LETTER, MIL_TEXT(\"K\")); /* Must be K. */ MocrSetConstraint(OcrFont, 1, M_LETTER, M_NULL); /* Any letter. */ MocrSetConstraint(OcrFont, 2, M_DIGIT, M_NULL); /* Any digit. */ MocrSetConstraint(OcrFont, 3, M_DIGIT, MIL_TEXT(\"12\")); /* Must be 1 or 2. */ MocrSetConstraint(OcrFont, 4, M_DIGIT, M_NULL); /* Any digit. */ MocrSetConstraint(OcrFont, 5, M_DEFAULT,M_NULL); /* Any character. */ Defining the target strings Calibrating your font Automatic font calibration Manual font calibration Setting appropriate processing controls Blanks Broken characters Morphological filtering Thickness and dots Touching characters Specifying other string information Number of strings String lengths Angle Positional variation Constraints ",
      "wordCount": 2023,
      "subEntries": []
    },
    {
      "id": "UG_ocr_Locating_your_text",
      "version": null,
      "title": "Locating your text",
      "subTitles": null,
      "location": "MIL UG P03: 2D processing and analysis",
      "pageURL": "content\\UserGuide\\ocr\\Locating_your_text.htm",
      "text": " Locating your text MIL OCR tries to locate the strings to read/verify automatically. Both the angle of the string and the string length information are used to perform the location. Under the appropriate conditions, the location step can be skipped to improve the speed of a read/verify operation, using MocrControl() with M_SKIP_STRING_LOCATION. When using an M_CONSTRAINED OCR font context, you can only skip the location step if you create a child buffer that contains only the target string and a minimum amount of space around it. Use other modules in MIL to determine the required buffer size. For more information, refer to the Using child buffers, ROIs, or a copy to manipulate specific data areas section of Chapter 23: Data buffers. When using an M_GENERAL OCR font context, string location can be skipped if you are using a clean target image. If results are unsatisfactory, the image might need further processing, such as using MimMorphic() with M_TOP_HAT or M_BOTTOM_HAT. For more information, refer to the Top and bottom hat subsection of the Custom morphological operations section of Chapter 4: Advanced image processing. Locating your text ",
      "wordCount": 187,
      "subEntries": []
    },
    {
      "id": "UG_ocr_Determining_what_is_a_match",
      "version": null,
      "title": "Determining what is a match",
      "subTitles": [
        "Acceptance levels",
        "Unrecognized characters"
      ],
      "location": "MIL UG P03: 2D processing and analysis",
      "pageURL": "content\\UserGuide\\ocr\\Determining_what_is_a_match.htm",
      "text": " Determining what is a match You can control what is considered a match between characters in an image and the provided OCR font context by adjusting acceptance levels. A character must meet a specified acceptance level to be considered a recognized character. If a character is unrecognized, a symbol can be returned at the position of the unrecognized character in the string. Acceptance levels You can set the acceptance level of a successful read/verify operation: For each character (MocrControl() with M_CHAR_ACCEPTANCE). If the correspondence (also known as the match score) between a character in an image and a character and its constraints in an OCR font context is less than the specified acceptance level, that character is considered invalid and the associated validity flag for that character is set to false. For the entire string of characters and the entire text (MocrControl() with M_STRING_ACCEPTANCE). If the match score for the entire string passes the acceptance level set for the string, the string is considered valid and its validity flag is set to true. The match score for the entire string is determined by taking the average of the match scores for all characters in that string. The match score for the entire text is the average of the match scores for all the read/verified strings. A perfect match has a match score of 100%, and no correlation has a match score of 0%. If your images have a lot of noise or distortion, set a lower acceptance level. Poor-quality images increase the chance of false readings and will probably increase the time required to read/verify the character. Perfect matches are highly improbable due to noise obtained during image acquisition. Unrecognized characters You can specify the symbol for unrecognized (or invalid) characters (MocrControl() with M_CHAR_INVALID). If a character's match score does not reach the specified acceptance level, you can force a specified symbol to be returned at that position in the string. If no symbol is specified (default), the character with the closest match will be returned. For example: Target string: \"HELLO\" Invalid character: \"*\" Acceptance level: 30% 30% 30% 30% 30% Match scores: 70% 15% 53% 24% 80% Result: H*L*O Since the match scores of the characters in the second and fourth positions are less than the specified acceptance level, these characters are replaced by asterisks in the result. Determining what is a match Acceptance levels Unrecognized characters ",
      "wordCount": 400,
      "subEntries": []
    },
    {
      "id": "UG_ocr_Retrieving_and_analyzing_the_results",
      "version": null,
      "title": "Retrieving and analyzing the results",
      "subTitles": [
        "A character",
        "A string",
        "A text",
        "Understanding odd results",
        "Hooking functions"
      ],
      "location": "MIL UG P03: 2D processing and analysis",
      "pageURL": "content\\UserGuide\\ocr\\Retrieving_and_analyzing_the_results.htm",
      "text": " Retrieving and analyzing the results After having potentially located the string in your target image using MocrReadString() or MocrVerifyString(), you can extract the required results from your result buffer using MocrGetResult(). All OCR results are based on the concept of a character. A string is a group of characters that reside along the same line along the same principal axis and the same angle. Multiple strings are a group of strings that are to be read together. Results are returned in the order in which they are read/verified, from left to right. Always check the validity of the string to ensure that the match score is greater than or equal to the acceptance level, using MocrGetResult() with M_STRING_VALID_FLAG. Additional checks against the actual length read and the intended length could be made to assure accuracy. Invalid characters in the resulting strings can be replaced with an ASCII character using MocrControl() with M_CHAR_INVALID. Note that this control type must be set before performing the read/verify operation. A character Character data is returned for each character in the string or strings. This data includes: Position along the X- and Y-axis. The height and width of the character. The match score of the character. The spacing of the character. The validity of the character (based on the character's acceptance level). The ASCII version of the character. A string String data is returned for each string. String data includes: The contents of the string. The angle of the string. The length of the string. The match score of the string. The validity of the string (based on the string's acceptance level). A text When reading/verifying multiple strings, text data is returned for all the strings. The text data includes: All the characters read, even if they are on different lines in the target image. The number of characters read in total. The match score for the entire text. The threshold value used to binarize the target image. Note that this is only available when using an M_GENERAL OCR font context, multiple strings, and/or the string has a few degrees of rotation. All the results for a single string are also available for each string in the entire text. Understanding odd results Unexpected results can come from one of the following scenarios. If characters are vertically overlapping (or touching). Create a child buffer that contains the characters below the point where they overlap. This effectively removes the overlapping portion of the characters. The more that characters overlap vertically, the less chance for a valid result. To read a target image containing multiple lines of text, MIL OCR requires that there is enough space between lines. If lines are too close together (vertically), the robustness of the search will suffer. Use MocrControl() with M_TOUCHING_CHAR to read horizontally touching characters. If the string or strings have non-uniform inter-character spacing. Read/verify the string with an M_GENERAL OCR font context type and use MocrControl() with M_TARGET_CHAR_SPACING set to M_ANY. This setting is best suited to read non-uniformly spaced characters. Create a child buffer to contain the most extreme spacing examples for best results. If the string or strings in the target image are greatly disparate. Create a child buffer for each different region in position, angle, and/or length. Read each region individually for best results. The more similar the strings in angle, position, and length, the faster and more robust the search. If the spacing, length or angle differ, use different MIL OCR font contexts for each child buffer, with their operational and processing controls configured appropriately for each situation. For more information, see the Defining the target strings section earlier in this chapter. If the target image contains multiple lines with different lengths. Create a child buffer that contains the area with the shorter strings and read the shorter strings, using a different OCR font context, into a different OCR result buffer. Strings of similar length are easiest to locate. Make sure that the target image has a consistent inter-line spacing, and that all lines start at a similar location along the X-axis, for best results. If the target image contains blanks. Verify that your string length is correct. Your string length determines the number of characters sought. If the problem persists and the ability to read blank spaces is enabled (use MocrControl() with M_BLANK_CHARACTERS) remember to include them in your string length (use MocrControl() with M_STRING_CHAR_NUMBER). If the target image contains a lot of non-character blobs. Try to improve your target image before trying to read/verify again. For more information, see the Defining the target strings section earlier in this chapter. An image that does not include blobs of equal intensity as the foreground will return best results. Use MocrControl() with M_MORPHOLOGIC_FILTERING to internally enhance the contrast of the image. If the target image contains a string longer or shorter than what was expected. MIL OCR will try to return the number of characters that you set as existing in the target image using MocrControl() with M_STRING_CHAR_NUMBER. If your string length is set to a value larger than the actual length of the string in the target image, and if using M_GENERAL OCR font context, MIL will return the best matches found and stop searching after it has found the specified number of characters. If using an M_CONSTRAINED OCR font context, the string length determines the exact number of characters found, even if this means returning characters with low match scores. If the target string is at an angle. Verify that the principal axis of the entire text is equal to the expected angle (nominal angle), specified using MocrControl() with M_STRING_ANGLE. A string at an angle not equal to 0 takes longer to find. Create a target image with a string angle of 0. If the string is properly read, your original application did not follow the expected use of string angle. Hooking functions MIL OCR allows you to attach or detach a user-defined function to a MIL OCR event when the specified OCR font context is used. This can be used to impose global string constraints, and can be used to implement custom checksum functions or to reject strings that would have otherwise met the character constraints imposed. Once your user-defined function is created, use MocrHookFunction() to attach it to the validation of a string. It will then execute during the last stage of either MocrReadString() or MocrVerifyString(). When MocrHookFunction() is used in conjunction with an M_SEMI... OCR font context type, the function being hooked will replace the default validation function. Retrieving and analyzing the results A character A string A text Understanding odd results Hooking functions ",
      "wordCount": 1103,
      "subEntries": []
    },
    {
      "id": "UG_ocr_Improving_search_speed",
      "version": null,
      "title": "Improving search speed",
      "subTitles": null,
      "location": "MIL UG P03: 2D processing and analysis",
      "pageURL": "content\\UserGuide\\ocr\\Improving_search_speed.htm",
      "text": " Improving search speed To ensure the fastest possible read or verify operation: Use as clean a target image as possible when using an M_GENERAL OCR font context. Calibrate the OCR font context's character size and target spacing, to match the characters in the target images. Preprocess once all the processing controls and constraints are set and before the application's first read/verify operation. Reduce the area to read/verify in the target image by creating a child buffer around the target string using MbufChild...(); the search time is roughly proportional to the area searched. Set character constraints using MocrSetConstraint(). Skip the location step, when possible. Set the speed and reliability of the algorithm by setting the robustness factor (MocrControl() with M_SPEED). For instance, when reading larger characters, robustness can be sacrificed for speed. Disable the M_BLANK_CHARACTERS, M_BROKEN_CHAR, and M_TOUCHING_CHAR control types unless absolutely necessary. Adjust your image to minimize the angular search range of the read/verify operation. The more you know about the target image, the faster it can be read/verified. This includes: Knowing where the string is located within the target image. Knowing the height, width, and the inter-character spacing of the string within the target image. Knowing the exact number of lines to be read from the target image. Knowing the exact string length or at least that all the strings are of similar length. Having good examples of each character to be found in the target image so a high-quality MIL OCR font can be made. MIL OCR can help determine some of this information, for example, MocrCalibrateFont() can automatically calibrate the OCR font context's character size to match the characters in the sample target image, and the string location step with MocrControl() can find a string within the image, barring any problems. Improving search speed ",
      "wordCount": 299,
      "subEntries": []
    },
    {
      "id": "UG_ocr_Optical_character_recognition_examples",
      "version": null,
      "title": "Optical character recognition example",
      "subTitles": null,
      "location": "MIL UG P03: 2D processing and analysis",
      "pageURL": "content\\UserGuide\\ocr\\Optical_character_recognition_examples.htm",
      "text": " Optical character recognition example The Optical Character Recognition example, MOcr.cpp illustrates how the module can be used with the following source image: Specifically, MOcr.cpp shows how to read the serial number in an image of a semiconductor wafer, using the OCR functions in conjunction with other MIL functions. The serial number, printed on the wafer, is a standard SEMI M12 92 font character string, containing a checksum. mocr.cpp To run this example, use the Matrox Example Launcher in the MIL Control Center. Optical character recognition example ",
      "wordCount": 88,
      "subEntries": []
    }
  ]
}]
[{
  "id": "Example_PlaceHolder_ID",
  "version": "2024020714",
  "title": "Example_PlaceHolder_Title",
  "wordCount": 0,
  "subEntries": [
    {
      "id": "Examples_Processing_3dMatching_SurfaceDefectDetection_CPP_draw_cpp",
      "version": "2024020714",
      "title": "draw.cpp",
      "location": "Sample Code from MIL Examples",
      "text": " Top //***************************************************************************************/ // // File name: Draw.h // Location: See Matrox Example Launcher in the MIL Control Center // // // Synopsis: Utility functions for the display. These are not necessary for the example. // // Copyright (C) Matrox Electronic Systems Ltd., 1992-2024. // All Rights Reserved //***************************************************************************************/ #include \"DefectDetection.h\" //**************************************************************************** // Constants. //**************************************************************************** // Display. static const MIL_INT64 BOX_COLOR = M_COLOR_YELLOW; static const MIL_INT64 DISTANCE_TO_MODEL_COLOR = M_COLOR_BLUE; static const MIL_INT64 DISTANCE_TO_OCCURRENCE_COLOR = M_COLOR_CYAN; static const MIL_INT64 DEFECT_MISSING_COLOR = M_COLOR_RED; static const MIL_INT64 DEFECT_EXTRA_COLOR = M_COLOR_DARK_RED; //**************************************************************************** // Draw a plane but with a larger clipping box. //**************************************************************************** MIL_INT64 DrawBackgroundPlane(MIL_ID Plane, MIL_ID GraList, MIL_INT64 Parent, MIL_DOUBLE Scale = 2) { auto ClippingBox = M3dgeoAlloc(M_DEFAULT_HOST, M_GEOMETRY, M_DEFAULT, M_UNIQUE_ID); M3dgraCopy(GraList, M_LIST, ClippingBox, M_DEFAULT, M_BOUNDING_BOX, M_DEFAULT); M3dimScale(ClippingBox, ClippingBox, Scale, Scale, Scale, M_GEOMETRY_CENTER, M_DEFAULT, M_DEFAULT, M_DEFAULT); M3dgraCopy(ClippingBox, M_DEFAULT, GraList, M_LIST, M_CLIPPING_BOX, M_DEFAULT); return M3dgeoDraw3d(M_DEFAULT, Plane, GraList, Parent, M_DEFAULT); } //**************************************************************************** // Model draw. //**************************************************************************** MIL_INT64 SModel::Draw(MIL_ID GraList, MIL_INT64 Parent) const { auto Node = M3dgraNode(GraList, Parent, M_DEFAULT, M_DEFAULT); M3dgraAdd(GraList, Node, Container, M_DEFAULT); auto BoxLabel = M3dgeoDraw3d(M_DEFAULT, Box, GraList, Node, M_DEFAULT); M3dgraControl(GraList, BoxLabel, M_APPEARANCE, M_WIREFRAME); M3dgraControl(GraList, BoxLabel, M_COLOR, BOX_COLOR); return Node; } //**************************************************************************** // Context draw. //**************************************************************************** MIL_INT64 SContext::Draw(MIL_ID GraList, MIL_INT64 Parent) const { auto Node = M3dgraNode(GraList, Parent, M_DEFAULT, M_DEFAULT); for(const auto&amp; Model : Models) Model.Draw(GraList, Node); if(CroppingPlane) DrawBackgroundPlane(CroppingPlane, GraList, Node); return Node; } //**************************************************************************** // Defect draw. //**************************************************************************** MIL_INT64 SDefect::Draw(MIL_ID GraList, MIL_INT64 Parent) const { auto ContainerLabel = M3dgraAdd(GraList, Parent, Container, M_DEFAULT); M3dgraControl(GraList, ContainerLabel, M_COLOR_COMPONENT, M_NULL); M3dgraControl(GraList, ContainerLabel, M_COLOR, Type == EType::eExtraData ? DEFECT_EXTRA_COLOR : DEFECT_MISSING_COLOR); M3dgraControl(GraList, ContainerLabel, M_THICKNESS, 3); return ContainerLabel; } //**************************************************************************** // Occurrence draw. //**************************************************************************** MIL_INT64 SOccurrence::Draw(MIL_ID GraList, MIL_INT64 Parent) const { auto Node = M3dgraNode(GraList, Parent, M_DEFAULT, M_DEFAULT); M3dgraAdd(GraList, Parent, Container, M_DEFAULT); for(const auto&amp; Defect : Defects) Defect.Draw(GraList, Node); auto BoxLabel = M3dgeoDraw3d(M_DEFAULT, Box, GraList, Node, M_DEFAULT); M3dgraControl(GraList, BoxLabel, M_APPEARANCE, M_WIREFRAME); M3dgraControl(GraList, BoxLabel, M_COLOR, BOX_COLOR); return Node; } //**************************************************************************** // Result draw. //**************************************************************************** MIL_INT64 SResult::Draw(MIL_ID GraList, MIL_INT64 Parent) const { auto Node = M3dgraNode(GraList, Parent, M_DEFAULT, M_DEFAULT); for(const auto&amp; Occurrence : Occurrences) { if(Occurrence) Occurrence-&gt;Draw(GraList, Node); } if(CroppingPlane) DrawBackgroundPlane(CroppingPlane, GraList, Node); return Node; } //**************************************************************************** // Converts a grayscale buffer to a RGB color buffer. //**************************************************************************** void GrayscaleToColor(MIL_ID SrcGrayScale, MIL_ID DstColor, MIL_INT64 Color, MIL_DOUBLE Gamma = 0.5) { for(MIL_INT i = 0; i &lt; 3; i++) { auto DstChild = MbufChildColor(DstColor, i, M_UNIQUE_ID); MimArith(SrcGrayScale, (Color &amp; (255 &lt;&lt; (8 * i))) &gt;&gt; (8 * i), DstChild, M_MULT_CONST); } MimArith(DstColor, Gamma, DstColor, M_EXP_CONST); } //**************************************************************************** // Didactic display for background removal step. //**************************************************************************** void DrawRemoveBackground(MIL_ID CroppedContainer, MIL_ID CroppingPlane, MIL_ID GraList, MIL_INT64 Parent) { if(CroppingPlane == M_NULL || GraList == M_NULL) return; auto ContainerLabel = M3dgraAdd(GraList, Parent, CroppedContainer, M_DEFAULT); DrawBackgroundPlane(CroppingPlane, GraList, Parent); MosPrintf(MIL_TEXT(\"The background plane is removed.\\n\") MIL_TEXT(\"Press any key to continue.\\n\\n\")); MosGetch(); M3dgraRemove(GraList, ContainerLabel, M_DEFAULT); } //**************************************************************************** // Didactic display for subsampling step. //**************************************************************************** void DrawSubsample(MIL_ID SampledContainer, MIL_ID GraList, MIL_INT64 /*Parent*/) { if(GraList == M_NULL) return; M3dgraAdd(GraList, M_ROOT_NODE, SampledContainer, M_DEFAULT); MosPrintf(MIL_TEXT(\"The scene is subsampled. This greatly improves the speed of M3dmodFind.\\n\") MIL_TEXT(\"Press any key to continue.\\n\\n\")); MosGetch(); } //**************************************************************************** // Didactic display for M3dmodFind step. //**************************************************************************** void DrawFind(MIL_ID Container, MIL_ID Box, MIL_INT Index, MIL_ID GraList, MIL_INT64 Parent) { if(GraList == M_NULL) return; auto BoxLabel = M3dgeoDraw3d(M_DEFAULT, Box, GraList, Parent, M_DEFAULT); M3dgraControl(GraList, BoxLabel, M_APPEARANCE, M_WIREFRAME); M3dgraControl(GraList, BoxLabel, M_COLOR, BOX_COLOR); if(Index == 0) { auto ContainerLabel = M3dgraAdd(GraList, Parent, Container, M_DEFAULT); M3dgraControl(GraList, ContainerLabel, M_COLOR_COMPONENT, M_NULL); M3dgraControl(GraList, ContainerLabel, M_COLOR, DISTANCE_TO_MODEL_COLOR); MosPrintf(MIL_TEXT(\"Model %i is located.\\n\") MIL_TEXT(\"The model's bounding box is used to remove inliers from subsequent finds\\n\") MIL_TEXT(\"as well as to get the inliers in the original (not subsampled) container.\\n\") MIL_TEXT(\"Press any key to continue.\\n\\n\"), Index + 1); MosGetch(); M3dgraRemove(GraList, ContainerLabel, M_DEFAULT); } } //**************************************************************************** // Didactic display for distance calculation step. //**************************************************************************** void DrawDistances(MIL_ID OccurrenceContainer, MIL_ID ModelContainer, MIL_INT Index, MIL_ID GraList, MIL_INT64 Parent) { if(GraList == M_NULL) return; std::vector&lt;MIL_ID&gt; ContainersToDraw = {OccurrenceContainer}; if(Index == 0) ContainersToDraw.push_back(ModelContainer); MIL_INT64 ContainerLabel = 0; for(MIL_ID Container : ContainersToDraw) { // Color the distances. auto Distances = MbufInquireContainer(Container, COMPONENT_DISTANCES, M_COMPONENT_ID, M_NULL); MIL_INT SizeX = MbufInquire(Distances, M_SIZE_X, M_NULL); MIL_INT SizeY = MbufInquire(Distances, M_SIZE_Y, M_NULL); auto DistancesColored = MbufAllocComponent(Container, 3, SizeX, SizeY, M_FLOAT + 32, M_IMAGE + M_PROC, COMPONENT_DISTANCES_COLORED, M_NULL); GrayscaleToColor(Distances, DistancesColored, Container == OccurrenceContainer ? DISTANCE_TO_MODEL_COLOR : DISTANCE_TO_OCCURRENCE_COLOR); // Draw the container. ContainerLabel = M3dgraAdd(GraList, Parent, Container, M_DEFAULT); M3dgraControl(GraList, ContainerLabel, M_COLOR_COMPONENT, COMPONENT_DISTANCES_COLORED); M3dgraControl(GraList, ContainerLabel, M_COLOR_COMPONENT_BAND, M_ALL_BANDS); M3dgraControl(GraList, ContainerLabel, M_COLOR_LIMITS, M_DATA_EXTREMES_GLOBAL); } if(Index == 0) { MosPrintf(MIL_TEXT(\"The model (in cyan) is superimposed on the occurrence (in blue).\\n\") MIL_TEXT(\"Distances between them are computed and shown by the brightness of each point.\\n\") MIL_TEXT(\"Bright cyan clusters (large distance to occurrence) indicate missing parts.\\n\") MIL_TEXT(\"Bright blue clusters (large distance to model) indicate extra parts.\\n\") MIL_TEXT(\"Press any key to continue.\\n\\n\")); MosGetch(); M3dgraRemove(GraList, ContainerLabel, M_DEFAULT); } } //**************************************************************************** // Didactic display for defect detection step. //**************************************************************************** void DrawDefects(const std::vector&lt;SDefect&gt;&amp; Defects, MIL_INT Index, MIL_ID GraList, MIL_INT64 Parent) { if(GraList == M_NULL) return; auto Node = M3dgraNode(GraList, Parent, M_DEFAULT, M_DEFAULT); for(const auto&amp; Defect : Defects) Defect.Draw(GraList, Node); if(Index == 0) { MosPrintf(MIL_TEXT(\"Points with a large distance are clustered into distinct defects.\\n\") MIL_TEXT(\"Missing parts are displayed in bright red and extra parts in dark red.\\n\") MIL_TEXT(\"Press any key to continue.\\n\\n\")); MosGetch(); M3dgraRemove(GraList, Node, M_DEFAULT); } } //**************************************************************************** // Didactic display for defect filtering step. //**************************************************************************** void DrawDefectFiltering(const std::vector&lt;SDefect&gt;&amp; Defects, MIL_ID ModelBox, MIL_INT Index, MIL_ID GraList, MIL_INT64 Parent) { if(GraList == M_NULL || Index != 0) return; // Find any occluded defect to illustrate it. for(const auto&amp; Defect : Defects) { auto Occlusion = IsDefectValid(Defect, Defects, ModelBox, M_NULL); if(Occlusion.Validity == SDefectValidity::eOccluded) { auto Node = M3dgraNode(GraList, Parent, M_DEFAULT, M_DEFAULT); M3dgraControl(GraList, Parent, M_OPACITY + M_RECURSIVE, 10); Defect.Draw(GraList, Node); Occlusion.Occluder-&gt;Draw(GraList, Node); MIL_DOUBLE RayLength = M3dgeoInquire(Occlusion.Ray, M_LENGTH, M_NULL); auto RayLabel = M3dgeoDraw3d(M_DEFAULT, Occlusion.Ray, GraList, Node, M_DEFAULT); M3dgraControl(GraList, RayLabel, M_LENGTH, RayLength * 1.5); M3dgraControl(GraList, RayLabel, M_THICKNESS, 3); auto OccludedLabel = M3dgeoDraw3d(M_DEFAULT, Defect.Box, GraList, Node, M_DEFAULT); auto OccludingLabel = M3dgeoDraw3d(M_DEFAULT, Occlusion.Occluder-&gt;Box, GraList, Node, M_DEFAULT); for(auto Label : {OccludedLabel, OccludingLabel}) { M3dgraControl(GraList, Label, M_APPEARANCE + M_RECURSIVE, M_WIREFRAME); M3dgraControl(GraList, Label, M_THICKNESS + M_RECURSIVE, 3); M3dgraControl(GraList, Label, M_COLOR, Label == OccludedLabel ? M_COLOR_DARK_GREEN : M_COLOR_GREEN); } MosPrintf(MIL_TEXT(\"Due to occlusions, defects often have another defect of the opposite type\\n\") MIL_TEXT(\"underneath them. This can be detected by casting rays from the center of the\\n\") MIL_TEXT(\"occurrence to each defect. In this example, a real defect is show in bright\\n\") MIL_TEXT(\"green and an occluded defect is shown in dark green.\\n\") MIL_TEXT(\"Only the furthest defects along each ray are kept.\\n\") MIL_TEXT(\"Press any key to continue.\\n\\n\")); MosGetch(); M3dgraRemove(GraList, Node, M_DEFAULT); M3dgraControl(GraList, Parent, M_OPACITY + M_RECURSIVE, 100); return; } } } //**************************************************************************** // Move both the container in the display and the view so it looks like nothing moved. // Used for linking displays together. //**************************************************************************** void SetMatrixWithoutChangingView(MIL_ID Display, MIL_ID Matrix) { auto Sys = MobjInquire(Display, M_OWNER_SYSTEM, M_NULL); M3ddispControl(Display, M_UPDATE, M_DISABLE); auto GraList = M3ddispInquire(Display, M_3D_GRAPHIC_LIST_ID, M_NULL); std::vector&lt;MIL_INT64&gt; Nodes; M3dgraInquire(GraList, M_ROOT_NODE, M_CHILDREN, Nodes); auto ViewMat = M3dgeoAlloc(Sys, M_TRANSFORMATION_MATRIX, M_DEFAULT, M_UNIQUE_ID); M3dgraCopy(GraList, Nodes[0], ViewMat, M_DEFAULT, M_TRANSFORMATION_MATRIX, M_DEFAULT); M3dgraCopy(Matrix, M_DEFAULT, GraList, Nodes[0], M_TRANSFORMATION_MATRIX, M_DEFAULT); M3dgeoMatrixSetTransform(ViewMat, M_INVERSE, ViewMat, M_DEFAULT, M_DEFAULT, M_DEFAULT, M_DEFAULT); M3dgeoMatrixSetTransform(ViewMat, M_COMPOSE_TWO_MATRICES, Matrix, ViewMat, M_DEFAULT, M_DEFAULT, M_DEFAULT); M3ddispSetView(Display, M_VIEW_MATRIX + M_COMPOSE_WITH_CURRENT, ViewMat, M_DEFAULT, M_DEFAULT, M_NO_HOOK); M3ddispControl(Display, M_UPDATE, M_ENABLE); } //***************************************************************************** // Allocates a 3D display and return its MIL identifier. //***************************************************************************** MIL_UNIQUE_3DDISP_ID Alloc3dDisplayId(MIL_ID MilSystem) { MappControl(M_DEFAULT, M_ERROR, M_PRINT_DISABLE); MIL_UNIQUE_3DDISP_ID MilDisplay3D = M3ddispAlloc(MilSystem, M_DEFAULT, MIL_TEXT(\"M_DEFAULT\"), M_DEFAULT, M_UNIQUE_ID); MappControl(M_DEFAULT, M_ERROR, M_PRINT_ENABLE); if(!MilDisplay3D) { MosPrintf(MIL_TEXT(\"\\n\") MIL_TEXT(\"The current system does not support the 3D display.\\n\") MIL_TEXT(\"Press any key to end.\\n\\n\")); MosGetch(); } return MilDisplay3D; } ",
      "wordCount": 1217
    },
    {
      "id": "Examples_Processing_3dMatching_SurfaceDefectDetection_CPP_surfacedefectdetection_cpp",
      "version": "2024020714",
      "title": "surfacedefectdetection.cpp",
      "location": "Sample Code from MIL Examples",
      "text": " Top //***************************************************************************************/ // // File name: SurfaceDefectDetection.cpp // Location: See Matrox Example Launcher in the MIL Control Center // // // Synopsis: This program finds models in a scene and analyzes them for defects. // See PrintHeader() for a more detailed description. // // Copyright (C) Matrox Electronic Systems Ltd., 1992-2024. // All Rights Reserved //***************************************************************************************/ #include &lt;mil.h&gt; #include \"DefectDetection.h\" #include \"Preprocessing.h\" #include \"../../../3dUtil/C++/Display3dLinker.h\" //**************************************************************************** // Example files. //**************************************************************************** static const MIL_STRING MODEL_FILE = M_IMAGE_PATH MIL_TEXT(\"SurfaceDefectDetection/ConnectorModel.ply\"); static const std::vector&lt;MIL_STRING&gt; SCENE_FILES = { M_IMAGE_PATH MIL_TEXT(\"SurfaceDefectDetection/ConnectorBrokenPin.ply\"), M_IMAGE_PATH MIL_TEXT(\"SurfaceDefectDetection/ConnectorMissingSeal.ply\"), M_IMAGE_PATH MIL_TEXT(\"SurfaceDefectDetection/ConnectorMoved.ply\"), M_IMAGE_PATH MIL_TEXT(\"SurfaceDefectDetection/ConnectorTearSeal.ply\") }; //**************************************************************************** // Constants. //**************************************************************************** // Display. static const MIL_INT SCENE_DISPLAY_SIZE_X = 800; static const MIL_INT SCENE_DISPLAY_SIZE_Y = 600; static const MIL_INT MODEL_DISPLAY_SIZE_X = 400; static const MIL_INT MODEL_DISPLAY_SIZE_Y = 400; static const MIL_DOUBLE DISPLAY_INITIAL_AZIM = 250; static const MIL_DOUBLE DISPLAY_INITIAL_ELEV = -50; static const MIL_DOUBLE DISPLAY_INITIAL_ROLL = 150; //**************************************************************************** // Example description. //**************************************************************************** void PrintHeader() { MosPrintf(MIL_TEXT(\"[EXAMPLE NAME]\\n\") MIL_TEXT(\"3d Defect Detection\\n\\n\") MIL_TEXT(\"[SYNOPSIS]\\n\") MIL_TEXT(\"This example analyzes a scene to define models.\\n\") MIL_TEXT(\"It then locates those models in new scenes and finds defects, if any.\\n\\n\") MIL_TEXT(\"[MODULES USED]\\n\") MIL_TEXT(\"Modules used: 3D Model Finder, 3D Blob, 3D Image Processing,\\n\") MIL_TEXT(\"3D Metrology, 3D Geometry, 3D Display, 3D Graphics, Image Processing, and Buffer.\\n\\n\")); } //**************************************************************************** // Main. //**************************************************************************** int MosMain(void) { PrintHeader(); auto App = MappAlloc(M_NULL, M_DEFAULT, M_UNIQUE_ID); auto Sys = MsysAlloc(App, M_SYSTEM_HOST, M_DEFAULT, M_DEFAULT, M_UNIQUE_ID); // Check for required example files. if(!CheckForRequiredMILFile(MODEL_FILE)) return EXIT_FAILURE; // Create the displays. auto SceneDisp = Alloc3dDisplayId(Sys); auto AnnotationDisp = Alloc3dDisplayId(Sys); M3ddispControl(SceneDisp, M_SIZE_X, SCENE_DISPLAY_SIZE_X); M3ddispControl(SceneDisp, M_SIZE_Y, SCENE_DISPLAY_SIZE_Y); M3ddispControl(SceneDisp, M_TITLE, MIL_TEXT(\"Original scene\")); M3ddispSetView(SceneDisp, M_AZIM_ELEV_ROLL, DISPLAY_INITIAL_AZIM, DISPLAY_INITIAL_ELEV, DISPLAY_INITIAL_ROLL, M_DEFAULT); M3ddispControl(AnnotationDisp, M_SIZE_X, SCENE_DISPLAY_SIZE_X); M3ddispControl(AnnotationDisp, M_SIZE_Y, SCENE_DISPLAY_SIZE_Y); M3ddispControl(AnnotationDisp, M_WINDOW_INITIAL_POSITION_X, SCENE_DISPLAY_SIZE_X); M3ddispControl(AnnotationDisp, M_TITLE, MIL_TEXT(\"Processed scene\")); auto SceneGraList = M3ddispInquire(SceneDisp, M_3D_GRAPHIC_LIST_ID, M_NULL); auto AnnotationGraList = M3ddispInquire(AnnotationDisp, M_3D_GRAPHIC_LIST_ID, M_NULL); for(const auto&amp; GraList : {SceneGraList, AnnotationGraList}) { M3dgraControl(GraList, M_DEFAULT_SETTINGS, M_COLOR_COMPONENT, M_COMPONENT_RANGE); M3dgraControl(GraList, M_DEFAULT_SETTINGS, M_COLOR_COMPONENT_BAND, 2); } // Restore and display the model scene. const auto ModelScene = MbufImport(MODEL_FILE, M_DEFAULT, M_RESTORE, Sys, M_UNIQUE_ID); M3ddispSelect(SceneDisp, ModelScene, M_DEFAULT, M_DEFAULT); CDisplayLinker SceneAnnotationLinker({SceneDisp, AnnotationDisp}); MosPrintf(MIL_TEXT(\"A typical scene is restored. It will be used as a golden template.\\n\") MIL_TEXT(\"Press any key to analyze the scene.\\n\\n\")); MosGetch(); // Analyze the model scene. const auto Context = Preprocess(ModelScene); Context.Draw(AnnotationGraList, M_ROOT_NODE); M3ddispSelect(AnnotationDisp, M_NULL, M_OPEN, M_DEFAULT); MosPrintf(MIL_TEXT(\"A plane is fit on the scene and used to crop the background.\\n\") MIL_TEXT(\"The remaining points are clustered into separate models.\\n\\n\")); if(Context.Models.empty()) { MosPrintf(MIL_TEXT(\"Could not locate any models.\\n\") MIL_TEXT(\"Press any key to end.\\n\\n\")); MosGetch(); return EXIT_FAILURE; } else { MosPrintf(MIL_TEXT(\"Found %i models.\\n\") MIL_TEXT(\"Press any key to analyze new scenes using these models.\\n\\n\"), Context.Models.size()); MosGetch(); } // Display the models. std::vector&lt;MIL_UNIQUE_3DDISP_ID&gt; ModelDisps(Context.Models.size()); for(MIL_UINT i = 0; i &lt; Context.Models.size(); i++) { ModelDisps[i] = Alloc3dDisplayId(Sys); M3ddispControl(ModelDisps[i], M_SIZE_X, MODEL_DISPLAY_SIZE_X); M3ddispControl(ModelDisps[i], M_SIZE_Y, MODEL_DISPLAY_SIZE_Y); M3ddispControl(ModelDisps[i], M_WINDOW_INITIAL_POSITION_X, (MIL_INT)i * MODEL_DISPLAY_SIZE_X); M3ddispControl(ModelDisps[i], M_WINDOW_INITIAL_POSITION_Y, SCENE_DISPLAY_SIZE_Y + 30); M3ddispControl(ModelDisps[i], M_TITLE, MIL_TEXT(\"Model \") + M_TO_STRING(i + 1)); auto ModelGraList = M3ddispInquire(ModelDisps[i], M_3D_GRAPHIC_LIST_ID, M_NULL); M3dgraControl(ModelGraList, M_DEFAULT_SETTINGS, M_COLOR_COMPONENT, M_COMPONENT_RANGE); M3dgraControl(ModelGraList, M_DEFAULT_SETTINGS, M_COLOR_COMPONENT_BAND, 2); M3ddispSetView(ModelDisps[i], M_AZIM_ELEV_ROLL, DISPLAY_INITIAL_AZIM, DISPLAY_INITIAL_ELEV, DISPLAY_INITIAL_ROLL, M_DEFAULT); M3ddispSelect(ModelDisps[i], Context.Models[i].Container, M_DEFAULT, M_DEFAULT); } CDisplayLinker ModelLinker(std::vector&lt;MIL_ID&gt;(ModelDisps.begin(), ModelDisps.end()), {SceneDisp, AnnotationDisp}); for(const auto&amp; File : SCENE_FILES) { // Restore and display the scene. M3dgraRemove(AnnotationGraList, M_ALL, M_DEFAULT); MosPrintf(MIL_TEXT(\"Scene %i of %i:\\n\"), &amp;File - SCENE_FILES.data() + 1, SCENE_FILES.size()); auto Scene = MbufImport(File, M_DEFAULT, M_RESTORE, Sys, M_UNIQUE_ID); M3ddispSelect(SceneDisp, Scene, M_DEFAULT, M_DEFAULT); // Find the models. auto Result = Process(Context, Scene); // Copy the model matrices so the display link works properly. for(MIL_UINT i = 0; i &lt; Context.Models.size(); i++) { if(Result.Occurrences[i]) SetMatrixWithoutChangingView(ModelDisps[i], Result.Occurrences[i]-&gt;Position); } // For the first scene, do the processing step by step. if(&amp;File == SCENE_FILES.data()) { MosPrintf(MIL_TEXT(\"Processing will be done step by step for the first scene.\\n\")); Result = Process(Context, Scene, AnnotationGraList, M_ROOT_NODE); M3dgraRemove(AnnotationGraList, M_ALL, M_DEFAULT); MosPrintf(MIL_TEXT(\"Results:\\n\")); } // Draw the results. Result.Draw(AnnotationGraList, M_ROOT_NODE); // Print the results. for(const auto&amp; Occurrence : Result.Occurrences) { MosPrintf(MIL_TEXT(\" Model %i: \"), &amp;Occurrence - Result.Occurrences.data() + 1); if(!Occurrence) { MosPrintf(MIL_TEXT(\"Not found\")); } else if(Occurrence-&gt;Defects.empty()) { MosPrintf(MIL_TEXT(\"Ok\")); } else { MIL_INT NbMissing = std::count_if(Occurrence-&gt;Defects.begin(), Occurrence-&gt;Defects.end(), [](const SDefect&amp; Defect) { return Defect.Type == SDefect::eMissingData; }); MIL_INT NbExtra = Occurrence-&gt;Defects.size() - NbMissing; if(NbMissing &gt; 0) MosPrintf(MIL_TEXT(\"%i Missing part(s) (bright red) \"), NbMissing); if(NbExtra &gt; 0) MosPrintf(MIL_TEXT(\"%i Extra part(s) (dark red) \"), NbExtra); } MosPrintf(MIL_TEXT(\"\\n\")); } if(&amp;File == SCENE_FILES.data()) MosPrintf(MIL_TEXT(\"The next scenes will be processed in one step.\\n\")); MosPrintf(MIL_TEXT(\"Press any key to %s.\\n\\n\"), &amp;File == &amp;SCENE_FILES.back() ? MIL_TEXT(\"end\") : MIL_TEXT(\"continue\")); MosGetch(); } return 0; } ",
      "wordCount": 704
    }
  ]
}]
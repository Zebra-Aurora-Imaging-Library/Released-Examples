[{
  "id": "Example_PlaceHolder_ID",
  "version": "2024020714",
  "title": "Example_PlaceHolder_Title",
  "wordCount": 0,
  "subEntries": [
    {
      "id": "Examples_BoardSpecific_General_MulticastSlave_CPP_multicastslave_cpp",
      "version": "2024020714",
      "title": "multicastslave.cpp",
      "location": "Sample Code from MIL Examples",
      "text": " Top /*************************************************************************************/ /* * File name: MulticastSlave.cpp * Location: See Matrox Example Launcher in the MIL Control Center * * * Synopsis: This program shows how to perform IP Multicast with GigE Vision devices. * * To do this you must have a network capable of delivering a Multicast * service over IPv4. This requires the use of routers and LAN switches * that support the Internet Group Management Protocol (IGMP). Some manual * configuration of you LAN switches might be required. More information * can be found in the IP Multicast section of Matrox GigE Vision * Assistant's help file. * * Note: This example must be used along with the MulticastMaster program * connected to the same GigE Vision device and running on another PC. * * Copyright (C) Matrox Electronic Systems Ltd., 1992-2024. * All Rights Reserved */ #include &lt;mil.h&gt; #if M_MIL_USE_WINDOWS #include &lt;windows.h&gt; #endif /* Number of images in the buffering grab queue. Generally, increasing this number gives better real-time grab. */ #define BUFFERING_SIZE_MAX 20 /* User's processing function hook data structure. */ typedef struct { MIL_ID MilDigitizer; MIL_ID MilDisplay; MIL_ID MilImageDisp; MIL_ID MilGrabBufferList[BUFFERING_SIZE_MAX]; MIL_INT MilGrabBufferListSize; MIL_INT ProcessedImageCount; MIL_INT CorruptImageCount; MIL_INT FrameSizeX; MIL_INT FrameSizeY; MIL_INT64 FramePixelFormat; MIL_INT FramePacketSize; bool DataFormatChanged; MIL_INT64 SourceDataFormat; MIL_ID Event; MIL_STRING DeviceVendor; MIL_STRING DeviceModel; } HookDataStruct; /* Function prototypes. */ void AllocateGrabBuffers(MIL_INT MilSystem, HookDataStruct* HookDataPtr); void FreeGrabBuffers(HookDataStruct* HookDataPtr); void AdaptToMulticastMasterStatus(MIL_INT MilSystem, HookDataStruct* HookDataPtr); void PrintCameraInfo(HookDataStruct* HookDataPtr); void PrintMasterStatusInfo(MIL_INT IsConnected); MIL_INT MFTYPE ProcessingFunction(MIL_INT HookType, MIL_ID HookId, void* HookDataPtr); /* Main function. */ /* ---------------*/ int MosMain(void) { MIL_ID MilApplication; MIL_ID MilSystem ; MIL_INT ProcessFrameCount = 0; MIL_INT DigProcessInProgress = M_FALSE; MIL_INT SystemType = 0; MIL_DOUBLE ProcessFrameRate= 0; HookDataStruct UserHookData; /* Allocate defaults. */ MappAllocDefault(M_DEFAULT, &amp;MilApplication, &amp;MilSystem, M_NULL, M_NULL, M_NULL); /* This example only runs on a MIL GigE Vision system type. */ MsysInquire(MilSystem, M_SYSTEM_TYPE, &amp;SystemType); if(SystemType != M_SYSTEM_GIGE_VISION_TYPE) { MosPrintf(MIL_TEXT(\"This example requires a M_GIGE_VISION system type.\\n\")); MosPrintf(MIL_TEXT(\"Please change system type in milconfig.\\n\")); MosPrintf(MIL_TEXT(\"\\nPress any key to quit.\\n\")); MosGetch(); MappFreeDefault(MilApplication, MilSystem, M_NULL, M_NULL, M_NULL); return 0; } /* Allocate a slave Multicast digitizer. */ MdigAlloc(MilSystem, M_DEFAULT, M_NULL, M_GC_MULTICAST_SLAVE, &amp;UserHookData.MilDigitizer); /* Allocate synchronization event. */ MthrAlloc(MilSystem, M_EVENT, M_NOT_SIGNALED+M_AUTO_RESET, M_NULL, M_NULL, &amp;UserHookData.Event); /* Allocate a display and buffers. */ MdispAlloc(MilSystem, M_DEFAULT, MIL_TEXT(\"M_DEFAULT\"), M_DEFAULT, &amp;UserHookData.MilDisplay); AllocateGrabBuffers(MilSystem, &amp;UserHookData); MosPrintf(MIL_TEXT(\"This example demonstrates the use of IP Multicast with GigE Vision\")); MosPrintf(MIL_TEXT(\" devices.\\n\")); MosPrintf(MIL_TEXT(\"It allocates a slave digitizer that can read and grab from a GigE\")); MosPrintf(MIL_TEXT(\" Vision\\n\")); MosPrintf(MIL_TEXT(\"device provided a Multicast master digitizer is allocated on the same\")); MosPrintf(MIL_TEXT(\" device.\\n\\n\")); MosPrintf(MIL_TEXT(\"This example must be used along with MulticastMaster.cpp connected to\")); MosPrintf(MIL_TEXT(\" the same\\n\")); MosPrintf(MIL_TEXT(\"GigE Vision device and running on another PC.\\n\")); MosPrintf(MIL_TEXT(\"Press any key to continue.\")); MosGetch(); MdispSelect(UserHookData.MilDisplay, UserHookData.MilImageDisp); /* Initialize the User's processing function data structure. */ UserHookData.ProcessedImageCount = 0; UserHookData.CorruptImageCount = 0; UserHookData.FrameSizeX = 0; UserHookData.FrameSizeY = 0; UserHookData.FramePacketSize = 0; UserHookData.FramePixelFormat = 0; UserHookData.DataFormatChanged = false; /* Print info related to the device we are connected to. */ PrintCameraInfo(&amp;UserHookData); /* Start the processing. The processing function is called for every frame grabbed. */ MdigProcess(UserHookData.MilDigitizer, UserHookData.MilGrabBufferList, UserHookData.MilGrabBufferListSize, M_START, M_DEFAULT, ProcessingFunction, &amp;UserHookData); /* NOTE: Now the main() is free to perform other tasks while the processing is executing. */ /* -------------------------------------------------------------------------------- */ /* Adjust the slave digitizer according to the master digitizer's status. */ AdaptToMulticastMasterStatus(MilSystem, &amp;UserHookData); MdigInquire(UserHookData.MilDigitizer, M_DIG_PROCESS_IN_PROGRESS, &amp;DigProcessInProgress); if(DigProcessInProgress == M_TRUE) { /* Stop the processing. */ MdigProcess(UserHookData.MilDigitizer, UserHookData.MilGrabBufferList, UserHookData.MilGrabBufferListSize, M_STOP, M_DEFAULT, ProcessingFunction, &amp;UserHookData); } /* Print statistics. */ MdigInquire(UserHookData.MilDigitizer, M_PROCESS_FRAME_COUNT, &amp;ProcessFrameCount); MdigInquire(UserHookData.MilDigitizer, M_PROCESS_FRAME_RATE, &amp;ProcessFrameRate); MosPrintf(MIL_TEXT(\"\\n\\n%lld frames grabbed at %.1f frames/sec (%.1f ms/frame).\\n\"), (long long)ProcessFrameCount, ProcessFrameRate, 1000.0/ProcessFrameRate); MosPrintf(MIL_TEXT(\"Press any key to end.\\n\\n\")); MosGetch(); FreeGrabBuffers(&amp;UserHookData); MdispFree(UserHookData.MilDisplay); MdigFree(UserHookData.MilDigitizer); MthrFree(UserHookData.Event); /* Release defaults. */ MappFreeDefault(MilApplication, MilSystem, M_NULL, M_NULL, M_NULL); return 0; } /* Allocate acquisition and display buffers. */ /* ----------------------------------------------------------------------- */ void AllocateGrabBuffers(MIL_INT MilSystem, HookDataStruct* HookDataPtr) { MIL_INT n = 0; MdigInquire(HookDataPtr-&gt;MilDigitizer, M_SOURCE_DATA_FORMAT, &amp;HookDataPtr-&gt;SourceDataFormat); /* Allocate the display buffer and clear it. */ MbufAllocColor(MilSystem, MdigInquire(HookDataPtr-&gt;MilDigitizer, M_SIZE_BAND, M_NULL), MdigInquire(HookDataPtr-&gt;MilDigitizer, M_SIZE_X, M_NULL), MdigInquire(HookDataPtr-&gt;MilDigitizer, M_SIZE_Y, M_NULL), MdigInquire(HookDataPtr-&gt;MilDigitizer, M_TYPE, M_NULL), M_IMAGE+M_DISP+M_GRAB+M_PROC+HookDataPtr-&gt;SourceDataFormat, &amp;HookDataPtr-&gt;MilImageDisp); MbufClear(HookDataPtr-&gt;MilImageDisp, M_COLOR_BLACK); /* Allocate the grab buffers and clear them. */ MappControl(M_DEFAULT, M_ERROR, M_PRINT_DISABLE); for(HookDataPtr-&gt;MilGrabBufferListSize = 0; HookDataPtr-&gt;MilGrabBufferListSize&lt;BUFFERING_SIZE_MAX; HookDataPtr-&gt;MilGrabBufferListSize++) { MbufAllocColor(MilSystem, MdigInquire(HookDataPtr-&gt;MilDigitizer, M_SIZE_BAND, M_NULL), MdigInquire(HookDataPtr-&gt;MilDigitizer, M_SIZE_X, M_NULL), MdigInquire(HookDataPtr-&gt;MilDigitizer, M_SIZE_Y, M_NULL), MdigInquire(HookDataPtr-&gt;MilDigitizer, M_TYPE, M_NULL), M_IMAGE+M_GRAB+M_PROC+HookDataPtr-&gt;SourceDataFormat, &amp;HookDataPtr-&gt;MilGrabBufferList[HookDataPtr-&gt;MilGrabBufferListSize]); if (HookDataPtr-&gt;MilGrabBufferList[HookDataPtr-&gt;MilGrabBufferListSize]) { MbufClear(HookDataPtr-&gt;MilGrabBufferList[HookDataPtr-&gt;MilGrabBufferListSize], M_COLOR_WHITE); } else break; } MappControl(M_DEFAULT, M_ERROR, M_PRINT_ENABLE); } /* Free MIL acquisition and display buffers. */ /* ----------------------------------------------------------------------- */ void FreeGrabBuffers(HookDataStruct* HookDataPtr) { while(HookDataPtr-&gt;MilGrabBufferListSize &gt; 0) MbufFree(HookDataPtr-&gt;MilGrabBufferList[--HookDataPtr-&gt;MilGrabBufferListSize]); MbufFree(HookDataPtr-&gt;MilImageDisp); } /* This routine queries periodically to determine if a Multicast master */ /* digitizer is connected to the device this slave digitizer connects to. */ /* If the Multicast master digitizer connection status changes, then this */ /* information is printed to the user. When the Multicast master digitizer */ /* connects back to this device, the slave digitizer will update its */ /* connection and resume image acquisition. */ /* ----------------------------------------------------------------------- */ void AdaptToMulticastMasterStatus(MIL_INT MilSystem, HookDataStruct* HookDataPtr) { MIL_INT IsConnected = M_FALSE, IsConnectedOld = M_FALSE; MIL_INT ProcessedImageCount = 0; MIL_INT DigProcessInProgress = M_FALSE; bool Done = false, GrabStopped = false;; /* Inquire the connection status of a Multicast master that might be */ /* connected to this GigE Vision device. */ MdigInquire(HookDataPtr-&gt;MilDigitizer, M_GC_MULTICAST_MASTER_CONNECTED, &amp;IsConnectedOld); IsConnected = IsConnectedOld; PrintMasterStatusInfo(IsConnectedOld); do { /* Save the current processing count. */ ProcessedImageCount = HookDataPtr-&gt;ProcessedImageCount; /* Sleep. */ MthrWait(HookDataPtr-&gt;Event, M_EVENT_WAIT+M_EVENT_TIMEOUT(1000), M_NULL); GrabStopped = (ProcessedImageCount == HookDataPtr-&gt;ProcessedImageCount); if(GrabStopped &amp;&amp; HookDataPtr-&gt;DataFormatChanged == false) { /* We are not grabbing anymore and we have not detected a data format change. Check if master is still connected. */ MdigInquire(HookDataPtr-&gt;MilDigitizer, M_GC_MULTICAST_MASTER_CONNECTED, &amp;IsConnected); } /* Validate if processing count has changed. */ if(((IsConnected == M_TRUE) &amp;&amp; (IsConnectedOld != IsConnected)) || HookDataPtr-&gt;DataFormatChanged) { // Reset variable HookDataPtr-&gt;DataFormatChanged = !HookDataPtr-&gt;DataFormatChanged; /* The Multicast master is present, we must: */ /* 1- Stop any grabs that had previously been started. */ /* 2- Update the Multicast slave's network sockets */ /* 3- Restart the grab. */ MdigInquire(HookDataPtr-&gt;MilDigitizer, M_DIG_PROCESS_IN_PROGRESS, &amp;DigProcessInProgress); if(DigProcessInProgress) { MdigProcess(HookDataPtr-&gt;MilDigitizer, HookDataPtr-&gt;MilGrabBufferList, HookDataPtr-&gt;MilGrabBufferListSize, M_STOP, M_DEFAULT, ProcessingFunction, HookDataPtr); } MdigControl(HookDataPtr-&gt;MilDigitizer, M_GC_UPDATE_MULTICAST_INFO, M_DEFAULT); PrintCameraInfo(HookDataPtr); FreeGrabBuffers(HookDataPtr); AllocateGrabBuffers(MilSystem, HookDataPtr); MdispSelect(HookDataPtr-&gt;MilDisplay, HookDataPtr-&gt;MilImageDisp); /* We are now ready to start grabbing. */ MdigProcess(HookDataPtr-&gt;MilDigitizer, HookDataPtr-&gt;MilGrabBufferList, HookDataPtr-&gt;MilGrabBufferListSize, M_START, M_DEFAULT, ProcessingFunction, HookDataPtr); } /* Back-up the current Multicast master connection status. */ IsConnectedOld = IsConnected; /* Tell the user what is happening. */ PrintMasterStatusInfo(IsConnected); /* Must we quit? */ if(MosKbhit()) { MosGetch(); Done = true; } } while(!Done); } /* Prints information regarding the device this slave digitizer is connected to. */ /* ----------------------------------------------------------------------- */ void PrintCameraInfo(HookDataStruct* HookDataPtr) { MIL_STRING PixelFormat; MIL_STRING MulticastAddress; #if M_MIL_USE_WINDOWS /* Clear console. */ system(\"cls\"); #endif if(HookDataPtr-&gt;DeviceVendor.empty() &amp;&amp; HookDataPtr-&gt;DeviceModel.empty()) { /* Inquire camera vendor name. */ MdigInquire(HookDataPtr-&gt;MilDigitizer, M_CAMERA_VENDOR, HookDataPtr-&gt;DeviceVendor); /* Inquire camera model name. */ MdigInquire(HookDataPtr-&gt;MilDigitizer, M_CAMERA_MODEL, HookDataPtr-&gt;DeviceModel); } if(HookDataPtr-&gt;FrameSizeX == 0 &amp;&amp; HookDataPtr-&gt;FrameSizeY == 0) { MdigInquire(HookDataPtr-&gt;MilDigitizer, M_SIZE_X, &amp;HookDataPtr-&gt;FrameSizeX); MdigInquire(HookDataPtr-&gt;MilDigitizer, M_SIZE_Y, &amp;HookDataPtr-&gt;FrameSizeY); } if(HookDataPtr-&gt;FramePixelFormat == 0) { MdigInquireFeature(HookDataPtr-&gt;MilDigitizer, M_FEATURE_VALUE, MIL_TEXT(\"PixelFormat\"), M_TYPE_INT64, &amp;HookDataPtr-&gt;FramePixelFormat); MdigInquireFeature(HookDataPtr-&gt;MilDigitizer, M_FEATURE_VALUE, MIL_TEXT(\"PixelFormat\"), M_TYPE_STRING, PixelFormat); } /* Inquire the Multicast address used. */ MdigInquire(HookDataPtr-&gt;MilDigitizer, M_GC_STREAM_CHANNEL_MULTICAST_ADDRESS_STRING, MulticastAddress); /* Print camera info. */ MosPrintf(MIL_TEXT(\"\\n--------------------- Slave digitizer connection status. \")); MosPrintf(MIL_TEXT(\"---------------------\\n\\n\")); MosPrintf(MIL_TEXT(\"Connected to %s %s\\n\"), HookDataPtr-&gt;DeviceVendor.c_str(), HookDataPtr-&gt;DeviceModel.c_str()); MosPrintf(MIL_TEXT(\"Device pixel format: %s\\n\"), PixelFormat.c_str()); MosPrintf(MIL_TEXT(\"Device AOI: %lld x %lld\\n\"), (long long)HookDataPtr-&gt;FrameSizeX, (long long)HookDataPtr-&gt;FrameSizeY); MosPrintf(MIL_TEXT(\"Multicast address: %s\\n\"), MulticastAddress.c_str()); MosPrintf(MIL_TEXT(\"\\nPress any key to stop.\\n\\n\")); } /* Prints whether a Multicast master digitizer is connected. */ /* -----------------------------------------------------------------------*/ void PrintMasterStatusInfo(MIL_INT IsConnected) { MosPrintf(MIL_TEXT(\"Master digitizer status: \")); if(IsConnected) MosPrintf(MIL_TEXT(\"connected\\r\")); else MosPrintf(MIL_TEXT(\"not connected --- waiting...\\r\")); } /* User's processing function called every time a grab buffer is modified. */ /* -----------------------------------------------------------------------*/ /* Local defines. */ #define STRING_LENGTH_MAX 20 #define STRING_POS_X 20 #define STRING_POS_Y 20 MIL_INT MFTYPE ProcessingFunction(MIL_INT HookType, MIL_ID HookId, void* HookDataPtr) { HookDataStruct *UserHookDataPtr = (HookDataStruct *)HookDataPtr; MIL_ID ModifiedBufferId; MIL_TEXT_CHAR Text[STRING_LENGTH_MAX]= {MIL_TEXT('\\0'),}; MIL_INT IsFrameCorrupt = M_FALSE; MIL_INT FrameSizeX = 0; MIL_INT FrameSizeY = 0; MIL_INT FramePixelFormat = 0; MIL_INT FramePacketSize = 0; /* Retrieve the MIL_ID of the grabbed buffer. */ MdigGetHookInfo(HookId, M_MODIFIED_BUFFER+M_BUFFER_ID, &amp;ModifiedBufferId); MdigGetHookInfo(HookId, M_CORRUPTED_FRAME, &amp;IsFrameCorrupt); MdigGetHookInfo(HookId, M_GC_FRAME_SIZE_X, &amp;FrameSizeX); MdigGetHookInfo(HookId, M_GC_FRAME_SIZE_Y, &amp;FrameSizeY); MdigGetHookInfo(HookId, M_GC_FRAME_PIXEL_TYPE, &amp;FramePixelFormat); MdigGetHookInfo(HookId, M_GC_PACKET_SIZE, &amp;FramePacketSize); /* Print and draw the frame count. */ UserHookDataPtr-&gt;ProcessedImageCount++; if(IsFrameCorrupt) UserHookDataPtr-&gt;CorruptImageCount++; if((FrameSizeX != UserHookDataPtr-&gt;FrameSizeX) || (FrameSizeY != UserHookDataPtr-&gt;FrameSizeY) || (FramePixelFormat != UserHookDataPtr-&gt;FramePixelFormat) || (FramePacketSize != UserHookDataPtr-&gt;FramePacketSize)) { UserHookDataPtr-&gt;FrameSizeX = FrameSizeX; UserHookDataPtr-&gt;FrameSizeY = FrameSizeY; UserHookDataPtr-&gt;FramePixelFormat = FramePixelFormat; UserHookDataPtr-&gt;FramePacketSize = FramePacketSize; // Do not set on first grab, we must initialize data once first. if (UserHookDataPtr-&gt;ProcessedImageCount &gt; 1) { UserHookDataPtr-&gt;DataFormatChanged = M_TRUE; // Wake up main thread to perform buffer re-allocation. MthrControl(UserHookDataPtr-&gt;Event, M_EVENT_SET, M_SIGNALED); } } MosSprintf(Text, STRING_LENGTH_MAX, MIL_TEXT(\"%lld\"), (long long)UserHookDataPtr-&gt;ProcessedImageCount); MgraText(M_DEFAULT, ModifiedBufferId, STRING_POS_X, STRING_POS_Y, Text); /* Perform the processing and update the display. */ MbufCopy(ModifiedBufferId, UserHookDataPtr-&gt;MilImageDisp); return 0; } ",
      "wordCount": 1395
    }
  ]
}]
[{
  "id": "Example_PlaceHolder_ID",
  "version": "2023100322",
  "title": "Example_PlaceHolder_Title",
  "wordCount": 0,
  "subEntries": [
    {
      "id": "Examples_BoardSpecific_clarityuhd_MdigCrossBar_CPP_md3ddisplayeffect_cpp",
      "version": "2023100322",
      "title": "md3ddisplayeffect.cpp",
      "location": "Sample Code from MIL Examples",
      "text": " Top /* * File name: md3ddisplayeffect.cpp * Location: See Matrox Example Launcher in the MIL Control Center * */ // // Copyright (C) Matrox Electronic Systems Ltd., 1992-2023. // All Rights Reserved #include &lt;windows.h&gt; #include &lt;mil.h&gt; #include &lt;queue&gt; #include &lt;list&gt; #include \"d3d9.h\" #include \"d3dx9.h\" #include \"md3ddisplayeffect.h\" struct CUSTOMVERTEX VertexDefinitionOriginal[] = {{-1.0f, 1.0f , 0.0f, 0.0f, 0.0f}, { -1.0f, -1.0f , 0.0f, 0.0f, 1.0f}, { 1.0f, 1.0f , 0.0f, 1.0f, 0.0f}, { 1.0f, -1.0f , 0.0f, 1.0f, 1.0f}}; void VertexResize(CUSTOMVERTEX *pVertexDefinition, float XFactor, float YFactor); void VertexTranslate(CUSTOMVERTEX *pVertexDefinition, float X, float Y); void AdjustViewMatrix(D3D_EFFECT *pD3DEffect, IDirect3DDevice9* d3ddev ); HRESULT DX9Processing(D3D_EFFECT *pD3DEffect, LPDIRECT3DDEVICE9 pD3DDevice, LPDIRECT3DSURFACE9 pSrcSurface, LPDIRECT3DSURFACE9 pDestSurface) { HRESULT hr; LPDIRECT3DTEXTURE9 SourceTexture1 = NULL; LPDIRECT3DTEXTURE9 SourceTexture2 = NULL; LPDIRECT3DTEXTURE9 MainTexture = NULL; LPDIRECT3DTEXTURE9 VideoOverlayTexture = NULL; LPDIRECT3DTEXTURE9 OverlayTexture1 = NULL; LPDIRECT3DSURFACE9 DestSurface = NULL; MIL_INT SizeX = pD3DEffect-&gt;SizeX; MIL_INT SizeY = pD3DEffect-&gt;SizeY; if(!pD3DEffect-&gt;IsAllocated) pD3DEffect-&gt;Alloc(pD3DDevice); hr = pD3DDevice-&gt;StretchRect(pSrcSurface, NULL, pD3DEffect-&gt;pSurface, NULL, D3DTEXF_LINEAR); MainTexture = pD3DEffect-&gt;pTexture; pD3DEffect-&gt;ProcessFrameCount++; FAIL_RET(pD3DDevice-&gt;SetFVF(CUSTOMFVF)); AdjustViewMatrix( pD3DEffect, pD3DDevice ) ; if(pD3DEffect-&gt;ProcessFrameCount &lt; 2) { memcpy(&amp;pD3DEffect-&gt;VertexDefinition[0], VertexDefinitionOriginal, sizeof(CUSTOMVERTEX) * 4); FAIL_RET(pD3DDevice-&gt;SetRenderState( D3DRS_LIGHTING, FALSE ) ) ; FAIL_RET(pD3DDevice-&gt;SetRenderState( D3DRS_CULLMODE,D3DCULL_NONE)); FAIL_RET(pD3DDevice-&gt;SetRenderState( D3DRS_ZENABLE,TRUE)); FAIL_RET(pD3DDevice-&gt;SetSamplerState(0, D3DSAMP_MAGFILTER, D3DTEXF_NONE)); FAIL_RET(pD3DDevice-&gt;SetSamplerState(0, D3DSAMP_MINFILTER, D3DTEXF_NONE)); FAIL_RET(pD3DDevice-&gt;SetSamplerState(0, D3DSAMP_ADDRESSU, D3DTADDRESS_BORDER)); FAIL_RET(pD3DDevice-&gt;SetSamplerState(0, D3DSAMP_ADDRESSV, D3DTADDRESS_BORDER)); } float TranslationX = 0; float TranslationY = 0; VertexResize (&amp;pD3DEffect-&gt;VertexDefinition[0], 1.0, 1.0); VertexTranslate(&amp;pD3DEffect-&gt;VertexDefinition[0], 0.0, 0.0); void* pVoid = 0; pD3DEffect-&gt;pD3DVertexBuffer-&gt;Lock(0, 0, (void**)&amp;pVoid, 0); memcpy(pVoid, pD3DEffect-&gt;VertexDefinition, sizeof(pD3DEffect-&gt;VertexDefinition)); pD3DEffect-&gt;pD3DVertexBuffer-&gt;Unlock(); while(pD3DDevice-&gt;BeginScene() != 0); FAIL_RET(pD3DDevice-&gt;SetStreamSource(0, pD3DEffect-&gt;pD3DVertexBuffer , 0, sizeof(CUSTOMVERTEX))); FAIL_RET(pD3DDevice-&gt;SetRenderTarget(0, pDestSurface)); hr = pD3DDevice-&gt;Clear( 0, NULL, D3DCLEAR_TARGET, D3DCOLOR_XRGB(127,127,127), 1.0f, 0 ); FAIL_RET(pD3DDevice-&gt;SetTexture(0, MainTexture)); FAIL_RET(pD3DDevice-&gt;DrawPrimitive(D3DPT_TRIANGLESTRIP, 0, 2)); FAIL_RET(pD3DDevice-&gt;EndScene()); return 0; } void AdjustViewMatrix(D3D_EFFECT *pD3DEffect, IDirect3DDevice9* d3ddev ) { float fRotX = 0.0f; float fRotY = 0.0f; D3DXMATRIX mPos; D3DXMATRIX mView; D3DXMATRIX mProj; if(pD3DEffect-&gt;AutomaticMoving) { if((pD3DEffect-&gt;ProcessFrameCount % 600) == 0) { D3DXMatrixTranslation( &amp;mPos, 0,0,0 ); D3DXMatrixTranslation( &amp;mView, 0,0,0 ); D3DXMatrixTranslation( &amp;mProj, 0,0,0 ); pD3DEffect-&gt;DisplayCurX = rand() % (pD3DEffect-&gt;SizeX/2); pD3DEffect-&gt;DisplayCurY = rand() % (pD3DEffect-&gt;SizeY/2); } else { pD3DEffect-&gt;DisplayCurX--; pD3DEffect-&gt;DisplayCurY++; } } if(0) { D3DXMatrixTranslation( &amp;mPos, 0,0,0 ); D3DXMatrixTranslation( &amp;mView, 0,0,0 ); D3DXMatrixTranslation( &amp;mProj, 0,0,0 ); } else { fRotX = pD3DEffect-&gt;DisplayCurX/255.0f*60.0f*(D3DX_PI/180.0f); fRotY = pD3DEffect-&gt;DisplayCurY/255.0f*60.0f*(D3DX_PI/180.0f); D3DXMATRIX mWorld; D3DXMATRIX mWorldX; D3DXMatrixRotationY( &amp;mWorld, 0); D3DXMatrixRotationX( &amp;mWorldX,0); D3DXVECTOR3 eye( fRotX, fRotY, -1.0); D3DXVECTOR3 at( 0, 0, 0 ); D3DXVECTOR3 up( 0, 1, 0 ); D3DXMatrixLookAtLH( &amp;mView, &amp;eye, &amp;at, &amp;up ); D3DXMatrixPerspectiveFovLH( &amp;mProj, D3DX_PI/4.0f, 1.0f, 1.0f, 100.0f ); D3DXMatrixTranslation( &amp;mPos, 0,0,0 ); mPos = mWorld*mWorldX*mPos; } d3ddev-&gt;SetTransform( D3DTS_VIEW, &amp;mView ); d3ddev-&gt;SetTransform( D3DTS_PROJECTION, &amp;mProj ); d3ddev-&gt;SetTransform( D3DTS_WORLD, &amp;mPos ); return ; } void VertexResize(CUSTOMVERTEX *pVertexDefinition, float XFactor, float YFactor) { pVertexDefinition[1].Y = 1.0f - (2.0f * YFactor); pVertexDefinition[2].X = -1.0f + (2.0f * XFactor); pVertexDefinition[3].Y = 1.0f - (2.0f * YFactor); pVertexDefinition[3].X = -1.0f + (2.0f * XFactor); } void VertexTranslate(CUSTOMVERTEX *pVertexDefinition, float X, float Y) { pVertexDefinition[0].X += X; pVertexDefinition[0].Y += Y; pVertexDefinition[1].X += X; pVertexDefinition[1].Y += Y; pVertexDefinition[2].X += X; pVertexDefinition[2].Y += Y; pVertexDefinition[3].X += X; pVertexDefinition[3].Y += Y; pVertexDefinition[0].X = min(pVertexDefinition[0].X, 1.0f); pVertexDefinition[1].X = min(pVertexDefinition[1].X, 1.0f); pVertexDefinition[2].X = min(pVertexDefinition[2].X, 1.0f); pVertexDefinition[3].X = min(pVertexDefinition[3].X, 1.0f); } ",
      "wordCount": 479
    },
    {
      "id": "Examples_BoardSpecific_clarityuhd_MdigCrossBar_CPP_mdigcrossbar_cpp",
      "version": "2023100322",
      "title": "mdigcrossbar.cpp",
      "location": "Sample Code from MIL Examples",
      "text": " Top /********************************************************************************/ /* * File name: MDigCrossbar * Location: See Matrox Example Launcher in the MIL Control Center * * * Synopsis: This program implements a crossbar switch where * any video input can be sent to any video output. * * Features include: * - Picture-in-picture overlay. * - Automatic calculation of output to input latency. * - No tearing video output. * - Low latency video output. * - Moving vertical line. * - Microsoft Direct3D warp effects. * * Note: * - Displays are allocated in full-screen mode. * You must have at least 2 display outputs. * * - In order to measure the latency, a video DVI-D output * must be connected to an input. * * - To compile this project you must have Microsoft DirectX SDK * installed. * http://www.microsoft.com/en-us/download/details.aspx?id=6812 * * Possible 'S1023' error when you install the DirectX SDK: * This is a known issue and is explained in the Microsoft support knowledge base. * This error can be ignored. * For more information, refer to: http://support.microsoft.com/kb/2728613 * * - It is recommended to disable Windows Aero. * * Copyright (C) Matrox Electronic Systems Ltd., 1992-2023. * All Rights Reserved */ #include &lt;windows.h&gt; #include &lt;mil.h&gt; #include &lt;vector&gt; #include &lt;queue&gt; #include &lt;list&gt; #include &lt;d3d9.h&gt; #include \"md3ddisplayeffect.h\" #include \"mdisplay.h\" #include \"mdigitizer.h\" using namespace std; /**************************************************************************** Example description. ****************************************************************************/ void PrintHeader() { MosPrintf(MIL_TEXT(\"[EXAMPLE NAME]\\n\")); MosPrintf(MIL_TEXT(\"MDigCrossbar\\n\\n\")); MosPrintf(MIL_TEXT(\"[SYNOPSIS]\\n\")); MosPrintf(MIL_TEXT(\"This program implements a crossbar switch where\\n\")\\ MIL_TEXT(\"any video input can be sent to any video output. \\n\\n\")\\ MIL_TEXT(\"Features include:\\n\")\\ MIL_TEXT(\" - Picture-in-picture overlay.\\n\")\\ MIL_TEXT(\" - Automatic calculation of output to input latency.\\n\")\\ MIL_TEXT(\" - No tearing video output.\\n\")\\ MIL_TEXT(\" - Low latency video output.\\n\")\\ MIL_TEXT(\" - Moving vertical line.\\n\")\\ MIL_TEXT(\" - Microsoft Direct3D warp effects.\\n\")\\ MIL_TEXT(\"Note:\\n\")\\ MIL_TEXT(\" - Displays are allocated in full-screen mode.\\n\")\\ MIL_TEXT(\" You must have at least 2 display outputs.\\n\")\\ MIL_TEXT(\" - In order to measure the latency, a video DVI-D output\\n\")\\ MIL_TEXT(\" must be connected to an input.\\n\\n\")); MosPrintf(MIL_TEXT(\"[MODULES USED]\\n\")); MosPrintf(MIL_TEXT(\"Modules used: application, system, display, buffer, digitizer.\\n\\n\")); MosPrintf(MIL_TEXT(\"Press any key to continue.\\r\")); MosGetch(); } #define MAX_SYSTEMS 6 typedef struct _AUTODETECT { MIL_INT DigDeviceNumber; MIL_STRING DCFName; } AUTODETECT; AUTODETECT DCF_SCAN[] = { {M_DEV0, MIL_TEXT(\"AutoDetect.dcf\") }, {M_DEV1, MIL_TEXT(\"AutoDetect.dcf\") }, {M_DEV2, MIL_TEXT(\"AutoDetect.dcf\") }, {M_DEV3, MIL_TEXT(\"AutoDetect.dcf\") }, {M_DEV4, MIL_TEXT(\"AutoDetect.dcf\") }, {M_DEV5, MIL_TEXT(\"AutoDetect.dcf\") }, {M_DEV6, MIL_TEXT(\"AutoDetect.dcf\") }, {M_DEV7, MIL_TEXT(\"AutoDetect.dcf\") }, }; size_t DCF_SCAN_COUNT = (sizeof(DCF_SCAN) / sizeof(AUTODETECT)); MIL_INT MFTYPE ProcessingFunction(MIL_INT HookType, MIL_ID HookId, void* HookDataPtr); bool SystemSupportsCrossBar(MIL_ID MilSystem); int MosMain(void) { MIL_ID MilApplication; MIL_ID MilSystem[MAX_SYSTEMS] = { M_NULL, }; MIL_INT SystemIndex = 0; MIL_STRING SystemDescriptor; MIL_INT InputCount = 0; vector&lt;CDigitizer *&gt; DigitizerList; vector&lt;CDisplay *&gt; DisplayList; vector&lt;CDisplay *&gt;::iterator pDispIterator; vector&lt;CDigitizer *&gt;::iterator pDigIterator; LPDIRECT3D9EX g_pD3D = NULL; Direct3DCreate9Ex(D3D_SDK_VERSION, &amp;g_pD3D); if (!g_pD3D) { MosPrintf(MIL_TEXT(\"Cannot allocated LPDIRECT3D9EX object.\")); MosGetch(); exit(1); } /////////////////////////////////// // Allocate systems and digitizers. /////////////////////////////////// MappAlloc(M_DEFAULT, &amp;MilApplication); MappControl(M_ERROR, M_PRINT_DISABLE); MgraFont(M_DEFAULT, M_FONT_DEFAULT_MEDIUM); MgraControl(M_DEFAULT, M_BACKGROUND_MODE, M_TRANSPARENT); MsysAlloc(M_SYSTEM_DEFAULT, M_DEV0, M_DEFAULT, &amp;MilSystem[0]); if ( !SystemSupportsCrossBar(MilSystem[0]) ) { MappFreeDefault(MilApplication, MilSystem[0], M_NULL, M_NULL, M_NULL); return 1; } else { MsysInquire(MilSystem[0], M_SYSTEM_DESCRIPTOR, SystemDescriptor); MsysFree(MilSystem[0]); } PrintHeader(); InputCount = 0; for(SystemIndex = 0; SystemIndex &lt; MAX_SYSTEMS; SystemIndex++) { MsysAlloc(M_SYSTEM_DEFAULT, SystemIndex, M_DEFAULT, &amp;MilSystem[SystemIndex]); if(MilSystem[SystemIndex] == M_NULL) break; // Start camera detection and print detected inputs. MosPrintf(MIL_TEXT(\"\\n\")); MosPrintf(MIL_TEXT(\"----------------------------------------------------------\\n\")); MosPrintf(MIL_TEXT(\"Searching for input sources on Matrox %s device %d.\\n\"), SystemDescriptor.c_str(), (int)SystemIndex); MosPrintf(MIL_TEXT(\"----------------------------------------------------------\\n\\n\")); for(size_t ScanElement = 0; ScanElement &lt; DCF_SCAN_COUNT; ScanElement++) { CDigitizer *pDig = new CDigitizer(MilSystem[SystemIndex], DCF_SCAN[ScanElement].DigDeviceNumber, DCF_SCAN[ScanElement].DCFName, InputCount); if(pDig-&gt;Digitizer()) { InputCount++; DigitizerList.push_back(pDig); MosPrintf(MIL_TEXT(\" Dig %d: \\n\"), (int) DCF_SCAN[ScanElement].DigDeviceNumber); pDig-&gt;PrintDigitizerInfo(); } else { delete pDig; MosPrintf(MIL_TEXT(\" Dig %d: No input detected. \\n\"), (int) DCF_SCAN[ScanElement].DigDeviceNumber); } } } MappControl(M_ERROR, M_PRINT_ENABLE); if(DigitizerList.empty()) { MosPrintf(MIL_TEXT(\"\\n\\nNo input(s) detected, exiting.\\n\")); goto end; } /////////////////////////////////// // Allocate displays. /////////////////////////////////// MosPrintf(MIL_TEXT(\"\\n\\n\")); MosPrintf(MIL_TEXT(\"------------------------------------\\n\")); MosPrintf(MIL_TEXT(\"Allocating displays.\\n\")); MosPrintf(MIL_TEXT(\"------------------------------------\\n\\n\")); for(UINT i = 0; i &lt; 32; i++) { CDigitizer *pDig = NULL; MIL_INT DigSizeX = M_NULL; MIL_INT DigSizeY = M_NULL; if(i &lt; DigitizerList.size()) pDig = DigitizerList.at(i); if(pDig) { DigSizeX = pDig-&gt;SizeX(); DigSizeY = pDig-&gt;SizeY(); } CDisplay *pDisp = new CDisplay(MilSystem[0], i, g_pD3D); if(pDisp-&gt;IsAllocated()) { DisplayList.push_back(pDisp); pDisp-&gt;SetDisplaySource((MIL_INT64)pDig, DigSizeX, DigSizeY); } else { delete pDisp; } } HWND hForegroundWindow = GetForegroundWindow(); ::InvalidateRect(hForegroundWindow, NULL, TRUE); UpdateWindow(hForegroundWindow); MosPrintf(MIL_TEXT(\"\\nPress any key to start.\\n\")); MosGetchar(); /////////////////////////////////// // Start grabbing. /////////////////////////////////// if(DigitizerList.size()) { MosPrintf(MIL_TEXT(\"\\nStart grabbing from detected inputs:\\n\")); MosPrintf(MIL_TEXT(\"------------------------------------\\n\")); } for (pDigIterator = DigitizerList.begin(); pDigIterator!= DigitizerList.end(); pDigIterator++) { CDigitizer *pDig = *pDigIterator; pDig-&gt;SetUserData(&amp;DisplayList); Sleep(100); pDig-&gt;Start(ProcessingFunction); } Sleep(1000); SetPriorityClass(GetCurrentProcess(), REALTIME_PRIORITY_CLASS); ///////////////////////////////////////// // Print commands, status and statistics. ///////////////////////////////////////// MIL_INT Key = 0; while( Key != 'q' ) { MIL_INT ProcessFrameCount = 0; MIL_INT ProcessFrameMissed = 0; MIL_DOUBLE ProcessFrameRate = 0; bool FoundDviDigitalSource = false; Sleep(1000); system(\"cls\"); MosPrintf(MIL_TEXT(\"MdigCrossbar.\\n\")); MosPrintf(MIL_TEXT(\"-------------\\n\\n\")); MosPrintf(MIL_TEXT(\"Commands:\\n\")); MosPrintf(MIL_TEXT(\"---------\\n\")); MosPrintf(MIL_TEXT(\" Press:\\n\")); MosPrintf(MIL_TEXT(\" &lt;0 to %d&gt; to display the selected input on all outputs.\\n\"), (int) DigitizerList.size() - 1); MosPrintf(MIL_TEXT(\" &lt;s&gt; to display a selected input on a selected output.\\n\")); MosPrintf(MIL_TEXT(\" &lt;o&gt; to overlay a selected input on a selected output.\\n\")); MosPrintf(MIL_TEXT(\" &lt;h&gt; to display one input per output.\\n\")); MosPrintf(MIL_TEXT(\" &lt;r&gt; to toggle between 30fps and 60fps.\\n\")); MosPrintf(MIL_TEXT(\" &lt;d&gt; to enable/disable Direct3D effects.\\n\")); MosPrintf(MIL_TEXT(\" &lt;m&gt; to enable/disable drawing a moving line.\\n\")); MosPrintf(MIL_TEXT(\" &lt;l&gt; to calculate the latency between the output and the input.\\n\")); MosPrintf(MIL_TEXT(\" &lt;q&gt; to quit.\\n\")); MosPrintf(MIL_TEXT(\"\\n\")); Key = 0; if(MosKbhit()) Key = MosGetch(); MosPrintf(MIL_TEXT(\"Digitizers grabbing:\\n\")); MosPrintf(MIL_TEXT(\"--------------------\\n\")); // Print digitizer statistics. for (pDigIterator = DigitizerList.begin(); pDigIterator!= DigitizerList.end(); pDigIterator++) { CDigitizer *pDig = *pDigIterator; pDig-&gt;GetStatistics(&amp;ProcessFrameCount, &amp;ProcessFrameRate, &amp;ProcessFrameMissed); MosPrintf(MIL_TEXT(\"%4d (%4d x %4d @ %.1f Hz), Frame: %5d (missed: %2d). \"), pDig-&gt;Index(), pDig-&gt;SizeX(), pDig-&gt;SizeY(), ProcessFrameRate, ProcessFrameCount, ProcessFrameMissed); CDisplay *pDispLatencySource = (CDisplay *) pDig-&gt;GetSourceId(); if(pDispLatencySource &amp;&amp; pDispLatencySource-&gt;Latency()) { MIL_DOUBLE Cur, Min, Max, Average; MIL_INT CurInFrames, Count; pDispLatencySource-&gt;GetLatency(&amp;Cur, &amp;Min, &amp;Max, &amp;Average, &amp;CurInFrames, &amp;Count); MosPrintf(MIL_TEXT(\"Latency from disp %lld (in ms): Cur:%.1f (%lld frames), Min:%.1f, Max:%.1f, Avg:%.1f, Count:%lld \"), (long long)pDispLatencySource-&gt;Index(), Cur*1000.0, (long long)CurInFrames, Min*1000.0, Max*1000.0, Average*1000.0, (long long)Count); } MosPrintf(MIL_TEXT(\"\\n\")); // Toggle between 30fps and 60fps. if(Key == 'r') { if(pDig-&gt;GrabDecimation() == 1) pDig-&gt;GrabDecimation(2); else pDig-&gt;GrabDecimation(1); } // Disable/disable drawing a moving line. if(Key == 'm') pDig-&gt;MovingLine(!pDig-&gt;MovingLine()); } // Print display statistics. MosPrintf(MIL_TEXT(\"\\n\")); MosPrintf(MIL_TEXT(\"Displays:\\n\")); MosPrintf(MIL_TEXT(\"---------\\n\")); for (pDispIterator = DisplayList.begin(); pDispIterator!= DisplayList.end(); pDispIterator++) { MIL_INT DisplayCount, DisplaySkipCount; MIL_DOUBLE DisplayRefreshRate; CDisplay *pDisp = *pDispIterator; pDisp-&gt;GetStatistic(&amp;DisplayRefreshRate, &amp;DisplayCount, &amp;DisplaySkipCount); CDigitizer *pDig = (CDigitizer *) pDisp-&gt;GetDisplaySource(); MosPrintf(MIL_TEXT(\"%4d (%4d x %4d @ %.1f Hz) \"), pDisp-&gt;Index(), pDisp-&gt;SizeX(), pDisp-&gt;SizeY(), DisplayRefreshRate); if(pDig) { MosPrintf(MIL_TEXT(\"displaying from dig %d, Frame: %5lld (skip: %3lld). \"), (int)pDig-&gt;Index(), (long long)DisplayCount, (long long)DisplaySkipCount); } else MosPrintf(MIL_TEXT(\"not displaying.\")); MosPrintf(MIL_TEXT(\"\\n\")); // Display the selected input on all outputs. if(Key &gt;= '0' &amp;&amp; Key &lt;= '7') { MIL_UINT Index = Key - '0'; if(Index &lt; DigitizerList.size() &amp;&amp; Index &gt;= 0) { CDigitizer *pDig = DigitizerList.at(Index); pDisp-&gt;SetDisplaySource((MIL_INT64)pDig, pDig-&gt;SizeX(), pDig-&gt;SizeY()); } } // Display one input per output. if(Key == 'h') { if((MIL_UINT)pDisp-&gt;Index() &lt; DigitizerList.size()) { CDigitizer *pDig = DigitizerList.at(pDisp-&gt;Index()); pDisp-&gt;SetDisplaySource((MIL_INT64)pDig, pDig-&gt;SizeX(), pDig-&gt;SizeY()); } else { pDisp-&gt;SetDisplaySource(0, 0, 0); } } if(Key == 'r') pDisp-&gt;ResetStatistic(); // Enable/disable Direct3D effects. if(Key == 'd') pDisp-&gt;D3DEffect(!pDisp-&gt;D3DEffect()); // Calculate the latency between the output and the input. if(Key == 'l') { MIL_INT InputMode; for (pDigIterator = DigitizerList.begin(); pDigIterator!= DigitizerList.end(); pDigIterator++) { CDigitizer *pDig = *pDigIterator; MdigInquire(pDig-&gt;Digitizer(), M_INPUT_MODE, &amp;InputMode); if(InputMode == M_DIGITAL) { FoundDviDigitalSource = true; break; } } if(FoundDviDigitalSource) pDisp-&gt;Latency(!pDisp-&gt;Latency()); } } if((Key == 'l') &amp;&amp; (FoundDviDigitalSource == false)) MosPrintf(MIL_TEXT(\"\\nCan not calculate the latency, no DVI-D input sources detected.\")); // Display/Overlay a selected input on a selected output. if(Key == 's' || Key == 'o') { CDigitizer *pDig = NULL; CDisplay *pDisp = NULL; bool IsSelect = (Key == 's')? true: false; MIL_INT DispIndex = 0; MIL_INT DigIndex = 0; MosPrintf(MIL_TEXT(\"\\nSelect display number (0 to %d): \\n\"), (int) (DisplayList.size() ? DisplayList.size() - 1 : 0)); Key = MosGetch(); DispIndex = Key - '0'; if((UINT)DispIndex &lt; DisplayList.size() &amp;&amp; DispIndex &gt;= 0) { pDisp = DisplayList.at(DispIndex); MosPrintf(MIL_TEXT(\"Select digitizer number to be outputed on display %d: (0 to %d): \\n\"), (int)DispIndex, (int) DigitizerList.size() - 1); Key = MosGetch(); DigIndex = Key - '0'; if((UINT)DigIndex &lt; DigitizerList.size() &amp;&amp; DigIndex &gt;= 0) pDig = DigitizerList.at(DigIndex); if(IsSelect) { if(pDig) pDisp-&gt;SetDisplaySource((MIL_INT64)pDig, pDig-&gt;SizeX(), pDig-&gt;SizeY()); else pDisp-&gt;SetDisplaySource(0 , 0, 0); } else { if(pDig) pDisp-&gt;SetDisplayOverlaySource((MIL_INT64)pDig, pDig-&gt;SizeX(), pDig-&gt;SizeY()); else pDisp-&gt;SetDisplayOverlaySource(0 , 0, 0); } MosPrintf(MIL_TEXT(\"\\n\")); } } MosPrintf(MIL_TEXT(\"\\n\")); } end: ///////////////////////////////////////// // Exiting. ///////////////////////////////////////// MosPrintf(MIL_TEXT(\"Stopping grabs.\\n\")); for(pDigIterator = DigitizerList.begin(); pDigIterator!= DigitizerList.end(); pDigIterator++) { CDigitizer *pDig = *pDigIterator; pDig-&gt;Stop(); } MosPrintf(MIL_TEXT(\"Freeing displays.\\n\")); while(!DisplayList.empty()) { CDisplay *pDisp = DisplayList.back(); DisplayList.pop_back(); delete pDisp; } MosPrintf(MIL_TEXT(\"Freeing digitizers.\\n\")); while(!DigitizerList.empty()) { CDigitizer *pDig = DigitizerList.back(); DigitizerList.pop_back(); delete pDig; } MosPrintf(MIL_TEXT(\"Freeing systems.\\n\")); for(SystemIndex = 0; SystemIndex &lt; MAX_SYSTEMS; SystemIndex++) { if(MilSystem[SystemIndex]) MsysFree(MilSystem[SystemIndex]); } MappFree(MilApplication); g_pD3D-&gt;Release(); ::InvalidateRect(hForegroundWindow, NULL, TRUE); return 0; } ////////////////////////// // Grab callback function. MIL_INT MFTYPE ProcessingFunction(MIL_INT HookType, MIL_ID HookId, void* HookDataPtr) { CDigitizer *pDig = (CDigitizer *)HookDataPtr; CDisplay *pDisp = NULL; vector&lt;CDisplay *&gt; *pDisplayList; MIL_ID ModifiedBufferId; pDisplayList = (vector&lt;CDisplay *&gt; *)pDig-&gt;GetUserData(); if(pDisplayList-&gt;empty()) return 0; MdigGetHookInfo(HookId, M_MODIFIED_BUFFER+M_BUFFER_ID, &amp;ModifiedBufferId); MIL_ID DestBuffer = pDig-&gt;GetWorkBuffer(); MbufCopy(ModifiedBufferId, DestBuffer); // Loop all displays to find the displays that output this source. vector&lt;CDisplay *&gt;::iterator pDispit; for (pDispit = pDisplayList-&gt;begin(); pDispit!= pDisplayList-&gt;end(); pDispit++) { CDisplay *pDisp = *pDispit; if(pDisp-&gt;UpdateLatency(ModifiedBufferId)) pDig-&gt;SetSourceId((MIL_INT64)pDisp); // We found a display that outputs this source. Insert buffer in the display queue. if(pDisp-&gt;GetDisplaySource() == (MIL_INT64)pDig) pDisp-&gt;DisplayBuffer(DestBuffer); // We found a display that outputs on the overlay this source. // Insert buffer in the overlay display queue. if(pDisp-&gt;GetDisplayOverlaySource() == (MIL_INT64)pDig) pDisp-&gt;DisplayOverlayBuffer(DestBuffer); } return 0; } /* Verify whether this example can run on the selected system. */ bool SystemSupportsCrossBar(MIL_ID MilSystem) { MIL_INT SystemType = 0; MsysInquire(MilSystem, M_SYSTEM_TYPE, &amp;SystemType); if ( SystemType == M_SYSTEM_ORION_HD_TYPE || SystemType == M_SYSTEM_CLARITY_UHD_TYPE ) { return true; } MosPrintf(MIL_TEXT(\"This example program can only be used with the Matrox Driver for:\\n\") MIL_TEXT(\"Orion HD, Clarity UHD.\\n\\n\")); MosPrintf(MIL_TEXT(\"Please ensure that the default system type is set accordingly in \") MIL_TEXT(\"MIL Config.\\n\")); MosPrintf(MIL_TEXT(\"-----------------------------------------------------------------\") MIL_TEXT(\"----------- \\n\\n\")); MosPrintf(MIL_TEXT(\"Press any key to quit.\\n\")); MosGetch(); return false; } ",
      "wordCount": 1567
    },
    {
      "id": "Examples_BoardSpecific_clarityuhd_MdigCrossBar_CPP_mdigitizer_cpp",
      "version": "2023100322",
      "title": "mdigitizer.cpp",
      "location": "Sample Code from MIL Examples",
      "text": " Top /********************************************************************************/ /* * File name: Mdigitizer.cpp * Location: See Matrox Example Launcher in the MIL Control Center * * * Synopsis: This class manages a digitizer. * * It manages: * - The allocations of the grab buffers. * - The drawing of the moving line. * - The starting and stopping of a grab stream. * - The statistics. * * Copyright (C) Matrox Electronic Systems Ltd., 1992-2023. * All Rights Reserved */ #include &lt;windows.h&gt; #include &lt;mil.h&gt; #include &lt;queue&gt; #include &lt;list&gt; #include \"mdigitizer.h\" // Private. // Initialisation. void CDigitizer::Init(bool iAll) { m_IsAllocated = false; m_IsDeviceUsed = false; m_CameraPresent = false; m_MilDigitizer = M_NULL; m_DetectDCFName.clear(); memset(m_MilImageWork, 0, sizeof(m_MilImageWork)); memset(m_MilBuffers, 0, sizeof(m_MilBuffers)); m_GrabCount = 0; m_Index = 0; m_SizeX = 0; m_SizeY = 0; m_EnableMovingLine = true; m_GraLinePos = 0; m_GraLineDir = 0; m_LatencyFromDispIndex = -1; m_GrabHalfFrameRate = false; m_Decimation = 1; m_SourceId = 0; if(iAll) { m_MilSystem = M_NULL; m_MilDitizerMinimal = M_NULL; m_DigDeviceNumber = M_INVALID; m_Channel = M_INVALID; m_DCFName.clear(); m_ProcessingFunctionPtr = M_NULL; m_PrivateData = NULL; } } // Private. // Allocates the digitizer. bool CDigitizer::AllocateDigitizer(MIL_ID iMilSystem, MIL_INT DevNum, const MIL_STRING&amp; DCFName) { MIL_ID MilDigitizer; MdigAlloc(iMilSystem, DevNum, DCFName, M_DEFAULT, &amp;MilDigitizer); if(MilDigitizer) { if(m_Channel != M_CH0) Sleep(250); MdigInquire(MilDigitizer, M_CAMERA_PRESENT, &amp;m_CameraPresent); if(m_CameraPresent) { m_MilDigitizer = MilDigitizer; MdigInquire(m_MilDigitizer, M_SIZE_X, &amp;m_SizeX); MdigInquire(m_MilDigitizer, M_SIZE_Y, &amp;m_SizeY); } else MdigFree(MilDigitizer); } return m_MilDigitizer? true:false; } // Private. // Allocates the grab buffers. bool CDigitizer::AllocateBuffers(MIL_INT iIndex) { MIL_INT ReturnValue = 0; m_Index = iIndex; m_IsAllocated = false; if(m_MilDigitizer) { MdigControl(m_MilDigitizer, M_GRAB_TIMEOUT, 5000); for(MIL_INT Buf = 0; Buf &lt; MAX_BUFFERING; Buf++) { MbufAllocColor(m_MilSystem, 3, m_SizeX, m_SizeY, 8 + M_UNSIGNED, M_IMAGE + M_GRAB + M_BGR32 + M_PACKED, &amp;m_MilBuffers[Buf]); MbufAllocColor(M_DEFAULT_HOST, 3, m_SizeX, m_SizeY, 8 + M_UNSIGNED, M_IMAGE + M_YUV16 + M_PACKED + M_HOST_MEMORY, &amp;m_MilImageWork[Buf]); } m_IsAllocated = true; } return m_IsAllocated; } // Private. // Frees everything. void CDigitizer::Free(bool iAll) { if(m_MilDigitizer) { MdigFree(m_MilDigitizer); for(MIL_INT Buf = 0; Buf &lt; MAX_BUFFERING; Buf++) { if(m_MilBuffers[Buf]) { MbufFree(m_MilBuffers[Buf]); m_MilBuffers[Buf] = M_NULL; } if(m_MilImageWork[Buf]) { MbufFree(m_MilImageWork[Buf]); m_MilImageWork[Buf]; } } } if(iAll) { if(m_MilDitizerMinimal) MdigFree(m_MilDitizerMinimal); } Init(iAll); } // Public. // Prints to the console the details of the detected input. void CDigitizer::PrintDigitizerInfo() { MIL_STRING DCFFormat; MIL_INT InputMode; MIL_INT ScanMode; MIL_INT SizeX, SizeY, SizeBand; MIL_DOUBLE FrameRate; MIL_INT DigitizerNumber; MdigInquire(m_MilDigitizer, M_NUMBER, &amp;DigitizerNumber); MdigInquire(m_MilDigitizer, M_SIZE_X, &amp;SizeX); MdigInquire(m_MilDigitizer, M_SIZE_Y, &amp;SizeY); MdigInquire(m_MilDigitizer, M_SIZE_BAND, &amp;SizeBand); MdigInquire(m_MilDigitizer, M_INPUT_MODE, &amp;InputMode); MdigInquire(m_MilDigitizer, M_SCAN_MODE, &amp;ScanMode); MdigInquire(m_MilDigitizer, M_SELECTED_FRAME_RATE, &amp;FrameRate); MdigInquire(m_MilDigitizer, M_FORMAT_DETECTED, DCFFormat); MosPrintf(MIL_TEXT(\"\\t%lld x %lld, %d band(s). \"), (long long)SizeX, (long long)SizeY, (int)SizeBand); switch(InputMode) { case M_ANALOG: MosPrintf(MIL_TEXT(\"Analog \"));break; case M_DIGITAL: MosPrintf(MIL_TEXT(\"Digital \"));break; default: MosPrintf(MIL_TEXT(\" \")); } switch(ScanMode) { case M_PROGRESSIVE: MosPrintf(MIL_TEXT(\"progressive \"));break; case M_INTERLACE: MosPrintf(MIL_TEXT(\"interlaced \"));break; default: MosPrintf(MIL_TEXT(\" \")); } m_DetectDCFName = DCFFormat; MosPrintf(MIL_TEXT(\"@ %0.2f fps.\\n\"), FrameRate); MosPrintf(MIL_TEXT(\"\\tDCF: %s.\\n\\n\"), DCFFormat.c_str()); } // Public. // Start the grab stream. void CDigitizer::Start(MIL_BUF_HOOK_FUNCTION_PTR UserProcessingFunctionPtr) { m_ProcessingFunctionPtr = UserProcessingFunctionPtr; if(m_MilDigitizer) if(!IsAllocated()) AllocateBuffers(m_Index); if(IsAllocated()) { MdigProcess(m_MilDigitizer, m_MilBuffers, MAX_BUFFERING, M_START, M_DEFAULT, DigProcessingFunction, this); m_IsDeviceUsed = true; } } MIL_INT CDigitizer::PrepareForGrabbing() { MIL_INT lRetVal = 0; if(AllocateDigitizer(m_MilSystem, DeviceNumber(), GetDcfName())) MdigInquire(m_MilDigitizer, M_FORMAT_DETECTED, m_DetectDCFName); else lRetVal = M_INVALID; return lRetVal; } // Public. // Stops the grab stream. void CDigitizer::Stop() { if(IsDeviceUsed()) MdigProcess(m_MilDigitizer, m_MilBuffers, MAX_BUFFERING, M_STOP, M_DEFAULT, DigProcessingFunction, this); } MIL_INT CDigitizer::StopGrabbing() { MIL_INT lRetVal = 0; Stop(); Free(false); m_IsDeviceUsed = false; m_CameraPresent = false; m_DetectDCFName.clear(); return lRetVal; } // Public. // Returns grab statistics. void CDigitizer::GetStatistics(MIL_INT *FrameCount, MIL_DOUBLE *FrameRate, MIL_INT *FramesMissed) { if(FrameCount) MdigInquire(m_MilDigitizer, M_PROCESS_FRAME_COUNT, FrameCount); if(FrameRate) MdigInquire(m_MilDigitizer, M_PROCESS_FRAME_RATE, FrameRate); if(FramesMissed) MdigInquire(m_MilDigitizer, M_PROCESS_FRAME_MISSED, FramesMissed); } // Public. void CDigitizer::FreeDigitizer() { if(m_MilDigitizer) { MdigFree(m_MilDigitizer); m_MilDigitizer = M_NULL; } } // Public. void CDigitizer::UpdateDetectedDcfName() { if(m_MilDitizerMinimal) { MdigInquire(m_MilDitizerMinimal, M_CAMERA_PRESENT, &amp;m_CameraPresent); if(m_CameraPresent) MdigInquire(m_MilDitizerMinimal, M_FORMAT_DETECTED, m_DetectDCFName); } } bool CDigitizer::AllocateDigitizerMinimal(MIL_ID iMilSystem, MIL_INT DevNum, const MIL_STRING&amp; DCFName) { MdigAlloc(iMilSystem, DevNum, DCFName, M_MINIMAL, &amp;m_MilDitizerMinimal); if(m_MilDitizerMinimal) { MdigHookFunction(m_MilDitizerMinimal, M_CAMERA_PRESENT, CDigitizer::DigHookCameraPresent, this); UpdateDetectedDcfName(); } return m_MilDitizerMinimal? true:false; } // Private // Hook on Camera present. MIL_INT MFTYPE CDigitizer::DigHookCameraPresent(MIL_INT hookType, MIL_ID eventId, void *userData) { CDigitizer *pDig = (CDigitizer * )userData; MIL_INT CameraPresent; MdigInquire(pDig-&gt;MinimalDigitizer(), M_CAMERA_PRESENT, &amp;CameraPresent); #ifdef SHOW_CAMERA_PRESENT_STATUS if(!CameraPresent) MosPrintf(MIL_TEXT(\"Camera disconnected from dev:%d \\n\"),(int)pDig-&gt;DeviceNumber()); else MosPrintf(MIL_TEXT(\"Camera connected from dev:%d \\n\"),(int)pDig-&gt;DeviceNumber()); #endif MthrControl(pDig-&gt;GetEvent(), M_EVENT_SET, M_SIGNALED); return 0; } ",
      "wordCount": 658
    },
    {
      "id": "Examples_BoardSpecific_clarityuhd_MdigCrossBar_CPP_mdisplay_cpp",
      "version": "2023100322",
      "title": "mdisplay.cpp",
      "location": "Sample Code from MIL Examples",
      "text": " Top /********************************************************************************/ /* * File name: mdisplay.cpp * Location: See Matrox Example Launcher in the MIL Control Center * * * Synopsis: This class manages a display output. * * * A thread is created for each display. * When a DisplayBuffer() is called, * the buffer is inserted in a FIFO that * is consumed by the created thread. * * To calculate the latency between the output and a input, * a black pixel containing the display index is inserted on the output image * at offset 0,0. The black pixel is sent for 10 frames then a white pixel is sent. * When the white pixel is grabbed, the time difference is taken which is the latency. * * Copyright (C) Matrox Electronic Systems Ltd., 1992-2023. * All Rights Reserved */ #include &lt;windows.h&gt; #include &lt;oleauto.h&gt; #include &lt;commdlg.h&gt; #include &lt;mil.h&gt; #include &lt;queue&gt; #include &lt;list&gt; #include \"d3d9.h\" #include \"md3ddisplayeffect.h\" #include \"mdisplay.h\" using namespace std; // Private. // Initialisation. void CDisplay::Init() { m_Index = 0; m_SizeX = 0; m_SizeY = 0; memset(m_SourceSizeX, 0, sizeof(m_SourceSizeX)); memset(m_SourceSizeY, 0, sizeof(m_SourceSizeY)); m_DisplayFrameRate = 0.0; m_DisplayCount = 0; m_DisplayOverlayCount = 0; m_FrameSkip = 0; m_DisplayStartTime = 0; m_pD3DDevice = NULL; m_ThreadId = M_NULL; memset(m_pDst, 0, sizeof(m_pDst)); memset(m_pDstOverlay, 0, sizeof(m_pDstOverlay)); m_DisplayOverlayLastBuffer = NULL; m_DisplayOverlayEnable = false; m_pD3DFont = NULL; //m_pSwapChain = NULL; memset(m_SourceId, 0, sizeof(m_SourceId)); m_Latency.Init(); m_EnableD3DEffect = false; m_D3DEffect.Init(); m_DrawDisplayInfo = DRAW_DISPLAYINFO; m_Exit = false; m_IsAllocated = false; } // Public. // Allocates the display. bool CDisplay::Allocate(MIL_ID iMilSystem, MIL_INT iIndex, LPDIRECT3D9EX pD3D) { bool Success = false; Init(); m_DisplayModeEx.Size = sizeof(D3DDISPLAYMODEEX); HRESULT hr = pD3D-&gt;GetAdapterDisplayModeEx((UINT)iIndex + 1, &amp;m_DisplayModeEx, NULL); if (hr == D3D_OK) { m_SizeX = m_DisplayModeEx.Width; m_SizeY = m_DisplayModeEx.Height; m_Index = iIndex; D3DPRESENT_PARAMETERS d3dpp; memset(&amp;d3dpp, 0, sizeof(d3dpp)); d3dpp.Windowed = FALSE; d3dpp.SwapEffect = D3DSWAPEFFECT_FLIPEX; d3dpp.BackBufferWidth = m_DisplayModeEx.Width; d3dpp.BackBufferHeight = m_DisplayModeEx.Height; d3dpp.BackBufferFormat = m_DisplayModeEx.Format; d3dpp.FullScreen_RefreshRateInHz = m_DisplayModeEx.RefreshRate; d3dpp.BackBufferCount = MAX_DISPLAY_BUFFERING + 1; d3dpp.PresentationInterval = D3DPRESENT_INTERVAL_ONE; d3dpp.hDeviceWindow = GetDesktopWindow(); hr = pD3D-&gt;CreateDeviceEx((UINT)(iIndex + 1), D3DDEVTYPE_HAL, GetDesktopWindow(), D3DCREATE_HARDWARE_VERTEXPROCESSING | D3DCREATE_ENABLE_PRESENTSTATS | D3DCREATE_MULTITHREADED, &amp;d3dpp, &amp;m_DisplayModeEx, &amp;m_pD3DDevice); if (hr == D3D_OK) { D3DXCreateFont(m_pD3DDevice, // D3D device (INT)m_SizeY / 50, // Height (UINT)m_SizeX / 160, // Width FW_BOLD, // Weight 1, // MipLevels, 0 = autogen mipmaps FALSE, // Italic DEFAULT_CHARSET, // CharSet OUT_DEFAULT_PRECIS, // OutputPrecision DEFAULT_QUALITY, // Quality DEFAULT_PITCH | FF_DONTCARE, // PitchAndFamily MIL_TEXT(\"Arial\"), // pFaceName &amp;m_pD3DFont); // ppFont m_pD3DDevice-&gt;GetSwapChain(0, &amp;m_pSwapChain); m_pSwapChain-&gt;QueryInterface(IID_IDirect3DSwapChain9Ex, reinterpret_cast&lt;void **&gt;(&amp;m_pSwapChainEx)); InitializeCriticalSection(&amp;m_CSLock); InitializeCriticalSection(&amp;m_ReallocationLock); MthrAlloc(iMilSystem, M_THREAD, M_DEFAULT, &amp;DispUpdateThread, (void *)this, &amp;m_ThreadId); MosPrintf(MIL_TEXT(\"Allocating display %d (%lld x %lld @ %lldHz %s)\\n\"), (int)iIndex, (long long)m_DisplayModeEx.Width, (long long)m_DisplayModeEx.Height, (long long)m_DisplayModeEx.RefreshRate, (m_DisplayModeEx.ScanLineOrdering == D3DSCANLINEORDERING_INTERLACED) ? MIL_TEXT(\"interlaced\") : MIL_TEXT(\"progressive\")); m_pD3DDevice-&gt;SetMaximumFrameLatency(2); } // Is everything allocated. if (m_pD3DDevice &amp;&amp; m_pD3DFont &amp;&amp; m_pSwapChain &amp;&amp; m_ThreadId) Success = true; } m_IsAllocated = Success; return Success; } // Private. // Frees everything. void CDisplay::Free() { m_Exit = true; if (m_IsAllocated) { MthrWait(m_ThreadId, M_THREAD_END_WAIT, M_NULL); MthrFree(m_ThreadId); m_pD3DDevice-&gt;Release(); for (MIL_INT i = 0; i &lt; MAX_DISPLAY_BUFFERING; i++) { if (m_pDst[i]) m_pDst[i]-&gt;Release(); if (m_pDstOverlay[i]) m_pDstOverlay[i]-&gt;Release(); } m_pD3DFont-&gt;Release(); DeleteCriticalSection(&amp;m_CSLock); DeleteCriticalSection(&amp;m_ReallocationLock); m_D3DEffect.Free(); Init(); m_IsAllocated = false; } } // Public. // Sets the display input source ID, reallocates internal buffers matching the input size. void CDisplay::SetDisplaySource(MIL_INT64 iSourceId, MIL_INT iSizeX, MIL_INT iSizeY) { EnterCriticalSection(&amp;m_ReallocationLock); EnterCriticalSection(&amp;m_CSLock); // Empty fifos. while (!m_DisplayQueue.empty()) m_DisplayQueue.pop(); for (MIL_INT i = 0; i &lt; MAX_DISPLAY_BUFFERING; i++) { if (m_pDst[i]) { m_pDst[i]-&gt;Release(); m_pDst[i] = NULL; } } for (MIL_INT i = 0; i &lt; MAX_DISPLAY_BUFFERING; i++) { if (iSourceId &amp;&amp; iSizeX &amp;&amp; iSizeY) { m_SourceSizeX[0] = iSizeX; m_SourceSizeY[0] = iSizeY; m_pD3DDevice-&gt;CreateOffscreenPlainSurface((UINT)m_SourceSizeX[0], (UINT)m_SourceSizeY[0], D3DFMT_YUY2, D3DPOOL_DEFAULT, &amp;m_pDst[i], NULL); } } m_SourceId[0] = iSourceId; ResetStatistic(); LPDIRECT3DSURFACE9 pBackBuffer; m_pSwapChainEx-&gt;GetBackBuffer(0, D3DBACKBUFFER_TYPE_MONO, &amp;pBackBuffer); if (m_pDst[0]) { D3DLOCKED_RECT LockRect; LockRect.pBits = 0; while (LockRect.pBits == 0) m_pDst[0]-&gt;LockRect(&amp;LockRect, NULL, 0); memset(LockRect.pBits, 127, LockRect.Pitch * m_SourceSizeY[0]); m_pDst[0]-&gt;UnlockRect(); } m_pD3DDevice-&gt;StretchRect(m_pDst[0], NULL, pBackBuffer, NULL, D3DTEXF_NONE); m_pD3DDevice-&gt;PresentEx(0, 0, 0, 0, 0); LeaveCriticalSection(&amp;m_CSLock); LeaveCriticalSection(&amp;m_ReallocationLock); } // Public. // Sets the display overlay input source ID, reallocates internal buffers matching the input size. void CDisplay::SetDisplayOverlaySource(MIL_INT64 iSourceId, MIL_INT iSizeX, MIL_INT iSizeY) { EnterCriticalSection(&amp;m_ReallocationLock); EnterCriticalSection(&amp;m_CSLock); m_DisplayOverlayEnable = false; // Empty fifos. while (!m_DisplayOverlayQueue.empty()) m_DisplayOverlayQueue.pop(); for (MIL_INT i = 0; i &lt; MAX_DISPLAY_BUFFERING; i++) { if (m_pDstOverlay[i]) { m_pDstOverlay[i]-&gt;Release(); m_pDstOverlay[i] = NULL; } } for (MIL_INT i = 0; i &lt; MAX_DISPLAY_BUFFERING; i++) { if (iSourceId &amp;&amp; iSizeX &amp;&amp; iSizeY) { m_DisplayOverlayEnable = true; m_SourceSizeX[1] = iSizeX; m_SourceSizeY[1] = iSizeY; m_pD3DDevice-&gt;CreateOffscreenPlainSurface((UINT)m_SourceSizeX[1], (UINT)m_SourceSizeY[1], D3DFMT_YUY2, D3DPOOL_DEFAULT, &amp;m_pDstOverlay[i], NULL); } } m_SourceId[1] = iSourceId; m_DisplayOverlayLastBuffer = NULL; LeaveCriticalSection(&amp;m_CSLock); LeaveCriticalSection(&amp;m_ReallocationLock); } // Public. // Reset the statistics. void CDisplay::ResetStatistic() { m_DisplayFrameRate = 0; m_DisplayCount = 0; m_DisplayOverlayCount = 0; m_FrameSkip = 0; } // Public. // Returns the display statistics. void CDisplay::GetStatistic(MIL_DOUBLE *FrameRate, MIL_INT *FrameCount, MIL_INT *FramesSkipped) { if (FrameRate) *FrameRate = m_DisplayFrameRate; if (FrameCount) *FrameCount = m_DisplayCount; if (*FramesSkipped) *FramesSkipped = m_FrameSkip; } // Public. // This function update the display with the buffer. bool CDisplay::DisplayBuffer(MIL_ID iBuffer) { EnterCriticalSection(&amp;m_CSLock); while (m_DisplayQueue.size() &gt;= MAX_DISPLAY_BUFFERING) { m_FrameSkip++; m_DisplayQueue.pop(); } m_DisplayQueue.push(iBuffer); LeaveCriticalSection(&amp;m_CSLock); return true; } // Public. // This function update the overlay with the buffer. bool CDisplay::DisplayOverlayBuffer(MIL_ID iBuffer) { // Update the overlay at half the rate. if (m_DisplayOverlayEnable) { m_DisplayOverlayCount++; if (m_DisplayOverlayCount % 2 == 0) return false; } EnterCriticalSection(&amp;m_CSLock); while (m_DisplayOverlayQueue.size() &gt;= MAX_DISPLAY_BUFFERING) m_DisplayOverlayQueue.pop(); m_DisplayOverlayQueue.push(iBuffer); LeaveCriticalSection(&amp;m_CSLock); return true; } // Public. // Calculates the latency. The unmodified grab buffer is used to read the latency tag. bool CDisplay::UpdateLatency(MIL_ID iBuffer) { bool IsBufferFromThisDisplay = false; // Calculate latency. if (m_Latency.Enable &amp;&amp; (m_Latency.State == eLATENCY_LATCH_WAITING_FOR_TAG)) { MIL_UINT32 PixelValue = 0; MbufGet2d(iBuffer, 0, 0, 1, 1, &amp;PixelValue); MIL_INT TagValue = ((PixelValue &gt;&gt; 8) &amp; 0xffff); MIL_INT DisplayIndex = ((PixelValue)&amp; 0xff) - 10; // Is buffer from this display. if (m_Index == DisplayIndex) IsBufferFromThisDisplay = true; // White image, now lets measure the latency. if ((TagValue == 0xf0f0) &amp;&amp; IsBufferFromThisDisplay) m_Latency.State = eLATENCY_READ_LATENCY; } return IsBufferFromThisDisplay; } // Public. // Enable/disable latency calculation. void CDisplay::Latency(bool State) { m_Latency.Init(); m_Latency.Enable = State; } // Public. // Returns if latency calculation is enabled. bool CDisplay::Latency() { return m_Latency.Enable; } // Public. // Returns latency results. bool CDisplay::GetLatency(MIL_DOUBLE *Cur, MIL_DOUBLE *Min, MIL_DOUBLE *Max, MIL_DOUBLE *Average, MIL_INT *CurInFrames, MIL_INT *Count) { *Cur = 0.0; *Min = 0.0; *Max = 0.0; *Average = 0.0; *CurInFrames = 0; *Count = 0; if (m_Latency.Enable) { if (Cur) *Cur = m_Latency.Cur; if (Min) *Min = m_Latency.Min; if (Max) *Max = m_Latency.Max; if (Average &amp;&amp; m_Latency.AverageCount) { *Average = (m_Latency.Average / (MIL_DOUBLE)m_Latency.AverageCount); } if (CurInFrames) *CurInFrames = m_Latency.LatencyInFrames; if (Count) *Count = m_Latency.AverageCount; } return m_Latency.Enable; } // Public. // Enable/disable Direct3D effects. void CDisplay::D3DEffect(bool State) { m_EnableD3DEffect = State; } // Public. // Returns if Direct3D effects is enabled. bool CDisplay::D3DEffect() { return m_EnableD3DEffect; } // Private. // Copies the image from the host to the board for display. void CDisplay::UpdateDisplay(CDisplay *pDisp, MIL_ID SourceBuf, MIL_ID OverlayBuf) { unsigned char *pSrcData = 0; MIL_INT SrcSizeX, SrcSizeY, SrcPitchByte; D3DLOCKED_RECT LockRect; MIL_ID SrcBuffers[2] = { SourceBuf, OverlayBuf }; MIL_INT BufferIndex = pDisp-&gt;m_DisplayCount%MAX_DISPLAY_BUFFERING; if (!pDisp-&gt;m_SourceId) return; MIL_DOUBLE lCurTime = 0; MappTimer(M_TIMER_READ + M_GLOBAL, &amp;lCurTime); if (pDisp-&gt;m_DisplayCount == 0) pDisp-&gt;m_DisplayStartTime = lCurTime; LPDIRECT3DSURFACE9 pDest[2] = { pDisp-&gt;m_pDst[BufferIndex], pDisp-&gt;m_pDstOverlay[BufferIndex] }; if (!pDest[0]) return; pDisp-&gt;m_DisplayCount++; m_DisplayFrameRate = (pDisp-&gt;m_DisplayCount) / (lCurTime - pDisp-&gt;m_DisplayStartTime); // Copy the buffers (main image and overlay) into on-board video memory. for (MIL_INT i = 0; (i &lt; 2) &amp;&amp; SrcBuffers[i] &amp;&amp; pDest[i]; i++) { MbufInquire(SrcBuffers[i], M_HOST_ADDRESS, &amp;pSrcData); MbufInquire(SrcBuffers[i], M_SIZE_X, &amp;SrcSizeX); MbufInquire(SrcBuffers[i], M_SIZE_Y, &amp;SrcSizeY); MbufInquire(SrcBuffers[i], M_PITCH_BYTE, &amp;SrcPitchByte); LockRect.pBits = 0; // Buffer is YUV16 if ((SrcSizeX == pDisp-&gt;m_SourceSizeX[i]) &amp;&amp; (SrcSizeY == pDisp-&gt;m_SourceSizeY[i])) { while (LockRect.pBits == 0) { pDest[i]-&gt;LockRect(&amp;LockRect, NULL, 0); } if (SrcPitchByte == LockRect.Pitch) { // When the pitchs are the same, use one memcpy. memcpy(LockRect.pBits, pSrcData, LockRect.Pitch * pDisp-&gt;m_SourceSizeY[i]); } else { // The pitchs are not the same, use memcpy per line. for (MIL_INT Line = 0; Line &lt; SrcSizeY; Line++) { unsigned char *pdestline = (unsigned char *)(((unsigned char *)LockRect.pBits) + (LockRect.Pitch * Line)); unsigned char *psrcline = pSrcData + (SrcPitchByte * Line); memcpy(pdestline, psrcline, SrcSizeX * 2); } } pDest[i]-&gt;UnlockRect(); } } LPDIRECT3DSURFACE9 pBackBuffer; pDisp-&gt;m_pSwapChainEx-&gt;GetBackBuffer(0, D3DBACKBUFFER_TYPE_MONO, &amp;pBackBuffer); if (pDisp-&gt;m_EnableD3DEffect) { DX9Processing(&amp;pDisp-&gt;m_D3DEffect, pDisp-&gt;m_pD3DDevice, pDest[0], pBackBuffer); } else { pDisp-&gt;m_pD3DDevice-&gt;StretchRect(pDest[0], NULL, pBackBuffer, NULL, D3DTEXF_NONE); } // Draw text. if (pDisp-&gt;m_DrawDisplayInfo) { MIL_STRING_STREAM Buf; Buf &lt;&lt; MIL_TEXT(\"Display:\") &lt;&lt; pDisp-&gt;m_Index &lt;&lt; MIL_TEXT(\" \"); RECT rc; SetRect(&amp;rc, 10, 5, 0, 0); m_pD3DDevice-&gt;BeginScene(); pDisp-&gt;m_pD3DFont-&gt;DrawText(NULL, Buf.str().c_str(), -1, &amp;rc, DT_NOCLIP, D3DXCOLOR(1.0f, 1.0f, 1.0f, 1.0f)); m_pD3DDevice-&gt;EndScene(); } if (pDisp-&gt;m_DisplayOverlayEnable) { RECT rect; rect.right = (LONG)pDisp-&gt;SizeX() / 3; rect.bottom = (LONG)pDisp-&gt;SizeY() / 3; rect.top = 90; rect.left = 50; // If no overlay buffer is present, use the last one. if (OverlayBuf == NULL) pDest[1] = m_DisplayOverlayLastBuffer; pDisp-&gt;m_pD3DDevice-&gt;StretchRect(pDest[1], NULL, pBackBuffer, &amp;rect, D3DTEXF_NONE); m_DisplayOverlayLastBuffer = pDest[1]; } pDisp-&gt;m_pD3DDevice-&gt;PresentEx(0, 0, 0, 0, D3DPRESENT_DONOTWAIT); // Calculate latency. if (pDisp-&gt;m_Latency.Enable) { RECT rect; rect.bottom = 1; rect.top = 0; rect.left = 0; rect.right = 1; if (pDisp-&gt;m_Latency.State == eLATENCY_DISABLE) { pDisp-&gt;m_Latency.StartCount = 10; pDisp-&gt;m_Latency.StartTime = 0.0; pDisp-&gt;m_Latency.State = eLATENCY_COUNTING; pDisp-&gt;m_Latency.LatencyInFramesCounter = 1; } else if (pDisp-&gt;m_Latency.State == eLATENCY_COUNTING) { // Now output 10 black images. The display index value is the R value // of the RGB output. pDisp-&gt;m_Latency.StartCount--; pDisp-&gt;m_pD3DDevice-&gt;ColorFill(pBackBuffer, &amp;rect, D3DCOLOR_XRGB(10 + pDisp-&gt;m_Index, 10, 10)); if (pDisp-&gt;m_Latency.StartCount == 0) pDisp-&gt;m_Latency.State = eLATENCY_LATCHING_TAG_IMAGE; } else if (pDisp-&gt;m_Latency.State == eLATENCY_LATCHING_TAG_IMAGE) { // Now output one white image; pDisp-&gt;m_pD3DDevice-&gt;ColorFill(pBackBuffer, &amp;rect, D3DCOLOR_XRGB(10 + pDisp-&gt;m_Index, 240, 240)); if (pDisp-&gt;m_Latency.StartTime == 0.0) pDisp-&gt;m_Latency.StartTime = lCurTime; pDisp-&gt;m_Latency.State = eLATENCY_LATCH_WAITING_FOR_TAG; pDisp-&gt;m_Latency.LatencyInFramesCounter = 1; } else if (pDisp-&gt;m_Latency.State == eLATENCY_LATCH_WAITING_FOR_TAG) { // Output one white image; pDisp-&gt;m_pD3DDevice-&gt;ColorFill(pBackBuffer, &amp;rect, D3DCOLOR_XRGB(10 + pDisp-&gt;m_Index, 240, 240)); pDisp-&gt;m_Latency.LatencyInFramesCounter++; } else if (pDisp-&gt;m_Latency.State == eLATENCY_READ_LATENCY) { // Now we read the latency. pDisp-&gt;m_Latency.EndTime = lCurTime; MIL_DOUBLE lLatency = pDisp-&gt;m_Latency.EndTime - pDisp-&gt;m_Latency.StartTime; if ((pDisp-&gt;m_Latency.Min == 0) || (lLatency &lt; pDisp-&gt;m_Latency.Min)) pDisp-&gt;m_Latency.Min = lLatency; if (lLatency &gt; pDisp-&gt;m_Latency.Max) pDisp-&gt;m_Latency.Max = lLatency; pDisp-&gt;m_Latency.Cur = lLatency; pDisp-&gt;m_Latency.Average += lLatency; pDisp-&gt;m_Latency.AverageCount++; pDisp-&gt;m_Latency.LatencyInFrames = pDisp-&gt;m_Latency.LatencyInFramesCounter; pDisp-&gt;m_Latency.State = eLATENCY_DISABLE; } } } ",
      "wordCount": 1590
    }
  ]
}]
[{
  "id": "Example_PlaceHolder_ID",
  "version": "2024020714",
  "title": "Example_PlaceHolder_Title",
  "wordCount": 0,
  "subEntries": [
    {
      "id": "Examples_Processing_3dReconstruction_DepthFromFocusInteractive_CPP_depthfromfocusinteractive_cpp",
      "version": "2024020714",
      "title": "depthfromfocusinteractive.cpp",
      "location": "Sample Code from MIL Examples",
      "text": " Top /***************************************************************************************/ /* * File name: DepthFromFocusInteractive.cpp * Location: See Matrox Example Launcher in the MIL Control Center * * * Synopsis: This program allows users to interactively load an index map and * the corresponding confidence map then show the index and corresponding * confidence values when clicking a spot on one of the maps. * Copyright (C) Matrox Electronic Systems Ltd., 1992-2024. * All Rights Reserved */ #include &lt;mil.h&gt; /* Example function prototype. */ void OnlineInteractiveIndexMapAndConfidenceMap(MIL_ID MilSystem, MIL_ID MilDisplay); /* Hook function when clicking on a map to show the index and confidence value */ MIL_INT MFTYPE ShowIndexConfidenceValues(MIL_INT HookType, MIL_ID EventId, void* UserDataPtr); /* Hook data when clicking on a map to show the index and confidence value */ struct HookDataInteractive { MIL_ID MilDisplayConfidence; MIL_ID ConfidenceImage; MIL_ID MilOverlayConfidence; MIL_INT ConfidenceTextColor; MIL_INT ConfidenceOverlayTransparentColor; MIL_ID MilDisplayIndex; MIL_ID IndexImage; MIL_ID MilOverlayIndex; MIL_INT IndexTextColor; MIL_INT IndexOverlayTransparentColor; }; /* Utility function. */ void RemapDisplayRangeTo8Bits(MIL_ID MilSystem, MIL_ID MilDisplay, MIL_ID MilScrImage, MIL_ID MilDisplayedImage); /* Source images directory. */ #define IMAGES_DIR_SOURCE_BOTTLE M_IMAGE_PATH MIL_TEXT(\"DepthFromFocus/BottleFocusStackingImages\") /* Constants for online depth from focus computations of the index map and the confidence map. */ const MIL_INT NB_IMG_BOTTLE = 101; const MIL_INT SIZE_X_IMG_BOTTLE = 512; const MIL_INT SIZE_Y_IMG_BOTTLE = 672; const MIL_INT BUFFER_SIZE = 5; const MIL_DOUBLE CONFIDENCE_THRESHOLD = 3.0; /*****************************************************************************/ /* Example description. */ /*****************************************************************************/ void PrintHeader() { MosPrintf(MIL_TEXT(\"[EXAMPLE NAME]\\n\") MIL_TEXT(\"DepthFromFocusInteractive\\n\\n\") MIL_TEXT(\"[SYNOPSIS]\\n\") MIL_TEXT(\"This program allows users to interactively load an index\\n\") MIL_TEXT(\"map and the corresponding confidence map resulting from\\n\") MIL_TEXT(\"depth-from-focus registration operation then show the\\n\") MIL_TEXT(\"index and corresponding confidence values when clicking\\n\") MIL_TEXT(\"on one of the maps.\\n\\n\") MIL_TEXT(\"[MODULES USED]\\n\") MIL_TEXT(\"Modules used: Application, System, Display,\\n\") MIL_TEXT(\"Buffer, Image Processing, Registration.\\n\\n\")); MosPrintf(MIL_TEXT(\"Press any key to continue.\\n\\n\")); MosGetch(); } /*****************************************************************************/ /* Ask the user for interactive method choice. */ /*****************************************************************************/ MIL_INT AskForInteractive() { // Ask the user if he wants to run the example in interactive mode. MosPrintf(MIL_TEXT(\"Option:\\n-Press &lt;ENTER&gt; or '1' to generate the index map\\n\") MIL_TEXT(\"and the corresponding confidence map using the images in:\\n\") MIL_TEXT(\"\\\"Matrox Imaging\\\\Images\\\\DepthFromFocus\\\\BottleFocusStackingImages\\\".\\n\") MIL_TEXT(\"\\n-Press '2' to restore an index map and the corresponding\\n\") MIL_TEXT(\"confidence map from disk.\\n\\n\")); MIL_INT ch; do { ch = MosGetch(); if (ch == '\\r') ch = '1'; } while (ch != '1' &amp;&amp; ch != '2'); return ch; } int MosMain() { MIL_ID MilApplication, /* Application identifier. */ MilSystem, /* System identifier. */ MilDisplay; /* Display identifier. */ PrintHeader(); /* Allocate application, system and display. */ MappAlloc(MIL_TEXT(\"M_DEFAULT\"), M_DEFAULT, &amp;MilApplication); MsysAlloc(M_DEFAULT, M_SYSTEM_HOST, M_DEFAULT, M_DEFAULT, &amp;MilSystem); MdispAlloc(MilSystem, M_DEFAULT, MIL_TEXT(\"M_DEFAULT\"), M_WINDOWED, &amp;MilDisplay); /* Example to show the index and confidence interactively. */ OnlineInteractiveIndexMapAndConfidenceMap(MilSystem, MilDisplay); /* Free application, system and display. */ MdispFree(MilDisplay); MsysFree(MilSystem); MappFree(MilApplication); return 0; } /*******************************************************************************************/ /* Online depth from focus with specified context and result. */ /*******************************************************************************************/ /* User's processing function hook data structure. */ typedef struct { MIL_ID RegContext; MIL_ID RegResult; MIL_ID Display; } HookDataStruct; /* User's processing function called every time a grab buffer is ready. */ MIL_INT MFTYPE ProcessingFunction(MIL_INT HookType, MIL_ID HookId, void* UserDataPtr) { HookDataStruct* UserStruct = (HookDataStruct*)UserDataPtr; /* Retrieve the MIL_ID of the grabbed buffer. */ MIL_ID ModifiedBufferId; MdigGetHookInfo(HookId, M_MODIFIED_BUFFER + M_BUFFER_ID, &amp;ModifiedBufferId); /* Display the image to be loaded. */ MdispSelect(UserStruct-&gt;Display, ModifiedBufferId); MosSleep(30); /* Accumulate the current buffer in the registration result. */ MregCalculate(UserStruct-&gt;RegContext, &amp;ModifiedBufferId, UserStruct-&gt;RegResult, 1, M_ACCUMULATE_AND_COMPUTE); return 0; } /*************************************************************************************************/ /* Online depth from focus with specified context and result and the use of the confidence map. */ /*************************************************************************************************/ void OnlineInteractiveIndexMapAndConfidenceMap(MIL_ID MilSystem, MIL_ID MilDisplay) { MIL_ID IndexMap, /* Id of the index map image. */ DisplayedIndexMap, /* Id of the remapped index map for a better display contrast. */ ConfidenceMap, /* Id of the confidence map image. */ DisplayedConfidenceMap, /* Id of the remapped confidence map for a better display contrast. */ RelevantResult, /* Id of the relevant result image. */ RegContext, /* Id of the registration context. */ RegResult, /* Id of the registration result. */ DigId; /* Id of the digitizer used to read the images. */ HookDataStruct UserHookData; /* User's processing function data structure. */ /* Allocating the depth from focus registration objects. */ RegContext = MregAlloc(MilSystem, M_DEPTH_FROM_FOCUS, M_DEFAULT, M_NULL); RegResult = MregAllocResult(MilSystem, M_DEPTH_FROM_FOCUS_RESULT, M_NULL); /* Allocating the digitizer. */ DigId = MdigAlloc(MilSystem, M_DEFAULT, IMAGES_DIR_SOURCE_BOTTLE, M_EMULATED, M_NULL); /* Setting the registration context parameters. */ MregControl(RegContext, M_DEFAULT, M_REGULARIZATION_MODE, M_AVERAGE); MregControl(RegContext, M_DEFAULT, M_REGULARIZATION_SIZE, 8); MregControl(RegContext, M_DEFAULT, M_CONFIDENCE_MAP, M_ENABLE); /* Initialize the user's processing function data structure. */ UserHookData.RegContext = RegContext; UserHookData.RegResult = RegResult; UserHookData.Display = MilDisplay; MIL_UNIQUE_DISP_ID MilDisplay2 = MdispAlloc(MilSystem, M_DEFAULT, MIL_TEXT(\"M_DEFAULT\"), M_WINDOWED, M_UNIQUE_ID); CHOOSE_IMAGES: if (AskForInteractive() == '1') { /* Allocating the sequence of images. */ MIL_ID ImagesArray[BUFFER_SIZE] = { 0 }; for (MIL_INT NumImg = 0; NumImg &lt; BUFFER_SIZE; NumImg++) { MbufAlloc2d(MilSystem, SIZE_X_IMG_BOTTLE, SIZE_Y_IMG_BOTTLE, 8 + M_UNSIGNED, M_IMAGE + M_DISP + M_PROC + M_GRAB, &amp;ImagesArray[NumImg]); } /* Allocating the other buffers. */ MbufAlloc2d(MilSystem, SIZE_X_IMG_BOTTLE, SIZE_Y_IMG_BOTTLE, 8 + M_UNSIGNED, M_IMAGE + M_DISP + M_PROC, &amp;IndexMap); MbufAlloc2d(MilSystem, SIZE_X_IMG_BOTTLE, SIZE_Y_IMG_BOTTLE, 8 + M_UNSIGNED, M_IMAGE + M_DISP + M_PROC, &amp;DisplayedIndexMap); MbufAlloc2d(MilSystem, SIZE_X_IMG_BOTTLE, SIZE_Y_IMG_BOTTLE, 32 + M_FLOAT, M_IMAGE + M_DISP + M_PROC, &amp;ConfidenceMap); MbufAlloc2d(MilSystem, SIZE_X_IMG_BOTTLE, SIZE_Y_IMG_BOTTLE, 32 + M_FLOAT, M_IMAGE + M_DISP + M_PROC, &amp;DisplayedConfidenceMap); MbufAlloc2d(MilSystem, SIZE_X_IMG_BOTTLE, SIZE_Y_IMG_BOTTLE, 32 + M_FLOAT, M_IMAGE + M_DISP + M_PROC, &amp;RelevantResult); /* Reading the current image. */ /* A pattern has been casted on the smooth surface of the object using a high power structured lighting such as EFFI-Lase by ®Effilux.*/ MosPrintf(MIL_TEXT(\"The images are being loaded and processed...\\n\")); MdigProcess(DigId, ImagesArray, BUFFER_SIZE, M_SEQUENCE + M_COUNT(NB_IMG_BOTTLE), M_DEFAULT, ProcessingFunction, &amp;UserHookData); MosPrintf(MIL_TEXT(\"A stack of %d images has been processed.\\n\\n\"), NB_IMG_BOTTLE); /* Get the index map image. */ MregDraw(M_DEFAULT, RegResult, IndexMap, M_DRAW_DEPTH_INDEX_MAP, M_DEFAULT, M_DEFAULT); /* Get the confidence map image. */ MregDraw(M_DEFAULT, RegResult, ConfidenceMap, M_DRAW_DEPTH_CONFIDENCE_MAP, M_DEFAULT, M_DEFAULT); /* Threshold the confidence map to keep the relevant result only. */ MimBinarize(ConfidenceMap, RelevantResult, M_FIXED + M_GREATER, CONFIDENCE_THRESHOLD, M_NULL); /* Correct the index map. */ /* Areas where confidences are lower than threshold are masked to 0. */ MimArith(IndexMap, RelevantResult, IndexMap, M_MULT); for (MIL_INT NumImg = 0; NumImg &lt; BUFFER_SIZE; NumImg++) { MbufFree(ImagesArray[NumImg]); } MbufFree(RelevantResult); } else { MosPrintf(MIL_TEXT(\"Choose the index map:\\n\")); MappControl(M_ERROR, M_PRINT_DISABLE); MbufRestore(M_INTERACTIVE, MilSystem, &amp;IndexMap); MappControl(M_ERROR, M_PRINT_ENABLE); if (IndexMap == M_NULL) goto CHOOSE_IMAGES; MosPrintf(MIL_TEXT(\"Choose the corresponding confidence map:\\n\\n\")); MappControl(M_ERROR, M_PRINT_DISABLE); MbufRestore(M_INTERACTIVE, MilSystem, &amp;ConfidenceMap); MappControl(M_ERROR, M_PRINT_ENABLE); if (ConfidenceMap == M_NULL) { if (IndexMap != M_NULL) MbufFree(IndexMap); goto CHOOSE_IMAGES; } MIL_INT sizeX = MbufInquire(IndexMap, M_SIZE_X, M_NULL); MIL_INT sizeY = MbufInquire(IndexMap, M_SIZE_Y, M_NULL); MbufAlloc2d(MilSystem, sizeX, sizeY, 8 + M_UNSIGNED, M_IMAGE + M_DISP + M_PROC, &amp;DisplayedIndexMap); MbufAlloc2d(MilSystem, sizeX, sizeY, 32 + M_FLOAT, M_IMAGE + M_DISP + M_PROC, &amp;DisplayedConfidenceMap); } /* Display the index map image. */ RemapDisplayRangeTo8Bits(MilSystem, MilDisplay, IndexMap, DisplayedIndexMap); MdispControl(MilDisplay, M_TITLE, MIL_TEXT(\"Index Map\")); /* Display the confidence map image. */ MdispControl(MilDisplay2, M_WINDOW_INITIAL_POSITION_X, MbufInquire(IndexMap, M_SIZE_X, 0)); MdispControl(MilDisplay2, M_TITLE, MIL_TEXT(\"Confidence Map\")); RemapDisplayRangeTo8Bits(MilSystem, MilDisplay2, ConfidenceMap, DisplayedConfidenceMap); MosPrintf(MIL_TEXT(\"The Index and Confidence maps are displayed.\\n\\n\")); /* Assign data to the hook data struct. */ HookDataInteractive HookDataStruct; HookDataStruct.MilDisplayConfidence = MilDisplay2; HookDataStruct.ConfidenceImage = ConfidenceMap; HookDataStruct.MilOverlayConfidence = MdispInquire(MilDisplay2, M_OVERLAY_ID, M_NULL); HookDataStruct.ConfidenceTextColor = M_COLOR_RED; HookDataStruct.ConfidenceOverlayTransparentColor = MdispInquire(MilDisplay2, M_TRANSPARENT_COLOR, M_NULL); HookDataStruct.MilDisplayIndex = MilDisplay; HookDataStruct.IndexImage = IndexMap; HookDataStruct.MilOverlayIndex = MdispInquire(MilDisplay, M_OVERLAY_ID, M_NULL); HookDataStruct.IndexTextColor = M_COLOR_GREEN; HookDataStruct.IndexOverlayTransparentColor = MdispInquire(MilDisplay, M_TRANSPARENT_COLOR, M_NULL); MosPrintf(MIL_TEXT(\"- Left-click on the confidence map to show the confidence in red.\\n\")); MosPrintf(MIL_TEXT(\" The corresponding index will be shown on the index map in green.\\n\")); MosPrintf(MIL_TEXT(\"- Left-click on the index map to show the index in green.\\n\")); MosPrintf(MIL_TEXT(\" The corresponding confidence will be shown on the confidence map in red.\\n\")); MosPrintf(MIL_TEXT(\"- Press 'C' or 'c' to erase all the values.\\n\\n\")); MosPrintf(MIL_TEXT(\"- Press &lt;ENTER&gt; to finish.\\n\\n\")); /* Hook a function when the left button is clicked to show confidence and index at the clicked position. */ MdispHookFunction(MilDisplay2, M_MOUSE_LEFT_BUTTON_DOWN, ShowIndexConfidenceValues, &amp;HookDataStruct); /* Hook a function when 'c' or 'C' is pressed to clear the overlays. */ MdispHookFunction(MilDisplay2, M_KEY_CHAR, ShowIndexConfidenceValues, &amp;HookDataStruct); /* Hook a function when the left button is click to show confidence and index at the clicked position. */ MdispHookFunction(MilDisplay, M_MOUSE_LEFT_BUTTON_DOWN, ShowIndexConfidenceValues, &amp;HookDataStruct); /* Hook a function when 'c' or 'C' is pressed to clear the overlays. */ MdispHookFunction(MilDisplay, M_KEY_CHAR, ShowIndexConfidenceValues, &amp;HookDataStruct); /* Finish if &lt;Enter&gt; is pressed. */ MIL_INT Ch = 0; while (Ch != '\\r') { Ch = MosGetch(); } /* Unhook functions from the confidence display. */ MdispHookFunction(MilDisplay2, M_MOUSE_LEFT_BUTTON_DOWN + M_UNHOOK, ShowIndexConfidenceValues, &amp;HookDataStruct); MdispHookFunction(MilDisplay2, M_KEY_CHAR + M_UNHOOK, ShowIndexConfidenceValues, &amp;HookDataStruct); MdispHookFunction(MilDisplay, M_MOUSE_LEFT_BUTTON_DOWN + M_UNHOOK, ShowIndexConfidenceValues, &amp;HookDataStruct); MdispHookFunction(MilDisplay, M_KEY_CHAR + M_UNHOOK, ShowIndexConfidenceValues, &amp;HookDataStruct); /* Free buffers. */ MbufFree(IndexMap); MbufFree(DisplayedIndexMap); MbufFree(ConfidenceMap); MbufFree(DisplayedConfidenceMap); /* Free digitizer. */ MdigFree(DigId); /* Free registration objects. */ MregFree(RegResult); MregFree(RegContext); } void RemapDisplayRangeTo8Bits(MIL_ID MilSystem, MIL_ID MilDisplay, MIL_ID MilScrImage, MIL_ID MilDisplayedImage) { /* Allocate a statistics context and result to compute source's min and max values. */ MIL_ID MilStatContext = MimAlloc(MilSystem, M_STATISTICS_CONTEXT, M_DEFAULT, M_NULL); MimControl(MilStatContext, M_STAT_MIN, M_ENABLE); MimControl(MilStatContext, M_STAT_MAX, M_ENABLE); MIL_ID MilStatResult = MimAllocResult(MilSystem, M_DEFAULT, M_STATISTICS_RESULT, M_NULL); /* Allocate a ramp LUT that will map the dynamic range. */ MIL_ID MilDynRangeLut = MbufAlloc1d(MilSystem, 256, 8 + M_UNSIGNED, M_LUT, M_NULL); /* Compute source's minimum and maximum values. */ MimStatCalculate(MilStatContext, MilScrImage, MilStatResult, M_DEFAULT); /* Obtain the source's minimum value. */ MIL_INT StatMin; MimGetResult(MilStatResult, M_STAT_MIN + M_TYPE_MIL_INT, &amp;StatMin); /* Obtain the source's maximum value. */ MIL_INT StatMax; MimGetResult(MilStatResult, M_STAT_MAX + M_TYPE_MIL_INT, &amp;StatMax); /* Define a ramp LUT mapping. */ MbufClear(MilDynRangeLut, 0.0); MgenLutRamp(MilDynRangeLut, StatMin, 1.0, StatMax, 255.0); /* Perform the LUT mapping. */ MimLutMap(MilScrImage, MilDisplayedImage, MilDynRangeLut); /* Free allocations. */ MbufFree(MilDynRangeLut); MimFree(MilStatResult); MimFree(MilStatContext); /* Display the remapped image. */ MdispSelect(MilDisplay, MilDisplayedImage); } MIL_INT MFTYPE ShowIndexConfidenceValues(MIL_INT HookType, MIL_ID EventId, void* UserDataPtr) { MIL_DOUBLE PosX, PosY; HookDataInteractive* HookDataPtr = (HookDataInteractive*)UserDataPtr; MIL_INT KeyVal; MdispGetHookInfo(EventId, M_KEY_VALUE, &amp;KeyVal); if (KeyVal == 'c' || KeyVal == 'C') { /* Clear the mask image and annotations in the overlay. */ MdispControl(HookDataPtr-&gt;MilDisplayConfidence, M_OVERLAY_CLEAR, M_DEFAULT); MdispControl(HookDataPtr-&gt;MilDisplayIndex, M_OVERLAY_CLEAR, M_DEFAULT); return 0; } /* Inquire the mouse position in the displayed buffer. */ MdispGetHookInfo(EventId, M_MOUSE_POSITION_BUFFER_X, &amp;PosX); MdispGetHookInfo(EventId, M_MOUSE_POSITION_BUFFER_Y, &amp;PosY); if (((MIL_INT)PosX &lt; MbufInquire(HookDataPtr-&gt;ConfidenceImage, M_SIZE_X, M_NULL) &amp;&amp; (MIL_INT)PosX &gt; 0) &amp;&amp; ((MIL_INT)PosY &lt; MbufInquire(HookDataPtr-&gt;ConfidenceImage, M_SIZE_Y, M_NULL) &amp;&amp; (MIL_INT)PosY &gt; 0)) { /* Extract confidence and index using the mouse clicked position. */ float ConfidenceVal = 0.0; MIL_INT IndexVal = 0; /* Extract the confidence at the position that is the closest to the mouse clicked position. */ MbufGet2d(HookDataPtr-&gt;ConfidenceImage, (MIL_INT)(PosX + 0.5), (MIL_INT)(PosY + 0.5), 1, 1, &amp;ConfidenceVal); /* Write the confidence in the display overlay. */ MgraColor(M_DEFAULT, (MIL_DOUBLE)HookDataPtr-&gt;ConfidenceTextColor); MgraControl(M_DEFAULT, M_BACKGROUND_MODE, M_TRANSPARENT); MgraText(M_DEFAULT, HookDataPtr-&gt;MilOverlayConfidence, PosX, PosY, M_TO_STRING(ConfidenceVal)); /* Draw the cross at the clicked position on the confidence map */ MgraColor(M_DEFAULT, M_COLOR_YELLOW); MgraLine(M_DEFAULT, HookDataPtr-&gt;MilOverlayConfidence, (MIL_INT)(PosX + 0.5) - 4, (MIL_INT)(PosY + 0.5), (MIL_INT)(PosX + 0.5) + 4, (MIL_INT)(PosY + 0.5)); MgraLine(M_DEFAULT, HookDataPtr-&gt;MilOverlayConfidence, (MIL_INT)(PosX + 0.5), (MIL_INT)(PosY + 0.5) - 4, (MIL_INT)(PosX + 0.5), (MIL_INT)(PosY + 0.5) + 4); /* Extract the index at the position that is the closest to the mouse clicked position. */ MbufGet2d(HookDataPtr-&gt;IndexImage, (MIL_INT)(PosX + 0.5), (MIL_INT)(PosY + 0.5), 1, 1, &amp;IndexVal); /* Write the index in the display overlay. */ MgraColor(M_DEFAULT, (MIL_DOUBLE)HookDataPtr-&gt;IndexTextColor); MgraText(M_DEFAULT, HookDataPtr-&gt;MilOverlayIndex, PosX, PosY, M_TO_STRING(IndexVal)); /* Draw the cross at the clicked position on the index map */ MgraColor(M_DEFAULT, M_COLOR_YELLOW); MgraLine(M_DEFAULT, HookDataPtr-&gt;MilOverlayIndex, (MIL_INT)(PosX + 0.5) - 4, (MIL_INT)(PosY + 0.5), (MIL_INT)(PosX + 0.5) + 4, (MIL_INT)(PosY + 0.5)); MgraLine(M_DEFAULT, HookDataPtr-&gt;MilOverlayIndex, (MIL_INT)(PosX + 0.5), (MIL_INT)(PosY + 0.5) - 4, (MIL_INT)(PosX + 0.5), (MIL_INT)(PosY + 0.5) + 4); } return 0; } ",
      "wordCount": 1819
    }
  ]
}]
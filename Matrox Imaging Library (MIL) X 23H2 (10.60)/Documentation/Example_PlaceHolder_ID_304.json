[{
  "id": "Example_PlaceHolder_ID",
  "version": "2024020714",
  "title": "Example_PlaceHolder_Title",
  "wordCount": 0,
  "subEntries": [
    {
      "id": "Examples_Processing_ProductInspection_BottleCapAndContentInspection_CPP_bottlecapandcontentinspection_cpp",
      "version": "2024020714",
      "title": "bottlecapandcontentinspection.cpp",
      "location": "Sample Code from MIL Examples",
      "text": " Top //***************************************************************************************/ // // File name: BottleCapAndContentInspection.cpp // Location: See Matrox Example Launcher in the MIL Control Center // // // Synopsis: This program contains an example of bottle inspection using various modules. // See the PrintHeader() function below for detailed description. // // // Copyright (C) Matrox Electronic Systems Ltd., 1992-2024. // All Rights Reserved #include &lt;mil.h&gt; #include \"ExampleManager.h\" // Include the different tasks that can be performed. #include \"CapScrewInspection_CapAndContent.h\" #include \"ModelFinderAlignmentTask.h\" #include \"TargetAlignmentTask.h\" #include \"PositionInspection.h\" #include \"DefectDetectionTask.h\" #include \"SimpleFixture.h\" //**************************************************************************** // Example description. //**************************************************************************** void PrintHeader() { MosPrintf(MIL_TEXT(\"[EXAMPLE NAME]\\n\") MIL_TEXT(\"BottleCapAndContentInspection\\n\\n\") MIL_TEXT(\"[SYNOPSIS]\\n\") MIL_TEXT(\"This example shows some basic inspection steps for bottle caps\\n\") MIL_TEXT(\"and content. The following features will be inspected:\\n\") MIL_TEXT(\" 1. Surface defect detection\\n\") MIL_TEXT(\" 2. Fill level measurement \\n\") MIL_TEXT(\" 3. Cap screw verification\\n\\n\") MIL_TEXT(\"[MODULES USED]\\n\") MIL_TEXT(\"Modules used: Application, system, graphic, calibration, measurement, \\n\") MIL_TEXT(\" blob, model finder\\n\\n\") MIL_TEXT(\"[ADDITIONNAL INSTRUCTIONS]\\n\") MIL_TEXT(\"Left click on an image to view results in a zoomable display.\\n\\n\") MIL_TEXT(\"Press any key to continue.\\n\\n\")); MosGetch(); } //**************************************************************************** // General Constants. //**************************************************************************** #define ARRAY_COUNT(x) (sizeof((x))/sizeof((x)[0])) // for array on the stack only // Root filename. #define EXAMPLE_IMAGE_PATH M_IMAGE_PATH MIL_TEXT(\"BottleCapAndContentInspection/\") //**************************************************************************** // Product 0 : Mouth Wash //**************************************************************************** // Image path #define PRODUCT0_PATH EXAMPLE_IMAGE_PATH MIL_TEXT(\"Product0/\") //***************************************************************************** // Main. //***************************************************************************** int MosMain(void) { // Declare and the tasks associated to each image associated with the product. // Image 0: Empty bottle analysis. CTargetAlignmentTask Prod0TargetAlignment(PRODUCT0_PATH MIL_TEXT(\"BottleContour.mmf\"), PRODUCT0_PATH MIL_TEXT(\"EmptyBottleTemplate.mim\"), M_RED); CDefectDetectionTask Prod0DefectDetection(PRODUCT0_PATH MIL_TEXT(\"EmptyBottleTemplate.mim\"), PRODUCT0_PATH MIL_TEXT(\"EmptyBottleTemplateMask.mim\"), enAbsoluteDiff, enTriangleBisection, M_RED, &amp;Prod0TargetAlignment, &amp;Prod0TargetAlignment); // Image 1: Fill level analysis. CModAlignmentTask Prod0View1Alignment(PRODUCT0_PATH MIL_TEXT(\"BottleContour.mmf\"), M_RED); CSimpleFixture Prod0FillLevelFixture(0, 0, -90, &amp;Prod0View1Alignment); CPositionInspection Prod0FillLevel(PRODUCT0_PATH MIL_TEXT(\"FillLevel.mrk\"), MIL_TEXT(\"fill level\"), -170, 5, M_RED, &amp;Prod0FillLevelFixture); // Image 2: Cap analysis. CModAlignmentTask Prod0View2Alignment(PRODUCT0_PATH MIL_TEXT(\"BottleContour.mmf\"), M_RED); CSimpleFixture Prod0CapFixture(0, -330, 0, &amp;Prod0View2Alignment); CCapScrewInspection Prod0CapScrew(PRODUCT0_PATH MIL_TEXT(\"CapScrew.mrk\"), 5, 2, M_RED, &amp;Prod0CapFixture); CInspectionTask* Prod0Image0Tasks[] = { &amp;Prod0TargetAlignment, &amp;Prod0DefectDetection }; CInspectionTask* Prod0Image1Tasks[] = { &amp;Prod0View1Alignment , &amp;Prod0FillLevelFixture, &amp;Prod0FillLevel }; CInspectionTask* Prod0Image2Tasks[] = { &amp;Prod0View2Alignment , &amp;Prod0CapFixture , &amp;Prod0CapScrew }; // Table of the task associated to each image. SImageTaskList Prod0ImagesTaskList[] = { CREATE_LIST(Prod0Image0Tasks, MIL_TEXT(\"Surface defect detection\")), CREATE_LIST(Prod0Image1Tasks, MIL_TEXT(\"Fill level measurement\")), CREATE_LIST(Prod0Image2Tasks, MIL_TEXT(\"Cap screw verification\")), }; // The filenames of the avi files. static MIL_CONST_TEXT_PTR Prod0ImagesAvi[ARRAY_COUNT(Prod0ImagesTaskList)] = { PRODUCT0_PATH MIL_TEXT(\"View0.avi\"), PRODUCT0_PATH MIL_TEXT(\"View1.avi\"), PRODUCT0_PATH MIL_TEXT(\"View2.avi\"), }; //***************************************************************************** // The product info structure that indicates the task and avi to load. SProductInfo ProductsInfoList[] = { { ARRAY_COUNT(Prod0ImagesTaskList), enSequential, Prod0ImagesAvi, Prod0ImagesTaskList }, }; //***************************************************************************** // Allocate application. MIL_ID MilApplication = MappAlloc(M_NULL, M_DEFAULT, M_NULL); // Allocate system. MIL_ID MilSystem = MsysAlloc(M_DEFAULT, M_SYSTEM_HOST, M_DEFAULT, M_DEFAULT, M_NULL); MosPrintf(MIL_TEXT(\"BOTTLE CAP AND CONTENT INSPECTION:\\n\")); MosPrintf(MIL_TEXT(\"---------------------------------------\\n\\n\")); // Print the header. PrintHeader(); // Allocate the example manager. CExampleMngr *pExampleManager = new CExampleMngr(MilSystem); // Run the example. pExampleManager-&gt;Run(ProductsInfoList, ARRAY_COUNT(ProductsInfoList)); // Free the example manager. delete pExampleManager; // Free the system. MsysFree(MilSystem); // Free the application. MappFree(MilApplication); return 0; } ",
      "wordCount": 452
    },
    {
      "id": "Examples_Processing_ProductInspection_BottleCapAndContentInspection_CPP_capscrewinspection_capandcontent_cpp",
      "version": "2024020714",
      "title": "capscrewinspection_capandcontent.cpp",
      "location": "Sample Code from MIL Examples",
      "text": " Top //*************************************************************************************** // // File name: CapScrewInspection_CapAndContent.cpp // Location: See Matrox Example Launcher in the MIL Control Center // // // Synopsis: This file contains the implementation of the CCapScrewInspection class // which is the inspection task used to check if the cap is well screwed. // // Copyright (C) Matrox Electronic Systems Ltd., 1992-2024. // All Rights Reserved #include &lt;mil.h&gt; #include &lt;math.h&gt; #include \"CapScrewInspection_CapAndContent.h\" //***************************************************************************** // Constants. //***************************************************************************** //***************************************************************************** // Constructor. //***************************************************************************** CCapScrewInspection::CCapScrewInspection(MIL_CONST_TEXT_PTR MeasContextPath, MIL_DOUBLE PositionYTolerance, MIL_DOUBLE AngleTolerance, MIL_INT ColorConversion /* = M_NONE */, CInspectionTask* FixtureProvider /* = M_NULL */, CInspectionTask* ImageProvider /* = M_NULL */) : CMeasInspectionTask(MeasContextPath, ColorConversion, FixtureProvider, ImageProvider), m_AngleTolerance(AngleTolerance), m_PositionTolerance(PositionYTolerance) { } //***************************************************************************** // Destructor. //***************************************************************************** CCapScrewInspection::~CCapScrewInspection() { } //***************************************************************************** // Inspect. //***************************************************************************** bool CCapScrewInspection::Calculate(MIL_ID MilImage) { // Do the measurement task. if(CMeasInspectionTask::Calculate(MilImage)) { MmeasGetResult(MilResult(), M_POSITION, &amp;m_PosX, &amp;m_PosY); MmeasGetResult(MilResult(), M_ANGLE, &amp;m_Angle, M_NULL); // Put the angle fro -Pi to PI. PutAngleBetweenMinus180And180(m_Angle); return true; } return false; } //***************************************************************************** // Set fixture. //***************************************************************************** void CCapScrewInspection::SetFixture() { SetOutputFixture(M_POINT_AND_ANGLE, M_NULL, M_DEFAULT, m_PosX, m_PosY, m_Angle, M_DEFAULT); } //***************************************************************************** // Draw text result. //***************************************************************************** void CCapScrewInspection::DrawTextResult(MIL_ID MilGraContext, MIL_ID MilDest) { MIL_DOUBLE AngleDiff = fabs(m_Angle); if(GetResultStatus() == eUnknown) { MgraControl(MilGraContext, M_COLOR, M_COLOR_YELLOW); MgraText(MilGraContext, MilDest, 0, 0, MIL_TEXT(\"Cap screw: UNKNOWN\")); } else { if(IsResultValid() &amp;&amp; (AngleDiff &lt;= m_AngleTolerance) &amp;&amp; fabs(m_PosY) &lt;= m_PositionTolerance) { MgraControl(MilGraContext, M_COLOR, M_COLOR_GREEN); MgraText(MilGraContext, MilDest, 0, 0, MIL_TEXT(\"Cap screw: PASS\")); } else { MgraControl(MilGraContext, M_COLOR, M_COLOR_RED); MgraText(MilGraContext, MilDest, 0, 0, MIL_TEXT(\"Cap screw: FAIL\")); } } MoveGraphicContextYOffset(MilGraContext, 1); } //***************************************************************************** // Draw graphical result. //***************************************************************************** void CCapScrewInspection::DrawGraphicalResult(MIL_ID MilGraContext, MIL_ID MilDest) { MgraControl(MilGraContext, M_COLOR, M_COLOR_GREEN); MmeasDraw(MilGraContext, MilResult(), MilDest, M_DRAW_SEARCH_REGION + M_DRAW_SEARCH_DIRECTION, M_DEFAULT, M_RESULT); MgraControl(MilGraContext, M_COLOR, M_COLOR_MAGENTA); MmeasDraw(MilGraContext, MilResult(), MilDest, M_DRAW_EDGES, M_DEFAULT, M_RESULT); } ",
      "wordCount": 273
    },
    {
      "id": "Examples_Processing_ProductInspection_BottleCapAndContentInspection_CPP_defectdetectionprocfunc_capandcontent_cpp",
      "version": "2024020714",
      "title": "defectdetectionprocfunc_capandcontent.cpp",
      "location": "Sample Code from MIL Examples",
      "text": " Top //*************************************************************************************** // // File name: defectdetectionprocfunc_CapAndContent.cpp // Location: See Matrox Example Launcher in the MIL Control Center // // // Synopsis: This file contains the processing functions declarations // that are used to perform some simple defect detection. // // Copyright (C) Matrox Electronic Systems Ltd., 1992-2024. // All Rights Reserved #include &lt;mil.h&gt; #include &lt;math.h&gt; #include \"defectdetectionprocfunc_CapAndContent.h\" //***************************************************************************** // Remaps to an 8 bit image. //***************************************************************************** void Remap8BitImage(MIL_ID MilSrcImage, MIL_ID MilDestImage, MIL_INT StartIndex, MIL_INT EndIndex, MIL_DOUBLE MinValue, MIL_DOUBLE MaxValue) { // Work on the same system of the SrcBufferId. MIL_ID MilSystem = MbufInquire(MilSrcImage, M_OWNER_SYSTEM, M_NULL); // Alloc the LUT. MIL_ID MilLut = MbufAlloc1d(MilSystem, 256, 32+M_FLOAT, M_LUT, M_NULL); // Generate the ramp. MgenLutRamp(MilLut, 0, MinValue, StartIndex, MinValue); MgenLutRamp(MilLut, StartIndex, MinValue, EndIndex, MaxValue); MgenLutRamp(MilLut, EndIndex, MaxValue, 255, MaxValue); // Apply the mapping. MimLutMap(MilSrcImage, MilDestImage, MilLut); // Free the buffers. MbufFree(MilLut); } //***************************************************************************** // Creates a gradient mask. //***************************************************************************** void CreateGradientMaskImage(MIL_ID MilTemplateImage, MIL_ID MilTemplateLumImage, MIL_DOUBLE GradientSmoothness, MIL_ID *MilGradientMaskImagePtr, MIL_ID *MilGradientLumMaskImagePtr) { // Get the owner system of the template image. MIL_ID MilSystem = MbufInquire(MilTemplateLumImage, M_OWNER_SYSTEM, M_NULL); // Get the size of the template image. MIL_INT TemplateSizeX = MbufInquire(MilTemplateLumImage, M_SIZE_X, M_NULL); MIL_INT TemplateSizeY = MbufInquire(MilTemplateLumImage, M_SIZE_Y, M_NULL); // Allocate the gradient mask images. MIL_ID MilGradientMaskColorImage = MbufAllocColor(MilSystem, 3, TemplateSizeX, TemplateSizeY, 8+M_UNSIGNED, M_IMAGE+M_PROC, M_NULL); MIL_ID MilGradientLumMaskImage = MbufAlloc2d(MilSystem, TemplateSizeX, TemplateSizeY, 8+M_UNSIGNED, M_IMAGE+M_PROC, M_NULL); MIL_ID MilGradientMaskImage = MbufAlloc2d(MilSystem, TemplateSizeX, TemplateSizeY, 8+M_UNSIGNED, M_IMAGE+M_PROC, M_NULL); MIL_ID MilLinearFilterIIRContext = MimAlloc(MilSystem, M_LINEAR_FILTER_IIR_CONTEXT, M_DEFAULT, M_NULL); MimControl(MilLinearFilterIIRContext, M_FILTER_TYPE, M_SHEN); MimControl(MilLinearFilterIIRContext, M_FILTER_SMOOTHNESS, GradientSmoothness); // Create the luminance gradient mask. MimDifferential(MilLinearFilterIIRContext, MilTemplateLumImage, M_NULL, M_NULL, M_NULL, MilGradientLumMaskImage, M_NULL, M_DEFAULT, M_GRADIENT, M_DEFAULT); // Create the gradient mask of each band. MimDifferential(MilLinearFilterIIRContext, MilTemplateImage, M_NULL, M_NULL, M_NULL, MilGradientMaskColorImage, M_NULL, M_DEFAULT, M_GRADIENT, M_DEFAULT); MimFree(MilLinearFilterIIRContext); // Create the gradient mask total image. MIL_ID MilGradientTotal = MbufAlloc2d(MilSystem, TemplateSizeX, TemplateSizeY, 32+M_UNSIGNED, M_IMAGE+M_PROC, M_NULL); MIL_ID MilGradientSquare = MbufAlloc2d(MilSystem, TemplateSizeX, TemplateSizeY, 16+M_UNSIGNED, M_IMAGE+M_PROC, M_NULL); MbufClear(MilGradientTotal, 0); for(MIL_INT BandIdx = 0; BandIdx &lt; 3; BandIdx++) { MIL_ID MilGradientBand = MbufChildColor(MilGradientMaskColorImage, M_RED &lt;&lt; BandIdx, M_NULL); MimArith(MilGradientBand, M_NULL, MilGradientSquare, M_SQUARE); MimArith(MilGradientTotal, MilGradientSquare, MilGradientTotal, M_ADD); MbufFree(MilGradientBand); } // Get the square root of the total of the gradient. MimArith(MilGradientTotal, M_NULL, MilGradientMaskImage, M_SQUARE_ROOT); // Since the IIR filter maximum value of the IIR filter is 127, we stretch back the two buffers to 255. static const MIL_INT MaxColorGradient = (MIL_INT)sqrt(127.0*127.0*3.0); Remap8BitImage(MilGradientMaskImage, MilGradientMaskImage, 0, MaxColorGradient, 0, 255); Remap8BitImage(MilGradientLumMaskImage, MilGradientLumMaskImage, 0, 127, 0, 255); if(MilGradientMaskImagePtr != M_NULL) { *MilGradientMaskImagePtr = MilGradientMaskImage; } else { MbufFree(MilGradientMaskImage); } if(MilGradientLumMaskImagePtr != M_NULL) { *MilGradientLumMaskImagePtr = MilGradientLumMaskImage; } else { MbufFree(MilGradientLumMaskImage); } MbufFree(MilGradientTotal); MbufFree(MilGradientSquare); MbufFree(MilGradientMaskColorImage); } //***************************************************************************** // Defines the model and the fixturing offset. //***************************************************************************** void DefineModelAndFixture(MIL_ID MilTemplateLumImage, MIL_ID MilModContext, MIL_ID MilFixturingOffset, MIL_DOUBLE ModelOffsetX, MIL_DOUBLE ModelOffsetY, MIL_DOUBLE ModelSizeX, MIL_DOUBLE ModelSizeY) { // Remove the model from the context if there is one if(MmodInquire(MilModContext, M_CONTEXT, M_NUMBER_MODELS + M_TYPE_MIL_INT, M_NULL)) MmodDefine(MilModContext, M_DELETE, M_ALL, M_DEFAULT, M_DEFAULT, M_DEFAULT, M_DEFAULT); // Define the model image from the template image. MmodDefine(MilModContext, M_IMAGE, MilTemplateLumImage, ModelOffsetX, ModelOffsetY, ModelSizeX, ModelSizeY); // Set the number of models to find to M_ALL and preprocess. MmodControl(MilModContext, 0, M_NUMBER, M_ALL); MmodPreprocess(MilModContext, M_DEFAULT); // Learn the fixture offset from the model. McalFixture(M_NULL, MilFixturingOffset, M_LEARN_OFFSET, M_MODEL_MOD, MilModContext, 0, M_DEFAULT, M_DEFAULT, M_DEFAULT); } //***************************************************************************** // Finds the model and returns the number of occurrences. //***************************************************************************** MIL_INT FindModel(MIL_ID MilModContext, MIL_ID MilTargetImage, MIL_ID MilModResult) { // Find the model in the target image. MmodFind(MilModContext, MilTargetImage, MilModResult); // Get the number of occurrences. MIL_INT NbOfOccurrences; MmodGetResult(MilModResult, M_GENERAL, M_NUMBER+M_TYPE_MIL_INT, &amp;NbOfOccurrences); return NbOfOccurrences; } //***************************************************************************** // Aligns the SrcImage in the destination image based on the fixturing info. //***************************************************************************** void AlignImageBasedOnFixture(MIL_ID MilSrcImage, MIL_ID MilDestImage, MIL_ID MilFixturingOffset, MIL_ID MilFixtureProvider, MIL_INT ResultType, MIL_INT OccurenceIdx) { // Fixture the current occurrence. McalFixture(MilSrcImage, MilFixturingOffset, M_MOVE_RELATIVE, ResultType, MilFixtureProvider, OccurenceIdx, M_DEFAULT, M_DEFAULT, M_DEFAULT); // Warp the occurrence in the inspection image. McalTransformImage(MilSrcImage, MilDestImage, M_DEFAULT, M_BILINEAR+M_OVERSCAN_CLEAR, M_DEFAULT, M_WARP_IMAGE+M_USE_DESTINATION_CALIBRATION); } //***************************************************************************** // Extracts the defects from the difference image. //***************************************************************************** MIL_INT ExtractDefects(MIL_ID MilDifferenceGrayImage, MIL_ID MilExtractedDefectsImage, MIL_DOUBLE TriangleLowerCutoff, MIL_DOUBLE TriangleUpperCutoff, MIL_DOUBLE BinCumulativeValue, MIL_DOUBLE NormalVariation, MIL_DOUBLE FixedDiffThreshold, MIL_INT CleanMorphSize, const BinarizationMethod BinMethod) { // Get the owner system and the size of the difference image. MIL_ID MilSystem = MbufInquire(MilDifferenceGrayImage, M_OWNER_SYSTEM, M_NULL); MIL_INT ImageSizeX = MbufInquire(MilDifferenceGrayImage, M_SIZE_X, M_NULL); MIL_INT ImageSizeY = MbufInquire(MilDifferenceGrayImage, M_SIZE_Y, M_NULL); // Allocate the binary image. MIL_ID MilInspectionBinImage = MbufAlloc2d(MilSystem, ImageSizeX, ImageSizeY, 1+M_UNSIGNED, M_IMAGE+M_PROC, M_NULL); // Allocate blob. MIL_ID MilBlobContext = MblobAlloc(MilSystem, M_DEFAULT, M_DEFAULT, M_NULL); MIL_ID MilBlobResult = MblobAllocResult(MilSystem, M_DEFAULT, M_DEFAULT, M_NULL); // Binarize the image. MIL_INT BinValue; switch(BinMethod) { case enCumulHistPercentage: BinValue = MimBinarize(MilDifferenceGrayImage, M_NULL, M_PERCENTILE_VALUE, BinCumulativeValue, M_NULL); break; case enTriangleBisection: NormalVariation = (MIL_DOUBLE) MimBinarize(MilDifferenceGrayImage, M_NULL, M_TRIANGLE_BISECTION_BRIGHT, TriangleLowerCutoff, TriangleUpperCutoff); case enFixed: BinValue = (MIL_INT) (((NormalVariation + FixedDiffThreshold) &gt; 255) ? 255 : (NormalVariation + FixedDiffThreshold)); break; case enBiModal: default: BinValue = MimBinarize(MilDifferenceGrayImage, M_NULL, M_BIMODAL, M_NULL, M_NULL); break; } MimBinarize(MilDifferenceGrayImage, MilInspectionBinImage, M_FIXED + M_GREATER_OR_EQUAL, (MIL_DOUBLE) BinValue, M_NULL); // Clean the binary image. MimOpen(MilInspectionBinImage, MilInspectionBinImage, CleanMorphSize, M_BINARY); // Calculate the blobs. MblobCalculate(MilBlobContext, MilInspectionBinImage, M_NULL, MilBlobResult); // Draw the blobs in the image. MbufClear(MilExtractedDefectsImage, 0); MgraControl(M_DEFAULT, M_COLOR, 255); MblobDraw(M_DEFAULT, MilBlobResult, MilExtractedDefectsImage, M_DRAW_BLOBS, M_DEFAULT, M_DEFAULT); // Free blob. MblobFree(MilBlobContext); MblobFree(MilBlobResult); // Free the binary image. MbufFree(MilInspectionBinImage); return BinValue; } //***************************************************************************** // Extracts the differences. //***************************************************************************** void ExtractDifferences(MIL_ID MilTemplateImage, MIL_ID MilTemplateLumImage, MIL_ID MilTemplateGradientMask, MIL_ID MilTemplateLumGradientMask, MIL_ID MilWarpedTarget, MIL_ID MilDifferenceGrayImage, MIL_ID MilStructElement, const DifferenceExtractionMethod DiffExtractMethod) { // Get the owner system and the size of the difference image. MIL_ID MilSystem = MbufInquire(MilDifferenceGrayImage, M_OWNER_SYSTEM, M_NULL); MIL_INT ImageSizeX = MbufInquire(MilDifferenceGrayImage, M_SIZE_X, M_NULL); MIL_INT ImageSizeY = MbufInquire(MilDifferenceGrayImage, M_SIZE_Y, M_NULL); // Create the luminance version of the Warped target if the difference method is not the color distance. MIL_ID MilWarpedTargetLum = M_NULL; if(DiffExtractMethod != enColDistance) { if(MbufInquire(MilWarpedTarget, M_SIZE_BAND, M_NULL) == 3) { // Allocate the warped target luminance image. MbufAlloc2d(MilSystem, ImageSizeX, ImageSizeY, 8+M_UNSIGNED, M_IMAGE+M_PROC, &amp;MilWarpedTargetLum); // Get the luminance of the warped target. MimConvert(MilWarpedTarget, MilWarpedTargetLum, M_RGB_TO_L); } else MilWarpedTargetLum = MilWarpedTarget; } // Extract the differences. switch(DiffExtractMethod) { case enAbsoluteDiff: MimArith(MilTemplateLumImage, MilWarpedTargetLum, MilDifferenceGrayImage, M_SUB_ABS); break; case enColDistance: McolDistance(MilTemplateImage, MilWarpedTarget, MilDifferenceGrayImage, M_NULL, M_DEFAULT, M_EUCLIDEAN, M_NO_NORMALIZE, M_DEFAULT); break; case enTopHat: MimMorphic(MilWarpedTargetLum, MilDifferenceGrayImage, MilStructElement, M_TOP_HAT, 1, M_GRAYSCALE); break; case enBottomHat: default: MimMorphic(MilWarpedTargetLum, MilDifferenceGrayImage, MilStructElement, M_BOTTOM_HAT, 1, M_GRAYSCALE); break; } // Subtract the gradient mask to prevent edge effect. MimArith(MilDifferenceGrayImage, DiffExtractMethod == enColDistance ? MilTemplateGradientMask : MilTemplateLumGradientMask, MilDifferenceGrayImage, M_SUB+M_SATURATION); if(MilWarpedTargetLum &amp;&amp; MilWarpedTargetLum != MilWarpedTarget) { MbufFree(MilWarpedTargetLum); } } ",
      "wordCount": 1015
    },
    {
      "id": "Examples_Processing_ProductInspection_BottleCapAndContentInspection_CPP_defectdetectiontask_cpp",
      "version": "2024020714",
      "title": "defectdetectiontask.cpp",
      "location": "Sample Code from MIL Examples",
      "text": " Top //*************************************************************************************** // // File name: DefectDetectionTask.cpp // Location: See Matrox Example Launcher in the MIL Control Center // // // Synopsis: This file contains the implementation of the CDefectDetectionTask class // which is the inspection task that detects defect using a template based // difference extraction. // // Copyright (C) Matrox Electronic Systems Ltd., 1992-2024. // All Rights Reserved #include &lt;mil.h&gt; #include \"DefectDetectionTask.h\" //***************************************************************************** // Constants. //***************************************************************************** static const MIL_INT DEFECT_SIZE = 4; static const MIL_DOUBLE GRADIENT_MASK_SMOOTHNESS = 70; static const MIL_DOUBLE TRIANGLE_LOWER_CUTOFF = 2; static const MIL_DOUBLE TRIANGLE_UPPER_CUTOFF = 255; static const MIL_DOUBLE BIN_CUMULATIVE_VALUE = 99.0; static const MIL_DOUBLE FIXED_DIFF_THRESHOLD = 10; static const MIL_DOUBLE NORMAL_VARIATIONS = 20; static const MIL_INT CLEAN_MORPH_SIZE = 0; static const MIL_DOUBLE MIN_AREA = 10; //***************************************************************************** // Constructor. //***************************************************************************** CDefectDetectionTask::CDefectDetectionTask(MIL_CONST_TEXT_PTR TemplatePath, MIL_CONST_TEXT_PTR TemplateMaskPath, DifferenceExtractionMethod DiffMethod, BinarizationMethod BinMethod, MIL_INT ColorConversion /* = M_NONE */, CInspectionTask* FixtureProvider /* = M_NULL */, CInspectionTask* ImageProvider /* = M_NULL */) : CInspectionTask(ColorConversion, FixtureProvider, ImageProvider), m_DiffMethod(DiffMethod), m_BinMethod(BinMethod), m_MilBlobContext (M_NULL), m_MilBlobResult (M_NULL), m_MilTemplateImage (M_NULL), m_MilTemplateGrayImage (M_NULL), m_MilTemplateMask (M_NULL), m_MilTemplateGradientMask (M_NULL), m_MilTemplateGradientGrayMask (M_NULL), m_MilDifferenceGrayImage (M_NULL), m_MilExtractedDefectsImage (M_NULL) { // Copy the path. CloneString(m_TemplatePath, TemplatePath); CloneString(m_TemplateMaskPath, TemplateMaskPath); } //***************************************************************************** // Destructor. //***************************************************************************** CDefectDetectionTask::~CDefectDetectionTask() { if(m_TemplateMaskPath) { delete [] m_TemplateMaskPath; } if(m_TemplatePath) { delete [] m_TemplatePath; } // Free the mil objects FreeMilObjects(); } //***************************************************************************** // Free function. //***************************************************************************** void CDefectDetectionTask::Free() { CInspectionTask::Free(); //Free the Mil objects FreeMilObjects(); } //***************************************************************************** // Init. //***************************************************************************** void CDefectDetectionTask::Init(MIL_ID MilSystem, MIL_INT ImageSizeX /* = 0 */, MIL_INT ImageSizeY /* = 0 */) { // Initialize the base classes CInspectionTask::Init(MilSystem, ImageSizeX, ImageSizeY); // Restore the template MbufRestore(m_TemplatePath, MilSystem, &amp;m_MilTemplateImage); // Get the size of the template MIL_INT TemplateSizeX = MbufInquire(m_MilTemplateImage, M_SIZE_X, M_NULL); MIL_INT TemplateSizeY = MbufInquire(m_MilTemplateImage, M_SIZE_Y, M_NULL); // Restore the mask MbufRestore(m_TemplateMaskPath, MilSystem, &amp;m_MilTemplateMask); // Create the gray scale image m_MilTemplateGrayImage = CreateConvertedImage(m_MilTemplateImage, GetColorConversion()); // Create the gradient mask CreateGradientMaskImage(m_MilTemplateGrayImage, m_MilTemplateImage, GRADIENT_MASK_SMOOTHNESS, &amp;m_MilTemplateGradientMask, &amp;m_MilTemplateGradientGrayMask); // Allocate the difference image MbufAlloc2d(MilSystem, TemplateSizeX, TemplateSizeY, 8+M_UNSIGNED, M_IMAGE+M_PROC, &amp;m_MilDifferenceGrayImage); // Allocate the extracted defects image MbufAlloc2d(MilSystem, TemplateSizeX, TemplateSizeY, 1+M_UNSIGNED, M_IMAGE+M_PROC, &amp;m_MilExtractedDefectsImage); // Allocate blob MblobAlloc(MilSystem, M_DEFAULT, M_DEFAULT, &amp;m_MilBlobContext); MblobControl(m_MilBlobContext, M_BOX, M_ENABLE); MblobAllocResult(MilSystem, M_DEFAULT, M_DEFAULT, &amp;m_MilBlobResult); MblobControl(m_MilBlobResult, M_RESULT_OUTPUT_UNITS, M_WORLD); } //***************************************************************************** // Inspect. //***************************************************************************** ResultStatusEnum CDefectDetectionTask::Inspect(MIL_ID MilImage) { // Extract the differences ExtractDifferences(m_MilTemplateImage, m_MilTemplateGrayImage, m_MilTemplateGradientMask, m_MilTemplateGradientGrayMask, MilImage, m_MilDifferenceGrayImage, M_NULL, m_DiffMethod); // Mask out differences outside the mask MimArith(m_MilDifferenceGrayImage, m_MilTemplateMask, m_MilDifferenceGrayImage, M_AND); // Extract the defect ExtractDefects(m_MilDifferenceGrayImage, m_MilExtractedDefectsImage, TRIANGLE_LOWER_CUTOFF, TRIANGLE_UPPER_CUTOFF, BIN_CUMULATIVE_VALUE, NORMAL_VARIATIONS, FIXED_DIFF_THRESHOLD, CLEAN_MORPH_SIZE, m_BinMethod); // Set the fixture on the image McalAssociate(M_NULL, m_MilExtractedDefectsImage, M_DEFAULT); McalUniform(m_MilExtractedDefectsImage, 0.0, 0.0, 1.0, 1.0, 0.0, M_DEFAULT); // Calculate the blobs MblobCalculate(m_MilBlobContext, m_MilExtractedDefectsImage, M_NULL, m_MilBlobResult); // Select the blobs that meet the area criteria MblobSelect(m_MilBlobResult, M_DELETE, M_AREA, M_LESS, MIN_AREA, M_NULL); return eValid; } //***************************************************************************** // Draw graphical result. //***************************************************************************** void CDefectDetectionTask::DrawGraphicalResult(MIL_ID MilGraContext, MIL_ID MilDest) { // Draw the blob result. MgraControl(MilGraContext, M_COLOR, M_COLOR_RED); MblobDraw(MilGraContext, m_MilBlobResult, MilDest, M_DRAW_BOX, M_DEFAULT, M_DEFAULT); } //***************************************************************************** // Draw text result. //***************************************************************************** void CDefectDetectionTask::DrawTextResult(MIL_ID MilGraContext, MIL_ID MilDest) { if(GetResultStatus() == eUnknown) { MgraControl(MilGraContext, M_COLOR, M_COLOR_YELLOW); MgraText(MilGraContext, MilDest, 0, 0, MIL_TEXT(\"Defect detection: UNKNOWN\")); } else { MIL_INT BlobNb; MblobGetResult(m_MilBlobResult, M_DEFAULT, M_NUMBER + M_TYPE_MIL_INT, &amp;BlobNb); if(IsResultValid() &amp;&amp; BlobNb == 0) { MgraControl(MilGraContext, M_COLOR, M_COLOR_GREEN); MgraText(MilGraContext, MilDest, 0, 0, MIL_TEXT(\"Defect detection: PASS\")); } else { MgraControl(MilGraContext, M_COLOR, M_COLOR_RED); MgraText(MilGraContext, MilDest, 0, 0, MIL_TEXT(\"Defect detection: FAIL\")); } } MoveGraphicContextYOffset(MilGraContext, 1); } //***************************************************************************** // Function that frees the MIL objects. //***************************************************************************** void CDefectDetectionTask::FreeMilObjects() { if(m_MilTemplateGrayImage) { MbufFree(m_MilTemplateGrayImage); m_MilTemplateGrayImage = 0; } if(m_MilTemplateImage) { MbufFree(m_MilTemplateImage); m_MilTemplateImage = 0; } if(m_MilTemplateMask) { MbufFree(m_MilTemplateMask); m_MilTemplateMask = 0; } if(m_MilTemplateGradientMask) { MbufFree(m_MilTemplateGradientMask); m_MilTemplateGradientMask = 0; } if(m_MilTemplateGradientGrayMask) { MbufFree(m_MilTemplateGradientGrayMask); m_MilTemplateGradientGrayMask = 0; } if(m_MilDifferenceGrayImage) { MbufFree(m_MilDifferenceGrayImage); m_MilDifferenceGrayImage = 0; } if(m_MilExtractedDefectsImage) { MbufFree(m_MilExtractedDefectsImage); m_MilExtractedDefectsImage = 0; } if(m_MilBlobContext) { MblobFree(m_MilBlobContext); m_MilBlobContext = 0; } if(m_MilBlobResult) { MblobFree(m_MilBlobResult); m_MilBlobResult = 0; } } ",
      "wordCount": 611
    }
  ]
}]
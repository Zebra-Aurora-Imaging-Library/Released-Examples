[{
  "id": "UG_fpga",
  "version": "2024020714",
  "title": "Using MIL with a Processing FPGA",
  "subTitles": null,
  "location": "MIL UG P11: Miscellaneous",
  "pageURL": "content\\UserGuide\\fpga\\ChapterInformation.htm",
  "text": " Chapter 66: Using MIL with a Processing FPGA This chapter explains how to use the MIL FPGA module with a Matrox board that has a Processing FPGA loaded with an FPGA configuration. Using MIL with a Processing FPGA - overview Processing an image with a Processing FPGA Steps to develop a function that performs an operation using a Processing FPGA Primitive function and execution of operation by PU Source and destination image buffers Setting and retrieving results from PU registers Cascaded and parallel processing Cascaded processing operation Parallel processing operation Issuing commands to the Processing FPGA and retrieving results Developing a user-defined MIL function to run the primitive function Master function and slave function and execution of operation specified by command context Operation synchronization ",
  "wordCount": 126,
  "subEntries": [
    {
      "id": "UG_fpga_FPGA_overview",
      "version": null,
      "title": "Using MIL with a Processing FPGA - overview",
      "subTitles": null,
      "location": "MIL UG P11: Miscellaneous",
      "pageURL": "content\\UserGuide\\fpga\\FPGA_overview.htm",
      "text": " Using MIL with a Processing FPGA - overview Some Matrox imaging boards have a Processing FPGA. You can configure this Processing FPGA to perform some required processing operations on-board to free up the Host for other tasks. Before any processing can take place using the Processing FPGA, you must configure it with an FPGA configuration that contains the appropriate processing units (PUs) to carry out the required set of tasks. Several useful Matrox FPGA configurations are distributed with MIL. However, depending on your application's requirements, you might need to develop a custom FPGA configuration using Matrox PUs and, if required, custom PUs. If this is the case, you must purchase and use the Matrox FPGA Developer's Toolkit (FDK). Once the Processing FPGA is configured, MIL will use it to perform any MIL function that can be performed using the Matrox PUs in the loaded FPGA configuration, if possible. MIL functions cannot be performed using custom PUs. To use PUs without a corresponding MIL function, or to reduce memory accesses by routing an output of one PU to an input of another PU (cascaded or parallel processing operations), you must use the MIL FPGA module to create, set up, and dispatch the required command(s) to the board. The MIL FPGA module allows you to create a command and set its target PU, specify the image buffers to associate with the stream input and output ports of the PU, and set the PU's user-specific registers (with required processing information). Besides associating image buffers with the ports, the MIL FPGA module also allows you to route the output of one command's PU to an input port of another command's PU, if the PUs are interconnected in the loaded FPGA configuration. You can create a simple function (primitive function) that calls all the required functions of the MIL FPGA module. However, if incorrect parameters are passed to your primitive function, you are not notified and you cannot use MIL's tracing mechanism to determine the cause of the unexpected results. To enable basic error checking and parameter validation, you must call your primitive function from a user-defined MIL function; to do so, see Chapter 67: The MIL function development module. Note that this error checking adds a small overhead to the processing function. When your Matrox imaging board also has an on-board processor, you must use a user-defined MIL function because the MIL FPGA functions must be executed by the on-board processor. If your board has an on-board processor and you don't define your primitive function as a user-defined MIL function, an error will be generated. Although an FPGA configuration also has components (referred to as transfer units and memory controllers) required to transfer data to/from the required PUs and to/from memory, the MIL FPGA module handles these transparently. Using MIL with a Processing FPGA - overview ",
      "wordCount": 474,
      "subEntries": []
    },
    {
      "id": "UG_fpga_Using_an_FPGA_configuration",
      "version": null,
      "title": "Processing an image with a Processing FPGA",
      "subTitles": null,
      "location": "MIL UG P11: Miscellaneous",
      "pageURL": "content\\UserGuide\\fpga\\Using_an_FPGA_configuration.htm",
      "text": " Processing an image with a Processing FPGA To process images using a Processing FPGA, perform the following steps: Use the MILConfig utility to select the FPGA configuration with which to program the Processing FPGA. When you select a Matrox FPGA configuration, the MILConfig utility will list all the PUs that are in this particular configuration. For a description of PUs and their interconnections, refer to the Matrox FPGA Components Reference Help file. Note that a valid Matrox FPGA configuration file has a (.mbf) or ( .firmware) extension and can be found in the Matrox Imaging\\Drivers\\Board_Name\\Firmware folder (for example, Board_Name should be RapixoCXP in the case of a Matrox RapixoCXP board). Call the MsysAlloc() function to load the configuration in the Processing FPGA. To load a different FPGA configuration from within your application, you can use MfpgaLoad(). You must include the MIL FPGA header file milfpga.h to make a call to any Mfpga module function. Note that this module is not supported in Distributed MIL applications. Note that for Matrox boards with on-board processors, you can load the Matrox FPGA configuration with the MILConfig utility. Changing the selected Matrox FPGA configuration will cause the Matrox board with on-board processor to reload its FPGA. Grab the image(s) into one or more on-board FPGA-accessible buffer(s) (MbufAlloc...() with M_GRAB + M_FPGA_ACCESSIBLE). Process the images using one of the following techniques: Call the required MIL function equivalent to the PU(s) in the loaded FPGA configuration. Set up and call the primitive function (or the user-defined MIL function) that dispatches the required commands to the Processing FPGA on-board. To set up the primitive function (or the user-defined MIL function), see the Steps to develop a function that performs an operation using a Processing FPGA section later in this chapter. Note that processing can typically be performed by the Processing FPGA if the source buffer is allocated on-board, the destination buffer is allocated in non-paged Host memory or on-board, and the FPGA configuration includes a path from the PU(s) to the memory banks in which the specified source and destination buffers are located. In the case of Matrox imaging boards with on-board processors, destination buffers cannot be in Host memory; only on-board destination buffers are supported. Using the M_FPGA_ACCESSIBLE attribute when allocating a buffer ensures that the buffer is in memory accessible to the Processing FPGA, although there might not be an available path between the PU and the memory bank, depending on the selected FPGA configuration. Note that if calling a standard MIL function that is not associated to the PU(s) in the loaded FPGA configuration, the Host will process the image(s), but the processing might be significantly slower than normal if the images are on-board. If calling a primitive function and the target PU is not in the loaded FPGA configuration, an error is generated. Processing an image with a Processing FPGA ",
      "wordCount": 479,
      "subEntries": []
    },
    {
      "id": "UG_fpga_Steps_to_develop_a_function_to_program_the_Processing_FPGA",
      "version": null,
      "title": "Steps to develop a function that performs an operation using a Processing FPGA",
      "subTitles": null,
      "location": "MIL UG P11: Miscellaneous",
      "pageURL": "content\\UserGuide\\fpga\\Steps_to_develop_a_function_to_program_the_Processing_FPGA.htm",
      "text": " Steps to develop a function that performs an operation using a Processing FPGA To perform a processing operation using your Processing FPGA when there is no equivalent MIL function, you must at least create a primitive function that uses the functions of the MIL Mfpga module to set up and dispatch all appropriate commands to the Processing FPGA. Also, you must include the MIL FPGA header file milfpga.h to make a call to any function of the Mfpga module. To create the primitive function: Inquire the handle of your source and destination buffers using MfuncInquire() with M_BUFFER_INFO. MIL FPGA functions do not take buffer identifiers; instead, they take the handle of the buffers. To enable basic parameter checking when using Mfpga functions, use MfpgaControl() with M_ERROR and M_PRINT_ENABLE. Note that this will also report errors when attempting to link the target PU with a PU not in the FPGA configuration, and when attempting to use an invalid interrupt. Allocate an FPGA command context for the target PU of the Processing FPGA using MfpgaCommandAlloc(). The FPGA command context is used to contain the necessary command information to perform the required operation using the specified PU. Specify the source image buffer(s) using MfpgaSetSource(). Specify the destination image buffer(s) using MfpgaSetDestination(). Set other processing information in the PU's user-specific registers using MfpgaSetRegister(). To route the stream output of one PU to the stream input port of another PU (that is, to cascade the PUs) repeat steps 2 through 5, creating and setting up a FPGA command context for each PU that you need to cascade. Then, link the command contexts, using MfpgaSetLink(). Queue the command(s) defined by the command context(s), using MfpgaCommandQueue(). Retrieve non-image results from the PU's registers using MfpgaGetRegister(). Free the command context using MfpgaCommandFree(). The following code snippet is an example of the type of code that should be included within your primitive function to set up and dispatch a command to a Processing FPGA. /* Inquire the buffer info object for the source and destination buffers. */ MfuncInquire(MilSourceImage, M_BUFFER_INFO, &amp;Src); MfuncInquire(MilDestinationImage, M_BUFFER_INFO, &amp;Dest); /* Allocate an asynchronous command context on the AddConstant processing unit. */ if(MfpgaCommandAlloc(MfuncBufOwnerSystemId(Src), M_DEV0, FPGA_ADDCONST_FID, M_DEFAULT,M_DEV0, M_ASYNCHRONOUS, M_DEFAULT, &amp;AddConstantContext)) { /* Initialize the shadow register structure. */ InitializeShadowRegisters(&amp;ShadowRegisters, Src, ConstantValue, ControlFlag); /* Input0 of AddConstant processing unit is connected to the Src buffer. */ MfpgaSetSource(AddConstantContext, Src, M_INPUT0, M_DEFAULT); /* Output0 of AddConstant processing unit is connected to the Dest buffer. */ MfpgaSetDestination(AddConstantContext, Dest, M_OUTPUT0, M_DEFAULT); /* Pass the initialized shadow register structure, it will be programmed */ /* when the processing operation is dispatched (before processing starts). */ MfpgaSetRegister(AddConstantContext, M_USER, 0, sizeof(ShadowRegisters), (void*)(&amp;ShadowRegisters), M_WHEN_DISPATCHED); /* Queue the processing operation, because this context is asynchronous, */ /* MfpgaComamndQueue will return before the operation is completed. */ MfpgaCommandQueue(AddConstantContext, M_DEFAULT, M_DEFAULT); /* Free the allocated context. */ MfpgaCommandFree(AddConstantContext, M_DEFAULT); } Note that to run the primitive function on a board with an on-board processor, you must call your primitive function from the slave function of a user-defined MIL function. The slave and primitive functions must be precompiled and preloaded into the shell of the on-board processor. For more information on creating a user-defined MIL function, see Chapter 67: The MIL function development module. Note that even without an on-board processor, it is useful to call your primitive function from a user-defined MIL function. This not only makes your code more portable, but also takes advantage of the parameter checking and error reporting capabilities that are integrated in MIL. Whenever you want to associate an FPGA command context with a PU, you must make sure the PU is actually present in the FPGA configuration loaded in the FPGA. In addition, when implementing cascaded or parallel processing operations, it is necessary to make sure that the PUs are interconnected properly in the FPGA configuration. Matrox FPGA configurations are documented in the Matrox FPGA Configurations Help file. Steps to develop a function that performs an operation using a Processing FPGA ",
      "wordCount": 660,
      "subEntries": []
    },
    {
      "id": "UG_fpga_Primitive_function_and_execution_of_operation_by_PU",
      "version": null,
      "title": " Primitive function and execution of operation by PU",
      "subTitles": null,
      "location": "MIL UG P11: Miscellaneous",
      "pageURL": "content\\UserGuide\\fpga\\Primitive_function_and_execution_of_operation_by_PU.htm",
      "text": " Primitive function and execution of operation by PU The FPGA configuration that you load into your Processing FPGA contains one or more PUs that your primitive function can use to carry out specific image processing operations. With each PU that you want to use, you must associate an FPGA command context, using MfpgaCommandAlloc(). An FPGA command context is a MIL object that stores the information required to select and configure a PU, within a loaded FPGA configuration, to perform an image processing operation. The command context stores information regarding the target PU, the source and destination buffers, operation information, register settings, register read requests, link information, and the execution mode. In essence, the command context specifies the command required to perform a processing operation. Once your command is completed and the FPGA command context is no longer needed, it should be freed using MfpgaCommandFree(). When allocating the command context, you must specify the target PU. To do so, you must specify the PU's function identifier. If your Matrox imaging board has multiple Processing FPGAs on-board, you must also specify in which is the required PU located. Several different variations of a Matrox PU can exist, each with slightly different optimizations, functionalities, or restrictions. If the loaded FPGA configuration has multiple versions of the same PU, identify which to use by specifying the required PU's subfunction identifier. Lastly, if the FPGA configuration loaded in the selected Processing FPGA has multiple instances of the required PU, you must specify which to use by specifying its rank. If any of the above-mentioned circumstances do not apply, you can set the corresponding parameter to M_DEFAULT. There are certain PUs that require multiple passes to setup and use. For example, the PU that performs a LUT mapping needs two passes. The first pass sets up the lookup table and the second enables the PU to map the input image through the LUT. You must ensure that you set up this type of PU correctly. Refer to the Matrox FPGA Configurations Help file for a list of the PUs contained in the available Matrox FPGA configurations. In addition, refer to the Matrox FPGA Components Reference Help file for a description of the Matrox PUs. Primitive function and execution of operation by PU ",
      "wordCount": 378,
      "subEntries": []
    },
    {
      "id": "UG_fpga_Source_and_destination_image_buffers",
      "version": null,
      "title": "Source and destination image buffers",
      "subTitles": null,
      "location": "MIL UG P11: Miscellaneous",
      "pageURL": "content\\UserGuide\\fpga\\Source_and_destination_image_buffers.htm",
      "text": " Source and destination image buffers Before using a PU, you must specify the appropriate source and destination image buffers for the command. Some PUs do not produce image data and, therefore, they do not require destination image buffers. To specify the source and destination buffers, use MfpgaSetSource() and MfpgaSetDestination(), respectively. These functions require that you pass the handle of the buffer and not its identifier. To get the handle of the buffer, you must call MfuncInquire() with M_BUFFER_INFO. All PUs have documented limitations on the types of buffers from which they can receive data using their stream input port(s). They also have documented limitations on the buffers to which they can transmit data from their stream output port(s). You must keep these limitations in mind when allocating your buffer(s). MfpgaSetDestination() and MfpgaSetSource() will not automatically convert the buffers so that they are appropriate for the operation. For more information, refer to the PU documentation available in the Matrox FPGA Components Reference Help file. Note that processing can typically be performed by the Processing FPGA if the source buffer is allocated on-board, the destination buffer is allocated in non-paged Host memory or on-board, and the FPGA configuration includes a path from the PU(s) to the memory banks in which the specified source and destination buffers are located. In the case of Matrox imaging boards with on-board processors, destination buffers cannot be in Host memory; only on-board destination buffers are supported. When allocating your image buffers for a Processing FPGA operation (MbufAlloc...()), you can have MIL automatically select the optimal memory location, which is accessible to the Processing FPGA, for the image buffers. To do so, add M_FPGA_ACCESSIBLE to the other required attributes (for example, M_PROC + M_GRAB). Note that although the buffers will be allocated in memory accessible to the Processing FPGA, you must ensure that a path between the PU and the buffers is available. To explicitly allocate your buffer in a specific memory location that is accessible to the Processing FPGA, you can add one of the following attributes to M_FPGA_ACCESSIBLE. Note that by explicitly allocating your buffer in a specific memory location, you can make your code less portable to other boards with a different number of memory banks or Host memory restrictions. However, you might obtain some performance benefits. M_ON_BOARD. Explicitly allocates the buffer in on-board memory. M_HOST_MEMORY. Explicitly allocates the buffer in Host memory. M_MEMORY_BANK_n. Explicitly specifies the on-board memory bank in which to allocate your image buffer. The variable n specifies the rank of the on-board memory bank in which your image must be allocated. Note that M_MEMORY_BANK_n is not supported on Matrox imaging boards with on-board processors; you must use other buffer attributes to force the allocation of the buffer into a specific memory bank (for example, M_FPGA_ACCESSIBLE + M_FAST_MEMORY). Note that in general, child buffers are not supported; only color-band child buffers are supported. If you want to route the stream output of one PU to the stream input port of another PU, you will have to cascade the PUs using the appropriate functions. For more information on these functions, see the Cascaded and parallel processing section later in this chapter. Source and destination image buffers ",
      "wordCount": 535,
      "subEntries": []
    },
    {
      "id": "UG_fpga_Setting_and_retrieving_results_from_PU_registers",
      "version": null,
      "title": "Setting and retrieving results from PU registers",
      "subTitles": null,
      "location": "MIL UG P11: Miscellaneous",
      "pageURL": "content\\UserGuide\\fpga\\Setting_and_retrieving_results_from_PU_registers.htm",
      "text": " Setting and retrieving results from PU registers Each PU has a dedicated register space which consists of three separate sections: a header section, an I/O control section, and a user-specific section. Each of these sections contains registers that hold specific information about the PU. Registers in the header and I/O sections do not require user modification, while registers in the user-specific section allow you to set the PU's operation settings. Most PUs that return non-image results also return these results in registers in the user-specific section. You can set a PU's user-specific register section using up to four calls to MfpgaSetRegister(). Similarly, you can set up a request to retrieve the values of a PU's user-specific register section using up to four calls to MfpgaGetRegister(). Four calls is usually more than sufficient because you can write to or read from multiple registers at a single time. For each PU, you are provided with PU-specific, predefined, C constructs to facilitate setting the PU's user-specific registers. The constructs are supplied in header files (fpga_*.h). For custom PUs, use the generated register header files to write values to/read values from registers, instead of hardcoding a register or field offset, since these help keep your code forward-compatible. In the header file, there is a structure that represents all the user-specific registers of the PU. For example, this is the structure for all the user-specific registers of the gainoffset PU. /************************************************************* * Section name : USER * USEROFF : 0x60 **************************************************************/ typedef struct { FPGA_GAINOFFSET_REG_CTRL ctrl; /* Address offset : [0x60] */ FPGA_GAINOFFSET_REG_CLIPVAL clipval; /* Address offset : [0x68] */ } FPGA_GAINOFFSET_USER_ST; In the header file, there is also a union for each user-specific register of the PU. Each union contains five items. The first four items u64, u32, u16, and u8 represent different sizes of data blocks that you can write to/read from the register. The last item is a C structure that facilitates setting and getting the different fields of the register. This union provides you with different ways of writing to/reading from the register. For example, you could clear all the fields of a register to 0 using the U64 item of the union. Alternatively, you could write specific values to the different register fields. The following is the union for the control (ctrl) register of the gainoffset PU. /************************************************************* * Register name : ctrl * Address : 0x60 **************************************************************/ typedef union { MIL_UINT64 u64; MIL_UINT32 u32; MIL_UINT16 u16; MIL_UINT8 u8; struct { MIL_UINT64 dsttype : 2; /* Bits&lt;1:0&gt;, */ /* The data type and depth of the output image. */ MIL_UINT64 gaintype : 2; /* Bits&lt;3:2&gt;, */ /* The data type and depth of the gain image. */ MIL_UINT64 offtype : 2; /* Bits&lt;5:4&gt;, */ /* The data type and depth of the offset image. */ MIL_UINT64 srctype : 2; /* Bits&lt;7:6&gt;, */ /* The data depth and type of the input image on /* which to operate. */ MIL_UINT64 shift : 5; /* Bits&lt;12:8&gt;, */ /* Number of bits to right-shift. */ MIL_UINT64 rsvd0 : 19; /* Bits&lt;31:13&gt;, */ /* Reserved Field */ } f; } FPGA_GAINOFFSET_REG_CTRL; You should always set up and verify the values of the individual fields of each register before setting these values in the target PU. The following is an example that verifies the values for the registers of the gainoffset PU. If the wrong value is used, an error is returned. /* Sets the gain offset registers */ /* Specifies the stream input port 0 data type. */ switch(Src1Type) { case 8+M_UNSIGNED: pGOShadow-&gt;ctrl.f.srctype = 0x1; break; case 16+M_UNSIGNED: pGOShadow-&gt;ctrl.f.srctype = 0x3; break; default: MosPrintf(MIL_TEXT(\"Gain offset error: Invalid input stream port 0 data type.\\n\")); break; } /* Specifies the stream input port 1 data type. */ switch(Src2Type) { case 8+M_UNSIGNED: pGOShadow-&gt;ctrl.f.offtype = 0x1; break; case 16+M_UNSIGNED: pGOShadow-&gt;ctrl.f.offtype = 0x3; break; default: MosPrintf(MIL_TEXT(\"Gain offset error: Invalid input stream port 1 data type.\\n\")); break; } /* Specifies the stream input port 2 data type. */ switch(Src3Type) { case 8+M_UNSIGNED: pGOShadow-&gt;ctrl.f.gaintype = 0x1; break; case 16+M_UNSIGNED: pGOShadow-&gt;ctrl.f.gaintype = 0x3; break; default: MosPrintf(MIL_TEXT(\"Gain offset error: Invalid input stream port 3 data type.\\n\")); break; } /* Specifies the stream output port 0 data type. */ switch(DstType) { case 8+M_UNSIGNED: pGOShadow-&gt;ctrl.f.dsttype = 0x1; break; case 16+M_UNSIGNED: pGOShadow-&gt;ctrl.f.dsttype = 0x3; break; default: MosPrintf(MIL_TEXT(\"Gain offset error: Invalid output stream port 0 data type.\\n\")); break; } /* Specifies the clipping value. */ pGOShadow-&gt;clipval.f.clipval = lMaxValue; /* Computes the number of bits to right-shift the output image. */ j=1; for(i=0; i&lt;32; i++) { if(Src4 &amp; j) { pGOShadow-&gt;ctrl.f.shift = i; break; } j &lt;&lt;= 1; } Once the values of the fields of all registers are set up, use MfpgaSetRegister() to specify the contents for your PU's registers. Note that when you queue your command with MfpgaCommandQueue(), the values set using MfpgaSetRegister() will be written to the hardware as a block once the hardware becomes free. For this reason, it is essential that you always set the values of all the fields of the target register before queueing the command. /* Inquire the buffer info object for the source and destination buffers. */ MfuncInquire(MilSourceImage, M_BUFFER_INFO, &amp;Src); MfuncInquire(MilDestinationImage, M_BUFFER_INFO, &amp;Dest); /* Allocate an asynchronous command context on the AddConstant processing unit. */ if(MfpgaCommandAlloc(MfuncBufOwnerSystemId(Src), M_DEV0, FPGA_ADDCONST_FID, M_DEFAULT,M_DEV0, M_ASYNCHRONOUS, M_DEFAULT, &amp;AddConstantContext)) { /* Initialize the shadow register structure. */ InitializeShadowRegisters(&amp;ShadowRegisters, Src, ConstantValue, ControlFlag); /* Input0 of AddConstant processing unit is connected to the Src buffer. */ MfpgaSetSource(AddConstantContext, Src, M_INPUT0, M_DEFAULT); /* Output0 of AddConstant processing unit is connected to the Dest buffer. */ MfpgaSetDestination(AddConstantContext, Dest, M_OUTPUT0, M_DEFAULT); /* Pass the initialized shadow register structure, it will be programmed */ /* when the processing operation is dispatched (before processing starts). */ MfpgaSetRegister(AddConstantContext, M_USER, 0, sizeof(ShadowRegisters), (void*)(&amp;ShadowRegisters), M_WHEN_DISPATCHED); /* Queue the processing operation, because this context is asynchronous, */ /* MfpgaComamndQueue will return before the operation is completed. */ MfpgaCommandQueue(AddConstantContext, M_DEFAULT, M_DEFAULT); /* Free the allocated context. */ MfpgaCommandFree(AddConstantContext, M_DEFAULT); } Setting and retrieving results from PU registers ",
      "wordCount": 990,
      "subEntries": []
    },
    {
      "id": "UG_fpga_Cascaded_and_parallel_asynchronous_processing_functions",
      "version": null,
      "title": "Cascaded and parallel processing",
      "subTitles": [
        "Cascaded processing operation",
        "Parallel processing operation"
      ],
      "location": "MIL UG P11: Miscellaneous",
      "pageURL": "content\\UserGuide\\fpga\\Cascaded_and_parallel_asynchronous_processing_functions.htm",
      "text": " Cascaded and parallel processing When designing a primitive function for your application, you might encounter situations where the entire operation must be carried out by two or more PUs. For example, your application might require a Bayer filter as well as a LUT mapping. Depending on the application, you might want specific PU operations to be cascaded (the result of one PU transferred directly to another PU) or carried out in parallel, or a combination of both to reduce the number of memory accesses. If the PUs are appropriately interconnected in the FPGA configuration, MIL allows you to do so. Refer to your FPGA documentation for more information. Cascaded processing operation You can cascade the processing operations of the PUs associated with two command contexts using MfpgaSetLink(). When you link two command contexts, the stream output of one PU is used as the stream input for the other PU. To transfer image data between two PUs, the stream output of the source PU and the stream input of the destination PU must be configured to the same image data format. To cascade several PUs, you must create a command context for each PU and then link the command contexts two at a time. Note that calling MfpgaSetLink() to route the output of one PU to the stream input of another PU requires that this path is available between the PUs in the FPGA configuration. To ensure that the cascaded processing operations start at the right moment in time, there are special considerations when queuing their commands. For more information, see the Issuing commands to the Processing FPGA and retrieving results section later in this chapter. Parallel processing operation You can also send data simultaneously from memory or from a PU to two or more different PUs. To do so, the FPGA configuration must include a specialized PU called a splitter PU. The splitter PU receives image data at its stream input port and copies this data to all its stream output ports. If you cascade the stream output ports of the splitter PU with the stream input ports of the required PUs, the required PUs will simultaneously process the same data. For example, you can simultaneously send the result of a PU that performs a Bayer operation to a PU that performs a gain and offset operation and a PU that performs a min/max operation. Note that a path between the stream output ports of the splitter PU and the stream input ports of the required PUs must exist. The number of output ports of the splitter PU, included in your FPGA configuration, depends on the PU's subfunction identifier. In addition, the stream outputs of the splitter PU and the stream input(s) of the destination PU(s) must be configured to the same image data format. Similar to when cascading processing operations, to ensure that the processing operations are performed in parallel, there are special considerations when queuing their commands. For more information, see the Issuing commands to the Processing FPGA and retrieving results section later in this chapter. Note that you must set up the splitter PU just like any other PU. This means that you must create a command context for each required splitter PU present in the FPGA configuration. Cascaded and parallel processing Cascaded processing operation Parallel processing operation ",
      "wordCount": 553,
      "subEntries": []
    },
    {
      "id": "UG_fpga_Issuing_commands_to_the_Processing_FPGA_and_retrieving_results",
      "version": null,
      "title": "Issuing commands to the Processing FPGA and retrieving results",
      "subTitles": null,
      "location": "MIL UG P11: Miscellaneous",
      "pageURL": "content\\UserGuide\\fpga\\Issuing_commands_to_the_Processing_FPGA_and_retrieving_results.htm",
      "text": " Issuing commands to the Processing FPGA and retrieving results Once you have specified register settings, source and destination image buffers, register result retrieval requests, and optionally linked information for each command context, you must queue the command(s), defined by these contexts, on the thread's system command queue using MfpgaCommandQueue(). Once on the queue, the commands will be executed in first-in first-out order as the Processing FPGA resources become available. Note that two commands can typically run at the same time if they don't reference the same buffers and they use different FPGA components that can access these buffers using different paths. For linked command contexts, you will have to combine the commands, defined by these contexts, into a complex command once you are ready to queue them. You combine commands into a complex command by queuing all linked commands, except the last, using MfpgaCommandQueue() with M_WAIT. Then you should add the last command to the complex command using MfpgaCommandQueue() with M_DISPATCH; this closes the complex command and queues it on the system command queue. The following example shows how to link two command contexts and then combine these commands into a complex command. /* Output0 of the OffsetGain is connected to Input0 of the LutMap. */ MfpgaSetLink(OffsetGainContext, M_OUTPUT0, LutMapContext, M_INPUT0, M_DEFAULT); /* Queue the processing operation, we use the M_WAIT flag because */ /* other MfpgaCommandQueue() follows. */ /* This tells the software to wait for other MfpgaCommandQueue() operations. */ MfpgaCommandQueue(LutMapContext, M_DEFAULT, M_WAIT); /* Queue the processing operation, using the M_DEFAULT flag. */ /* This tells the software to send the processing operation to the FPGA. */ MfpgaCommandQueue(OffsetGainContext, M_DEFAULT, M_DEFAULT); For Matrox imaging boards with on-board processors, the order in which you add commands to the complex command plays an important role; the command queued using MfpgaCommandQueue() with M_DISPATCH must be the command associated with the first PU in the processing chain. The completion mode of an MfpgaCommandQueue() call specifies when the command should be tagged as complete. When tagged as complete, you can read back results from your destination buffer(s) or the variables passed to the register result retrieval requests. For complex commands, the completion mode of the last command added to the complex command determines the completion mode for the entire complex command. All other commands in the complex command should have their completion mode set to M_DEFAULT. When you allocate an FPGA command context, you must specify how the command will be dispatched to the Matrox imaging board. You can specify that a command should run synchronously or asynchronously. A synchronous command (MfpgaCommandAlloc() with M_SYNCHRONOUS) causes the thread from which the command is dispatched to wait for the command to complete before executing subsequent statements. An asynchronous command ( MfpgaCommandAlloc() with M_ASYNCHRONOUS) causes the thread to continue executing subsequent statements without waiting for the command to complete. For complex commands, MIL uses the synchronous/asynchronous setting of the last command in the complex command (that is, the call to MfpgaCommandQueue() with M_DISPATCH). The Host processor supports both M_SYNCHRONOUS and M_ASYNCHRONOUS settings; it can continue to work if the command is asynchronous. However on Matrox imaging boards with on-board processors, only the M_SYNCHRONOUS setting is supported: the thread of the on-board processor executing the call to MfpgaCommandAlloc() with M_DISPATCH always waits until each command has finished processing (synchronous operation). Issuing commands to the Processing FPGA and retrieving results ",
      "wordCount": 561,
      "subEntries": []
    },
    {
      "id": "UG_fpga_Developing_a_custom_MIL_function_to_run_the_primitive_function",
      "version": null,
      "title": "Developing a user-defined MIL function to run the primitive function",
      "subTitles": [
        "Master function and slave function and execution of operation specified by command context",
        "Operation synchronization"
      ],
      "location": "MIL UG P11: Miscellaneous",
      "pageURL": "content\\UserGuide\\fpga\\Developing_a_custom_MIL_function_to_run_the_primitive_function.htm",
      "text": " Developing a user-defined MIL function to run the primitive function Although creating a primitive function that calls the appropriate functions of the MIL FPGA module is a critical step to issuing commands to your processing FPGA, sometimes additional steps are required. If your Matrox imaging board has an on-board processor, you must call your primitive function from the slave function of a user-defined MIL function; for more information on how to define a user-defined MIL function, see Chapter 67: The MIL function development module. If your Matrox imaging board does not have an on-board processor (for example, Matrox Solios), you can also call your primitive function from the slave function of a user-defined function to obtain basic error reporting or other built-in MIL features. Doing so might incur some small overhead but provides great benefits and can save considerable development time. To develop a user-defined MIL function to call the primitive function, perform the following: Create a master function to register and check the parameters passed to the master function before sending the information to the slave function. Create a slave function to recuperate the values of the parameters registered in the master function and call the primitive function. To log any of your user-defined error messages with the MIL error handling mechanism, use MfuncErrorReport(). Note that when your Matrox imaging board has an on-board processor, the slave and primitive functions must be precompiled and preloaded into the shell of the on-board processor. Master function and slave function and execution of operation specified by command context When you allocate a MIL function context in the master function of your user-defined MIL function using MfuncAlloc(), you must specify the identifier to associate with the MIL function. This identifier need not match the PU's function identifier that is specified when allocating the command context using MfpgaCommandAlloc(). Operation synchronization When you allocate your MIL function context using MfuncAlloc(), you must specify whether your master function should wait for the slave function to finish executing before executing the next statement in the master function. This should not be confused with the synchronization specified by MfpgaCommandAlloc(), which specifies whether the current thread should issue the Processing FPGA command synchronously or asynchronously. The following illustrates the primitive function call from the slave function of a user-defined function. Choosing whether to set the user-defined function as synchronous or asynchronous depends on the application. A synchronous function can be easier to code, but using an asynchronous function allows you to perform Host and Processing FPGA operations simultaneously. Note that for Matrox imaging boards with on-board processors, the thread of the on-board processor always waits until each Processing FPGA command has completed its synchronous operation. Developing a user-defined MIL function to run the primitive function Master function and slave function and execution of operation specified by command context Operation synchronization ",
      "wordCount": 473,
      "subEntries": []
    }
  ]
}]
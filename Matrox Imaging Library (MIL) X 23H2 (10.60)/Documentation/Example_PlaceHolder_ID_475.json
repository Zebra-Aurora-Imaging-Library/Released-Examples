[{
  "id": "Example_PlaceHolder_ID",
  "version": "2024020714",
  "title": "Example_PlaceHolder_Title",
  "wordCount": 0,
  "subEntries": [
    {
      "id": "Examples_IndustrialCommunication_Robots_Kuka_CPP_mcomkuka_cpp",
      "version": "2024020714",
      "title": "mcomkuka.cpp",
      "location": "Sample Code from MIL Examples",
      "text": " Top /******************************************************************************/ /* * File name: McomKUKA.cpp * Location: See Matrox Example Launcher in the MIL Control Center * * * Synopsis: This program allocates a MIL application and system. * Then allocate a MIL industrial communication context to a * KUKA robot instance. * * Notes: This example is only available if you have the MIL Industrial Communication package, * or another relevant update installed. * * Copyright (C) Matrox Electronic Systems Ltd., 1992-2024. * All Rights Reserved */ #include &lt;mil.h&gt; MIL_ID MilApplication, /* Application identifier. */ MilSystem, /* System identifier. */ MilCom; /* Industrial communication identifier. */ /* The address and port used to communicate with the robot */ MIL_CONST_TEXT_PTR ROBOT_IP = MIL_TEXT(\"127.0.0.1:59002\"); /* NEED TO BE CHANGED */ /* Signaled to be true when a connection timeout is reported in hook to error */ MIL_BOOL isTimeout = M_FALSE; MIL_INT MFTYPE AsyncErrorHook(MIL_INT HookType, MIL_ID EventId, void* UserData); void GetNextPosition(MIL_DOUBLE&amp; x, MIL_DOUBLE&amp; y, MIL_DOUBLE&amp; z); int MosMain(void) { MIL_INT64 opcode; MIL_INT64 status; MIL_INT64 modelid; MIL_DOUBLE robot_x, robot_y, robot_z; MIL_DOUBLE robot_rx, robot_ry, robot_rz; MIL_INT connectRetryWait = 0; MIL_BOOL isConnected = M_FALSE; MIL_BOOL isTimeoutSignaled = M_FALSE; /* Allocate a default MIL application, system, display and image. */ MappAllocDefault(M_DEFAULT, &amp;MilApplication, &amp;MilSystem, M_NULL, M_NULL, M_NULL); /* Using M_COM_NO_CONNECT is a meyhod to have control when the connection to the robot is done */ McomAlloc(MilSystem, M_COM_PROTOCOL_KUKA, ROBOT_IP, M_COM_NO_CONNECT, M_DEFAULT, &amp;MilCom); /* Get advised when MCOM report an error */ McomHookFunction(MilCom, M_COM_ERROR_TRIGGER, AsyncErrorHook, M_NULL); /* Set the number of connection retry */ McomControl(MilCom, M_COM_ROBOT_CONNECT_RETRY, 5); /* Now that we are hooked to error, we launch the asynchronous connection */ McomControl(MilCom, M_COM_ROBOT_CONNECT, M_DEFAULT); /* Retrieve elapsed time between connection attempts to robot */ McomInquire(MilCom, M_COM_ROBOT_CONNECT_RETRY_WAIT, &amp;connectRetryWait); /* Wait for a key press. */ MosPrintf(MIL_TEXT(\"Press any key to end.\\n\")); while (!MosKbhit()) { if (!isConnected &amp;&amp; !isTimeout) { McomInquire(MilCom, M_COM_ROBOT_ISCONNECTED, &amp;isConnected); MosSleep(connectRetryWait); } else if(isConnected) { /* Wait for the robot to request a new position */ McomWaitPositionRequest(MilCom, &amp;opcode, &amp;status, &amp;modelid, &amp;robot_x, &amp;robot_y, &amp;robot_z, &amp;robot_rx, &amp;robot_ry, &amp;robot_rz, M_DEFAULT, M_DEFAULT); /* Find the next position to send the robot*/ GetNextPosition(robot_x, robot_y, robot_z); /* Send the next position to the robot*/ McomSendPosition(MilCom, M_COM_ROBOT_FIND_POSITION_RESULT, 0, modelid, robot_x, robot_y, robot_z, robot_rx, robot_ry, robot_rz, M_DEFAULT, M_DEFAULT); } else if(isTimeout &amp;&amp; !isTimeoutSignaled) { MosPrintf(MIL_TEXT(\"Network error. Cannot connect to the robot.\\n\")); isTimeoutSignaled = M_TRUE; } } /* Free MIL objects*/ McomFree(MilCom); MappFreeDefault(MilApplication, MilSystem, M_NULL, M_NULL, M_NULL); return 0; } void GetNextPosition(MIL_DOUBLE&amp; x, MIL_DOUBLE&amp; y, MIL_DOUBLE&amp; z) { /* Only move the robot to an offset in x in this example */ x += 15; if (x &gt; 300) x = 0; } MIL_INT MFTYPE AsyncErrorHook(MIL_INT HookType, MIL_ID EventId, void* UserData) { UNREFERENCED_PARAMETER(UserData); UNREFERENCED_PARAMETER(HookType); MIL_INT32 errorCode; McomGetHookInfo(EventId, M_COM_ERROR_NUMBER, &amp;errorCode); if (errorCode == M_COM_NETWORK_ERROR_ROBOT_CONNECT) { isTimeout = M_TRUE; } return 0; } ",
      "wordCount": 457
    }
  ]
}]
[{
  "id": "Example_PlaceHolder_ID",
  "version": "2024020714",
  "title": "Example_PlaceHolder_Title",
  "wordCount": 0,
  "subEntries": [
    {
      "id": "Examples_Core_Full_Multi3dDisplaySharedGraphicsList_CPP_multi3ddisplaysharedgraphicslist_cpp",
      "version": "2024020714",
      "title": "multi3ddisplaysharedgraphicslist.cpp",
      "location": "Sample Code from MIL Examples",
      "text": " Top //---------------------------------------------------------------------------- // // File name: Multi3dDisplaySharedGraphicsList.cpp // Location: See Matrox Example Launcher in the MIL Control Center // // // Synopsis: This example demonstrates an application using multiple // displays with shared 3D graphics lists. It also demonstrates // display linking, point picking, handles graphics and display // view limiting controls. // // Copyright (C) Matrox Electronic Systems Ltd., 1992-2024. // All Rights Reserved //---------------------------------------------------------------------------- #include &lt;mil.h&gt; #include \"Display3dLinker.h\" //----------------------------------------------------------------------------- // Constants. //----------------------------------------------------------------------------- static const MIL_INT DISP_SIZE = 400; static const MIL_INT DISP_PADDING_X = 0; static const MIL_INT DISP_PADDING_Y = 30; static const MIL_INT FONT_SIZE = 12; static const MIL_INT FONT_SIZE_SMALL = FONT_SIZE / 2; static const MIL_INT ROT_90 = 90; static const MIL_INT AZIMUTH = 180; static const MIL_INT HIGH_RENDER_L = 2; static const MIL_INT GRAPHIC_OPACITY = 25; static const MIL_INT GRAPHIC_THICKNESS = 3; static const MIL_INT NUMBER_OF_POINTS = 2; static const std::vector&lt;MIL_DOUBLE&gt; SHIFT_0 = {50.0, 45.0 , 0.0 }; static const std::vector&lt;MIL_DOUBLE&gt; SHIFT_1 = {65.0, -20.0, 0.0 }; static const std::vector&lt;MIL_DOUBLE&gt; SHIFT_2 = {20.0, 0.0 , 50.0}; static const MIL_STRING PT_CLD_FILE = M_IMAGE_PATH MIL_TEXT(\"M3dgra/MaskOrganized.mbufc\"); //---------------------------------------------------------------------------- struct SHandleStruct { MIL_INT64 BoxLabel; MIL_ID Box; MIL_ID Gralist; MIL_ID OriginalContainer; MIL_ID CroppedContainer; }; struct SPickStruct { MIL_ID Gralist; MIL_ID PickContext; MIL_ID PickResult; }; //---------------------------------------------------------------------------- // Function Declaration. //---------------------------------------------------------------------------- bool CheckForRequiredMILFile(const MIL_STRING&amp; FileName); MIL_ID Alloc3dDisplayId(MIL_ID MilSystem); MIL_INT MFTYPE BoxModifiedHandler(MIL_INT HookType, MIL_ID EventId, void* UserDataPtr); MIL_INT MFTYPE ClickHandler(MIL_INT HookType, MIL_ID EventId, void* UserDataPtr); void RetrieveBoxAndCrop(SHandleStruct* PickStruct); //----------------------------------------------------------------------------- // Main. //----------------------------------------------------------------------------- int MosMain() { MosPrintf( MIL_TEXT(\"[EXAMPLE NAME]\\n\") MIL_TEXT(\"Multi3dDisplaySharedGraphicsList\\n\\n\") MIL_TEXT(\"[SYNOPSIS]\\n\") MIL_TEXT(\"This example demonstrates an application using multiple \\n\") MIL_TEXT(\"displays with shared 3D graphics lists, display linking, \\n\") MIL_TEXT(\"point picking, graphic handling and display view limiting controls. \\n\\n\") MIL_TEXT(\"[MODULES USED]\\n\") MIL_TEXT(\"Modules used: application, system, buffer, 3D display, 3D graphics.\\n\\n\")); // Allocate defaults. auto MilApplication = MappAlloc(MIL_TEXT(\"M_DEFAULT\"), M_DEFAULT, M_UNIQUE_ID); auto MilSystem = MsysAlloc(M_DEFAULT, M_SYSTEM_DEFAULT, M_DEFAULT, M_DEFAULT, M_UNIQUE_ID); // Check for required example files. if(!CheckForRequiredMILFile(PT_CLD_FILE)) { return 0; } // Initialize the 3D Displays. auto MilCropDisplay = Alloc3dDisplayId(MilSystem); auto MilTopViewDisplay = Alloc3dDisplayId(MilSystem); auto MilPickDisplay = Alloc3dDisplayId(MilSystem); auto MilSideViewDisplay = Alloc3dDisplayId(MilSystem); // Ensure proper allocation of 3D Displays. if(!MilCropDisplay || !MilTopViewDisplay || !MilPickDisplay || !MilSideViewDisplay) { if(MilCropDisplay) M3ddispFree(MilCropDisplay); if(MilTopViewDisplay) M3ddispFree(MilTopViewDisplay); if(MilPickDisplay) M3ddispFree(MilPickDisplay); if(MilSideViewDisplay) M3ddispFree(MilSideViewDisplay); MosPrintf(MIL_TEXT(\"The current system does not support the 3D display.\\n\") MIL_TEXT(\"Press any key to exit.\\n\")); return 0; } auto MilCropGraList = M3ddispInquire(MilCropDisplay , M_3D_GRAPHIC_LIST_ID, M_NULL); auto MilTopViewGraList = M3ddispInquire(MilTopViewDisplay , M_3D_GRAPHIC_LIST_ID, M_NULL); auto MilPickGraList = M3ddispInquire(MilPickDisplay , M_3D_GRAPHIC_LIST_ID, M_NULL); auto MilSideViewGraList = M3ddispInquire(MilSideViewDisplay, M_3D_GRAPHIC_LIST_ID, M_NULL); // Set display titles. M3ddispControl(MilCropDisplay , M_TITLE, MIL_TEXT(\"Cropping Display\") ); M3ddispControl(MilTopViewDisplay , M_TITLE, MIL_TEXT(\"Top View Display\") ); M3ddispControl(MilPickDisplay , M_TITLE, MIL_TEXT(\"Picking Display\") ); M3ddispControl(MilSideViewDisplay, M_TITLE, MIL_TEXT(\"Side View Display\")); // Set all display's sizes and initial positions so that all are visible and don't overlap. M3ddispControl(MilCropDisplay , M_SIZE_X, DISP_SIZE); M3ddispControl(MilCropDisplay , M_SIZE_Y, DISP_SIZE); M3ddispControl(MilTopViewDisplay , M_SIZE_X, DISP_SIZE); M3ddispControl(MilTopViewDisplay , M_SIZE_Y, DISP_SIZE); M3ddispControl(MilPickDisplay , M_SIZE_X, DISP_SIZE); M3ddispControl(MilPickDisplay , M_SIZE_Y, DISP_SIZE); M3ddispControl(MilSideViewDisplay, M_SIZE_X, DISP_SIZE); M3ddispControl(MilSideViewDisplay, M_SIZE_Y, DISP_SIZE); M3ddispControl(MilTopViewDisplay , M_WINDOW_INITIAL_POSITION_X, DISP_SIZE + DISP_PADDING_X); M3ddispControl(MilPickDisplay , M_WINDOW_INITIAL_POSITION_Y, DISP_SIZE + DISP_PADDING_Y); M3ddispControl(MilSideViewDisplay, M_WINDOW_INITIAL_POSITION_Y, DISP_SIZE + DISP_PADDING_Y); M3ddispControl(MilSideViewDisplay, M_WINDOW_INITIAL_POSITION_X, DISP_SIZE + DISP_PADDING_X); // Set views for the top and side displays. M3ddispSetView(MilTopViewDisplay, M_AUTO, M_TOP_VIEW, M_DEFAULT, M_DEFAULT, M_DEFAULT); M3ddispSetView(MilTopViewDisplay, M_AZIMUTH, AZIMUTH, M_DEFAULT, M_DEFAULT, M_DEFAULT); M3ddispSetView(MilSideViewDisplay, M_AUTO, M_FRONT_VIEW, M_DEFAULT, M_DEFAULT, M_DEFAULT); // Disable mouse rotations for these 2 displays to keep their view on the given side. M3ddispControl(MilTopViewDisplay , M_MOUSE_ROTATION, M_DISABLE); M3ddispControl(MilSideViewDisplay, M_MOUSE_ROTATION, M_DISABLE); // Set the prjection mode to parallel, // this will make a better view from the side when translating. M3ddispControl(MilSideViewDisplay, M_PROJECTION_MODE, M_PARALLEL); auto Mil3dSharedGraList = M3dgraAlloc(MilSystem, M_DEFAULT, M_UNIQUE_ID); // Restore the point cloud from a file. auto MilOriginalContainer = MbufImport(PT_CLD_FILE, M_DEFAULT, M_RESTORE, MilSystem, M_UNIQUE_ID); // Create a cropped copy of the point cloud and add it to the shared graphics list. auto MilCroppedContainer = MbufAllocContainer(MilSystem, M_PROC + M_DISP, M_DEFAULT, M_UNIQUE_ID); auto PointCloudLabel = M3dgraAdd(Mil3dSharedGraList, M_ROOT_NODE, MilCroppedContainer, M_DEFAULT); M3dgraControl(Mil3dSharedGraList, PointCloudLabel, M_COLOR_USE_LUT, M_TRUE); M3dgraControl(Mil3dSharedGraList, PointCloudLabel, M_COLOR_COMPONENT, M_COMPONENT_RANGE); M3dgraControl(Mil3dSharedGraList, PointCloudLabel, M_COLOR_COMPONENT_BAND, 2); M3dgraCopy(M_COLORMAP_TURBO+M_FLIP, M_DEFAULT, Mil3dSharedGraList, PointCloudLabel, M_COLOR_LUT, M_DEFAULT); // Create an editable box in the graphics list. // Initialize the size of the box to a fraction of the original point cloud's size. auto MilBoundingBox = M3dgeoAlloc(MilSystem, M_GEOMETRY, M_DEFAULT, M_UNIQUE_ID); M3dimStat(M_STAT_CONTEXT_BOUNDING_BOX, MilOriginalContainer, MilBoundingBox, M_DEFAULT); M3dgeoBox(MilBoundingBox, M_CENTER_AND_DIMENSION, M_UNCHANGED, M_UNCHANGED, M_UNCHANGED, M3dgeoInquire(MilBoundingBox, M_SIZE_X, M_NULL) * 0.5, M3dgeoInquire(MilBoundingBox, M_SIZE_Y, M_NULL) * 0.5, M_UNCHANGED, M_DEFAULT); // Draw the cropping box inside the cropping display's graphics list. auto BoxLabel = M3dgeoDraw3d(M_DEFAULT, MilBoundingBox, MilCropGraList, M_ROOT_NODE, M_DEFAULT); auto MilCroppingBox = M3dgeoAlloc(MilSystem, M_GEOMETRY, M_DEFAULT, M_UNIQUE_ID); M3dgraControl(MilCropGraList, BoxLabel, M_OPACITY, GRAPHIC_OPACITY); // Set it to be translatable accross the X axis by setting its handle type. M3dgraControl(MilCropGraList, BoxLabel, M_HANDLE_TYPE, M_HANDLE_TRANSLATION_X); // Setup the picking context for click handler. auto MilPickContext = M3ddispAlloc(MilSystem, M_DEFAULT, MIL_TEXT(\"M_DEFAULT\"), M_PICKING_CONTEXT, M_UNIQUE_ID); auto MilPickResult = M3ddispAllocResult(M_DEFAULT_HOST, M_PICKING_RESULT, M_DEFAULT, M_UNIQUE_ID); M3ddispControl(MilPickContext, M_GRAPHIC_TYPE , M_GRAPHIC_TYPE_POINT_CLOUD); M3ddispControl(MilPickContext, M_FACES_AND_LINES, M_DISABLE); // Create a hook to crop the container when the box is translated. SHandleStruct HandleStruct; HandleStruct.Box = MilCroppingBox; HandleStruct.BoxLabel = BoxLabel; HandleStruct.Gralist = MilCropGraList; HandleStruct.OriginalContainer = MilOriginalContainer; HandleStruct.CroppedContainer = MilCroppedContainer; M3dgraHookFunction(MilCropGraList, M_HANDLE_GRAPHIC_TRANSLATED, &amp;BoxModifiedHandler, &amp;HandleStruct); // Creates a hook when the pick display registers a left click. SPickStruct PickStruct; PickStruct.Gralist = Mil3dSharedGraList; PickStruct.PickContext = MilPickContext; PickStruct.PickResult = MilPickResult; M3ddispHookFunction(MilPickDisplay, M_MOUSE_LEFT_BUTTON_DOWN, &amp;ClickHandler, &amp;PickStruct); // Crop a first time before starting the interactivity. RetrieveBoxAndCrop(&amp;HandleStruct); // Setup the text labels in each display. auto MilMatrix = M3dgeoAlloc(MilSystem, M_TRANSFORMATION_MATRIX, M_DEFAULT, M_UNIQUE_ID); M3dgeoMatrixSetTransform(MilMatrix, M_TRANSLATION, SHIFT_0[0], SHIFT_0[1], SHIFT_0[2], M_DEFAULT, M_DEFAULT); auto TextLabel = M3dgraText(MilCropGraList, M_ROOT_NODE, MIL_TEXT(\"Cropping Display\"), MilMatrix, M_DEFAULT, M_DEFAULT); M3dgraControl(MilCropGraList, TextLabel, M_RENDER_LAYER, HIGH_RENDER_L); M3dgraControl(MilCropGraList, TextLabel, M_COLOR, M_COLOR_MAGENTA); M3dgraControl(MilCropGraList, TextLabel, M_FONT_SIZE, FONT_SIZE); TextLabel = M3dgraText(MilPickGraList, M_ROOT_NODE, MIL_TEXT(\"Picking Display\"), MilMatrix, M_DEFAULT, M_DEFAULT); M3dgraControl(MilPickGraList, TextLabel, M_RENDER_LAYER, HIGH_RENDER_L); M3dgraControl(MilPickGraList, TextLabel, M_COLOR, M_COLOR_DARK_YELLOW); M3dgraControl(MilPickGraList, TextLabel, M_FONT_SIZE, FONT_SIZE); M3dgeoMatrixSetTransform(MilMatrix, M_ROTATION_Z, ROT_90, M_DEFAULT, M_DEFAULT, M_DEFAULT, M_COMPOSE_WITH_CURRENT); M3dgeoMatrixSetTransform(MilMatrix, M_TRANSLATION, SHIFT_1[0], SHIFT_1[1], SHIFT_1[2], M_DEFAULT, M_COMPOSE_WITH_CURRENT); TextLabel = M3dgraText(MilTopViewGraList, M_ROOT_NODE, MIL_TEXT(\"Top View Display\"), MilMatrix, M_DEFAULT, M_DEFAULT); M3dgraControl(MilTopViewGraList, TextLabel, M_RENDER_LAYER, HIGH_RENDER_L); M3dgraControl(MilTopViewGraList, TextLabel, M_COLOR, M_COLOR_CYAN); M3dgraControl(MilTopViewGraList, TextLabel, M_FONT_SIZE, FONT_SIZE); // Setup display text. M3dgeoMatrixSetTransform(MilMatrix, M_ROTATION_X, ROT_90, M_DEFAULT, M_DEFAULT, M_DEFAULT, M_COMPOSE_WITH_CURRENT); M3dgeoMatrixSetTransform(MilMatrix, M_ROTATION_Y, ROT_90, M_DEFAULT, M_DEFAULT, M_DEFAULT, M_COMPOSE_WITH_CURRENT); M3dgeoMatrixSetTransform(MilMatrix, M_TRANSLATION, SHIFT_2[0], SHIFT_2[1], SHIFT_2[2], M_DEFAULT, M_COMPOSE_WITH_CURRENT); TextLabel = M3dgraText(MilSideViewGraList, M_ROOT_NODE, MIL_TEXT(\"Side View Display\"), MilMatrix, M_DEFAULT, M_DEFAULT); M3dgraControl(MilSideViewGraList, TextLabel, M_RENDER_LAYER, HIGH_RENDER_L); M3dgraControl(MilSideViewGraList, TextLabel, M_COLOR, M_COLOR_GREEN); M3dgraControl(MilSideViewGraList, TextLabel, M_FONT_SIZE, FONT_SIZE_SMALL); M3ddispSelect(MilCropDisplay , Mil3dSharedGraList, M_SELECT, M_DEFAULT); M3ddispSelect(MilTopViewDisplay , Mil3dSharedGraList, M_SELECT, M_DEFAULT); M3ddispSelect(MilPickDisplay , Mil3dSharedGraList, M_SELECT, M_DEFAULT); M3ddispSelect(MilSideViewDisplay, Mil3dSharedGraList, M_SELECT, M_DEFAULT); MosPrintf( MIL_TEXT(\"In order from top left to bottom right the displays perform the following:\\n\") MIL_TEXT(\" 1: Crops the shared point cloud based on the editable box.\\n\") MIL_TEXT(\" - Move the box (mouse drag) to see the point cloud cropped \") MIL_TEXT(\"in all displays.\\n\") MIL_TEXT(\" 2: Shows the top view of the point cloud. Rotation disabled.\\n\") MIL_TEXT(\" 3: Calculates the distance of 2 picked \") MIL_TEXT(\"points and draws a line in the shared list.\\n\") MIL_TEXT(\" - Click on the point cloud to pick a point.\\n\") MIL_TEXT(\" 4: Shows the side view of the point cloud. Rotation disabled.\\n\\n\")); MosPrintf( MIL_TEXT(\"Cropping display and picking display are fully linked meaning they will\\n\") MIL_TEXT(\"have the same view when modified. The top view and side view displays\\n\") MIL_TEXT(\"are linked in terms of zoom. \\n\\n\")); MosPrintf( MIL_TEXT(\"Text graphics, lines and dots have a higher render layer meaning they \\n\") MIL_TEXT(\"will always appear \\\"above\\\" graphics which have a lower render layer. \\n\\n\")); M3ddispSelect(MilCropDisplay , M_NULL, M_OPEN, M_DEFAULT); M3ddispSelect(MilTopViewDisplay , M_NULL, M_OPEN, M_DEFAULT); M3ddispSelect(MilPickDisplay , M_NULL, M_OPEN, M_DEFAULT); M3ddispSelect(MilSideViewDisplay, M_NULL, M_OPEN, M_DEFAULT); // Link cropping and picking displays. CDisplayLinker FullLinker = CDisplayLinker({MilCropDisplay, MilPickDisplay}, eFullLink); CDisplayLinker ZoomLinker = CDisplayLinker({MilTopViewDisplay, MilSideViewDisplay}, eDistanceLink); MosPrintf(MIL_TEXT(\"Press 0 in the console to swap editability of the cropping box. \\n\")); MosPrintf(MIL_TEXT(\"Press &lt;Enter&gt; to exit. \\n\\n\")); auto done = false, isvisible = true; while(!done) { auto Choice = MosGetch(); if(Choice == '\\r') { done = true; } else { Choice -= ('0' + 0); if(Choice == 0) { M3dgraControl(MilCropGraList, BoxLabel, M_VISIBLE, isvisible ? M_FALSE : M_TRUE); isvisible = !isvisible; } } } // Unhook functions. M3dgraHookFunction (MilCropGraList, M_HANDLE_GRAPHIC_TRANSLATED + M_UNHOOK, &amp;BoxModifiedHandler, &amp;HandleStruct); M3ddispHookFunction(MilPickDisplay, M_MOUSE_LEFT_BUTTON_DOWN + M_UNHOOK, &amp;ClickHandler , &amp;PickStruct); // Free displays. M3ddispFree(MilCropDisplay); M3ddispFree(MilTopViewDisplay); M3ddispFree(MilPickDisplay); M3ddispFree(MilSideViewDisplay); return 0; } //---------------------------------------------------------------------------- // Handler called whenever the box is handled through translation or rotation. //---------------------------------------------------------------------------- MIL_INT MFTYPE BoxModifiedHandler(MIL_INT /*HookType*/, MIL_ID /*EventId*/, void* UserDataPtr) { SHandleStruct* HandleStruct = static_cast&lt;SHandleStruct*&gt;(UserDataPtr); RetrieveBoxAndCrop(HandleStruct); return 0; } //---------------------------------------------------------------------------- // Click handler which adds dots and line. //---------------------------------------------------------------------------- MIL_INT MFTYPE ClickHandler(MIL_INT /*HookType*/, MIL_ID EventId, void* UserDataPtr) { static MIL_DOUBLE PointX[NUMBER_OF_POINTS] = {M_NULL, M_NULL}; static MIL_DOUBLE PointY[NUMBER_OF_POINTS] = {M_NULL, M_NULL}; static MIL_DOUBLE PointZ[NUMBER_OF_POINTS] = {M_NULL, M_NULL}; static MIL_UINT8 ColorR[NUMBER_OF_POINTS] = {255 , 255 }; static MIL_UINT8 ColorG[NUMBER_OF_POINTS] = {M_NULL, M_NULL}; static MIL_UINT8 ColorB[NUMBER_OF_POINTS] = {255 , 255 }; static MIL_INT64 DotsLabel = M_NULL; static MIL_INT64 LineLabel = M_NULL; static MIL_INT Index = 0; SPickStruct* PickStruct = static_cast&lt;SPickStruct*&gt;(UserDataPtr); MIL_ID MilDisp3d; M3ddispGetHookInfo(EventId, M_DISPLAY, &amp;MilDisp3d); MIL_INT64 MouseX, MouseY; M3ddispGetHookInfo(EventId, M_MOUSE_POSITION_X, &amp;MouseX); M3ddispGetHookInfo(EventId, M_MOUSE_POSITION_Y, &amp;MouseY); M3ddispPick(PickStruct-&gt;PickContext, MilDisp3d, PickStruct-&gt;PickResult, MouseX, MouseY, M_DEFAULT); MIL_INT Results = -1; M3ddispGetResult(PickStruct-&gt;PickResult, M_DEFAULT, M_NUMBER, &amp;Results); if(Results &gt; 0) { if(DotsLabel != M_NULL) { M3dgraRemove(PickStruct-&gt;Gralist, DotsLabel, M_DEFAULT); } if(LineLabel != M_NULL) { M3dgraRemove(PickStruct-&gt;Gralist, LineLabel, M_DEFAULT); } // Prevents the Display from interpreting this as a rotation interaction. // To permit rotation, but prevent the gyro from appearing on the initial click, // set M_CONSUMED to M_NO_CLEAR instead. M3ddispSetHookInfo(EventId, M_CONSUMED, M_TRUE); M3ddispGetResult(PickStruct-&gt;PickResult, M_PICKING_INDEX(0), M_PICKED_POSITION_3D_X, &amp;PointX[Index]); M3ddispGetResult(PickStruct-&gt;PickResult, M_PICKING_INDEX(0), M_PICKED_POSITION_3D_Y, &amp;PointY[Index]); M3ddispGetResult(PickStruct-&gt;PickResult, M_PICKING_INDEX(0), M_PICKED_POSITION_3D_Z, &amp;PointZ[Index]); DotsLabel = M3dgraDots(PickStruct-&gt;Gralist, M_ROOT_NODE, LineLabel != M_NULL || Index == 1 ? 2 : 1, PointX, PointY, PointZ, ColorR, ColorG, ColorB, M_DEFAULT); M3dgraControl(PickStruct-&gt;Gralist, DotsLabel, M_OPACITY, GRAPHIC_OPACITY); M3dgraControl(PickStruct-&gt;Gralist, DotsLabel, M_RENDER_LAYER, HIGH_RENDER_L); M3dgraControl(PickStruct-&gt;Gralist, DotsLabel, M_THICKNESS, GRAPHIC_THICKNESS); if(LineLabel != M_NULL || Index == 1) //We have 2 points now. { if(LineLabel == M_NULL) { MosPrintf(MIL_TEXT(\"Point1\\t\\t\\t\\tPoint2\\t\\t\\t\\tDistance \\n\")); } LineLabel = M3dgraLine(PickStruct-&gt;Gralist, M_ROOT_NODE, M_TWO_POINTS, M_DEFAULT, PointX[0], PointY[0], PointZ[0], PointX[1], PointY[1], PointZ[1], M_DEFAULT, M_DEFAULT); M3dgraControl(PickStruct-&gt;Gralist, LineLabel, M_COLOR, M_RGB888(ColorR[0], ColorG[0], ColorB[0])); M3dgraControl(PickStruct-&gt;Gralist, LineLabel, M_THICKNESS, GRAPHIC_THICKNESS); M3dgraControl(PickStruct-&gt;Gralist, LineLabel, M_RENDER_LAYER, HIGH_RENDER_L); MIL_DOUBLE Size = -1; MIL_INT PrevIndex = (Index + 1) % 2; M3dgraInquire(PickStruct-&gt;Gralist, LineLabel, M_LENGTH, &amp;Size); MosPrintf(MIL_TEXT(\"{%6.2f, %6.2f, %6.2f}\\t{%6.2f, %6.2f, %6.2f}\\t%.2f \\r\"), PointX[PrevIndex], PointY[PrevIndex], PointZ[PrevIndex], PointX[Index], PointY[Index], PointZ[Index], Size); } } Index = ++Index % 2; return 0; } //---------------------------------------------------------------------------- // Crops point cloud using the box as boundaries. //---------------------------------------------------------------------------- void RetrieveBoxAndCrop(SHandleStruct* HandleStruct) { // Retrieve the edited box from the graphics list. M3dgraCopy(HandleStruct-&gt;Gralist, HandleStruct-&gt;BoxLabel, HandleStruct-&gt;Box, M_DEFAULT, M_GEOMETRY, M_DEFAULT); // Crop the point cloud using the retrieved box. M3dimCrop(HandleStruct-&gt;OriginalContainer, HandleStruct-&gt;CroppedContainer, HandleStruct-&gt;Box, M_NULL, M_SAME, M_DEFAULT); } //---------------------------------------------------------------------------- // Check for required files to run the example. //---------------------------------------------------------------------------- bool CheckForRequiredMILFile(const MIL_STRING&amp; FileName) { MIL_INT FilePresent = M_NO; MappFileOperation(M_DEFAULT, FileName, M_NULL, M_NULL, M_FILE_EXISTS, M_DEFAULT, &amp;FilePresent); if(FilePresent == M_NO) { MosPrintf(MIL_TEXT(\"The footage needed to run this example is missing. You need \\n\") MIL_TEXT(\"to obtain and apply a separate specific update to have it.\\n\\n\")); MosPrintf(MIL_TEXT(\"Press any key to end.\\n\\n\")); MosGetch(); } return (FilePresent == M_YES); } //----------------------------------------------------------------------------- // Allocates a 3D display and returns its MIL identifier. //----------------------------------------------------------------------------- MIL_ID Alloc3dDisplayId(MIL_ID MilSystem) { MappControl(M_DEFAULT, M_ERROR, M_PRINT_DISABLE); MIL_ID MilDisplay3D = M3ddispAlloc(MilSystem, M_DEFAULT, MIL_TEXT(\"M_DEFAULT\"), M_DEFAULT, M_NULL); MappControl(M_DEFAULT, M_ERROR, M_PRINT_ENABLE); return MilDisplay3D; } ",
      "wordCount": 1763
    }
  ]
}]
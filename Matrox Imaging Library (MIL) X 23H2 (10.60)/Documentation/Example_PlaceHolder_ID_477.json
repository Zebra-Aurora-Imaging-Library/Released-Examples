[{
  "id": "Example_PlaceHolder_ID",
  "version": "2024020714",
  "title": "Example_PlaceHolder_Title",
  "wordCount": 0,
  "subEntries": [
    {
      "id": "Examples_LinuxSpecific_MdispGtk_CPP_childframe_cpp",
      "version": "2024020714",
      "title": "childframe.cpp",
      "location": "Sample Code from MIL Examples",
      "text": " Top /* * File name: childframe.cpp * Location: See Matrox Example Launcher in the MIL Control Center * */ // // Copyright (C) Matrox Electronic Systems Ltd., 1992-2024. // All Rights Reserved #include &lt;mil.h&gt; #include &lt;gtk/gtk.h&gt; #include &lt;X11/Xlib.h&gt; #include \"mdispgtkapp.h\" #include &lt;gdk/gdkx.h&gt; #include \"childframe.h\" #include \"mdispgtkview.h\" #include \"mainframe.h\" #include \"mdispgtkmarshal.h\" gint ChildFrame::SignalId = 0; ChildFrame::ChildFrame(MainFrame* mf):m_mf(mf) { m_View = NULL; m_FrameStr[0] ='\\0'; m_ScaleStr[0] ='\\0'; m_MouseStr[0] ='\\0'; GtkWidget* vbox = NULL; SignalId++; m_frameRateChangedSignalName = g_strdup_printf(\"frame-rate-changed-%d\", SignalId); m_zoomFactorChangedSignalName = g_strdup_printf(\"zoom-factor-changed-%d\",SignalId); m_mousePositionChangedSignalName = g_strdup_printf(\"mouse-position-changed-%d\",SignalId); m_window = gtk_window_new (GTK_WINDOW_TOPLEVEL); m_frameRateChangedSignal = g_signal_new(m_frameRateChangedSignalName, G_TYPE_OBJECT, G_SIGNAL_RUN_LAST, 0, NULL, NULL, mdispgtk_marshal_VOID__DOUBLE, G_TYPE_NONE, 1, G_TYPE_DOUBLE); m_zoomFactorChangedSignal = g_signal_new(m_zoomFactorChangedSignalName, G_TYPE_OBJECT, G_SIGNAL_RUN_LAST, 0, NULL, NULL, mdispgtk_marshal_VOID__DOUBLE_DOUBLE, G_TYPE_NONE, 2, G_TYPE_DOUBLE, G_TYPE_DOUBLE); m_mousePositionChangedSignal = g_signal_new(m_mousePositionChangedSignalName, G_TYPE_OBJECT, G_SIGNAL_RUN_LAST, 0, NULL, NULL, mdispgtk_marshal_VOID__INT_INT_DOUBLE_DOUBLE, G_TYPE_NONE, 4, G_TYPE_INT, G_TYPE_INT, G_TYPE_DOUBLE, G_TYPE_DOUBLE); // if we want to make image child window in the center // gtk_window_set_position(GTK_WINDOW(m_window), GTK_WIN_POS_CENTER); vbox = gtk_box_new (GTK_ORIENTATION_VERTICAL, 0); gtk_container_add (GTK_CONTAINER (m_window), vbox); m_DrawingArea = gtk_drawing_area_new (); gtk_box_pack_start (GTK_BOX (vbox), m_DrawingArea, TRUE, TRUE, 0); // for each child frame drawin area attach parent frame GtkWidget* mainWindow = m_mf-&gt;MainWindow(); MdispGtkApp* App = (MdispGtkApp *) g_object_get_data(G_OBJECT(mainWindow),\"App\"); g_object_set_data(G_OBJECT(m_DrawingArea),\"App\",(void *) App); g_object_set_data(G_OBJECT(m_DrawingArea),\"MainWindow\",(void *) mainWindow); // create the view and set it's parent m_View = new MdispGtkView(this); gtk_window_set_title(GTK_WINDOW(m_window), m_View-&gt;filename()); gtk_window_set_default_size (GTK_WINDOW(m_window),100,100); m_StatusBar = gtk_statusbar_new (); gtk_box_pack_end (GTK_BOX (vbox), m_StatusBar, false, false, 0); gtk_widget_set_events (m_DrawingArea, GDK_EXPOSURE_MASK | GDK_SCROLL_MASK); /* !!! very important to get drawing area repaint correctly in Gtk !!! */ G_GNUC_BEGIN_IGNORE_DEPRECATIONS gtk_widget_set_double_buffered(m_DrawingArea,FALSE); G_GNUC_END_IGNORE_DEPRECATIONS /* !!! disable mouse handling in Gtk for this widget */ gtk_widget_set_events(m_DrawingArea,0); // attach callbacks to events m_FocusSignalId = g_signal_connect (G_OBJECT (m_window), \"focus-in-event\", G_CALLBACK (ChildFrame::OnChildGetFocus),this); g_signal_connect (G_OBJECT (m_window), \"delete-event\", G_CALLBACK (ChildFrame::OnChildDelete),this); g_signal_connect (G_OBJECT (m_window), \"destroy\", G_CALLBACK (ChildFrame::OnChildDestroy),this); m_ConfigureEventSignalId = g_signal_connect (G_OBJECT (m_DrawingArea), \"configure-event\", G_CALLBACK (ChildFrame::OnChildConfigure),this); m_DrawSignalId = g_signal_connect (G_OBJECT (m_DrawingArea), \"draw\", G_CALLBACK (ChildFrame::OnChildExpose),this); m_FrameRateChangedSignalId = g_signal_connect (G_OBJECT (m_window), m_frameRateChangedSignalName, G_CALLBACK (ChildFrame::OnFrameRateChanged),this); m_ZoomFactorChangedSignalId = g_signal_connect (G_OBJECT (m_window), m_zoomFactorChangedSignalName, G_CALLBACK (ChildFrame::OnZoomFactorChanged),this); m_MousePositionChangedSignalId = g_signal_connect (G_OBJECT (m_window), m_mousePositionChangedSignalName, G_CALLBACK (ChildFrame::OnMousePositionChanged),this); gtk_widget_show_all(m_window); gdk_display_flush(gdk_display_get_default()); // set this child as current child frame m_mf-&gt;setcf(this); UpdateStatusBarWithFrameRate(0.0); UpdateStatusBarWithScale(1.0, 1.0); UpdateStatusBarWithMousePosition(0,0,0.0,0.0); m_layout = gtk_widget_create_pango_layout(m_DrawingArea,NULL); } ChildFrame::~ChildFrame() { if (m_FocusSignalId) { g_signal_handler_disconnect(G_OBJECT (m_window), m_FocusSignalId); } if (m_ConfigureEventSignalId) { g_signal_handler_disconnect(G_OBJECT (m_DrawingArea), m_ConfigureEventSignalId); } if (m_DrawSignalId) { g_signal_handler_disconnect(G_OBJECT (m_DrawingArea), m_DrawSignalId); } if (m_FrameRateChangedSignalId) { g_signal_handler_disconnect(G_OBJECT (m_window), m_FrameRateChangedSignalId); } if (m_ZoomFactorChangedSignalId) { g_signal_handler_disconnect(G_OBJECT (m_window), m_ZoomFactorChangedSignalId); } if (m_MousePositionChangedSignalId) { g_signal_handler_disconnect(G_OBJECT (m_window), m_MousePositionChangedSignalId); } if(m_View) delete m_View; g_free(m_frameRateChangedSignalName); g_free(m_zoomFactorChangedSignalName); g_free(m_mousePositionChangedSignalName); } MdispGtkView* ChildFrame::View() { return m_View; } void ChildFrame::close() { gtk_widget_destroy(m_window); } void ChildFrame::setTitle(const gchar* title) { if(title) gtk_window_set_title(GTK_WINDOW(m_window),title); } void ChildFrame::show() { gtk_widget_show_all(m_window); } void ChildFrame::Destroy() { if (m_View &amp;&amp; m_View-&gt;IsModified()) { GtkWidget *dialog = gtk_message_dialog_new (m_mf?GTK_WINDOW(m_mf-&gt;MainWindow()):NULL, GTK_DIALOG_DESTROY_WITH_PARENT, GTK_MESSAGE_QUESTION, GTK_BUTTONS_YES_NO, \" MdispGtk Save Image ?\"); gtk_window_set_title(GTK_WINDOW(dialog),\"MdispGtk Message\"); gint result = gtk_dialog_run (GTK_DIALOG (dialog)); gtk_widget_destroy (dialog); switch(result) { case GTK_RESPONSE_YES: m_mf-&gt;fileSaveAs(NULL,NULL, m_mf); break; case GTK_RESPONSE_NO: break; } } // remove the view if(m_View) delete m_View; m_View = NULL; } void ChildFrame::OnChildDestroy(GtkWidget *widget, gpointer user_data) { ChildFrame* cf = (ChildFrame *) user_data; g_return_if_fail(cf); cf-&gt;OnChildDelete(widget,NULL, user_data); } gboolean ChildFrame::OnChildDelete(GtkWidget *widget, GdkEvent *event, gpointer user_data) { ChildFrame* cf = (ChildFrame *) user_data; g_return_val_if_fail(cf, false); MainFrame* mf = cf-&gt;m_mf; cf-&gt;Destroy(); if(mf) { mf-&gt;remove(cf); } return false; } gboolean ChildFrame::OnChildGetFocus(GtkWidget *widget, GdkEventFocus *event, gpointer user_data) { ChildFrame* cf = (ChildFrame *) user_data; g_return_val_if_fail(cf, true); MainFrame* mf = cf-&gt;m_mf; g_return_val_if_fail(mf, true); g_return_val_if_fail(!mf-&gt;Quit(), true); mf-&gt;setcf(cf); return true; } gboolean ChildFrame::OnChildConfigure(GtkWidget *widget, GdkEventConfigure *event, gpointer user_data) { return true; } gboolean ChildFrame::OnChildExpose(GtkWidget *widget, cairo_t *cr, gpointer user_data) { ChildFrame* cf = (ChildFrame *) user_data; g_return_val_if_fail(cf, true); MainFrame* mf = cf-&gt;m_mf; cf-&gt;m_View-&gt;Paint(cr); return true; } void ChildFrame::UpdateStatusBar() { if(gtk_widget_is_visible(m_window)) { gchar *text = g_strdup_printf(\"%s | %s %s\", m_FrameStr, m_ScaleStr, m_MouseStr); gtk_statusbar_push (GTK_STATUSBAR(m_StatusBar), 0, text); g_free(text); } } void ChildFrame::UpdateStatusBarWithFrameRate(MIL_DOUBLE CurrentRate) { if(CurrentRate == M_INVALID) { g_snprintf(m_FrameStr,STRING_SIZE,\"%s\",\"Display Updates Not Available\"); } else { g_snprintf(m_FrameStr,STRING_SIZE,\"Display Updates :%.2f fps\",CurrentRate); } UpdateStatusBar(); } void ChildFrame::UpdateStatusBarWithScale(MIL_DOUBLE CurrentScaleX, MIL_DOUBLE CurrentScaleY) { g_snprintf(m_ScaleStr,STRING_SIZE,\"%.4f, %.4f\",CurrentScaleX, CurrentScaleY ); UpdateStatusBar(); } void ChildFrame::UpdateStatusBarWithMousePosition(long DispX, long DispY, double BufX, double BufY) { g_snprintf(m_MouseStr,STRING_SIZE,\"M:(%d,%d)-&gt;(%.2f,%.2f)\",(gint)DispX, (gint)DispY, BufX, BufY); UpdateStatusBar(); } void ChildFrame::UpdateContentSize(long SizeX, long SizeY) { long NewSizeX = SizeX; long NewSizeY = SizeY; if(gtk_widget_is_visible(m_window)) { GtkAllocation allocation; gtk_widget_get_allocation (m_StatusBar, &amp;allocation); NewSizeY+= allocation.height; gdk_window_resize(gtk_widget_get_window(m_window),NewSizeX,NewSizeY); } } void ChildFrame::OnFrameRateChanged(GtkWidget *widget, gdouble Rate, gpointer user_data) { ChildFrame* cf = (ChildFrame *) user_data; g_return_if_fail(cf); cf-&gt;UpdateStatusBarWithFrameRate(Rate); } void ChildFrame::OnZoomFactorChanged(GtkWidget *widget, gdouble ScaleX, gdouble ScaleY, gpointer user_data) { ChildFrame* cf = (ChildFrame *) user_data; g_return_if_fail(cf); cf-&gt;UpdateStatusBarWithScale(ScaleX, ScaleY); } void ChildFrame::OnMousePositionChanged(GtkWidget *widget, gint DispX, gint DispY, gdouble BufX, gdouble BufY, gpointer user_data) { ChildFrame* cf = (ChildFrame *) user_data; g_return_if_fail(cf); cf-&gt;UpdateStatusBarWithMousePosition(DispX, DispY, BufX, BufY); } GtkWidget *ChildFrame::ParentWindow() { return m_mf-&gt;MainWindow(); } ",
      "wordCount": 736
    },
    {
      "id": "Examples_LinuxSpecific_MdispGtk_CPP_mainframe_cpp",
      "version": "2024020714",
      "title": "mainframe.cpp",
      "location": "Sample Code from MIL Examples",
      "text": " Top /* * File name: mainframe.cpp * Location: See Matrox Example Launcher in the MIL Control Center * */ // // Copyright (C) Matrox Electronic Systems Ltd., 1992-2024. // All Rights Reserved #include &lt;mil.h&gt; #include &lt;gtk/gtk.h&gt; #include &lt;X11/Xlib.h&gt; #include &lt;stdlib.h&gt; #include \"mainframe.h\" #include \"childframe.h\" #include \"mdispgtkview.h\" #include \"mdispgtkapp.h\" static void activate_toggle (GSimpleAction *action, GVariant *parameter, gpointer user_data) { GVariant *state; state = g_action_get_state (G_ACTION (action)); g_action_change_state (G_ACTION (action), g_variant_new_boolean (!g_variant_get_boolean (state))); g_variant_unref (state); } static GtkRadioActionEntry view_mode_entries[] = { { \"Default\", NULL, \"M_DEFAULT\", NULL,\"M_DEFAULT\", VIEW_MODE_DEFAULT }, { \"Transparent\", NULL,\"M_TRANSPARENT\", NULL,\"M_TRANSPARENT\", VIEW_MODE_TRANSPARENT }, { \"AutoScale\", NULL, \"M_AUTO_SCALE\", NULL,\"M_AUTO_SCALE\",VIEW_MODE_AUTO_SCALE }, { \"MultiBytes\", NULL, \"M_MULTI_BYTES\", NULL,\"M_MULTI_BYTES\",VIEW_MODE_MULTI_BYTES }, { \"BitShift2\", NULL, \"M_BIT_SHIFT:2\", NULL,\"M_BIT_SHIFT:2 \",VIEW_MODE_BIT_SHIFT2 }, { \"BitShift4\", NULL, \"M_BIT_SHIFT:4\", NULL,\"M_BIT_SHIFT:4\",VIEW_MODE_BIT_SHIFT4 }, { \"BitShift8\", NULL, \"M_BIT_SHIFT:8\", NULL,\"M_BIT_SHIFT:8\",VIEW_MODE_BIT_SHIFT8 }, }; static guint n_view_mode_entries = G_N_ELEMENTS (view_mode_entries); static GActionEntry win_entries[] = { // File { \"new\", MainFrame::fileNew, NULL, NULL, NULL }, { \"open\", MainFrame::fileOpen, NULL, NULL, NULL }, { \"close\", MainFrame::fileClose, NULL, NULL, NULL }, { \"save\", MainFrame::fileSave, NULL, NULL, NULL }, { \"saveas\", MainFrame::fileSaveAs, NULL, NULL, NULL }, { \"quit\", MainFrame::fileQuit, NULL, NULL, NULL }, // View { \"standard_toolbar\", activate_toggle, NULL, \"true\", MainFrame::viewStandardToolbar }, { \"display_toolbar\", activate_toggle, NULL, \"true\", MainFrame::viewDisplayToolbar }, //Display { \"overlay\", activate_toggle, NULL, \"false\", MainFrame::dispOverlay }, // Display -&gt; Overlay -&gt; Opacity { \"overlayopacity\", MainFrame::overlayOpacity, \"s\", \"'M_DEFAULT'\", NULL }, { \"scale\", activate_toggle, NULL, \"false\", MainFrame::dispScaleDisplay }, { \"graannotations\", activate_toggle, NULL, \"false\", MainFrame::dispGraphicsAnnotations }, // Display -&gt; Graphics -&gt; Opacity { \"graphiclistopacity\", MainFrame::graphicListOpacity, \"s\", \"'M_DEFAULT'\", NULL }, // Display -&gt; Graphics { \"grarectangle\", MainFrame::dispNewRectangle, NULL, NULL, NULL }, { \"graarc\", MainFrame::dispNewArc, NULL, NULL, NULL }, { \"grapolygon\", MainFrame::dispNewPolygon, NULL, NULL, NULL }, { \"graorientedrect\", MainFrame::dispNewOrientedRect, NULL, NULL, NULL }, { \"graarcthreepoints\", MainFrame::dispNewArcThreePoints, NULL, NULL, NULL }, { \"graselectcolor\", MainFrame::dispSelectGraphicColor, NULL, NULL, NULL }, { \"grafill\", MainFrame::dispFillGraphic, NULL, NULL, NULL }, { \"gradrawdir\", MainFrame::dispDrawDir, NULL, NULL, NULL }, // Display -&gt; Zoom { \"nozoom\", MainFrame::dispNoZoom, NULL, NULL, NULL }, { \"zoomin\", MainFrame::dispZoomIn, NULL, NULL, NULL }, { \"zoomout\", MainFrame::dispZoomOut, NULL, NULL, NULL }, // Display -&gt; DistributedMIL-&gt;ASyncghronous { \"dmilasync\", MainFrame::dmilASync, \"s\", \"'disabled'\", NULL }, // Display -&gt; DistributedMIL-&gt;Compression { \"dmilcompression\", MainFrame::dmilCompression, \"s\", \"'none'\", NULL }, // Display -&gt; DistributedMIL-&gt;QFactor { \"dmilqfactor\", MainFrame::dmilQFactor, \"s\", \"'60'\", NULL }, //Display-&gt;Exclusive Display-&gt;Restrict Cursor { \"restrictcursor\", activate_toggle, NULL, \"false\", MainFrame::dispRestrictCursor }, // Grab { \"grabstart\", MainFrame::dispGrabStart, NULL, NULL, NULL }, { \"grabstop\", MainFrame::dispGrabStop, NULL, NULL, NULL }, // About { \"about\", MainFrame::about, NULL, NULL, NULL }, }; ///////////////////////////////////////////////////////////////////////////// // MainFrame // Create the Main Window // MainFrame::MainFrame(GtkApplication *gtkApp) { m_Quit = false; m_ChildList = NULL; GtkBuilder *builder = NULL; GtkWidget *grid = NULL; GtkToolItem* item_view = NULL; GdkRectangle workarea = {0}; gdk_monitor_get_workarea(gdk_display_get_primary_monitor(gdk_display_get_default()), &amp;workarea); m_MainWindow = gtk_application_window_new (GTK_APPLICATION (gtkApp)); gtk_widget_set_size_request(m_MainWindow, workarea.width/2, -1); g_action_map_add_action_entries (G_ACTION_MAP (m_MainWindow), win_entries, G_N_ELEMENTS (win_entries), this); builder = gtk_builder_new (); gtk_builder_add_from_resource (builder, \"/images/mdispgtk.ui\", NULL); grid = (GtkWidget *)gtk_builder_get_object (builder, \"grid1\"); m_ToolbarStd = (GtkWidget *)gtk_builder_get_object (builder, \"toolbarstd\"); m_ToolbarDisp = (GtkWidget *)gtk_builder_get_object (builder, \"toolbardisp\"); // view mode item_view = (GtkToolItem *)gtk_builder_get_object (builder, \"viewitem\"); if(item_view) { m_ViewComboBox = gtk_combo_box_text_new(); for (int i=0 ; i&lt; (int) n_view_mode_entries; i++) { gtk_combo_box_text_append(GTK_COMBO_BOX_TEXT(m_ViewComboBox),NULL,view_mode_entries[i].label); } gtk_combo_box_set_active (GTK_COMBO_BOX(m_ViewComboBox),0); gtk_container_add(GTK_CONTAINER(item_view),m_ViewComboBox); } gtk_widget_show(m_ViewComboBox); gtk_container_add (GTK_CONTAINER (m_MainWindow), grid); g_signal_connect (m_ViewComboBox,\"changed\",G_CALLBACK(MainFrame::OnCbViewChanged),this); g_signal_connect (m_MainWindow,\"destroy\",G_CALLBACK(MainFrame::OnDestroy),this); g_object_unref (builder); updateActions(NULL); } ///////////////////////////////////////////////////////////////////////////// // MainFrame // Destructor // MainFrame::~MainFrame() { } ///////////////////////////////////////////////////////////////////////////// // OnInitialize // Create an initial child frame // void MainFrame::OnInitialize() { ChildFrame* cf = new ChildFrame(this); if(!cf-&gt;View()-&gt;newDoc()) { cf-&gt;close(); } else { add(cf); } } ///////////////////////////////////////////////////////////////////////////// // setcf // set current child frame // void MainFrame::setcf(ChildFrame* cf) { m_cf= cf; updateActions(cf); } ///////////////////////////////////////////////////////////////////////////// // remove // remove child frame from the list // void MainFrame::remove(ChildFrame *cf) { m_ChildList = g_list_remove(m_ChildList,cf); if(g_list_length(m_ChildList)) { GList* l = g_list_last(m_ChildList); setcf((ChildFrame *) l-&gt;data); } else { setcf(NULL); } } ///////////////////////////////////////////////////////////////////////////// // add // add child frame tio list of childs // void MainFrame::add(ChildFrame *cf) { if(cf) { m_ChildList = g_list_append(m_ChildList,cf); } } ///////////////////////////////////////////////////////////////////////////// // setEnable // Enable action // void MainFrame::setEnable(const gchar* name, bool value) { GSimpleAction* action = NULL; action = G_SIMPLE_ACTION(g_action_map_lookup_action(G_ACTION_MAP (m_MainWindow), name)); if(action) { g_simple_action_set_enabled (action,value); } } ///////////////////////////////////////////////////////////////////////////// // setActive // Activate action // void MainFrame::setActive(const gchar* name, bool newvalue) { GAction *action = NULL; bool oldvalue; action = g_action_map_lookup_action(G_ACTION_MAP (m_MainWindow), name); if(action) { oldvalue = g_action_get_state (action); if(oldvalue != newvalue) { Update(false); g_action_change_state (action, g_variant_new_boolean (newvalue)); Update(true); } } } ///////////////////////////////////////////////////////////////////////////// // setActive // Activate a radio action // void MainFrame::setActive(const gchar* name, const gchar *newvalue) { GAction *action = NULL; GVariant* oldvalue; action = g_action_map_lookup_action(G_ACTION_MAP (m_MainWindow), name); if(action) { oldvalue = g_action_get_state (action); if (!g_variant_equal(oldvalue ,newvalue)) { Update(false); g_action_change_state (action, g_variant_new_string (newvalue)); Update(true); } } } ///////////////////////////////////////////////////////////////////////////// // dispGtkApp // Get App // MdispGtkApp* MainFrame::dispGtkApp() { void *UserData = g_object_get_data(G_OBJECT(m_MainWindow),\"App\"); return (MdispGtkApp *) UserData; } ///////////////////////////////////////////////////////////////////////////// // fileNew // // void MainFrame::fileNew (GSimpleAction *action, GVariant *parameter, gpointer user_data) { MainFrame* mf = (MainFrame *) user_data; g_return_if_fail(mf); ChildFrame* cf = new ChildFrame(mf); if(!cf-&gt;View()-&gt;newDoc()) { cf-&gt;close(); } else { mf-&gt;add(cf); } } ///////////////////////////////////////////////////////////////////////////// // fileOpen // // void MainFrame::fileOpen (GSimpleAction *action, GVariant *parameter, gpointer user_data) { MainFrame* mf = (MainFrame *) user_data; g_return_if_fail(mf); GtkWidget *dialog = gtk_file_chooser_dialog_new (\"Open File\", GTK_WINDOW(mf-&gt;MainWindow()), GTK_FILE_CHOOSER_ACTION_OPEN, \"_Cancel\", GTK_RESPONSE_CANCEL, \"_Open\", GTK_RESPONSE_ACCEPT, NULL); GtkFileFilter*imageFilter = gtk_file_filter_new(); gtk_file_filter_set_name(imageFilter,\"Images Files (*.mim:*.bmp:*..tif;*.jpg;*.jp2;*.png)\"); gtk_file_filter_add_pattern(imageFilter,\"*.mim\"); gtk_file_filter_add_pattern(imageFilter,\"*.bmp\"); gtk_file_filter_add_pattern(imageFilter,\"*.tif\"); gtk_file_filter_add_pattern(imageFilter,\"*.jpg\"); gtk_file_filter_add_pattern(imageFilter,\"*.jp2\"); gtk_file_filter_add_pattern(imageFilter,\"*.png\"); gtk_file_chooser_add_filter(GTK_FILE_CHOOSER(dialog),imageFilter); GtkFileFilter* allFilter = gtk_file_filter_new(); gtk_file_filter_set_name(allFilter,\"All Files (*.*)\"); gtk_file_filter_add_pattern(allFilter,\"*.*\"); gtk_file_chooser_add_filter(GTK_FILE_CHOOSER(dialog),allFilter); if (gtk_dialog_run (GTK_DIALOG (dialog)) == GTK_RESPONSE_ACCEPT) { gchar *filename = gtk_file_chooser_get_filename (GTK_FILE_CHOOSER (dialog)); if(filename) { ChildFrame* cf = new ChildFrame(mf); if ( !cf-&gt;View()-&gt;load(filename) ) { GtkWidget *dialog = gtk_message_dialog_new (GTK_WINDOW(mf-&gt;MainWindow()), GTK_DIALOG_DESTROY_WITH_PARENT, GTK_MESSAGE_ERROR, GTK_BUTTONS_CLOSE, \"Could not load image from %s\", filename); gtk_dialog_run (GTK_DIALOG (dialog)); gtk_widget_destroy (dialog); cf-&gt;close(); delete cf; cf = NULL; } else { cf-&gt;setTitle(g_path_get_basename(filename)); mf-&gt;add(cf); } g_free(filename); mf-&gt;updateActions(cf); } } gtk_widget_destroy (dialog); } ///////////////////////////////////////////////////////////////////////////// // fileSave // // void MainFrame::fileSave (GSimpleAction *action, GVariant *parameter, gpointer user_data) { MainFrame* mf = (MainFrame *) user_data; g_return_if_fail(mf); if(mf) mf-&gt;fileSaveAs(action, NULL, user_data); } ///////////////////////////////////////////////////////////////////////////// // fileClose // // void MainFrame::fileClose (GSimpleAction *action, GVariant *parameter, gpointer user_data) { MainFrame* mf = (MainFrame *) user_data; g_return_if_fail(mf); ChildFrame* cf = (ChildFrame*) mf-&gt;cf(); if (cf) { cf-&gt;close(); } } ///////////////////////////////////////////////////////////////////////////// // fileSaveAs // // void MainFrame::fileSaveAs (GSimpleAction *action, GVariant *parameter, gpointer user_data) { MainFrame* mf = (MainFrame *) user_data; g_return_if_fail(mf); ChildFrame* cf = (ChildFrame*) mf-&gt;cf(); if(cf) { GtkWidget *dialog = gtk_file_chooser_dialog_new (\"Save File\", GTK_WINDOW(mf-&gt;MainWindow()), GTK_FILE_CHOOSER_ACTION_SAVE, \"_Cancel\", GTK_RESPONSE_CANCEL, \"_Save\", GTK_RESPONSE_ACCEPT, NULL); gtk_file_chooser_set_current_name(GTK_FILE_CHOOSER (dialog),cf-&gt;View()-&gt;filename()); if (gtk_dialog_run (GTK_DIALOG (dialog)) == GTK_RESPONSE_ACCEPT) { gchar *extfilename; gchar *filename = gtk_file_chooser_get_filename (GTK_FILE_CHOOSER (dialog)); if (filename) { if(index(filename, '.')) { extfilename = g_strdup (filename); } else { extfilename = g_strconcat (filename, \".mim\", NULL); } cf-&gt;View()-&gt;save(extfilename); cf-&gt;setTitle(g_path_get_basename(extfilename)); g_free(extfilename); g_free(filename); } } gtk_widget_destroy (dialog); } } ///////////////////////////////////////////////////////////////////////////// // fileQuit // // void MainFrame::fileQuit (GSimpleAction *action, GVariant *parameter, gpointer user_data) { MainFrame* mf = (MainFrame *) user_data; g_return_if_fail(mf); if(mf) { mf-&gt;OnDestroy(NULL,mf); g_application_quit(g_application_get_default()); } } ///////////////////////////////////////////////////////////////////////////// // viewStandardToolbar // // void MainFrame::viewStandardToolbar(GSimpleAction *action, GVariant *state, gpointer user_data) { MainFrame* mf = (MainFrame *) user_data; g_return_if_fail(mf); gboolean active = g_variant_get_boolean(state); if(active) gtk_widget_show(mf-&gt;m_ToolbarStd); else gtk_widget_hide(mf-&gt;m_ToolbarStd); g_simple_action_set_state (action, state); } ///////////////////////////////////////////////////////////////////////////// // viewDisplayToolbar // // void MainFrame::viewDisplayToolbar(GSimpleAction *action, GVariant *state, gpointer user_data) { MainFrame* mf = (MainFrame *) user_data; g_return_if_fail(mf); gboolean active = g_variant_get_boolean(state); if(active) gtk_widget_show(mf-&gt;m_ToolbarDisp); else gtk_widget_hide(mf-&gt;m_ToolbarDisp); g_simple_action_set_state (action, state); } ///////////////////////////////////////////////////////////////////////////// // dispOverlay // // void MainFrame::dispOverlay(GSimpleAction *action, GVariant *state, gpointer user_data) { MainFrame* mf = (MainFrame *) user_data; g_return_if_fail(mf); if(mf-&gt;Update()) { ChildFrame* cf = (ChildFrame*) mf-&gt;cf(); if (cf) { bool on = g_variant_get_boolean(state); cf-&gt;View()-&gt;Overlay(on); mf-&gt;updateActions(cf); } } g_simple_action_set_state (action, state); } ///////////////////////////////////////////////////////////////////////////// // overlayOpacity // // void MainFrame::overlayOpacity(GSimpleAction *action, GVariant *parameter, gpointer user_data) { MainFrame* mf = (MainFrame *) user_data; g_return_if_fail(mf); ChildFrame* cf = (ChildFrame*) mf-&gt;cf(); if (cf) { const gchar *name; const gchar *value; MIL_INT val = M_DEFAULT; name = g_action_get_name (G_ACTION (action)); value = g_variant_get_string (parameter, NULL); if (value) { if (!strcmp(value, \"M_DEFAULT\")) val = M_DEFAULT; else if (!strcmp(value, \"M_DISABLE\")) val = M_DISABLE; else if (!strcmp(value, \"0\")) val = 0; else if (!strcmp(value, \"20\")) val = 20; else if (!strcmp(value, \"40\")) val = 40; else if (!strcmp(value, \"60\")) val = 60; else if (!strcmp(value, \"80\")) val = 80; else if (!strcmp(value, \"100\")) val = 100; cf-&gt;View()-&gt;ChangeOverlayOpacity(val); g_action_change_state (G_ACTION (action), parameter); mf-&gt;updateActions(cf); } } } ///////////////////////////////////////////////////////////////////////////// // dispScaleDisplay // // void MainFrame::dispScaleDisplay(GSimpleAction *action, GVariant *state, gpointer user_data) { MainFrame* mf = (MainFrame *) user_data; g_return_if_fail(mf); if(mf-&gt;Update()) { ChildFrame* cf = (ChildFrame*) mf-&gt;cf(); if (cf) { bool on = g_variant_get_boolean(state); cf-&gt;View()-&gt;ScaleDisplay(on); mf-&gt;updateActions(cf); } } g_simple_action_set_state (action, state); } ///////////////////////////////////////////////////////////////////////////// // dispGraphicsAnnotations // // void MainFrame::dispGraphicsAnnotations(GSimpleAction *action, GVariant *state, gpointer user_data) { MainFrame* mf = (MainFrame *) user_data; g_return_if_fail(mf); if(mf-&gt;Update()) { ChildFrame* cf = (ChildFrame*) mf-&gt;cf(); if (cf) { bool on = g_variant_get_boolean(state); cf-&gt;View()-&gt;GraphicsAnnotations(on); mf-&gt;updateActions(cf); } } g_simple_action_set_state (action, state); } ///////////////////////////////////////////////////////////////////////////// // graphicListOpacity // // void MainFrame::graphicListOpacity(GSimpleAction *action, GVariant *parameter, gpointer user_data) { MainFrame* mf = (MainFrame *) user_data; g_return_if_fail(mf); ChildFrame* cf = (ChildFrame*) mf-&gt;cf(); if (cf) { const gchar *name; const gchar *value; MIL_INT val = M_DEFAULT; name = g_action_get_name (G_ACTION (action)); value = g_variant_get_string (parameter, NULL); if (value) { if (!strcmp(value, \"M_DEFAULT\")) val = M_DEFAULT; else if (!strcmp(value, \"M_DISABLE\")) val = M_DISABLE; else if (!strcmp(value, \"0\")) val = 0; else if (!strcmp(value, \"20\")) val = 20; else if (!strcmp(value, \"40\")) val = 40; else if (!strcmp(value, \"60\")) val = 60; else if (!strcmp(value, \"80\")) val = 80; else if (!strcmp(value, \"100\")) val = 100; cf-&gt;View()-&gt;ChangeGraphicListOpacity(val); g_action_change_state (G_ACTION (action), parameter); mf-&gt;updateActions(cf); } } } ///////////////////////////////////////////////////////////////////////////// // dispNewRectangle // // void MainFrame::dispNewRectangle(GSimpleAction *action, GVariant *state, gpointer user_data) { MainFrame* mf = (MainFrame *) user_data; g_return_if_fail(mf); ChildFrame* cf = (ChildFrame*) mf-&gt;cf(); if (cf) { cf-&gt;View()-&gt;OnGraRectangle(); mf-&gt;updateActions(cf); } } ///////////////////////////////////////////////////////////////////////////// // dispNewArc // // void MainFrame::dispNewArc(GSimpleAction *action, GVariant *state, gpointer user_data) { MainFrame* mf = (MainFrame *) user_data; g_return_if_fail(mf); ChildFrame* cf = (ChildFrame*) mf-&gt;cf(); if (cf) { cf-&gt;View()-&gt;OnGraCircle(); mf-&gt;updateActions(cf); } } ///////////////////////////////////////////////////////////////////////////// // dispNewPolygon // // void MainFrame::dispNewPolygon(GSimpleAction *action, GVariant *state, gpointer user_data) { MainFrame* mf = (MainFrame *) user_data; g_return_if_fail(mf); ChildFrame* cf = (ChildFrame*) mf-&gt;cf(); if (cf) { cf-&gt;View()-&gt;OnGraPolygon(); mf-&gt;updateActions(cf); } } ///////////////////////////////////////////////////////////////////////////// // dispNewOrientedRect // // void MainFrame::dispNewOrientedRect(GSimpleAction *action, GVariant *state, gpointer user_data) { MainFrame* mf = (MainFrame *) user_data; g_return_if_fail(mf); ChildFrame* cf = (ChildFrame*) mf-&gt;cf(); if (cf) { cf-&gt;View()-&gt;OnGraOrientedRect(); mf-&gt;updateActions(cf); } } ///////////////////////////////////////////////////////////////////////////// // dispNewArcThreePoints // // void MainFrame::dispNewArcThreePoints(GSimpleAction *action, GVariant *state, gpointer user_data) { MainFrame* mf = (MainFrame *) user_data; g_return_if_fail(mf); ChildFrame* cf = (ChildFrame*) mf-&gt;cf(); if (cf) { cf-&gt;View()-&gt;OnGraArcThreePoints(); mf-&gt;updateActions(cf); } } ///////////////////////////////////////////////////////////////////////////// // dispSelectGraphicColor // // void MainFrame::dispSelectGraphicColor(GSimpleAction *action, GVariant *state, gpointer user_data) { MainFrame* mf = (MainFrame *) user_data; g_return_if_fail(mf); ChildFrame* cf = (ChildFrame*) mf-&gt;cf(); if (cf) { cf-&gt;View()-&gt;OnGraChooseColor(); mf-&gt;updateActions(cf); } } ///////////////////////////////////////////////////////////////////////////// // dispFillGraphic // // void MainFrame::dispFillGraphic(GSimpleAction *action, GVariant *state, gpointer user_data) { MainFrame* mf = (MainFrame *) user_data; g_return_if_fail(mf); ChildFrame* cf = (ChildFrame*) mf-&gt;cf(); if (cf) { cf-&gt;View()-&gt;OnGraFill(); mf-&gt;updateActions(cf); } } ///////////////////////////////////////////////////////////////////////////// // dispDrawDir // // void MainFrame::dispDrawDir(GSimpleAction *action, GVariant *state, gpointer user_data) { MainFrame* mf = (MainFrame *) user_data; g_return_if_fail(mf); ChildFrame* cf = (ChildFrame*) mf-&gt;cf(); if (cf) { cf-&gt;View()-&gt;OnDrawDir(); mf-&gt;updateActions(cf); } } ///////////////////////////////////////////////////////////////////////////// // dispNoZoom // // void MainFrame::dispNoZoom(GSimpleAction *action, GVariant *state, gpointer user_data) { MainFrame* mf = (MainFrame *) user_data; g_return_if_fail(mf); ChildFrame* cf = (ChildFrame*) mf-&gt;cf(); if (cf) { cf-&gt;View()-&gt;NoZoom(); mf-&gt;updateActions(cf); } } ///////////////////////////////////////////////////////////////////////////// // dispZoomIn // // void MainFrame::dispZoomIn(GSimpleAction *action, GVariant *state, gpointer user_data) { MainFrame* mf = (MainFrame *) user_data; g_return_if_fail(mf); ChildFrame* cf = (ChildFrame*) mf-&gt;cf(); if (cf) { cf-&gt;View()-&gt;ZoomIn(); mf-&gt;updateActions(cf); } } ///////////////////////////////////////////////////////////////////////////// // dmilASync // // void MainFrame::dmilASync(GSimpleAction *action, GVariant *parameter, gpointer user_data) { MainFrame* mf = (MainFrame *) user_data; g_return_if_fail(mf); ChildFrame* cf = (ChildFrame*) mf-&gt;cf(); if (cf) { const gchar *name; const gchar *value; MIL_INT val = M_DISABLE; name = g_action_get_name (G_ACTION (action)); value = g_variant_get_string (parameter, NULL); if (value) { if (!strcmp(value, \"1\")) val = 1; else if (!strcmp(value, \"5\")) val = 5; else if (!strcmp(value, \"10\")) val = 10; else if (!strcmp(value, \"15\")) val = 15; else if (!strcmp(value, \"30\")) val = 30; else if (!strcmp(value, \"maxrate\")) val = M_INFINITE; cf-&gt;View()-&gt;ChangeAsynchronousMode(val!=M_DISABLE, val); g_action_change_state (G_ACTION (action), parameter); mf-&gt;updateActions(cf); } } } ///////////////////////////////////////////////////////////////////////////// // dmilCompression // // void MainFrame::dmilCompression(GSimpleAction *action, GVariant *parameter, gpointer user_data) { MainFrame* mf = (MainFrame *) user_data; g_return_if_fail(mf); ChildFrame* cf = (ChildFrame*) mf-&gt;cf(); if (cf) { const gchar *name; const gchar *value; MIL_INT val = M_NULL; name = g_action_get_name (G_ACTION (action)); value = g_variant_get_string (parameter, NULL); if (value) { if (!strcmp(value, \"lossy\")) val = M_JPEG_LOSSY; else if (!strcmp(value, \"lossless\")) val = M_JPEG_LOSSLESS; cf-&gt;View()-&gt;ChangeCompressionType(val); g_action_change_state (G_ACTION (action), parameter); mf-&gt;updateActions(cf); } } } ///////////////////////////////////////////////////////////////////////////// // dmilQFactor // // void MainFrame::dmilQFactor(GSimpleAction *action, GVariant *parameter, gpointer user_data) { MainFrame* mf = (MainFrame *) user_data; g_return_if_fail(mf); ChildFrame* cf = (ChildFrame*) mf-&gt;cf(); if (cf) { const gchar *name; const gchar *value; MIL_INT val =60; name = g_action_get_name (G_ACTION (action)); value = g_variant_get_string (parameter, NULL); if (value) { if (!strcmp(value, \"70\")) val = 70; else if (!strcmp(value, \"75\")) val = 75; else if (!strcmp(value, \"80\")) val = 80; else if (!strcmp(value, \"82\")) val = 82; else if (!strcmp(value, \"85\")) val = 85; else if (!strcmp(value, \"87\")) val = 87; else if (!strcmp(value, \"90\")) val = 90; else if (!strcmp(value, \"92\")) val = 92; else if (!strcmp(value, \"95\")) val = 92; else if (!strcmp(value, \"99\")) val = 99; cf-&gt;View()-&gt;ChangeQFactor(val); g_action_change_state (G_ACTION (action), parameter); mf-&gt;updateActions(cf); } } } ///////////////////////////////////////////////////////////////////////////// // dispRestrictcursor // // void MainFrame::dispRestrictCursor(GSimpleAction *action, GVariant *state, gpointer user_data) { MainFrame* mf = (MainFrame *) user_data; g_return_if_fail(mf); if(mf-&gt;Update()) { ChildFrame* cf = (ChildFrame*) mf-&gt;cf(); if (cf) { bool on = g_variant_get_boolean(state); cf-&gt;View()-&gt;RestrictCursor(on); mf-&gt;updateActions(cf); } } g_simple_action_set_state (action, state); } ///////////////////////////////////////////////////////////////////////////// // dispZoomOut // // void MainFrame::dispZoomOut(GSimpleAction *action, GVariant *state, gpointer user_data) { MainFrame* mf = (MainFrame *) user_data; g_return_if_fail(mf); ChildFrame* cf = (ChildFrame*) mf-&gt;cf(); if (cf) { cf-&gt;View()-&gt;ZoomOut(); mf-&gt;updateActions(cf); } } ///////////////////////////////////////////////////////////////////////////// // dispGrabStart // // void MainFrame::dispGrabStart(GSimpleAction *action, GVariant *state, gpointer user_data) { MainFrame* mf = (MainFrame *) user_data; g_return_if_fail(mf); ChildFrame* cf = (ChildFrame*) mf-&gt;cf(); if (cf) { cf-&gt;View()-&gt;GrabStart(); mf-&gt;updateActions(cf); } } ///////////////////////////////////////////////////////////////////////////// // dispGrabStop // // void MainFrame::dispGrabStop(GSimpleAction *action, GVariant *state, gpointer user_data) { MainFrame* mf = (MainFrame *) user_data; g_return_if_fail(mf); ChildFrame* cf = (ChildFrame*) mf-&gt;cf(); if (cf) { cf-&gt;View()-&gt;GrabStop(); mf-&gt;updateActions(cf); } } ///////////////////////////////////////////////////////////////////////////// // About // // void MainFrame::about(GSimpleAction *action, GVariant *state, gpointer user_data) { MainFrame* mf = (MainFrame *) user_data; g_return_if_fail(mf); GtkWidget *dialog; GtkWidget *milLogo; GInputStream *stream = g_resources_open_stream (\"/images/about.png\", G_RESOURCE_LOOKUP_FLAGS_NONE, NULL); GdkPixbuf *pixbuf = gdk_pixbuf_new_from_stream (stream, NULL, NULL); dialog = gtk_dialog_new_with_buttons(\"MdispGtk\", GTK_WINDOW(mf-&gt;m_MainWindow), GTK_DIALOG_DESTROY_WITH_PARENT, \"_Ok\", GTK_RESPONSE_NONE, NULL); milLogo = gtk_image_new_from_pixbuf(pixbuf); gtk_box_pack_start(GTK_BOX(gtk_dialog_get_content_area (GTK_DIALOG(dialog))),milLogo,true, true,0); g_signal_connect_swapped (dialog, \"response\", G_CALLBACK (gtk_widget_destroy), dialog); gtk_widget_show_all (dialog); } ///////////////////////////////////////////////////////////////////////////// // Ondestroy // when the window is closed // void MainFrame::OnDestroy(GtkWidget *widget, gpointer user_data) { MainFrame* mf = (MainFrame *) user_data; if(mf) { for(GList* l = mf-&gt;m_ChildList; l != NULL; l = l-&gt;next) { ChildFrame* cf = (ChildFrame *)l-&gt;data; if(cf) { cf-&gt;Destroy(); delete cf; } } g_list_free(mf-&gt;m_ChildList); } } ///////////////////////////////////////////////////////////////////////////// // OnCbViewChanged // // void MainFrame::OnCbViewChanged(GtkWidget *widget, gpointer user_data) { MainFrame* mf = (MainFrame *) user_data; g_return_if_fail(mf); ChildFrame* cf = (ChildFrame*) mf-&gt;cf(); gint value = gtk_combo_box_get_active(GTK_COMBO_BOX(widget)); if (cf &amp;&amp; value &lt; (gint) n_view_mode_entries) { switch(value) { case VIEW_MODE_BIT_SHIFT8 : cf-&gt;View()-&gt;ChangeViewMode(M_BIT_SHIFT,8); break; case VIEW_MODE_BIT_SHIFT4: cf-&gt;View()-&gt;ChangeViewMode(M_BIT_SHIFT,4); break; case VIEW_MODE_BIT_SHIFT2: cf-&gt;View()-&gt;ChangeViewMode(M_BIT_SHIFT,2); break; case VIEW_MODE_MULTI_BYTES: cf-&gt;View()-&gt;ChangeViewMode(M_MULTI_BYTES); break; case VIEW_MODE_AUTO_SCALE: cf-&gt;View()-&gt;ChangeViewMode(M_AUTO_SCALE); break; case VIEW_MODE_TRANSPARENT: cf-&gt;View()-&gt;ChangeViewMode(M_TRANSPARENT); break; case VIEW_MODE_DEFAULT: cf-&gt;View()-&gt;ChangeViewMode(M_DEFAULT); break; } mf-&gt;updateActions(cf); } } ///////////////////////////////////////////////////////////////////////////// // updateActions // // void MainFrame::updateActions(ChildFrame *cf) { guint ViewValue; if(Quit()) return; gtk_widget_set_sensitive(GTK_WIDGET(m_ViewComboBox), cf != NULL); setEnable(\"close\",cf != NULL); setEnable(\"save\",cf != NULL); setEnable(\"saveas\",cf != NULL); setEnable(\"overlay\",cf != NULL); setEnable(\"graannotations\",cf != NULL); if (cf) { MdispGtkApp* app = (MdispGtkApp*) dispGtkApp(); MdispGtkView* view = cf-&gt;View(); setEnable(\"grabstart\",app-&gt;m_numberOfDigitizer != 0 &amp;&amp; !(app-&gt;m_pGrabView &amp;&amp; app-&gt;m_isGrabStarted)); setEnable(\"grabstop\", app-&gt;m_pGrabView &amp;&amp; app-&gt;m_isGrabStarted ); setActive(\"scale\", cf-&gt;View()-&gt;IsScaleDisplayEnabled() ); setActive(\"Overlay\",cf-&gt;View()-&gt;IsOverlayEnabled() ); setEnable(\"overlayopacity\", cf-&gt;View()-&gt;IsOverlayEnabled()); setActive(\"graannotations\", cf-&gt;View()-&gt;IsGraphicsAnnotationsEnabled() ); setEnable(\"graphiclistopacity\", cf-&gt;View()-&gt;IsGraphicsAnnotationsEnabled() ); setEnable(\"grarectangle\", cf-&gt;View()-&gt;IsGraphicsAnnotationsEnabled()); setEnable(\"graarc\", cf-&gt;View()-&gt;IsGraphicsAnnotationsEnabled()); setEnable(\"grapolygon\", cf-&gt;View()-&gt;IsGraphicsAnnotationsEnabled()); setEnable(\"graorientedrect\", cf-&gt;View()-&gt;IsGraphicsAnnotationsEnabled()); setEnable(\"graarcthreepoints\", cf-&gt;View()-&gt;IsGraphicsAnnotationsEnabled()); setEnable(\"graselectcolor\", cf-&gt;View()-&gt;IsGraphicsAnnotationsEnabled()); setEnable(\"grafill\", cf-&gt;View()-&gt;IsGraphicsAnnotationsEnabled()); setEnable(\"gradrawdir\", cf-&gt;View()-&gt;IsGraphicsAnnotationsEnabled()); if ( view-&gt;IsScaleDisplayEnabled() ) { setEnable(\"nozoom\",false); setEnable(\"zoomin\",false); setEnable(\"zoomout\",false); } else { setEnable(\"zoomin\", cf-&gt;View()-&gt;CurrentZoomFactorX() &lt; 16.0 ); setEnable(\"zoomout\", cf-&gt;View()-&gt;CurrentZoomFactorX() &gt; 1.0/16.0 ); setEnable(\"nozoom\", true); } setEnable(\"scale\", ( !cf-&gt;View()-&gt;IsExclusive()));; setEnable(\"restrictcursor\", cf-&gt;View()-&gt;IsExclusive()); switch(view-&gt;OverlayOpacity()) { case M_DEFAULT: setActive(\"overlayopacity\",\"M_DEFAULT\"); break; case M_DISABLE: setActive(\"overlayopacity\",\"M_DISABLE\"); break; case 0: setActive(\"overlayopacity\",\"0\"); break; case 20: setActive(\"overlayopacity\",\"20\"); break; case 40: setActive(\"overlayopacity\",\"40\"); break; case 60: setActive(\"overlayopacity\",\"60\"); break; case 80: setActive(\"overlayopacity\",\"80\"); break; case 100: setActive(\"overlayopacity\",\"100\"); break; } switch(view-&gt;GraphicListOpacity()) { case M_DEFAULT: setActive(\"graphiclistopacity\",\"M_DEFAULT\"); break; case M_DISABLE: setActive(\"graphiclistopacity\",\"M_DISABLE\"); break; case 0: setActive(\"graphiclistopacity\",\"0\"); break; case 20: setActive(\"graphiclistopacity\",\"20\"); break; case 40: setActive(\"graphiclistopacity\",\"40\"); break; case 60: setActive(\"graphiclistopacity\",\"60\"); break; case 80: setActive(\"graphiclistopacity\",\"80\"); break; case 100: setActive(\"graphiclistopacity\",\"100\"); break; } ViewValue = VIEW_MODE_DEFAULT; switch(view-&gt;CurrentViewMode()) { case M_DEFAULT: ViewValue = VIEW_MODE_DEFAULT; break; case M_TRANSPARENT: ViewValue = VIEW_MODE_TRANSPARENT; break; case M_AUTO_SCALE: ViewValue = VIEW_MODE_AUTO_SCALE; break; case M_MULTI_BYTES: ViewValue = VIEW_MODE_MULTI_BYTES; break; case M_BIT_SHIFT: { if(view-&gt;CurrentShiftValue() == 2) ViewValue = VIEW_MODE_BIT_SHIFT2; else if(view-&gt;CurrentShiftValue() == 4) ViewValue = VIEW_MODE_BIT_SHIFT4; else if(view-&gt;CurrentShiftValue() == 8) ViewValue = VIEW_MODE_BIT_SHIFT8; } break; } gtk_combo_box_set_active (GTK_COMBO_BOX(m_ViewComboBox),ViewValue); // DMILs menu setEnable(\"dmilasync\", view-&gt;IsNetworkedSystem()); setEnable(\"dmilcompression\", view-&gt;IsNetworkedSystem()); setEnable(\"dmilqfactor\", view-&gt;IsNetworkedSystem()); if(view-&gt;IsNetworkedSystem()) { if(!view-&gt;IsInAsynchronousMode()) setActive(\"dmilasync\",\"disabled\"); else { switch(view-&gt;AsynchronousFrameRate()) { case 1: setActive(\"dmilasync\",\"1\"); break; case 5: setActive(\"dmilasync\",\"5\"); break; case 10: setActive(\"dmilasync\",\"10\"); break; case 15: setActive(\"dmilasync\",\"15\"); break; case 30: setActive(\"dmilasync\",\"30\"); break; case M_INFINITE: setActive(\"dmilasync\",\"maxrate\"); break; } } switch(view-&gt;CompressionType()) { case M_NULL: setActive(\"dmilcompression\",\"none\"); break; case M_JPEG_LOSSY: setActive(\"dmilcompression\",\"lossy\"); break; case M_JPEG_LOSSLESS: setActive(\"dmilcompression\",\"lossless\"); break; } switch(view-&gt;QFactor()) { case 60: setActive(\"dmilqfactor\",\"60\"); break; case 70: setActive(\"dmilqfactor\",\"70\"); break; case 75: setActive(\"dmilqfactor\",\"75\"); break; case 80: setActive(\"dmilqfactor\",\"80\"); break; case 82: setActive(\"dmilqfactor\",\"82\"); break; case 85: setActive(\"dmilqfactor\",\"85\"); break; case 87: setActive(\"dmilqfactor\",\"87\"); break; case 90: setActive(\"dmilqfactor\",\"90\"); break; case 92: setActive(\"dmilqfactor\",\"92\"); break; case 95: setActive(\"dmilqfactor\",\"95\"); break; case 99: setActive(\"dmilqfactor\",\"99\"); break; } } } else { setEnable(\"new\",true); setEnable(\"open\",true); setEnable(\"save\",false); setEnable(\"close\",false); setEnable(\"saveas\",false); setEnable(\"grabstart\",false); setEnable(\"grabstop\",false); setEnable(\"overlay\",false); setEnable(\"overlayopacity\", false); setEnable(\"graannotations\",false); setEnable(\"zoomin\",false); setEnable(\"nozoom\",false); setEnable(\"zoomout\",false); setEnable(\"scale\",false); setEnable(\"graphiclistopacity\", false); setEnable(\"grarectangle\", false); setEnable(\"graarc\", false); setEnable(\"grapolygon\", false); setEnable(\"graorientedrect\", false); setEnable(\"graarcthreepoints\", false); setEnable(\"graselectcolor\", false); setEnable(\"grafill\", false); setEnable(\"gradrawdir\", false); setEnable(\"dmilasync\", false); setEnable(\"dmilcompression\", false); setEnable(\"dmilqfactor\", false); setEnable(\"restrictcursor\", false); } } ",
      "wordCount": 2849
    },
    {
      "id": "Examples_LinuxSpecific_MdispGtk_CPP_mdispgtk_cpp",
      "version": "2024020714",
      "title": "mdispgtk.cpp",
      "location": "Sample Code from MIL Examples",
      "text": " Top /* * File name: MdispGtk.cpp * Location: See Matrox Example Launcher in the MIL Control Center * */ // // Copyright (C) Matrox Electronic Systems Ltd., 1992-2024. // All Rights Reserved #include &lt;mil.h&gt; #include &lt;gtk/gtk.h&gt; #include &lt;X11/Xlib.h&gt; #include &lt;stdlib.h&gt; #include \"mdispgtkapp.h\" #include \"mainframe.h\" static void activate (GApplication *app, gpointer user_data) { GtkWidget *win; MdispGtkApp* dispApp = (MdispGtkApp *) user_data; dispApp-&gt;InitWindow(); gtk_window_present (GTK_WINDOW (dispApp-&gt;GetMainFrame()-&gt;MainWindow())); } static void shutdown (GApplication *app, gpointer user_data) { MdispGtkApp* dispApp = (MdispGtkApp *) user_data; if(dispApp) dispApp-&gt;GetMainFrame()-&gt;Quit(true); } static void startup (GApplication *app, gpointer user_data) { GtkBuilder *builder; GMenuModel *menubar; builder = gtk_builder_new (); gtk_builder_add_from_resource (builder, \"/images/menus.ui\", NULL); menubar = (GMenuModel *)gtk_builder_get_object (builder, \"menubar\"); gtk_application_set_menubar (GTK_APPLICATION (app), menubar); g_object_unref (builder); } int main(int argc, char *argv[]) { GtkApplication *gtkApp; // Force X11 backend setenv(\"GDK_BACKEND\",\"x11\", 1); // init Xlib thread XInitThreads(); // init Gtk gtk_init (NULL, NULL); #if GLIB_CHECK_VERSION(2,74,0) gtkApp = gtk_application_new (\"com.matrox.MdispGtk\", G_APPLICATION_DEFAULT_FLAGS); #else gtkApp = gtk_application_new (\"com.matrox.MdispGtk\", G_APPLICATION_FLAGS_NONE); #endif MdispGtkApp dispApp(gtkApp); // g_action_map_add_action_entries (G_ACTION_MAP (app), app_entries, G_N_ELEMENTS (app_entries), app); g_signal_connect (gtkApp, \"startup\", G_CALLBACK (startup), &amp;dispApp); g_signal_connect (gtkApp, \"activate\", G_CALLBACK (activate), &amp;dispApp); g_signal_connect (gtkApp, \"shutdown\", G_CALLBACK (shutdown), &amp;dispApp); g_application_run (G_APPLICATION (gtkApp), 0, NULL); return 0; } ",
      "wordCount": 192
    },
    {
      "id": "Examples_LinuxSpecific_MdispGtk_CPP_mdispgtkapp_cpp",
      "version": "2024020714",
      "title": "mdispgtkapp.cpp",
      "location": "Sample Code from MIL Examples",
      "text": " Top /* * File name: mdispgtkapp.cpp * Location: See Matrox Example Launcher in the MIL Control Center * */ // // Copyright (C) Matrox Electronic Systems Ltd., 1992-2024. // All Rights Reserved #include &lt;mil.h&gt; #include &lt;gtk/gtk.h&gt; #include &lt;X11/Xlib.h&gt; #include &lt;stdlib.h&gt; #include \"mainframe.h\" #include \"mdispgtkapp.h\" static gint MessageBox(GtkWindow *parent, gchar *text,GtkMessageType messagetype,GtkButtonsType buttonstype) { GtkWidget *dialog; gint result; dialog = gtk_message_dialog_new (GTK_WINDOW(parent), GTK_DIALOG_DESTROY_WITH_PARENT, messagetype, buttonstype, \"%s\", text); gtk_window_set_title(GTK_WINDOW(dialog),\"MIL Error\"); result=gtk_dialog_run (GTK_DIALOG (dialog)); gtk_widget_destroy (dialog); return result; } static gboolean RunDialog(gpointer user_data) { DialogData *data = (DialogData *) user_data; g_return_val_if_fail(data, FALSE); g_mutex_lock (&amp;data-&gt;mutex); data-&gt;Result = MessageBox(data-&gt;Parent, data-&gt;Text, data-&gt;MessageType, data-&gt;ButtonsType); data-&gt;Done = TRUE; g_cond_signal (&amp;data-&gt;cond); g_mutex_unlock (&amp;data-&gt;mutex); return FALSE; } MdispGtkApp::MdispGtkApp(GtkApplication *gtkApp) { m_GtkApp = gtkApp; m_MainFrame = NULL; m_MainThread = g_thread_self(); m_isCurrentlyHookedOnErrors = false; InitInstance(); } MdispGtkApp::~MdispGtkApp() { ExitInstance(); if(m_MainFrame) delete m_MainFrame; m_MainFrame = NULL; } void MdispGtkApp::InitWindow() { m_MainFrame = new MainFrame(m_GtkApp); g_object_set_data(G_OBJECT(m_MainFrame-&gt;MainWindow()),\"App\",(void *)this); m_MainFrame-&gt;OnInitialize(); } bool MdispGtkApp::InitInstance() { // Allocate an application and system [CALL TO MIL] MappAllocDefault(M_DEFAULT, &amp;m_MilApplication, &amp;m_MilSystem, M_NULL, M_NULL, M_NULL); // Hook MIL error on function DisplayError() [CALL TO MIL] MappHookFunction(M_DEFAULT, M_ERROR_CURRENT,DisplayErrorExt,this); m_isCurrentlyHookedOnErrors = true; // Disable MIL error message to be displayed as the usual way [CALL TO MIL] MappControl(M_DEFAULT, M_ERROR,M_PRINT_DISABLE); // Inquire number of digitizers available on the system [CALL TO MIL] MsysInquire(m_MilSystem,M_DIGITIZER_NUM,&amp;m_numberOfDigitizer); // Digitizer is available if (m_numberOfDigitizer) { // Allocate a digitizer [CALL TO MIL] MdigAlloc(m_MilSystem,M_DEFAULT,MIL_TEXT(\"M_DEFAULT\"),M_DEFAULT,&amp;m_MilDigitizer); // Inquire digitizer informations [CALL TO MIL] MdigInquire(m_MilDigitizer,M_SIZE_X,&amp;m_digitizerSizeX); MdigInquire(m_MilDigitizer,M_SIZE_Y,&amp;m_digitizerSizeY); MdigInquire(m_MilDigitizer,M_SIZE_BAND,&amp;m_digitizerNbBands); } // Initialize the state of the grab m_isGrabStarted = false; return true; } bool MdispGtkApp::ExitInstance() { ///////////////////////////////////////////////////////////////////////// // MIL: Write your code that will be executed on application exit ///////////////////////////////////////////////////////////////////////// //Free the digitizer [CALL TO MIL] if(m_MilDigitizer) MdigFree (m_MilDigitizer); //Free the system [CALL TO MIL] if(m_MilSystem) MsysFree (m_MilSystem); if(m_MilApplication) { // Enable MIL error message to be displayed as the usual way [CALL TO MIL] MappControl(M_DEFAULT, M_ERROR,M_PRINT_ENABLE); // Unhook MIL error on function DisplayError() [CALL TO MIL] if(m_isCurrentlyHookedOnErrors) { //MappHookFunction(M_DEFAULT, M_ERROR_CURRENT+M_UNHOOK,DisplayErrorExt,pMdispGtkView); m_isCurrentlyHookedOnErrors = false; } // Free the application [CALL TO MIL] MappFree(m_MilApplication); } ///////////////////////////////////////////////////////////////////////// // MIL: Write your code that will be executed on application exit ///////////////////////////////////////////////////////////////////////// return true; } long MFTYPE MdispGtkApp::DisplayErrorExt(long HookType, MIL_ID EventId, void* UserDataPtr) { MdispGtkApp* UserData = (MdispGtkApp *) UserDataPtr; //If user clicks NO on error message, unhook to errors. if(UserData-&gt;DisplayError(HookType,EventId, UserDataPtr) == GTK_RESPONSE_NO) { MappHookFunction(M_DEFAULT, M_ERROR_CURRENT+M_UNHOOK,DisplayErrorExt,UserDataPtr); UserData-&gt;HookedOnErrors(false); } return M_NULL; } long MFTYPE MdispGtkApp::DisplayError(MIL_INT HookType, MIL_ID EventId, void* UserDataPtr) { MIL_STRING ErrorMessageFunction; MIL_STRING ErrorMessage; MIL_STRING ErrorSubMessage1; MIL_STRING ErrorSubMessage2; MIL_STRING ErrorSubMessage3; long NbSubCode; GString *GErrorMessage; gint result = GTK_RESPONSE_YES; GErrorMessage=g_string_new(NULL); //Retrieve error message [CALL TO MIL] MappGetHookInfo(M_DEFAULT, EventId,M_MESSAGE+M_CURRENT_OPCODE,ErrorMessageFunction); MappGetHookInfo(M_DEFAULT, EventId,M_MESSAGE+M_CURRENT,ErrorMessage); MappGetHookInfo(M_DEFAULT, EventId,M_CURRENT_SUB_NB,&amp;NbSubCode); if (NbSubCode &gt; 2) MappGetHookInfo(M_DEFAULT, EventId,M_MESSAGE+M_CURRENT_SUB_3,ErrorSubMessage3); if (NbSubCode &gt; 1) MappGetHookInfo(M_DEFAULT, EventId,M_MESSAGE+M_CURRENT_SUB_2,ErrorSubMessage2); if (NbSubCode &gt; 0) MappGetHookInfo(M_DEFAULT, EventId,M_MESSAGE+M_CURRENT_SUB_1,ErrorSubMessage1); GErrorMessage = g_string_append(GErrorMessage,ErrorMessageFunction.c_str()); GErrorMessage = g_string_append(GErrorMessage ,\"\\n\"); GErrorMessage = g_string_append(GErrorMessage ,ErrorMessage.c_str()); if(NbSubCode &gt; 0) { GErrorMessage = g_string_append(GErrorMessage , \"\\n\"); GErrorMessage = g_string_append(GErrorMessage , ErrorSubMessage1.c_str()); } if(NbSubCode &gt; 1) { GErrorMessage = g_string_append(GErrorMessage , \"\\n\"); GErrorMessage = g_string_append(GErrorMessage , ErrorSubMessage2.c_str()); } if(NbSubCode &gt; 2) { GErrorMessage = g_string_append(GErrorMessage , \"\\n\"); GErrorMessage = g_string_append(GErrorMessage , ErrorSubMessage3.c_str()); } GErrorMessage = g_string_append(GErrorMessage , \"\\n\\n\"); GErrorMessage = g_string_append(GErrorMessage , \"Do you want to continue error print?\"); if ( m_MainThread == g_thread_self()) { if (m_MainFrame &amp;&amp; GTK_IS_WINDOW(m_MainFrame-&gt;MainWindow())) result = MessageBox(GTK_WINDOW(m_MainFrame-&gt;MainWindow()), GErrorMessage-&gt;str, GTK_MESSAGE_QUESTION, GTK_BUTTONS_YES_NO); else result = MessageBox(NULL, GErrorMessage-&gt;str, GTK_MESSAGE_QUESTION, GTK_BUTTONS_YES_NO); } else { DialogData *data; data = g_new0 (DialogData, 1); data-&gt;Parent = GTK_WINDOW(m_MainFrame-&gt;MainWindow()); data-&gt;MessageType = GTK_MESSAGE_QUESTION; data-&gt;ButtonsType = GTK_BUTTONS_YES_NO; data-&gt;Text = GErrorMessage-&gt;str; data-&gt;Done = FALSE; g_mutex_init (&amp;data-&gt;mutex); g_cond_init (&amp;data-&gt;cond); g_mutex_lock (&amp;data-&gt;mutex); g_main_context_invoke (NULL, RunDialog, data); while (!data-&gt;Done) g_cond_wait (&amp;data-&gt;cond, &amp;data-&gt;mutex); result = data-&gt;Result; g_mutex_unlock (&amp;data-&gt;mutex); g_mutex_clear (&amp;data-&gt;mutex); g_cond_clear (&amp;data-&gt;cond); g_free (data); } g_string_free(GErrorMessage,TRUE); return result; } ",
      "wordCount": 593
    },
    {
      "id": "Examples_LinuxSpecific_MdispGtk_CPP_mdispgtkmarshal_cpp",
      "version": "2024020714",
      "title": "mdispgtkmarshal.cpp",
      "location": "Sample Code from MIL Examples",
      "text": " Top /* * File name: mdispgtkmarshal.cpp * Location: See Matrox Example Launcher in the MIL Control Center * */ // // Copyright (C) Matrox Electronic Systems Ltd., 1992-2024. // All Rights Reserved #include \"mdispgtkmarshal.h\" #include &lt;glib-object.h&gt; #ifdef G_ENABLE_DEBUG #define g_marshal_value_peek_boolean(v) g_value_get_boolean (v) #define g_marshal_value_peek_char(v) g_value_get_char (v) #define g_marshal_value_peek_uchar(v) g_value_get_uchar (v) #define g_marshal_value_peek_int(v) g_value_get_int (v) #define g_marshal_value_peek_uint(v) g_value_get_uint (v) #define g_marshal_value_peek_long(v) g_value_get_long (v) #define g_marshal_value_peek_ulong(v) g_value_get_ulong (v) #define g_marshal_value_peek_int64(v) g_value_get_int64 (v) #define g_marshal_value_peek_uint64(v) g_value_get_uint64 (v) #define g_marshal_value_peek_enum(v) g_value_get_enum (v) #define g_marshal_value_peek_flags(v) g_value_get_flags (v) #define g_marshal_value_peek_float(v) g_value_get_float (v) #define g_marshal_value_peek_double(v) g_value_get_double (v) #define g_marshal_value_peek_string(v) (char*) g_value_get_string (v) #define g_marshal_value_peek_param(v) g_value_get_param (v) #define g_marshal_value_peek_boxed(v) g_value_get_boxed (v) #define g_marshal_value_peek_pointer(v) g_value_get_pointer (v) #define g_marshal_value_peek_object(v) g_value_get_object (v) #else /* !G_ENABLE_DEBUG */ /* WARNING: This code accesses GValues directly, which is UNSUPPORTED API. * Do not access GValues directly in your code. Instead, use the * g_value_get_*() functions */ #define g_marshal_value_peek_boolean(v) (v)-&gt;data[0].v_int #define g_marshal_value_peek_char(v) (v)-&gt;data[0].v_int #define g_marshal_value_peek_uchar(v) (v)-&gt;data[0].v_uint #define g_marshal_value_peek_int(v) (v)-&gt;data[0].v_int #define g_marshal_value_peek_uint(v) (v)-&gt;data[0].v_uint #define g_marshal_value_peek_long(v) (v)-&gt;data[0].v_long #define g_marshal_value_peek_ulong(v) (v)-&gt;data[0].v_ulong #define g_marshal_value_peek_int64(v) (v)-&gt;data[0].v_int64 #define g_marshal_value_peek_uint64(v) (v)-&gt;data[0].v_uint64 #define g_marshal_value_peek_enum(v) (v)-&gt;data[0].v_long #define g_marshal_value_peek_flags(v) (v)-&gt;data[0].v_ulong #define g_marshal_value_peek_float(v) (v)-&gt;data[0].v_float #define g_marshal_value_peek_double(v) (v)-&gt;data[0].v_double #define g_marshal_value_peek_string(v) (v)-&gt;data[0].v_pointer #define g_marshal_value_peek_param(v) (v)-&gt;data[0].v_pointer #define g_marshal_value_peek_boxed(v) (v)-&gt;data[0].v_pointer #define g_marshal_value_peek_pointer(v) (v)-&gt;data[0].v_pointer #define g_marshal_value_peek_object(v) (v)-&gt;data[0].v_pointer #endif /* !G_ENABLE_DEBUG */ /* VOID:DOUBLE */ void mdispgtk_marshal_VOID__DOUBLE (GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data) { typedef void (*GMarshalFunc_VOID__DOUBLE) (gpointer data1, gdouble arg_1, gpointer data2); register GMarshalFunc_VOID__DOUBLE callback; register GCClosure *cc = (GCClosure*) closure; register gpointer data1, data2; g_return_if_fail (n_param_values == 2); if (G_CCLOSURE_SWAP_DATA (closure)) { data1 = closure-&gt;data; data2 = g_value_peek_pointer (param_values + 0); } else { data1 = g_value_peek_pointer (param_values + 0); data2 = closure-&gt;data; } callback = (GMarshalFunc_VOID__DOUBLE) (marshal_data ? marshal_data : cc-&gt;callback); callback (data1, g_marshal_value_peek_double (param_values + 1), data2); } /* VOID:DOUBLE,DOUBLE */ void mdispgtk_marshal_VOID__DOUBLE_DOUBLE (GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data) { typedef void (*GMarshalFunc_VOID__DOUBLE_DOUBLE) (gpointer data1, gdouble arg_1, gdouble arg_2, gpointer data2); register GMarshalFunc_VOID__DOUBLE_DOUBLE callback; register GCClosure *cc = (GCClosure*) closure; register gpointer data1, data2; g_return_if_fail (n_param_values == 3); if (G_CCLOSURE_SWAP_DATA (closure)) { data1 = closure-&gt;data; data2 = g_value_peek_pointer (param_values + 0); } else { data1 = g_value_peek_pointer (param_values + 0); data2 = closure-&gt;data; } callback = (GMarshalFunc_VOID__DOUBLE_DOUBLE) (marshal_data ? marshal_data : cc-&gt;callback); callback (data1, g_marshal_value_peek_double (param_values + 1), g_marshal_value_peek_double (param_values + 2), data2); } /* VOID:INT,INT,INT,INT */ void mdispgtk_marshal_VOID__INT_INT_INT_INT (GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data) { typedef void (*GMarshalFunc_VOID__INT_INT_INT_INT) (gpointer data1, gint arg_1, gint arg_2, gint arg_3, gint arg_4, gpointer data2); register GMarshalFunc_VOID__INT_INT_INT_INT callback; register GCClosure *cc = (GCClosure*) closure; register gpointer data1, data2; g_return_if_fail (n_param_values == 5); if (G_CCLOSURE_SWAP_DATA (closure)) { data1 = closure-&gt;data; data2 = g_value_peek_pointer (param_values + 0); } else { data1 = g_value_peek_pointer (param_values + 0); data2 = closure-&gt;data; } callback = (GMarshalFunc_VOID__INT_INT_INT_INT) (marshal_data ? marshal_data : cc-&gt;callback); callback (data1, g_marshal_value_peek_int (param_values + 1), g_marshal_value_peek_int (param_values + 2), g_marshal_value_peek_int (param_values + 3), g_marshal_value_peek_int (param_values + 4), data2); } /* VOID:INT,INT,DOUBLE,DOUBLE */ void mdispgtk_marshal_VOID__INT_INT_DOUBLE_DOUBLE (GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data) { typedef void (*GMarshalFunc_VOID__INT_INT_DOUBLE_DOUBLE) (gpointer data1, gint arg_1, gint arg_2, gdouble arg_3, gdouble arg_4, gpointer data2); register GMarshalFunc_VOID__INT_INT_DOUBLE_DOUBLE callback; register GCClosure *cc = (GCClosure*) closure; register gpointer data1, data2; g_return_if_fail (n_param_values == 5); if (G_CCLOSURE_SWAP_DATA (closure)) { data1 = closure-&gt;data; data2 = g_value_peek_pointer (param_values + 0); } else { data1 = g_value_peek_pointer (param_values + 0); data2 = closure-&gt;data; } callback = (GMarshalFunc_VOID__INT_INT_DOUBLE_DOUBLE) (marshal_data ? marshal_data : cc-&gt;callback); callback (data1, g_marshal_value_peek_int (param_values + 1), g_marshal_value_peek_int (param_values + 2), g_marshal_value_peek_double (param_values + 3), g_marshal_value_peek_double (param_values + 4), data2); } ",
      "wordCount": 592
    },
    {
      "id": "Examples_LinuxSpecific_MdispGtk_CPP_mdispgtkview_cpp",
      "version": "2024020714",
      "title": "mdispgtkview.cpp",
      "location": "Sample Code from MIL Examples",
      "text": " Top /* * File name: mdispgtkview.cpp * Location: See Matrox Example Launcher in the MIL Control Center * */ // // Copyright  Matrox Electronic Systems Ltd., 1992-2024. // All Rights Reserved #include &lt;gtk/gtk.h&gt; #include &lt;mil.h&gt; #include &lt;gdk/gdkx.h&gt; #include &lt;X11/Xlib.h&gt; #include &lt;cairo-xlib.h&gt; #include \"mdispgtkview.h\" #include \"mdispgtkapp.h\" #include \"childframe.h\" #include &lt;algorithm&gt; #define IMAGE_FILE M_IMAGE_PATH MIL_TEXT(\"BaboonRGB.mim\") // Do not grab display inside gtk libs // this prevent Xserver freeze when annotation is enabled int XGrabServer(Display *dpy) { return 1;} int XUngrabServer(Display *dpy) { return 1;} MIL_INT MFTYPE MouseFct(MIL_INT /*HookType*/, MIL_ID EventID, void* UserDataPtr) { MdispGtkView* pCurrentView = (MdispGtkView *)UserDataPtr; if(pCurrentView) { MOUSEPOSITION MousePosition; MdispGetHookInfo(EventID, M_MOUSE_POSITION_X, &amp;MousePosition.m_DisplayPositionX); MdispGetHookInfo(EventID, M_MOUSE_POSITION_Y, &amp;MousePosition.m_DisplayPositionY); MdispGetHookInfo(EventID, M_MOUSE_POSITION_BUFFER_X, &amp;MousePosition.m_BufferPositionX); MdispGetHookInfo(EventID, M_MOUSE_POSITION_BUFFER_Y, &amp;MousePosition.m_BufferPositionY); pCurrentView-&gt;SetMousePosition(MousePosition); pCurrentView-&gt;UpdateStatusBarWithMousePosition(); } return 0; } MIL_INT MFTYPE GraphicListModifiedHookFct(MIL_INT HookType, MIL_ID EventID, void* UserDataPtr) { MdispGtkView *pCurrentView = (MdispGtkView *)UserDataPtr; if(pCurrentView) { MIL_INT State = M_NULL; MgraGetHookInfo(EventID, M_INTERACTIVE_GRAPHIC_STATE, &amp;State); if((State != M_STATE_WAITING_FOR_CREATION) &amp;&amp; (State != M_STATE_BEING_CREATED)) { pCurrentView-&gt;ResetPrimitiveCreation(); } } return 0; } MdispGtkView::MdispGtkView(ChildFrame* cf) { m_cf = cf; m_Modified = false; m_window = cf-&gt;DrawingArea(); m_MilOverlayImage = M_NULL; // Overlay image buffer identifier m_MilDisplay = M_NULL; // Display identifier. m_MilGraphContext = M_NULL; m_MilGraphList = M_NULL; static int viewNumber = 0; m_filename = g_strdup_printf(\"Image%d.mim\",++viewNumber); m_isWindowed = true; m_isExclusive = false; m_isOverlayEnabled = false; // Overlay state m_isOverlayInitialized = false; m_isScaleDisplayEnabled = false; m_isGraphicsAnnotationsEnabled = false; m_currentViewMode = M_TRANSPARENT; m_currentShiftValue = M_NULL; m_isInAsynchronousMode = false; m_currentCompressionType = M_NULL; m_currentAsynchronousFrameRate = M_INFINITE; m_currentQFactor = M_DEFAULT; m_currentOverlayOpacity = M_DEFAULT; m_currentGraphicListOpacity = M_DEFAULT; m_currentRestrictCursor = M_ENABLE; m_PrimitiveInCreation = M_NULL; m_FrameTimeOutTag = g_timeout_add(100,MdispGtkView::timerEvent,this); m_imageSizeX = DEFAULTSIZEX; m_imageSizeY = DEFAULTSIZEY; m_currentZoomFactorX = 1.0; m_currentZoomFactorY = 1.0; UpdateContentSize(); } MdispGtkView::~MdispGtkView() { // Halt the grab, deselected the display, free the display and the image buffer // only if MbufAlloc was successful if (m_MilImage) { // Make sure display is deselected and grab is halt RemoveFromDisplay(); // Free image buffer [CALL TO MIL] MbufFree(m_MilImage); } // remove timer g_source_remove(m_FrameTimeOutTag); g_free(m_filename); } MdispGtkApp* MdispGtkView::dispGtkApp() { void *UserData = g_object_get_data(G_OBJECT(m_window),\"App\"); return (MdispGtkApp *) UserData; } void MdispGtkView::GrabStart() { // TODO: Add your command handler code here ///////////////////////////////////////////////////////////////////////// // MIL: Write code that will be executed on a grab start ///////////////////////////////////////////////////////////////////////// // If there is a grab in a view, halt the grab before starting a new one if(((MdispGtkApp*)dispGtkApp())-&gt;m_isGrabStarted) ((MdispGtkApp*)dispGtkApp())-&gt;m_pGrabView-&gt;GrabStop(); // Start a continuous grab in this view MdigGrabContinuous(((MdispGtkApp*)dispGtkApp())-&gt;m_MilDigitizer, m_MilImage); // Update the variable GrabIsStarted ((MdispGtkApp*)dispGtkApp())-&gt;m_isGrabStarted = true; // GrabInViewPtr is now a pointer to m_pGrabView view ((MdispGtkApp*)dispGtkApp())-&gt;m_pGrabView = this; // Document has been modified m_Modified = true; ///////////////////////////////////////////////////////////////////////// // MIL: Write code that will be executed on a grab start ///////////////////////////////////////////////////////////////////////// } void MdispGtkView::GrabStop() { // TODO: Add your command handler code here ///////////////////////////////////////////////////////////////////////// // MIL: Write code that will be executed on a grab stop ///////////////////////////////////////////////////////////////////////// // Halt the grab MdigHalt(((MdispGtkApp*)dispGtkApp())-&gt;m_MilDigitizer); ((MdispGtkApp*)dispGtkApp())-&gt;m_isGrabStarted = false; ///////////////////////////////////////////////////////////////////////// // MIL: Write code that will be executed on a grab stop ///////////////////////////////////////////////////////////////////////// } void MdispGtkView::Overlay(bool on) { // Enable overlay if (on &amp;&amp; !m_isOverlayEnabled) { MdispControl(m_MilDisplay, M_OVERLAY, M_ENABLE); //If overlay buffer as not been initialized yet, do it now. if(!m_isOverlayInitialized) InitializeOverlay(); m_isOverlayEnabled = true; } // Disable overlay else if (!on &amp;&amp; m_isOverlayEnabled) { // Disable the overlay display. [CALL TO MIL] MdispControl(m_MilDisplay, M_OVERLAY, M_DISABLE); m_isOverlayInitialized = false; m_isOverlayEnabled = false; } ///////////////////////////////////////////////////////////////////////// // MIL: Write code that will be executed when 'add overlay' is selected ///////////////////////////////////////////////////////////////////////// } void MdispGtkView::Initialize() { // Allocate a display [CALL TO MIL] MdispAlloc(((MdispGtkApp*)dispGtkApp())-&gt;m_MilSystem, M_DEFAULT, \"M_DEFAULT\", M_DEFAULT, &amp;m_MilDisplay); if(m_MilDisplay) { MIL_INT DisplayType = MdispInquire(m_MilDisplay, M_DISPLAY_TYPE, M_NULL); // Check display type [CALL TO MIL] if((DisplayType&amp;(M_WINDOWED|M_EXCLUSIVE)) !=M_WINDOWED) m_isWindowed = false; if(DisplayType&amp;(M_EXCLUSIVE)) m_isExclusive = true; // Initially set view mode to default ChangeViewMode(M_DEFAULT); if(IsNetworkedSystem()) { // Check compression type [CALL TO MIL] MdispInquire(m_MilDisplay, M_COMPRESSION_TYPE, &amp;m_currentCompressionType); // Check asynchronous mode [CALL TO MIL] m_isInAsynchronousMode = (MdispInquire(m_MilDisplay, M_ASYNC_UPDATE, M_NULL) == M_ENABLE); // Check asynchronous frame rate [CALL TO MIL] MdispInquire(m_MilDisplay, M_UPDATE_RATE_MAX, &amp;m_currentAsynchronousFrameRate); // Check Q factor [CALL TO MIL] MdispInquire(m_MilDisplay, M_Q_FACTOR, &amp;m_currentQFactor); // Check Overlay Opacity [CALL TO MIL] MdispInquire(m_MilDisplay, M_OVERLAY_OPACITY, &amp;m_currentOverlayOpacity); // Check Graphic List Opacity [CALL TO MIL] MdispInquire(m_MilDisplay, M_GRAPHIC_LIST_OPACITY, &amp;m_currentGraphicListOpacity); } if(m_isExclusive) { MdispInquire(m_MilDisplay, M_RESTRICT_CURSOR, &amp;m_currentRestrictCursor); } //Select the buffer from its display object and given window [CALL TO MIL] MdispSelectWindow(m_MilDisplay, m_MilImage, m_isWindowed?GDK_WINDOW_XID(gtk_widget_get_window(m_window)):0); // Allow panning and zooming with the mouse [CALL TO MIL] MdispControl(m_MilDisplay, M_MOUSE_USE, M_ENABLE); // Tell Mil Display we are using Gtk toolkit So background will be // cleared by MIL when resizing MdispControl(m_MilDisplay, M_GTK_MODE, M_ENABLE); // Allow mouse cursor handling [CALL TO MIL] MdispControl(m_MilDisplay, M_MOUSE_CURSOR_CHANGE, M_ENABLE); // Hook a function to mouse-movement event, to update cursor position in status bar. MdispHookFunction(m_MilDisplay, M_MOUSE_MOVE, MouseFct, (void*)this); } ///////////////////////////////////////////////////////////////////////// // MIL: Code that will be executed when a view is first attached to the document ///////////////////////////////////////////////////////////////////////// } void MdispGtkView::RemoveFromDisplay() { //Halt grab if in process in THIS view if ((((MdispGtkApp*)dispGtkApp())-&gt;m_pGrabView == this) &amp;&amp; ((MdispGtkApp*)dispGtkApp())-&gt;m_isGrabStarted) { //Ask the digitizer to halt the grab [CALL TO MIL] MdigHalt(((MdispGtkApp*)dispGtkApp())-&gt;m_MilDigitizer); ((MdispGtkApp*)dispGtkApp())-&gt;m_isGrabStarted = false; } if (m_MilImage &amp;&amp; m_MilDisplay) { //Deselect the buffer from its display object and given window [CALL TO MIL] MdispSelect(m_MilDisplay, M_NULL); // Hook from mouse-movement event. MdispHookFunction(m_MilDisplay, M_MOUSE_MOVE+M_UNHOOK, MouseFct, (void*)this); //Free the display [CALL TO MIL] if(m_MilGraphList) { MgraFree(m_MilGraphList); m_MilGraphList = M_NULL; } if(m_MilGraphContext) { MgraFree(m_MilGraphContext); m_MilGraphContext = M_NULL; } //Free the display [CALL TO MIL] MdispFree(m_MilDisplay); m_MilDisplay = M_NULL; } } bool MdispGtkView::newDoc() { // Set buffer attributes if(((MdispGtkApp*)dispGtkApp())-&gt;m_numberOfDigitizer) { m_bufferAttributes=M_IMAGE+M_DISP+M_GRAB+M_PROC; m_imageSizeX = ((MdispGtkApp*)dispGtkApp())-&gt;m_digitizerSizeX; m_imageSizeY = ((MdispGtkApp*)dispGtkApp())-&gt;m_digitizerSizeY; m_NbBands = ((MdispGtkApp*)dispGtkApp())-&gt;m_digitizerNbBands; // Allocate a buffer [CALL TO MIL] MbufAllocColor(((MdispGtkApp*)dispGtkApp())-&gt;m_MilSystem, m_NbBands, m_imageSizeX, m_imageSizeY, 8+M_UNSIGNED, m_bufferAttributes, &amp;m_MilImage); // Clear the buffer [CALL TO MIL] MbufClear(m_MilImage,M_COLOR_BLACK); } else { //Import image in buffer [CALL TO MIL] MbufImport(IMAGE_FILE,M_DEFAULT,M_RESTORE,((MdispGtkApp*)dispGtkApp())-&gt;m_MilSystem,&amp;m_MilImage); // Set SizeX and SizeY variable to the size of the buffer [CALL TO MIL] if (m_MilImage) { m_imageSizeX = MbufInquire(m_MilImage, M_SIZE_X, M_NULL); m_imageSizeY = MbufInquire(m_MilImage, M_SIZE_Y, M_NULL); m_NbBands = MbufInquire(m_MilImage, M_SIZE_BAND, M_NULL); } } UpdateContentSize(); // If not able to allocate a buffer, do not create a new document if(!m_MilImage) return false; Initialize(); return true; } bool MdispGtkView::load(const char *filename) { //Import image in buffer [CALL TO MIL] MbufImport(filename,M_DEFAULT,M_RESTORE,((MdispGtkApp*)dispGtkApp())-&gt;m_MilSystem,&amp;m_MilImage); // Set SizeX and SizeY variable to the size of the buffer [CALL TO MIL] if (m_MilImage) { Initialize(); m_imageSizeX = MbufInquire(m_MilImage,M_SIZE_X,M_NULL); m_imageSizeY = MbufInquire(m_MilImage,M_SIZE_Y,M_NULL); if (m_filename) { g_free(m_filename); } m_filename = g_strdup(g_path_get_basename(filename)); UpdateContentSize(); return true; } else { return false; } } bool MdispGtkView::save(const char *filename) { gboolean SaveStatus; gchar *tmp; // Halt the grab if the current view has it [CALL TO MIL] if((((MdispGtkApp*)dispGtkApp())-&gt;m_pGrabView == this) &amp;&amp; (((MdispGtkApp*)dispGtkApp())-&gt;m_isGrabStarted == true)) MdigHalt(((MdispGtkApp*)dispGtkApp())-&gt;m_MilDigitizer); // Save the current buffer [CALL TO MIL] tmp = g_strdup(filename); MbufExport(tmp, M_USE_EXTENSION, m_MilImage); g_free(tmp); // Verify if save operation was successful [CALL TO MIL] SaveStatus = (MappGetError(M_DEFAULT, M_CURRENT,M_NULL) == M_NULL_ERROR); // Document has been saved if (!((((MdispGtkApp*)dispGtkApp())-&gt;m_pGrabView == this) &amp;&amp; (((MdispGtkApp*)dispGtkApp())-&gt;m_isGrabStarted == true))) m_Modified = false; // Restart the grab if the current view had it [CALL TO MIL] if((((MdispGtkApp*)dispGtkApp())-&gt;m_pGrabView == this) &amp;&amp; (((MdispGtkApp*)dispGtkApp())-&gt;m_isGrabStarted == true)) MdigGrabContinuous(((MdispGtkApp*)dispGtkApp())-&gt;m_MilDigitizer, m_MilImage); return SaveStatus; } void MdispGtkView::ChangeOverlayOpacity(MIL_INT Opacity) { if(m_MilDisplay) { // Apply Overlay Opacity to display [CALL TO MIL] MdispControl(m_MilDisplay, M_OVERLAY_OPACITY, Opacity); // Check if control worked correctly before considering it successful [CALL TO MIL] if((Opacity == M_DEFAULT) || (MdispInquire(m_MilDisplay, M_OVERLAY_OPACITY, M_NULL) == Opacity)) { m_currentOverlayOpacity = Opacity; } } } void MdispGtkView::ChangeViewMode(long ViewMode,long ShiftValue) { if(m_MilDisplay) { //Apply view mode on display [CALL TO MIL] MdispControl(m_MilDisplay, M_VIEW_MODE, ViewMode); if(ViewMode == M_BIT_SHIFT) MdispControl(m_MilDisplay, M_VIEW_BIT_SHIFT, ShiftValue); //Check if control worked correctly before considering it as successful [CALL TO MIL] if(MdispInquire(m_MilDisplay, M_VIEW_MODE,M_NULL)==ViewMode) { m_currentViewMode = ViewMode; m_currentShiftValue = ShiftValue; } } } void MdispGtkView::ChangeCompressionType(MIL_INT CompressionType) { if(m_MilDisplay) { // Apply compression type to display [CALL TO MIL] MdispControl(m_MilDisplay, M_COMPRESSION_TYPE, CompressionType); // Check if control worked correctly before considering it successful [CALL TO MIL] if(MdispInquire(m_MilDisplay, M_COMPRESSION_TYPE, M_NULL) == CompressionType) { m_currentCompressionType = CompressionType; } } } void MdispGtkView::ChangeAsynchronousMode(bool Enabled, MIL_INT FrameRate) { if(Enabled &amp;&amp; (FrameRate != m_currentAsynchronousFrameRate)) { if(m_MilDisplay) { // Apply asynchronous frame rate to display [CALL TO MIL] MdispControl(m_MilDisplay, M_UPDATE_RATE_MAX, FrameRate); // Check if control worked correctly before considering it successful [CALL TO MIL] if(MdispInquire(m_MilDisplay, M_UPDATE_RATE_MAX, M_NULL) == FrameRate) { m_currentAsynchronousFrameRate = FrameRate; } } } if((Enabled &amp;&amp; !m_isInAsynchronousMode) || (!Enabled &amp;&amp; m_isInAsynchronousMode)) { if(m_MilDisplay) { // Apply asynchronous update to display [CALL TO MIL] MdispControl(m_MilDisplay, M_ASYNC_UPDATE, (Enabled ? M_ENABLE : M_DISABLE)); // Check if control worked correctly before considering it successful [CALL TO MIL] if(MdispInquire(m_MilDisplay, M_ASYNC_UPDATE, M_NULL) == (Enabled ? M_ENABLE : M_DISABLE)) { m_isInAsynchronousMode = Enabled; } } } } void MdispGtkView::ChangeQFactor(MIL_INT QFactor) { if(m_MilDisplay) { // Apply Q factor to display [CALL TO MIL] MdispControl(m_MilDisplay, M_Q_FACTOR, QFactor); // Check if control worked correctly before considering it successful [CALL TO MIL] if(MdispInquire(m_MilDisplay, M_Q_FACTOR, M_NULL) == QFactor) { m_currentQFactor = QFactor; } } } bool MdispGtkView::IsNetworkedSystem() { bool NetworkedSystem = false; MIL_ID SystemId = ((MdispGtkApp*)dispGtkApp())-&gt;m_MilSystem; // Check if system is networked (DistributedMIL) [CALL TO MIL] if(SystemId) NetworkedSystem = (MsysInquire(SystemId, M_LOCATION, M_NULL) == M_REMOTE); return NetworkedSystem; } void MdispGtkView::ZoomIn() { ///////////////////////////////////////////////////////////////////////// // MIL: Write code that will be executed when 'Zoom In' button or menu is clicked ///////////////////////////////////////////////////////////////////////// if(m_MilDisplay) { //Calculate new zoom factors MIL_DOUBLE ZoomX = 1.0, ZoomY = 1.0; MdispInquire(m_MilDisplay, M_ZOOM_FACTOR_X, &amp;ZoomX); MdispInquire(m_MilDisplay, M_ZOOM_FACTOR_Y, &amp;ZoomY); if((ZoomX &lt;= 8.0) &amp;&amp; (ZoomY&lt;=8.0)) { ZoomX*=2.0; ZoomY*=2.0; } //Perform zooming with MIL (using MdispZoom) Zoom(ZoomX, ZoomY); } } void MdispGtkView::ZoomOut() { ///////////////////////////////////////////////////////////////////////// // MIL: Write code that will be executed when 'Zoom Out' button or menu is clicked ///////////////////////////////////////////////////////////////////////// if(m_MilDisplay) { //Calculate new zoom factors MIL_DOUBLE ZoomX = 1.0, ZoomY = 1.0; MdispInquire(m_MilDisplay, M_ZOOM_FACTOR_X, &amp;ZoomX); MdispInquire(m_MilDisplay, M_ZOOM_FACTOR_Y, &amp;ZoomY); if((ZoomX &gt;= 0.125) &amp;&amp; (ZoomY&gt;=0.125)) { ZoomX/=2.0; ZoomY/=2.0; } //Perform zooming with MIL (using MdispZoom) Zoom(ZoomX, ZoomY); } } void MdispGtkView::NoZoom() { ///////////////////////////////////////////////////////////////////////// // MIL: Write code that will be executed when 'No Zoom' button or menu is clicked ///////////////////////////////////////////////////////////////////////// if(m_MilDisplay) { //Perform zooming with MIL Zoom(1.0, 1.0); MdispPan(m_MilDisplay, M_NULL, M_NULL); } } void MdispGtkView::Zoom( MIL_DOUBLE ZoomFactorToApplyX, MIL_DOUBLE ZoomFactorToApplyY) { ///////////////////////////////////////////////////////////////////////// // MIL: Apply current zoom factor on display ///////////////////////////////////////////////////////////////////////// //Apply zoom [CALL TO MIL] MdispZoom(m_MilDisplay, ZoomFactorToApplyX, ZoomFactorToApplyY); m_currentZoomFactorX = ZoomFactorToApplyX; m_currentZoomFactorY = ZoomFactorToApplyY; } void MdispGtkView::ScaleDisplay( bool on ) { if(m_MilDisplay) { if(!on) { if(gtk_widget_get_window(m_window)) { if(gtk_widget_get_window(m_window)) gdk_window_invalidate_rect(gtk_widget_get_window(m_window), NULL, false); } } //Using MIL, enable/disable Scale Display Mode [CALL TO MIL] MdispControl(m_MilDisplay, M_SCALE_DISPLAY, on ? M_ENABLE : M_DISABLE); m_isScaleDisplayEnabled = on; } } void MdispGtkView::ChangeGraphicListOpacity(MIL_INT Opacity) { if(m_MilDisplay &amp;&amp; m_MilGraphList) { // Apply Graphic List Opacity to display [CALL TO MIL] MdispControl(m_MilDisplay, M_GRAPHIC_LIST_OPACITY, Opacity); // Check if control worked correctly before considering it successful [CALL TO MIL] if((Opacity == M_DEFAULT) || (MdispInquire(m_MilDisplay, M_GRAPHIC_LIST_OPACITY, M_NULL) == Opacity)) { m_currentGraphicListOpacity = Opacity; } } } void MdispGtkView::OnGraRectangle() { if(m_MilDisplay) { if(m_isGraphicsAnnotationsEnabled) { MgraControl(m_MilGraphContext, M_COLOR, M_COLOR_WHITE); MgraInteractive(m_MilGraphContext, m_MilGraphList, M_GRAPHIC_TYPE_RECT, M_DEFAULT, M_AXIS_ALIGNED_RECT); m_PrimitiveInCreation = M_AXIS_ALIGNED_RECT; } } } void MdispGtkView::OnGraCircle() { if(m_MilDisplay) { if(m_isGraphicsAnnotationsEnabled) { MgraControl(m_MilGraphContext, M_COLOR, M_COLOR_YELLOW); MgraInteractive(m_MilGraphContext, m_MilGraphList, M_GRAPHIC_TYPE_ARC, M_DEFAULT, M_CIRCLE); m_PrimitiveInCreation = M_CIRCLE; } } } void MdispGtkView::OnGraPolygon() { if(m_MilDisplay) { if(m_isGraphicsAnnotationsEnabled) { MgraControl(m_MilGraphContext, M_COLOR, M_COLOR_MAGENTA); MgraInteractive(m_MilGraphContext, m_MilGraphList, M_GRAPHIC_TYPE_POLYGON, M_DEFAULT, M_DEFAULT); m_PrimitiveInCreation = M_GRAPHIC_TYPE_POLYGON; } } } void MdispGtkView::OnGraOrientedRect() { if(m_MilDisplay) { if(m_isGraphicsAnnotationsEnabled) { MgraControl(m_MilGraphContext, M_COLOR, M_COLOR_BLUE); MgraInteractive(m_MilGraphContext, m_MilGraphList, M_GRAPHIC_TYPE_RECT, M_DEFAULT, M_ORIENTED_RECT); m_PrimitiveInCreation = M_ORIENTED_RECT; } } } void MdispGtkView::OnGraArcThreePoints() { if(m_MilDisplay) { if(m_isGraphicsAnnotationsEnabled) { MgraControl(m_MilGraphContext, M_COLOR, M_COLOR_GREEN); MgraInteractive(m_MilGraphContext, m_MilGraphList, M_GRAPHIC_TYPE_ARC, M_DEFAULT, M_ARC_THREE_POINTS); m_PrimitiveInCreation = M_ARC_THREE_POINTS; } } } void MdispGtkView::OnGraChooseColor() { if(m_MilDisplay &amp;&amp; m_MilGraphList) { GdkRGBA gColor; GtkWidget *dialog = gtk_color_chooser_dialog_new (\"Changing color\", GTK_WINDOW(m_cf-&gt;ParentWindow())); gtk_window_set_modal (GTK_WINDOW (dialog), TRUE); gtk_color_chooser_set_rgba (GTK_COLOR_CHOOSER (dialog), &amp;gColor); gint result = gtk_dialog_run (GTK_DIALOG (dialog)); if(result == GTK_RESPONSE_OK) { gtk_color_chooser_get_rgba (GTK_COLOR_CHOOSER (dialog), &amp;gColor); MIL_INT R = (MIL_INT) (gColor.red * 255.0); MIL_INT G = (MIL_INT) (gColor.green * 255.0); MIL_INT B = (MIL_INT) (gColor.blue * 255.0); MIL_INT NewColor = M_RGB888(R, G, B); MgraControlList(m_MilGraphList, M_ALL_SELECTED, M_DEFAULT, M_COLOR, (MIL_INT)NewColor); MgraControlList(m_MilGraphList, M_ALL, M_DEFAULT, M_GRAPHIC_SELECTED, M_FALSE); } gtk_widget_destroy (dialog); } } void MdispGtkView::OnDrawDir() { if(m_MilDisplay &amp;&amp; m_MilGraphList) { const MIL_INT NbValues = 4; MIL_INT DrawDirValues[NbValues] = { M_NONE, M_PRIMARY_DIRECTION, M_SECONDARY_DIRECTION, M_PRIMARY_DIRECTION + M_SECONDARY_DIRECTION }; MIL_INT NbGrph = 0; MgraInquireList(m_MilGraphList, M_LIST, M_DEFAULT, M_NUMBER_OF_GRAPHICS, &amp;NbGrph); MIL_INT DrawDirCurValueIdx = 0; MIL_INT NbSelectedGrph = 0; for(MIL_INT g = 0; g &lt; NbGrph; g++) // Finds the highest draw direction among selected graphics { if(MgraInquireList(m_MilGraphList, M_GRAPHIC_INDEX(g), M_DEFAULT, M_GRAPHIC_SELECTED, M_NULL) == M_TRUE) { MIL_INT GrphDrawDir = MgraInquireList(m_MilGraphList, M_GRAPHIC_INDEX(g), M_DEFAULT, M_DRAW_DIRECTION, M_NULL); if(GrphDrawDir == M_DEFAULT) { GrphDrawDir = M_NONE; } MIL_INT FoundIdx = std::find(&amp;DrawDirValues[0], &amp;DrawDirValues[NbValues], GrphDrawDir) - &amp;DrawDirValues[0]; if(FoundIdx &lt; NbValues) { DrawDirCurValueIdx = std::max(DrawDirCurValueIdx, FoundIdx); } ++NbSelectedGrph; } } if(NbSelectedGrph &gt; 0) { // toggle current value DrawDirCurValueIdx = (DrawDirCurValueIdx + 1) % NbValues; MgraControlList(m_MilGraphList, M_ALL_SELECTED, M_DEFAULT, M_DRAW_DIRECTION, DrawDirValues[DrawDirCurValueIdx]); } } } void MdispGtkView::OnGraFill() { if(m_MilDisplay &amp;&amp; m_MilGraphList) { MgraControlList(m_MilGraphList, M_ALL_SELECTED, M_DEFAULT, M_FILLED, M_TRUE); MgraControlList(m_MilGraphList, M_ALL, M_DEFAULT, M_GRAPHIC_SELECTED, M_FALSE); } } void MdispGtkView::GraphicsAnnotations( bool on ) { if(m_MilDisplay) { m_isGraphicsAnnotationsEnabled = on; if(m_isGraphicsAnnotationsEnabled) { if(!m_MilGraphContext &amp;&amp; !m_MilGraphList) { MIL_INT BufSizeX = 0, BufSizeY = 0; MIL_INT Offset = 15; MgraAlloc(((MdispGtkApp*)dispGtkApp())-&gt;m_MilSystem, &amp;m_MilGraphContext); MgraAllocList(((MdispGtkApp*)dispGtkApp())-&gt;m_MilSystem, M_DEFAULT, &amp;m_MilGraphList); MdispControl(m_MilDisplay, M_ASSOCIATED_GRAPHIC_LIST_ID, m_MilGraphList); MdispControl(m_MilDisplay, M_UPDATE_GRAPHIC_LIST, M_DISABLE); MbufInquire(m_MilImage, M_SIZE_X, &amp;BufSizeX); MbufInquire(m_MilImage, M_SIZE_Y, &amp;BufSizeY); MgraClear(m_MilGraphContext, m_MilGraphList); MgraControl(m_MilGraphContext, M_COLOR, M_COLOR_LIGHT_BLUE); MgraRect(m_MilGraphContext, m_MilGraphList, Offset, Offset, BufSizeX - Offset, BufSizeY - Offset); MgraControl(m_MilGraphContext, M_COLOR, M_COLOR_GREEN); MgraControl(m_MilGraphContext, M_BACKGROUND_MODE, M_TRANSPARENT); MgraControl(m_MilGraphContext, M_TEXT_ALIGN_HORIZONTAL, M_CENTER); MgraControl(m_MilGraphContext, M_TEXT_ALIGN_VERTICAL, M_CENTER); MgraControl(m_MilGraphContext, M_FONT_SIZE, 24); MgraFont(m_MilGraphContext, M_FONT_DEFAULT_TTF); MgraText(m_MilGraphContext, m_MilGraphList, BufSizeX/2, Offset, MIL_TEXT(\"Interactive Graphic Annotations\")); //Initialize graphic list MdispControl(m_MilDisplay, M_UPDATE_GRAPHIC_LIST, M_ENABLE); MdispControl(m_MilDisplay, M_GRAPHIC_LIST_INTERACTIVE, M_ENABLE); MgraHookFunction(m_MilGraphList, M_INTERACTIVE_GRAPHIC_STATE_MODIFIED, GraphicListModifiedHookFct, (void*)this); } } else { MgraHookFunction(m_MilGraphList, M_INTERACTIVE_GRAPHIC_STATE_MODIFIED+M_UNHOOK, GraphicListModifiedHookFct, (void*)this); MdispControl(m_MilDisplay, M_ASSOCIATED_GRAPHIC_LIST_ID, M_NULL); if(m_MilGraphList) { MgraFree(m_MilGraphList); m_MilGraphList = M_NULL; } if(m_MilGraphContext) { MgraFree(m_MilGraphContext); m_MilGraphContext = M_NULL; } } } } void MdispGtkView::InitializeOverlay() { MIL_TEXT_CHAR chText[80]; // Initialize overlay if not already done if ((!m_isOverlayInitialized) &amp;&amp; (m_MilDisplay)) { //Only do it on a valid windowed display [CALL TO MIL] if (m_MilImage &amp;&amp; m_MilDisplay ) { // Prepare overlay buffer // //////////////////////////// // Enable display overlay annotations. MdispControl(m_MilDisplay, M_OVERLAY, M_ENABLE); // Inquire the Overlay buffer associated with the displayed buffer [CALL TO MIL] MdispInquire(m_MilDisplay, M_OVERLAY_ID, &amp;m_MilOverlayImage); // Clear the overlay to transparent. MdispControl(m_MilDisplay, M_OVERLAY_CLEAR, M_DEFAULT); // Disable the overlay display update to accelerate annotations. MdispControl(m_MilDisplay, M_OVERLAY_SHOW, M_DISABLE); // Draw MIL monochrome overlay annotation * //***************************************** // Inquire MilOverlayImage size x and y [CALL TO MIL] long imageWidth = MbufInquire(m_MilOverlayImage,M_SIZE_X,M_NULL); long imageHeight = MbufInquire(m_MilOverlayImage,M_SIZE_Y,M_NULL); // Set graphic text to transparent background. [CALL TO MIL] MgraControl(M_DEFAULT, M_BACKGROUND_MODE, M_TRANSPARENT); // Set drawing color to white. [CALL TO MIL] MgraControl(M_DEFAULT, M_COLOR, M_COLOR_WHITE); // Print a string in the overlay image buffer. [CALL TO MIL] MgraText(M_DEFAULT, m_MilOverlayImage, imageWidth/9, imageHeight/5, \" -------------------- \"); MgraText(M_DEFAULT, m_MilOverlayImage, imageWidth/9, imageHeight/5+25, \" - MIL Overlay Text - \"); MgraText(M_DEFAULT, m_MilOverlayImage, imageWidth/9, imageHeight/5+50, \" -------------------- \"); // Print a green string in the green component overlay image buffer. [CALL TO MIL] MgraControl(M_DEFAULT, M_COLOR, M_COLOR_GREEN); MgraText(M_DEFAULT, m_MilOverlayImage, imageWidth*11/18, imageHeight/5, \" -------------------- \"); MgraText(M_DEFAULT, m_MilOverlayImage, imageWidth*11/18, imageHeight/5+25, \" - MIL Overlay Text - \"); MgraText(M_DEFAULT, m_MilOverlayImage, imageWidth*11/18, imageHeight/5+50, \" -------------------- \"); // Draw GDI color overlay annotation * //************************************ // Disable hook to MIL error because control might not be supported MappControl(M_DEFAULT, M_ERROR_HOOKS, M_DISABLE); // Create a device context to draw in the overlay buffer with Cairo. [CALL TO MIL] MbufControl(m_MilOverlayImage, M_SURFACE_ALLOC, M_COMPENSATION_ENABLE); // Reenable hook to MIL error MappControl(M_DEFAULT, M_ERROR_HOOKS, M_ENABLE); // Retrieve the cairo surface of the overlay [CALL TO MIL] gdk_x11_display_error_trap_push(gdk_display_get_default()); cairo_surface_t *surface = (cairo_surface_t *)MbufInquire(m_MilOverlayImage, M_SURFACE_HANDLE, M_NULL); if (surface) { cairo_t *cr; cr = cairo_create (surface); cairo_set_source_rgb (cr, 0, 0, 1); // Draw a blue cross in the overlay buffer. cairo_move_to (cr, 0, imageHeight/2); cairo_line_to (cr, imageWidth, imageHeight/2); cairo_stroke (cr); cairo_move_to (cr, imageWidth/2, 0); cairo_line_to (cr, imageWidth/2, imageHeight); cairo_stroke (cr); // Write Red text in the overlay buffer. MosStrcpy(chText, 80, \"X Overlay Text \"); cairo_set_source_rgb (cr, 1, 0, 0); cairo_set_font_size(cr, 13); cairo_move_to(cr, imageWidth*3/18, imageHeight*4/6); cairo_show_text(cr, chText); // Write Yellow text in the overlay buffer. cairo_set_source_rgb (cr, 1, 1, 0); cairo_set_font_size(cr, 13); cairo_move_to(cr, imageWidth*12/18,imageHeight*4/6); cairo_show_text(cr, chText); cairo_surface_flush(surface); // /* flush */ gdk_display_flush(gdk_display_get_default()); // Delete created the Surface. [CALL TO MIL] MbufControl(m_MilOverlayImage, M_SURFACE_FREE, M_DEFAULT); // Signal MIL that the overlay buffer was modified. [CALL TO MIL] MbufControl(m_MilOverlayImage, M_MODIFIED, M_DEFAULT); // Now that overlay buffer is correctly prepared, we can show it [CALL TO MIL] MdispControl(m_MilDisplay, M_OVERLAY_SHOW, M_ENABLE); // Overlay is now initialized m_isOverlayInitialized = true; cairo_destroy(cr); gdk_x11_display_error_trap_pop_ignored (gdk_display_get_default()); } } } } gboolean MdispGtkView::timerEvent(gpointer user_data) { MdispGtkView* pCurrentView = (MdispGtkView *) user_data; if(pCurrentView &amp;&amp; pCurrentView-&gt;m_MilDisplay) { MIL_DOUBLE CurrentFrameRate = M_NULL; MdispInquire(pCurrentView-&gt;m_MilDisplay, M_UPDATE_RATE, &amp;CurrentFrameRate); g_signal_emit(G_OBJECT(pCurrentView-&gt;m_cf-&gt;Window()), pCurrentView-&gt;m_cf-&gt;frameRateChangedSignal(), 0, CurrentFrameRate); MIL_DOUBLE ZoomX =1.0, ZoomY = 1.0; MdispInquire(pCurrentView-&gt;m_MilDisplay, M_ZOOM_FACTOR_X, &amp;ZoomX); MdispInquire(pCurrentView-&gt;m_MilDisplay, M_ZOOM_FACTOR_Y, &amp;ZoomY); g_signal_emit(G_OBJECT(pCurrentView-&gt;m_cf-&gt;Window()), pCurrentView-&gt;m_cf-&gt;zoomFactorChangedSignal(), 0, ZoomX, ZoomY); g_signal_emit(G_OBJECT(pCurrentView-&gt;m_cf-&gt;Window()), pCurrentView-&gt;m_cf-&gt;mousePositionChangedSignal(), 0, pCurrentView-&gt;m_LastMousePosition.m_DisplayPositionX, pCurrentView-&gt;m_LastMousePosition.m_DisplayPositionY, pCurrentView-&gt;m_LastMousePosition.m_BufferPositionX, pCurrentView-&gt;m_LastMousePosition.m_BufferPositionY); // Reset mouse position //m_LastMousePosition.Set(M_INVALID, M_INVALID, M_INVALID, M_INVALID); } return true; } void MdispGtkView::RestrictCursor(bool on) { ///////////////////////////////////////////////////////////////////////// // MIL: Write code that will be executed when 'Restrict Cursor' menu item is clicked ///////////////////////////////////////////////////////////////////////// if(m_MilDisplay) { MdispControl(m_MilDisplay, M_RESTRICT_CURSOR,on?M_ENABLE:M_DISABLE); // Check if control worked correctly before considering it successful [CALL TO MIL] MdispInquire(m_MilDisplay, M_RESTRICT_CURSOR, &amp;m_currentRestrictCursor); } } void MdispGtkView::UpdateContentSize() { int sizeX, sizeY; if(m_MilDisplay) { MdispInquire(m_MilDisplay, M_ZOOM_FACTOR_X, &amp;m_currentZoomFactorX); MdispInquire(m_MilDisplay, M_ZOOM_FACTOR_Y, &amp;m_currentZoomFactorY); } sizeX = int( m_imageSizeX * m_currentZoomFactorX ); sizeY = int( m_imageSizeY * m_currentZoomFactorY ); // tell this child frame to update the window if(m_cf) m_cf-&gt;UpdateContentSize(sizeX, sizeY); } void MdispGtkView::UpdateStatusBarWithMousePosition() { } void MdispGtkView::Paint(cairo_t *cr) { GtkAllocation allocation; cairo_text_extents_t extents; if(!m_MilDisplay) { cairo_select_font_face (cr, \"serif\", CAIRO_FONT_SLANT_NORMAL, CAIRO_FONT_WEIGHT_NORMAL); cairo_set_font_size (cr, 12.0); cairo_set_source_rgb (cr, 1.0, 0.0, 0.0); cairo_text_extents(cr, \"Display Allocation failed\", &amp;extents); cairo_move_to (cr, (m_imageSizeX/2 - extents.width/2), 20.0); cairo_show_text (cr, \"Display Allocation failed\"); } else if(!m_isWindowed) { cairo_select_font_face (cr, \"serif\", CAIRO_FONT_SLANT_NORMAL, CAIRO_FONT_WEIGHT_NORMAL); cairo_set_font_size (cr, 12.0); cairo_set_source_rgb (cr, 0.0, 0.0, 0.0); cairo_text_extents(cr, \"Image displayed on external screen\", &amp;extents); cairo_move_to (cr, (m_imageSizeX/2 - extents.width/2), 20.0); cairo_show_text (cr, \"Image displayed on external screen\"); } } ",
      "wordCount": 2849
    }
  ]
}]
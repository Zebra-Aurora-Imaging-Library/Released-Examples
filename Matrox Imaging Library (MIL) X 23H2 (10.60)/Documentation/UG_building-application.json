[{
  "id": "UG_building-application",
  "version": "2024020714",
  "title": "Building an application",
  "subTitles": null,
  "location": "MIL UG P02: MIL in a nutshell",
  "pageURL": "content\\UserGuide\\building-application\\ChapterInformation.htm",
  "text": " Chapter 2: Building an application This chapter shows you the basics in building an application. Organization of the MIL modules Similar MIL functions in different modules Processing and analysis modules Interactive functionality Mandatory allocations: allocating an application context and its systems MIL application context MIL system Categories of MIL systems Multiple systems Remote systems Allocating, displaying, and annotating an image buffer Allocating an image buffer Displaying an image buffer Annotating an image on display Grabbing images Continuous grabbing and adjusting your camera Sequential grabbing An example Pixel and real-world units Pixel units and the pixel coordinate system World units and world coordinate systems Camera calibration Child buffers, regions of interest, and fixturing Child buffers Regions of interest Fixturing an object with the relative coordinate system Dealing with color Grabbing Mapping grabbed data through a LUT Displaying Managing color images Color processing and analysis Converting color images to grayscale Creating a child buffer from one of the three color bands Copying one of the three color bands to a 1-band buffer Color space conversion Working with 3D 3D data containers and grabbing Converting 3D data for processing and 3D display Displaying 3D data Processing 3D data Calibration Storing the output of 3D functions Regions of interest Fixturing Using the defaults Using the MILConfig utility to change your default settings Using your defaults Error reporting Multiple systems MIL custom data types, void pointers, extensions, and portability functions MIL custom data types Void pointers MIL smart identifiers Strings and arrays MIL directory constants M_MIL_USE_SAFE_TYPE extension Portability functions Combination values and macros Combination values Function-like macros Event handling in MIL with hook-handler functions MIL hook-type functions Events and user data Unhooking hook-handler functions MIL hook information functions Porting a 32-bit MIL application to MIL 64-bit Modified functions Retrieving a pointer to a modified function Void pointers M_MIL_USE_SAFE_TYPE extension Project processor definitions Working with files Moving, sharing, and searching for files Additional functionality for DMIL Importing and exporting data MIL file extension list MIL under Linux How to create a portable application MIL with .NET and Python MIL with .NET MIL with Python Using MIL add-on to Visual Studio MIL menu and toolbar F1 contextual help Statement completion ",
  "wordCount": 365,
  "subEntries": [
    {
      "id": "UG_building-application_Organization_of_the_MIL_modules",
      "version": null,
      "title": "Organization of the MIL modules",
      "subTitles": [
        "Similar MIL functions in different modules",
        "Processing and analysis modules",
        "Interactive functionality"
      ],
      "location": "MIL UG P02: MIL in a nutshell",
      "pageURL": "content\\UserGuide\\building-application\\Organization_of_the_MIL_modules.htm",
      "text": " Organization of the MIL modules All functions in MIL are grouped into modules. Functions are named based on their module and functionality. Each function name is prefixed with the letter M for Matrox, followed by a few letters representing the function's module name, and ends with a word that describes the function's purpose. For example, MbufSave() saves a data buffer in a file. Similar MIL functions in different modules Functions are grouped into modules according to their main functionality. For example, the Buffer module contains all the functions in MIL that are specific to allocating, controlling, inquiring about, importing, and saving buffers. All MIL modules are based on the same structure and you can find similar functions in different modules. These functions differ depending on the specifications of the module, but they all perform the same basic task. The following specifies MIL functions that are available in most MIL modules. For more information on a specific function, see the MIL Reference. M...Alloc(). Allocates the specified MIL object (a data structure with a MIL ID) and its required resources. Examples of MIL objects include MIL buffers, displays, and contexts. You must allocate these before you use them. Once you are finished using them, you should release them using M...Free(). M...Free(). Frees an allocated MIL object and its resources. M...Control(). Sets the controls for the specified MIL object (for example, buffer, context, or element(s) that exist in the context). An M...Control() function allows you to customize how the operations of that specific module are performed. Note that most control types have a default setting. M...Inquire(). Inquires about a specified setting. Most settings that can be set using M...Control() can be inquired using the corresponding M...Inquire() function. M...Save(). Saves the specified MIL object (for example, the specified context or buffer) to a specified file. M...Restore() / M...Load(). Restores the specified MIL object (for example, the specified context or buffer) from a specified file. M...HookFunction(). Allows you to attach or detach a user-defined function to a specified event. Once an event-handler function is defined and hooked to an event, it is automatically called when the event occurs. The event-handler function is also referred to as a hook-handler function. M...GetHookInfo(). Retrieves information about the event that caused the hook-handler function to be called. This function should only be called within the scope of a hook-handler function call. Processing and analysis modules The following specifies MIL functions that are common in most MIL processing and analysis modules. For more information on a specific function, see the MIL Reference. M...AllocResult(). Allocates the specified result buffer. Result buffers store results obtained from the module's M...Calculate(), M...Read(), or M...Find() operations. When the result buffer is no longer required, release its memory, using M...Free(). M...Calculate() / M...Read() / M...Find(). Perform the operation(s) specific to the module, respecting the controls specified using M...Control(). The results of the operations are stored in the specified result buffer. M...GetResult(). Retrieves the results of the specified type from the specified result buffer. M...Copy/CopyResult(). Copies settings or results from the specified MIL object (for example, context) to another specified MIL object. Some functions also support moving results. M...Draw(). Draws specific source information or results destructively into the specified destination image buffer, or stores them as vector graphics in a specialized MIL object called a 2D graphics list. The latter can be used for several purposes, including 2D display. M...Draw3d(). Stores specific source information or results as 3D vector graphics in a specialized MIL object called a 3D graphics list. The latter can be used for 3D display. M...Stream(). Loads, restores, or saves the specified MIL object (for example, context) from/to a file or memory stream. Similar functions exist for the 3D modules. These functions are prefixed with M3D. Interactive functionality Under Microsoft Windows, some MIL functions can launch dialog boxes that allow you to specify certain information at runtime. The most common functions that support dialog boxes are listed below: M...Save() with M_INTERACTIVE. Opens the File Save As dialog box from which you can interactively specify the drive, directory, and name of the file. M...Restore() with M_INTERACTIVE. Opens the File Open dialog box from which you can interactively specify the drive, directory, and name of the file. M...Stream() with M_INTERACTIVE. Opens a dialog box from which you can interactively specify the drive, directory, and name of the file, when the StreamType parameter is set to M_FILE. For a full list of all the functions that support dialog boxes, type INTERACTIVE into the edit field of the Search tab, in the left pane of this Help file, and enable the \"Match similar words\" option. You can also interactively add, move, resize, and rotate graphics in a 2D graphics list, if the 2D graphics list is associated to the 2D display and interactivity is enabled on the 2D display (MdispControl() with M_GRAPHIC_LIST_INTERACTIVE). For more information, see the Creating and modifying graphics interactively section of Chapter 26: Generating graphics. Note that Linux only supports interactive functionality with MbufRestore(), MbufSave(), and the MIL 2D Graphics module. Organization of the MIL modules Similar MIL functions in different modules Processing and analysis modules Interactive functionality ",
      "wordCount": 855,
      "subEntries": []
    },
    {
      "id": "UG_building-application_Mandatory_allocations_allocating_an_application_and_its_systems",
      "version": null,
      "title": "Mandatory allocations: allocating an application context and its systems",
      "subTitles": [
        "MIL application context",
        "MIL system",
        "Categories of MIL systems",
        "Multiple systems",
        "Remote systems"
      ],
      "location": "MIL UG P02: MIL in a nutshell",
      "pageURL": "content\\UserGuide\\building-application\\Mandatory_allocations_allocating_an_application_and_its_systems.htm",
      "text": " Mandatory allocations: allocating an application context and its systems At the beginning of each application, you must: Allocate a MIL application context using MappAlloc(). This initializes MIL. Allocate a MIL system using MsysAlloc(). A MIL system typically represents a group of hardware resources capable of grabbing, storing, processing, and/or displaying images. At the end of each application, free each system using MsysFree(), and then free the application context using MappFree(). MIL application context A MIL application context is a data structure (specifically a MIL object) populated with the information needed to run a MIL application. You must allocate a MIL application context before calling any other MIL function (using MappAlloc() or MappAllocDefault()). Upon allocating a MIL application context, it is initialized with the information required by MIL. This initialization determines the type of CPU and CPU cores available, the licenses available which depend on the version of MIL installed, and the files/functions available based on the licenses. Furthermore, it sets up a MIL identification table that will hold the identifiers of all MIL objects. It initializes how errors are displayed (MappAlloc() with M_QUIET to suppress the display of error messages), and initializes and controls the creation of trace logs (MappAlloc() with M_TRACE_LOG_DISABLE to disable the creation of trace logs). MIL system A MIL system is a MIL object that represents a group of hardware resources that MIL can access and use. You must allocate at least one MIL system, using MsysAlloc() or MappAllocDefault(). Upon allocating a MIL system, MIL gathers information about the specified hardware and opens communication between your MIL application and the appropriate hardware drivers. Once communication has been established, you can allocate and then use the system's hardware resources. Hardware resources might include memory (MbufAlloc...()), display (MdispAlloc()), and digitizers (MdigAlloc()). See the MsysAlloc() function reference and the MIL Hardware-specific Notes for the list of supported MIL systems and the hardware resources that they require. Categories of MIL systems MIL systems can be divided into three general categories with different capabilities: the Host system (which does not require specific hardware), acquisition-type systems (which provide access to image grabbing hardware), and non-acquisition-type systems (which provide access to Matrox hardware that only has non-image-grabbing functionality, such as I/O signaling). The following table summarizes which MIL systems fall into each category, what capabilities they have, and what specific hardware they require. MIL systems that support processing usually use the Host CPU and memory. Category of MIL Systems Processing/display Grabbing Specific hardware requirements Host system Yes Simulated using images from files No Acquisition-type system Yes Yes Yes Matrox frame grabber-specifc system (for example, MIL Rapixo CXP system) Specific Matrox frame grabber (for example, Matrox Rapixo CXP) MIL GigE Vision system Gigabit Ethernet port (or faster) MIL USB3 Vision system USB 3.0 port MIL GenTL Consumer system Depends on GenTL Producer Device that is a GenTL Producer Non-acquisition-type system No No Yes MIL Indio system Matrox Indio MIL Concord PoE system Matrox Concord PoE Typically, a single system represents a single board in your computer (and some Host hardware resources). However, a few types of MIL systems represent all boards (hardware components) of that specific type in a computer. For example, a single MIL GigE Vision system represents all GigE Vision adapters in your computer. This means that once you allocate a MIL GigE Vision system, you can allocate and grab from any connected GigE Vision camera (or other device). Additionally, different functionality on one board might require the allocation of multiple different types of MIL systems. For example, to use the functionality of a Matrox Indio board, you allocate a MIL GigE Vision system to access and grab images from a GigE Vision camera (or other device), and you allocate a MIL Indio system to use all other functionality on the board (for example, the auxiliary I/O signals). For information, refer to the MIL Hardware-specific Notes for your particular hardware. Multiple systems You can allocate more than one system per application context and then use their identifiers to access their hardware resources. All currently supported MIL systems also support multi-processing. This means that the same board can be allocated by more than one process simultaneously; CPU and memory resources will be split between each process as needed. However, many resources (such as individual digitizers on some boards) cannot be allocated by more than one process simultaneously. Refer to the MIL Hardware-specific Notes for your particular hardware to determine which resources cannot be allocated by more than one process simultaneously. Processing can be done using the resources of the different systems within a single process. Any operation involving more than one system will be performed by the most appropriate one. By default, if none of these systems is more appropriate than the Host, the Host is used to perform the operation. Remote systems During MIL system allocation, you can specify that the hardware resources are on a remote computer. This allocates a remote MIL system, which makes the resources of the specified computer available: its specified Matrox imaging board (or third-party hardware), its CPU, and its memory. Both the local and remote computers must have MIL/MIL-Lite installed with the Distributed MIL option. A MIL application that uses remote MIL systems is called a Distributed MIL controlling application, and the remote MIL systems are called DMIL remote systems. In a Distributed MIL controlling application, multiple DMIL remote systems can collaborate with each other and with local MIL systems across a network (for example, a local area network, or a wide area network such as the internet) controlled by a single MIL application. A group of computers interacting using Distributed MIL is called a cluster. When developing a Distributed MIL controlling application that uses functionality only available in the full version of MIL, the local computer requires a MIL development license; the remote computer(s) only require appropriate runtime licenses for Distributed MIL and the MIL modules that they actually use. When only running such an application, all computers in the cluster require appropriate runtime licenses for Distributed MIL and the MIL modules that they actually use; sending a command to another computer is not using a module so no specific license is needed in this case. When developing or running a Distributed MIL application that uses only MIL-Lite functionality, the local and remote computers require a Distributed MIL supplemental license. For more information on Distributed MIL, see Chapter 62: Distributed MIL. Mandatory allocations: allocating an application context and its systems MIL application context MIL system Categories of MIL systems Multiple systems Remote systems ",
      "wordCount": 1090,
      "subEntries": []
    },
    {
      "id": "UG_building-application_Allocating_displaying_and_annotating_an_image_buffer",
      "version": null,
      "title": "Allocating, displaying, and annotating an image buffer",
      "subTitles": [
        "Allocating an image buffer",
        "Displaying an image buffer",
        "Annotating an image on display"
      ],
      "location": "MIL UG P02: MIL in a nutshell",
      "pageURL": "content\\UserGuide\\building-application\\Allocating_displaying_and_annotating_an_image_buffer.htm",
      "text": " Allocating, displaying, and annotating an image buffer After you have allocated an application along with any required system(s), you are ready to grab and display an image. This section covers how to allocate and display an image buffer. For the basics required to start grabbing, see the Grabbing images section later in this chapter. Allocating an image buffer Image buffers are storage areas that can hold image data so that it can be displayed, manipulated, grabbed, and/or analyzed. To store color image data, MIL uses the concept of bands; your buffer needs one band per color component of your image. For example, an RGB image needs a buffer with three bands. You can allocate a monochrome image buffer using MbufAlloc2d(). This function requires that you specify the following image buffer attributes: The system on which to allocate the buffer. The image buffer's size in X and Y. The depth of the buffer: 1-, 8-, 16-, or 32-bit. The image buffer's data type. Signed, unsigned, and floating-point buffers are all supported by MIL. The image buffer's intended use (for example, processing or display). You can allocate a color image buffer using MbufAllocColor(). This function requires that you specify the number of color bands in addition to the attributes listed above. To operate on a specific band or region of an image buffer, you can use MbufChild...(). For more information on how to deal with color using MIL, see the Dealing with color section later in this chapter. When you allocate an image buffer, you need to specify its intended uses so that it will be appropriately allocated in memory. If you intend to use the buffer to store grabbed data, the buffer must be allocated with an M_GRAB attribute. If you intend to display the buffer, you must allocate it with an M_DISP attribute. If you intend to use the buffer as the source or destination buffer of a processing or analysis operation, you must allocate the buffer with an M_PROC attribute. Note that you can combine these attribute so that the buffer can be allocated for multiple uses. For more information on buffers and other buffer attributes, see Chapter 23: Data buffers. Displaying an image buffer Especially during application development, it is useful to display the image buffer that you are manipulating. You must first allocate a MIL 2D display on the target system, using MdispAlloc(). If you have allocated a displayable image buffer (M_DISP), select it to this 2D display, using MdispSelect(); you can use the same function to stop displaying it. Note that the image buffer and the 2D display should be allocated on the same system. Annotating an image on display You can also annotate an image on display. This can be done either destructively, which alters the original image, or non-destructively, which maintains the original image but displays annotations placed on top of it. To draw directly in an image, which replaces the image's original pixel values with the newly drawn values, you can use the MIL 2D graphics functions. For non-destructive image annotation, MIL offers two main options: using a 2D graphics list and using the overlay mechanism. To draw directly in an image, you can use the functions in the MIL 2D graphics module, such as MgraArcFill() or MgraText() in the following example. You can specify a default 2D graphics context that uses default settings for background and foreground color and text alignment. Alternatively, you can allocate a new 2D graphics context. For both the default and user-allocated 2D graphics contexts, you can specify the graphics settings and these contexts can be re-used for multiple MIL 2D graphics functions. To annotate an image non-destructively, you can allocate a 2D graphics list, using MgraAllocList(), populate it with graphics created using MIL 2D graphics functions or the draw functions of other MIL modules, and associate the 2D graphics list with the 2D display using MdispControl() with M_ASSOCIATED_GRAPHIC_LIST_ID. Once the 2D graphics list is associated with the 2D display, the graphics are drawn over the image buffer without altering the image buffer itself. When annotating with a 2D graphics list, zooming the 2D display will not affect the size or orientation of the annotations. You can also use the overlay mechanism to annotate an image non-destructively, using MdispControl() with M_OVERLAY set to M_ENABLE. Once you have enabled the overlay mechanism, a temporary overlay buffer is allocated which you can populate with annotations using, for example, the MIL 2D graphics module or Windows GDI annotations. You can directly access this temporary overlay buffer using MdispInquire() with M_OVERLAY_ID. The overlay buffer has a transparency (keying) color that helps determine whether the overlay buffer's pixels or the image buffer's pixels will be displayed. The pixels in the overlay buffer that are set to the transparency color are rendered invisible, displaying the underlying image buffer's pixels. Every pixel in the overlay buffer that has a color other than the transparency color will be displayed. You can determine the transparency color using MdispInquire() with M_TRANSPARENT_COLOR, and you can select another color using MdispControl() with M_TRANSPARENT_COLOR. When annotating with the overlay mechanism, zooming the 2D display will resize the annotations. This can lead to pixelation, the loss of some annotations, or changes in line thickness. The following code snippet shows you how to allocate, display, and annotate an image buffer. Note that the annotations are destructive because there is neither a 2D graphics list specified, nor is the overlay mechanism enabled. /* Allocate a system for a Matrox Morphis board. Use a different */ /* value or \"M_DEFAULT\" for other types of systems. */ MappAlloc (M_DEFAULT, &amp;MilApplication); MsysAlloc (M_DEFAULT, M_SYSTEM_MORPHIS, M_DEFAULT, M_DEFAULT, &amp;MilSystem); MdispAlloc (MilSystem, M_DEFAULT, MIL_TEXT(\"M_DEFAULT\"), M_WINDOWED, &amp;MilDisplay); /* Allocate an image buffer with the default dimensions to do graphics. */ MbufAlloc2d (MilSystem, 512,512, 8+M_UNSIGNED, M_IMAGE+M_DISP+M_GRAB, &amp;MilImage); /* Draw and display a circle */ MbufClear (MilImage, 0L); MgraArcFill (M_DEFAULT, MilImage, 256L, 240L, 100L, 100L, 0.0, 360.0); MgraText (M_DEFAULT, MilImage, 238L, 234L, MIL_TEXT(\" MIL \")); /* Display the image buffer. */ MdispSelect (MilDisplay, MilImage); /* Print a message. */ MosPrintf (MIL_TEXT(\"A circle was drawn in the displayed image buffer.\\n\")); /* Free all allocations */ MbufFree (MilImage); MdispFree (MilDisplay); MsysFree (MilSystem); MappFree (MilApplication); For more information on displaying and annotating an image, see Chapter 25: Displaying an image. To allocate a display on a DMIL remote system, see the Remote displays subsection of the Controlling configuration section of Chapter 62: Distributed MIL. For more information on MIL 2D graphics functions and 2D graphics lists, see Chapter 26: Generating graphics. Allocating, displaying, and annotating an image buffer Allocating an image buffer Displaying an image buffer Annotating an image on display ",
      "wordCount": 1107,
      "subEntries": []
    },
    {
      "id": "UG_building-application_Grabbing_images",
      "version": null,
      "title": "Grabbing images",
      "subTitles": [
        "Continuous grabbing and adjusting your camera",
        "Sequential grabbing",
        "An example"
      ],
      "location": "MIL UG P02: MIL in a nutshell",
      "pageURL": "content\\UserGuide\\building-application\\Grabbing_images.htm",
      "text": " Grabbing images Many applications depend on the ability to grab an image for later analysis or inspection. With MIL, you use an allocated digitizer to grab from a video source (typically a video camera). To allocate a digitizer, use MdigAlloc() and specify a digitizer configuration format (DCF) that is compatible with the output format of your camera. This configures the required acquisition paths (camera interface) on the frame grabber so that they can accept input from the camera. With a call to MdigGrab(), you can then grab into a grab image buffer (an image buffer with an M_GRAB attribute). Allocate the grab image buffer on the same system, and of the same data format, as the digitizer. For color cameras, use color image buffers. By default, when MdigGrab() is issued, it grabs a complete frame of data, as defined by the DCF used to allocate the digitizer and not by the size of the image buffer. For more details on how to grab with the digitizer, see Chapter 27: Grabbing with your digitizer. Continuous grabbing and adjusting your camera When adjusting and focusing your camera, grabbing a single frame at a time can be tedious. MIL features a continuous grab function, MdigGrabContinuous(), that grabs image frames into a specified buffer until you issue MdigHalt(). Since you are grabbing continuously into the same buffer, this function is only really useful if you select the buffer to a display, using MdispSelect(), prior to starting the continuous grab, so that you can view what is being grabbed. If your camera supports remote lens adjustment, you can use MdigFocus() to automatically adjust the lens motor of the camera to achieve optimum focus in your images. For more information, see the Auto-focusing section of Chapter 27: Grabbing with your digitizer. Sequential grabbing Typically, you need to grab and process images continuously. To ensure that no frames are missed, the MdigProcess() function allows you to grab images sequentially, store them into a list of image buffers, and process them as they are being grabbed. MdigProcess() has the same requirements as MdigGrab(), except MdigProcess() accepts an array of grab image buffers and can cause a user-defined function to be called after an image has been grabbed into any of the image buffers. MdigProcess() can round-robin through the buffers; in this case, buffers are filled with the grabbed data typically in the order they are stored in the list, wrapping around to the first buffer in the list once the last buffer in the list is filled. For more information and examples, see the Multiple buffering subsection of the Grabbing and processing section of Chapter 27: Grabbing with your digitizer. An example The following example grabs a single image from the camera. /* Allocate a system for a Matrox Morphis board. Use a different */ /* value or \"M_DEFAULT\" for other types of systems. */ MappAlloc(M_NULL, M_DEFAULT, &amp;MilApplication); MsysAlloc(M_SYSTEM_MORPHIS, M_DEFAULT, M_DEFAULT, &amp;MilSystem); MdispAlloc(MilSystem, M_DEFAULT, MIL_TEXT(\"M_DEFAULT\"), M_WINDOWED, &amp;MilDisplay); /* Allocate a digitizer for RS170 camera. Use a different */ /* value or \"M_DEFAULT\" for other types of cameras. */ MdigAlloc(MilSystem, M_DEV0, MIL_TEXT(\"M_RS170\"), M_DEFAULT, &amp;MilDigitizer); /* Allocate an image buffer with the default dimensions. */ MbufAlloc2d(MilSystem, 512, 512, 8 + M_UNSIGNED, M_IMAGE + M_DISP + M_GRAB, &amp;MilImage); /* Display the image buffer. */ MdispSelect(MilDisplay, MilImage); /*Grab an image into image buffer*/ MdigGrab(MilDigitizer, MilImage); /* Free all allocations */ MbufFree(MilImage); MdigFree(MilDigitizer); MdispFree(MilDisplay); MsysFree(MilSystem); MappFree(MilApplication); Grabbing images Continuous grabbing and adjusting your camera Sequential grabbing An example ",
      "wordCount": 577,
      "subEntries": []
    },
    {
      "id": "UG_building-application_Pixel_and_real_world_units",
      "version": null,
      "title": "Pixel and real-world units",
      "subTitles": [
        "Pixel units and the pixel coordinate system",
        "World units and world coordinate systems",
        "Camera calibration"
      ],
      "location": "MIL UG P02: MIL in a nutshell",
      "pageURL": "content\\UserGuide\\building-application\\Pixel_and_real_world_units.htm",
      "text": " Pixel and real-world units In MIL, there are two types of units that you can use for setting information and retrieving results: pixel units and real-world units (for example, inches or centimeters). Real-world units are called world units for simplicity. Pixel units are directly related to the image and are always available; however, to work in world units, you must perform camera calibration to establish the relationship between the pixel coordinate system and the real world. Note that MIL-Lite does not support world units. Pixel units and the pixel coordinate system When working in pixel units, you are using the pixel coordinate system. The center of the top-left pixel of the image corresponds to the origin (0,0). The X-axis follows the first row of pixels, and the Y-axis follows the first column of pixels. The following image shows the pixel coordinate system; the dots indicate the center of the pixels. For MIL modules that support subpixel accuracy, it is important to keep in mind that since the center of the pixel is used as its reference position, the top-left corner of the first pixel is considered (-0.5, -0.5), and the bottom-right corner of the last pixel is (sizeX - 0.5, sizeY - 0.5). When working in pixel units, angles are interpreted and measured in degrees with respect to the pixel coordinate system; positive angles are always interpreted to be in a counter-clockwise direction from the initial side. Note that since the Y-axis of an image is oriented downwards, the angles in MIL are inverted from mathematical convention. In certain cases, you might want to convert angles from MIL convention to mathematical convention: the negative value of an angle in MIL convention is the true value of the same angle in mathematical convention. For example, 45° in MIL convention is the same as -45° in mathematical convention. For more information on the pixel coordinate system, using subpixel accuracy, and angle conventions in MIL, see the Pixel conventions and subpixel accuracy section of Chapter 23: Data buffers. World units and world coordinate systems In MIL, you can set and retrieve positional information in real-world units (for example, inches or centimeters). To do so, you must specify the relationship between the pixel coordinate system and the real world through camera calibration. This involves choosing a fixed location (that is, a position and orientation) in the real world from which to make this mapping, and the distance that will represent one unit. Together, these define the absolute real-world coordinate system (or for simplicity, the absolute coordinate system). You can then map pixels to the location that they represent in the real world with reference to the absolute coordinate system. After calibrating, you should further specify a reference in the absolute coordinate system, known as the relative coordinate system, from which you want to specify settings and retrieve results. Unlike the absolute coordinate system, which is immoveable, you can move the relative coordinate system to any required location. This allows you to specify settings and retrieve information with respect to any required location. Moving the relative coordinate system can be useful, for example, if an object appears at a number of different positions in your image, and you want to apply the same measurement or inspection process to every instance of the object. You can fix the relative coordinate system with respect to each object in succession, and apply your process to every instance of the object. This process is known as fixturing; for more information, see the Fixturing an object with the relative coordinate system subsection of the Child buffers, regions of interest, and fixturing section later in this chapter. If you then need to transform results with respect to a location in the real world other than the absolute coordinate system (for example, the camera), MIL allows you to define other coordinate systems in the real world and transform locations between them. For more information, see the Coordinate systems section of Chapter 28: Calibrating your camera setup. Most MIL modules support real-world units and can take settings and return results with respect to the relative coordinate system. For a complete list of MIL modules that support this functionality, see the Working with real-world units section of Chapter 28: Calibrating your camera setup. Camera calibration Camera calibration relates pixels to real locations and distances. For example, you can create the following relationship between a pixel and its size and location in the real world. Uniform camera calibration is the simplest technique that you can use to calibrate your camera setup. To use this technique, each pixel in the image should represent the same sized area in the real world, your camera should be placed directly above the subject in the image, and lens distortion should be negligible. To perform a uniform camera calibration, use McalUniform(). This mapping can be any combination of scaling, rotation, and translation. The following illustrations show the position of the pixel and absolute coordinate systems after three example uniform camera calibrations. Note that the pixel coordinate system is defined with respect to the absolute coordinate system (not vice versa) because the absolute coordinate system is fixed in the world. To handle more complex setups and various types of distortion, MIL supports a variety of different camera calibration modes, including 3D-based camera calibration modes. For more information on camera calibration, see the Camera calibration modes section of Chapter 28: Calibrating your camera setup. Pixel and real-world units Pixel units and the pixel coordinate system World units and world coordinate systems Camera calibration ",
      "wordCount": 923,
      "subEntries": []
    },
    {
      "id": "UG_building-application_Child_buffers_regions_of_interest_and_fixturing",
      "version": null,
      "title": "Child buffers, regions of interest, and fixturing ",
      "subTitles": [
        "Child buffers ",
        "Regions of interest ",
        "Fixturing an object with the relative coordinate system"
      ],
      "location": "MIL UG P02: MIL in a nutshell",
      "pageURL": "content\\UserGuide\\building-application\\Child_buffers_regions_of_interest_and_fixturing.htm",
      "text": " Child buffers, regions of interest, and fixturing When working in MIL, you can operate on a specified subset of data of an image buffer. This can be done with child buffers or with regions of interest (ROI). You can also fixture the relative coordinate system of an image to the same point on an object, regardless of the location of the object in the image, so that you can position a region of interest or a module's search region according to an object's found location. This can be used, for example, when automating a series of measurement operations. MIL-Lite does not support fixturing. Child buffers A child buffer is a specified subset of a data buffer (known as the parent buffer), associated with a MIL identifier. Child buffers occupy a specific rectangular area of the parent buffer. Since this area is part of the same physical memory space as the parent buffer, changes made to the data of the child buffer affect the data of the parent buffer and vice versa. Since a child buffer has a MIL identifier, it is considered a data buffer, and it can be used in the same context as its parent buffer; for example, it can be selected to a MIL display and be the only data that is displayed. A child buffer takes on the same attributes and type as its parent buffer. However, any pixel coordinates specified or returned when using a child buffer are relative to the child buffer's top-left corner. Just as its parent buffer, a child buffer must be allocated so that it can be associated with an identifier and recognized as an entity by MIL. You can use one of the MIL functions from the table below to allocate the child buffer. MIL function Monochrome parent buffer. Multi-band parent buffer. MbufChild1d() 1D region of first row of band. 1D region of first row of all bands. MbufChild2d() 2D region of band. 2D region of all bands. MbufChildColor() - Entire area of band chosen. MbufChildColor2d() - 2D region of band chosen or 2D region of all bands. Specify a child buffer's size and offset keeping in mind the parent buffer's dimensions. Note that, as a subset of the parent buffer, a child buffer cannot exceed the bounds of its parent in any dimension. For example, a color child buffer cannot be created from a monochrome parent buffer. Once you have finished using a child buffer, you must free it using MbufFree(), before freeing its parent buffer. For more information, see the Child buffers subsection of the Using child buffers, ROIs, or a copy to manipulate specific data areas section of Chapter 23: Data buffers. Regions of interest A region of interest (ROI) is similar to a child buffer in that it identifies a subset of data in an image buffer. The ROI of an image buffer can be of any shape and can be composed of several non-contiguous areas. When dealing with processing operations that respect the ROI, all pixels outside the ROI are ignored. You can have the ROI move within the image buffer according to the relative coordinate system, if the image is calibrated. Note that, unlike a child buffer, an ROI does not have its own MIL identifier and cannot have results returned with respect to it. Use MbufSetRegion() to create an ROI from an image mask, the graphics in a 2D graphics list, or the valid pixels in a depth map. When defined from an image mask, the region of interest consists of the pixels corresponding to the non-zero pixels in the image mask. When defined from the graphics contained in a 2D graphics list, only areas corresponding to the graphics are processed. If the graphics defining the ROI are not filled, the ROI will consist of only the graphics' outline (MgraControlList() with M_LINE_THICKNESS). However, if the combination constant M_FILL_REGION is specified when calling MbufSetRegion(), the ROI is created such that non-filled graphics are considered filled. This is useful if you want to display the 2D graphics list defining the region of interest, or modify it interactively, without obstructing the target image. You can also specify the combination constant M_USE_LINE_THICKNESS_1 when calling MbufSetRegion() to ignore the M_LINE_THICKNESS setting of the graphics in the 2D graphics list and use the default value of one pixel. This is useful when interactively creating a region of interest from graphics in a 2D graphics list that have line thickness greater than one pixel for visual clarity. You can use MbufControl() with M_REGION_USE to set whether the ROI associated with the image buffer is used with supported image processing operations. It is not possible to set an ROI in an image buffer that has one or more child buffers. However, it is possible to define an ROI directly in a child buffer. The child buffer's ROI is not accessible from the parent buffer. For more information, see the Specifying a region of interest subsection of the Using child buffers, ROIs, or a copy to manipulate specific data areas section of Chapter 23: Data buffers. Fixturing an object with the relative coordinate system A technique known as fixturing is available to place the relative coordinate system at a fixed position from an object. This is useful if the object could appear any number of times at any location or orientation in your images, and you want to apply the same measurement or inspection process to every instance of the object. Since fixturing is based on the relative coordinate system, your images must be calibrated even if they only use a one-to-one uniform camera calibration. To fixture an object, you must first set up an analysis operation that will return the location(s) of the object in your image (for example, using Model Finder). Once you have established the location (reference location) for each instance of the object, create a loop that calls McalFixture() with M_MOVE_RELATIVE and the reference location of one of the instances. For each instance of your object, the relative coordinate system is placed at the reference location. In the loop, after displacing the relative coordinate system, set up the rest of the inspection process with respect to the relative coordinate system. You can now process each instance of your object, and have results returned with respect to the displaced relative coordinate system. The following animation depicts a set of nails where the relative coordinate system is fixtured to each instance of the nail, before placing the MIL Measurement module's search region with respect to the relative coordinate system and then performing the analysis. The following code snippet illustrates how to setup fixturing. An image calibrated with a uniform one-to-one camera calibration is used. // [...] // Associates the default uniform calibration context with your image; // this sets the absolute coordinate system to have the same origin // and orientation as the pixel coordinate system // and sets the world units equal to 1 pixel. McalUniform(TargetImage, 0.0, 0.0, 1.0, 1.0, 0.0, M_DEFAULT); // Find all occurrences of the model in the target image. MmodFind(ModCtx, TargetImage, ModRes); // Allocate a stripe marker. MIL_ID MeasStripe = MmeasAllocMarker(System, M_STRIPE, M_DEFAULT, M_NULL); MmeasSetMarker(MeasStripe, M_ORIENTATION, M_HORIZONTAL, M_NULL); // Use a graphics list to define the region to be fixtured and used by measurement. const MIL_DOUBLE SearchRegionOriginX = 30; const MIL_DOUBLE SearchRegionOriginY = 10; const MIL_DOUBLE SearchRegionSizeX = 200; const MIL_DOUBLE SearchRegionSizeY = 70; MgraControl(M_DEFAULT, M_INPUT_UNITS, M_WORLD); MgraRect(M_DEFAULT, GraphicLst, SearchRegionOriginX, SearchRegionOriginY, SearchRegionSizeX, SearchRegionSizeY); MbufSetRegion(TargetImage, GraphicLst, M_DEFAULT, M_NO_RASTERIZE + M_FILL_REGION, M_DEFAULT); // [...] MIL_INT NbFound = 0; MmodGetResult(ModRes, M_GENERAL, M_NUMBER + M_TYPE_MIL_INT, &amp;NbFound); // For each found occurrence of the model. for(MIL_INT i = 0; i &lt; NbFound; i++) { // [...] // Moves the image's relative coordinate system to the reference position and // orientation of the current model occurrence. McalFixture(TargetImage, M_NULL, M_MOVE_RELATIVE, M_RESULT_MOD, ModRes, i, M_DEFAULT, M_DEFAULT, M_DEFAULT); // Measure the stripe in the fixtured search region. MmeasFindMarker(M_DEFAULT, TargetImage, MeasStripe, M_DEFAULT); // Analyze the results of the measured stripe. MmeasGetResult(MeasStripe, M_ANGLE + M_EDGE_FIRST , &amp;Edge1AngleDeg, M_NULL); MmeasGetResult(MeasStripe, M_ANGLE + M_EDGE_SECOND , &amp;Edge2AngleDeg, M_NULL); // [...] } For more information, see the Fixturing in MIL section of Chapter 29: Fixturing in MIL. Child buffers, regions of interest, and fixturing Child buffers Regions of interest Fixturing an object with the relative coordinate system ",
      "wordCount": 1379,
      "subEntries": []
    },
    {
      "id": "UG_building-application_Dealing_with_color",
      "version": null,
      "title": "Dealing with color ",
      "subTitles": [
        "Grabbing ",
        "Mapping grabbed data through a LUT ",
        "Displaying ",
        "Managing color images ",
        "Color processing and analysis ",
        "Converting color images to grayscale ",
        "Creating a child buffer from one of the three color bands ",
        "Copying one of the three color bands to a 1-band buffer ",
        "Color space conversion "
      ],
      "location": "MIL UG P02: MIL in a nutshell",
      "pageURL": "content\\UserGuide\\building-application\\Dealing_with_color.htm",
      "text": " Dealing with color MIL supports grabbing, displaying, accessing, and processing color images. MIL can represent an object in color with a single color buffer, allocated with MbufAllocColor(). Grabbing You grab from a color video source (typically a camera) into a color image buffer, as you would into a grayscale image buffer, by calling MdigGrab() or MdigGrabContinuous(). Before performing a color grab, you must allocate a digitizer, using MdigAlloc() (or MappAllocDefault()), specifying a digitizer configuration format (DCF) appropriate for your color camera. In addition, the digitizer and the image buffer must be allocated on the same system and have compatible dimensions. Once you have finished using the digitizer, you should free it, using MdigFree(). When grabbing from a color digitizer, each color component is transmitted simultaneously. The destination buffer must have the same number of color bands as the digitizer. The data is simultaneously stored in the appropriate component of the image buffer. When grabbing RGB, the red component is stored in the first color band, the green component is stored in the second color band, and the blue component is stored in the third color band. If the hardware permits, you can control the digitization reference level of each acquisition path of the digitizer, using MdigControl() with the values in the For the general reference settings table. Note, upon installation, if you specified a color camera, the default image buffer, allocated with MappAllocDefault(), will be a three-band color image buffer. If you didn't specify a color camera, but would now prefer to use one, you can update your defaults using the MILConfig utility. Mapping grabbed data through a LUT You can also correct or precondition input data by mapping it through a lookup table (LUT) upon acquisition (if the hardware permits). This requires that you associate a LUT buffer with the digitizer, using MdigControl() with M_LUT_ID. You can associate either a single-band LUT buffer or a LUT buffer that has the same number of color bands as the digitizer. If you associate a single-band LUT buffer with the digitizer, each component of the digitizer LUT is loaded with the same data. If you associate a multi-band LUT buffer with the digitizer, each component of the digitizer LUT is loaded with the data from corresponding color band of the LUT buffer. To disassociate the LUT buffer from the digitizer, you need to re-associate the default LUT with the digitizer, using MdigControl() with M_LUT_ID set to M_DEFAULT. Displaying You display a color-image buffer as you would a two-dimensional grayscale image buffer. You must first allocate the image buffer with a displayable attribute (M_DISP), and then select it for display, using MdispSelect(). To stop displaying the image buffer and leave the display blank, use MdispSelect() with M_NULL. Before you can display a buffer, the display must be allocated, using MdispAlloc() (or MappAllocDefault()). The image buffer and the display should be allocated on the same system. When you display a color image buffer (usually RGB), the first band is routed to the first output channel (usually red), the second band is routed to the second output channel (usually green), while the third band is routed to the third output channel (usually blue). Managing color images MIL supports the saving and loading of color images from disk in different file formats. See the MbufSave(), MbufLoad(), MbufRestore(), MbufImport(), and MbufExport() function reference descriptions for more details. Note, all the MIL data allocation, access, and generation (Mbuf...() and MgenLut...()) functions can handle color image buffers. Color processing and analysis To process and analyze color images, MIL offers many solutions. The Color Analysis module, for example, accepts color images and allows you to perform color-based procedures such as transforming color data using relative color calibration, matching colors, calculating the difference between colors, and separating colors. The Image Processing module also accepts color images and offers a wide variety of operations that allow you to perform image enhancements, distortion corrections, and basic analysis. Unlike the Color Analysis module, the Image Processing module processes each band one at a time. Most analysis modules usually require 1-band monochrome images. If you have a color image and you want to use it with a module that does not support color, you must do one of the following: convert the color image to grayscale, create a child buffer from one of the three color bands, or copy one of the three color bands to a 1-band buffer. After performing these operations and storing the transformed data in a monochrome buffer, you can pass it to an analysis module. Converting color images to grayscale You can use MimConvert() to convert color images to grayscale using M_RGB_TO_L, where L represents the luminance (L) component of the HSL color space, or using M_RGB_TO_Y, where Y represents the luminance (Y) component of the YUV color space. You can then use the converted image with an analysis module that does not support color. You can also convert color images to grayscale using McolProject() with M_PRINCIPAL_COMPONENT_PROJECTION which, unlike MimConvert(), does not simply extract a single component of the color space. Instead, it uses the distribution of the image's color data to calculate the best grayscale conversion possible, minimizing the loss of information. This results in a grayscale image that can better differentiate the color in the original source image. For more information on converting color images to grayscale, see the Converting to grayscale section of Chapter 22: Color processing and analysis. Creating a child buffer from one of the three color bands Since most analysis modules usually require 1-band monochrome images, you can use MbufChildColor() to allocate a 1-band child buffer within a 3-band color parent buffer. For example, if you have an RGB parent buffer, and use MbufChildColor() with M_RED, you will have a 1-band child buffer which contains the red color band of its parent. You can also use MbufChildColor2d() to select a 2-dimensional region in one of the color bands of the parent buffer. For more information, see the Child buffers subsection of the Using child buffers, ROIs, or a copy to manipulate specific data areas section of Chapter 23: Data buffers. Copying one of the three color bands to a 1-band buffer Instead of using a child buffer to create a 1-band monochrome image from a color image, you can use MbufCopyColor() to copy one band of a 3-band color image buffer. For example, if you have an RGB source image buffer, and use MbufCopyColor() with M_RED, you will have a 1-band destination buffer which contains the red color band of its source. You can also use MbufCopyColor2d() to select a 2-dimensional region of the source buffer from which to copy. For more information, see the Copying data from one buffer to another subsection of the Managing data buffers section of Chapter 23: Data buffers. Color space conversion You can convert color data between HSL and RGB color spaces using MimConvert() with M_HSL_TO_RGB or M_RGB_TO_HSL. If using the MIL Color Analysis module, you can call McolSetMethod() to convert RGB to LAB or HSL before performing McolMatch(). You can also use MimConvert() to convert sRGB to LAB (M_SRGB_TO_LAB), and to convert LAB to sRGB (M_LAB_TO_SRGB). In these cases, your RGB data must adhere to standard RGB specifications, referred to as sRGB, as defined by the International Electrotechnical Commission (IEC) Project Team 61966-2-1. MimConvert() allows many variations with which to convert to and from sRGB. For example, you can specify the LCH color space (a reinterpretation of LAB) and you can specify whether color data is linear (gamma corrected). For more information, see the Color spaces and converting between them section of Chapter 22: Color processing and analysis. MimConvert() is available with MIL-Lite, while McolSetMethod() requires the full version of MIL. Dealing with color Grabbing Mapping grabbed data through a LUT Displaying Managing color images Color processing and analysis Converting color images to grayscale Creating a child buffer from one of the three color bands Copying one of the three color bands to a 1-band buffer Color space conversion ",
      "wordCount": 1334,
      "subEntries": []
    },
    {
      "id": "UG_building-application_Working_with_3D",
      "version": null,
      "title": "Working with 3D",
      "subTitles": [
        "3D data containers and grabbing",
        "Converting 3D data for processing and 3D display",
        "Displaying 3D data",
        "Processing 3D data",
        "Calibration",
        "Storing the output of 3D functions",
        "Regions of interest",
        "Fixturing"
      ],
      "location": "MIL UG P02: MIL in a nutshell",
      "pageURL": "content\\UserGuide\\building-application\\Working_with_3D.htm",
      "text": " Working with 3D The MIL 3D modules (M3d...) support display, analysis, and processing of 3D data of a scene. The 3D data can either be a point cloud or a depth map. A point cloud is a collection of data points, each with X-, Y-, and Z-coordinate values, and represents an object or scene in 3D space. A depth map is an image where the gray value of a pixel represents its depth in the world. You can perform arithmetic and statistical operations, as well as comparative measurements between point clouds, depth maps, and 3D geometries. For example, you can fit a 3D geometry to a point cloud or depth map and calculate distances between points and the fitted surface. You can scale, rotate, and translate 3D data, compute 3D profiles to examine a cross-section of data, and merge multiple point clouds or perform pairwise registration between point clouds. You can also sample a subset of points or reconstruct surfaces (meshes) for point clouds. You can grab point clouds from a 3D sensor or generate point clouds from a laser line profiling setup. You can also load point clouds from PLY and STL files, or create them manually in your application. PLY and STL are 3D data formats that can be used to store point clouds acquired from 3D sensors or generated from CAD drawings. 3D data containers and grabbing Typically, MIL 3D functions work with 3D data stored in a MIL container. A MIL container is a MIL object that contains buffers, called its components. You allocate a container using MbufAllocContainer(). To grab 3D data from a 3D sensor, you should pass a container to MdigGrab(), MdigProcess(), or MdigGrabContinuous(). These functions will automatically allocate components in the container appropriate for the data being transmitted from the 3D sensor. Each component of a 3D container stores a different type of information about the 3D scene. The type of data stored in a component is typically set automatically; if not, you must specify it using MbufControlContainer() with M_COMPONENT_TYPE. Typically, respective positions in each component correspond to information about the same position in the scene. A 3D container has either a range component or a disparity component. A range component stores coordinates of points, or a depth map. A disparity component stores depth information grabbed from a stereoscopic camera. Typically, a 3D container also has a confidence component that stores whether each point should be used or ignored (for example, a point might be invalid because it was occluded during acquisition). The container can also have other components, such as an intensity component that stores the intensity or color of the points. 3D data in a container can be organized or unorganized. Organized 3D data is typically stored in components that are buffers with several rows; it is assumed that points close to each other in 3D space are also close to each other in the components (although not necessarily adjacent). Unorganized 3D data is stored in components that are buffers with a single row; the position of the points in the components has no meaning. For more information on point cloud organization, see the Organized and unorganized point clouds subsection of the Working with points in a point cloud section of Chapter 35: 3D image processing. For more information on grabbing from devices that transmit 3D data in a format that is compliant with an industry standard (such as GigE Vision or GenICam), see the Working with compliant cameras section of Chapter 42: Grabbing from 3D sensors. Note that some 3D sensors transmit data in a non-compliant format. In this case, see the Working with non-compliant cameras section of Chapter 42: Grabbing from 3D sensors. Converting 3D data for processing and 3D display Although you can grab 3D data in many formats, you can only process and/or display 3D data if it is in a MIL 3D-processable or 3D-displayable format, respectively. You can inquire if a container is 3D-processable or 3D-displayable using MbufInquireContainer() with M_3D_PROCESSABLE or M_3D_DISPLAYABLE. If it isn't, you can convert it to a 3D-processable or 3D-displayable container using MbufConvert3d() (if the 3D data is in a format that is compliant with an industry standard). You can also use this function to convert a fully-corrected depth map image buffer to a 3D-processable or 3D-displayable point cloud container. Before converting a 3D container using MbufConvert3d(), the 3D settings of the range or disparity component must be set correctly. These settings identify how 3D data is stored in the container (such as what scaling must be applied in each axis direction for the data to be natively calibrated). If your 3D sensor is configured to transmit this information, these settings will be set automatically during acquisition. Otherwise, you must set the 3D settings of the range or disparity component manually using MbufControlContainer() with settings from the table For specifying settings useful with components that store 3D data. 3D displays, and some 3D processing functions, support fully-corrected depth maps stored in image buffers. You cannot use the range component of a container as though it were a fully-corrected depth map image buffer; you must project the 3D data in the container to a fully-corrected depth map image buffer using M3dimProject(). If the range component stores a depth map in a specific format, you can convert the container to a fully-corrected depth map image buffer using MbufConvert3d(). For more information, see the Preparing a container for display or processing section of Chapter 41: 3D Containers. Displaying 3D data To display 3D data in 3D, you must first allocate a 3D display using M3ddispAlloc(). You can then select a 3D-displayable container or a fully-corrected depth map image buffer to the 3D display, using M3ddispSelect(). If you pass a container that is not in a 3D-displayable format, MIL will try to compensate by converting it internally. If this is not possible, an error will be generated. Once a 3D display is shown in a window, you can look at the 3D data in the 3D display from different angles, either interactively using the mouse and keyboard or by manually specifying the required view using M3ddispSetView(). For more information, see the Manipulating the view section of Chapter 43: 3D Display and graphics. You can also annotate the display with 3D graphics. To do so, inquire the 3D display's internal 3D graphics list using M3ddispInquire() with M_3D_GRAPHIC_LIST_ID, and then use the functions of the M3dgra...() module to draw into this 3D graphics list. For more information, see the Annotating the 3D display section of Chapter 43: 3D Display and graphics. Processing 3D data 3D processing and analysis functions can work on MIL 3D-processable containers. Some can work on fully corrected depth map image buffers. Calibration When working with point cloud containers and/or 3D geometry objects, you do not associate them with a calibration context; all source data is treated as if it is natively calibrated. That is, a point cloud or geometry's coordinates are expected to be real world values. To work with a depth map with the 3D modules, it must be in a calibrated image buffer and be fully corrected; when fully corrected, a depth map's pixels represent a constant size in X and Y in the world and the difference of one gray level in the depth map corresponds to a specified real-world distance (McalControl() with M_GRAY_LEVEL_SIZE_Z). Coordinates of a point cloud reflect the calibration set at acquisition time using the 3D sensor; coordinates of point clouds loaded from PLY or STL files are always in world units. Each point cloud container has its own working coordinate system within which 3D point coordinates are expressed. You might need to transform the points in a point cloud so that they are expressed in the same working coordinate system as another point cloud using M3dimMatrixTransform(). When a 3D geometry object is defined (for example, using M3dgeoBox()), its coordinates are assumed to reflect real-world distances. Storing the output of 3D functions Many functions of the 3D Image Processing module require you to specify source and destination containers. Most of these functions compute results that affect 1 component. If the destination container doesn't have the component, the function adds it to the destination container. If it already has the component, the function tries to use it. If the type, size, or number of bands of the components in the destination container are not appropriate to store resulting components, components are freed and reallocated as required at an appropriate size, with new MIL identifiers. Components are added, removed, or adjusted in the destination container so that it is 3D-processable. In some cases, when affecting the range component, only the coordinates of the points are affected instead of where that data is saved in the component (for example, M3dimRotate()). Similarly, the confidence component is typically used to mask out data in the range component instead of physically changing the size of the component (for example, M3dimCrop()). Typically, when working with point clouds, processing is most efficient if the source data is organized. Regions of interest When working with point clouds, the MIL 3D modules do not support regions of interest (ROIs) as they are implemented for 2D modules. For example, you will get an error if you associate an ROI to one of the components of a container and then try to use that container as an input to a 3D function. There are 4 ways to specify a region of interest for a point cloud container: Pass a 3D geometry object to the functions that support them to limit the processing region. To do so, allocate a 3D geometry object (using M3dgeoAlloc() with M_GEOMETRY), define the geometry's shape (using the appropriate function in the 3D Geometry module, or obtained as a result from another 3D image processing function), and then pass the 3D geometry object to the 3D function. Copy the points of interest into a separate container and then use this container. To copy the points of interest, allocate a 3D geometry object, define the geometry's shape, and then use M3dimCrop() to crop points that are inside/outside the specified geometry object. M3dimCrop() can also perform cropping in-place (that is, the source container is the same as the destination container) without any reallocation if the resulting cropped point cloud is forced to have the same organizational structure as the source (M_SAME). Mask unwanted points using a calibrated mask image buffer. To do so, use M3dimCrop(); 3D points projected onto 0-valued pixels in the specified calibrated mask image buffer are not kept in the resulting point cloud. Change the data in the confidence component of a container to mask out unwanted regions. To do so, inquire the confidence component's MIL identifier using MbufInquireContainer() with M_COMPONENT_ID, and then pass the identifier of the component to MIL functions that work on image buffers to create the mask. For example, you can use the component with MbufCopyCond(), MIL image processing functions (such as MimArith()), or draw into the component using the 2D graphics functions (Mgra...()). Values set to 0 in the confidence component (M_COMPONENT_CONFIDENCE) cause the corresponding coordinates in the range component to be ignored. When dealing with depth maps, some MIL 3D functions support depth map image buffers associated with ROIs. For example, in the 3D Metrology module, the M3dmetFit() function permits a source depth map image buffer to have a raster type ROI. Fixturing Since you do not associate point cloud containers and 3D geometry objects with a calibration context, you use a different method to fixture when using the MIL 3D modules instead of the relative coordinate system method implemented for the 2D modules. Before using a 3D processing or analysis function, you can transform coordinates to fixture point clouds or 3D geometries to a required position and orientation. To do so: Allocate a transformation matrix object using M3dgeoAlloc(). Generate the required transformation coefficients using M3dgeoMatrixSetTransform() or M3dgeoMatrixSetWithAxes(). Alternatively, you can copy a resulting matrix from another MIL 3D module (for example, the 3D Metrology or 3D Registration module) into the transformation matrix object. Apply the transformation matrix to the 3D points using M3dimMatrixTransform(). Typically, you store the resulting transformed points to a different container if your source point cloud has multiple instances of regions that need to be analyzed. For example, if the surface on which an object will be scanned is at a slant, obtain a point cloud of only the surface either by scanning the surface without the object, or masking out the object from an existing scan. You can then fit a plane to the surface using M3dmetFit(), and then copy the fixturing matrix of the fitted plane to a transformation matrix object using M3dmetCopyResult() with M_FIXTURING_MATRIX. You can then transform the point clouds of subsequently scanned objects with this matrix using M3dimMatrixTransform(). For more information, see Fixturing in 3D. Working with 3D 3D data containers and grabbing Converting 3D data for processing and 3D display Displaying 3D data Processing 3D data Calibration Storing the output of 3D functions Regions of interest Fixturing ",
      "wordCount": 2169,
      "subEntries": []
    },
    {
      "id": "UG_building-application_Using_the_defaults",
      "version": null,
      "title": "Using the defaults",
      "subTitles": [
        "Using the MILConfig utility to change your default settings",
        "Using your defaults"
      ],
      "location": "MIL UG P02: MIL in a nutshell",
      "pageURL": "content\\UserGuide\\building-application\\Using_the_defaults.htm",
      "text": " Using the defaults During the installation of your MIL software, you are asked a number of questions (such as, the type of Matrox hardware installed in your computer), so that the installer knows what to install. This information is also used to define the default settings that are configurable. You can change these default settings later, using the MILConfig utility. Using the MILConfig utility to change your default settings Review the Default Values tab in the MILConfig utility to make sure that your computer's default settings match your application's required default settings. If they don't match, you can use the MILConfig utility to change them. For example, you can use the MILConfig utility to change the default system, the default image buffer size and attributes, the default display settings, and the default digitizer's DCF. Using your defaults You can use the MappAllocDefault() macro to allocate a MIL application context and your default system. On this system, MappAllocDefault() also allows you to allocate your default image buffer, default display, and default digitizer. Alternatively, you can use MappAlloc(), MsysAlloc(), MbufAllocColor(), MdispAlloc(), and MdigAlloc() with M_DEFAULT to allocate these defaults. By allocating these using their default settings, you create a more portable, device-independent application, since these settings are not hard-coded in your application, and are determined when your client installs the MIL software. If the MIL driver for a Matrox frame grabber has been installed, the size, number of bands, and attributes for the default image buffer will be established based on the specified DCF for the default digitizer. If a monochrome DCF is specified as the default, a single-band monochrome buffer is allocated as the default image buffer. If a color DCF is specified, a multi-band color buffer is allocated as the default image buffer. The default buffer size is the same as that of the image capture-size specified in the DCF. When allocating both the default image buffer and the default display using MappAllocDefault(), the image buffer is given a displayable attribute, cleared, and selected to the display. Note that although there are advantages to using the default settings, it can make debugging more difficult since the settings for the defaults are not determined within your application. Using the defaults Using the MILConfig utility to change your default settings Using your defaults ",
      "wordCount": 383,
      "subEntries": []
    },
    {
      "id": "UG_building-application_Error_reporting",
      "version": null,
      "title": "Error reporting",
      "subTitles": null,
      "location": "MIL UG P02: MIL in a nutshell",
      "pageURL": "content\\UserGuide\\building-application\\Error_reporting.htm",
      "text": " Error reporting You can enable or disable error reporting to the Host screen, using MappControl(). By default, error reporting is enabled. If you disable error reporting, you can still determine the success of a particular function or a sequence of functions, using MappGetError(). In addition, you can assign a user-defined function to handle the event of a MIL error using MappHookFunction(). For an example that uses MappGetError() to determine if the allocation of the default application, default system, default display, and default image buffer is a success, see MAppStart.cpp in the Testing the installation section of Chapter 1: Introduction. For assistance with debugging your application, see the Matrox Profiler and trace logs section of Chapter 64: Development and debugging tools and techniques. Error reporting ",
      "wordCount": 126,
      "subEntries": []
    },
    {
      "id": "UG_building-application_Multiple_systems",
      "version": null,
      "title": "Multiple systems",
      "subTitles": null,
      "location": "MIL UG P02: MIL in a nutshell",
      "pageURL": "content\\UserGuide\\building-application\\Multiple_systems.htm",
      "text": " Multiple systems There is no limit to the number of systems an application can access; it is limited only by the physical devices present in your computer or accessible from your computer. To use multiple Matrox imaging boards, you have to allocate a MIL system for each board. If necessary, you can use MappInquire() with M_INSTALLED_SYSTEM_DESCRIPTOR + n to select the system to use at runtime. To perform a processing operation, your source and destination buffers can be on different systems; MIL will transparently copy buffers to the most efficient of these systems, if necessary. To exchange data between systems, you can physically copy the data from one system to another. The copy is always performed by the most suitable system. If both systems are of the same type, the copy is always performed by the destination system. Instead of performing a physical copy using MbufCopy(), you can allocate a buffer on one system and use MbufCreate...() to access this buffer from another system. MbufCreate...() creates a buffer that maps to allocated mappable memory, for example, on the Host or any MIL system; no memory is actually allocated to this newly created buffer. This technique can be used, for example, to update a buffer (or part of it) with data grabbed from different systems. Note that after writing to the created buffer, you should notify the real buffer that its contents have been changed, by calling MbufControl() with M_MODIFIED. For more information about creating data buffers, see Chapter 23: Data buffers. To grab, the digitizer and the destination buffer must be allocated on the same MIL system. Similarly, to display a buffer, the display and the buffer must be allocated on the same MIL system. Windowed displays from different systems on the same computer will automatically display together on the same screen in different windows. Multiple systems ",
      "wordCount": 309,
      "subEntries": []
    },
    {
      "id": "UG_building-application_MIL_custom_data_types_extensions_and_portability_functions",
      "version": null,
      "title": "MIL custom data types, void pointers, extensions, and portability functions",
      "subTitles": [
        "MIL custom data types",
        "Void pointers",
        "MIL smart identifiers",
        "Strings and arrays",
        "MIL directory constants",
        "M_MIL_USE_SAFE_TYPE extension",
        "Portability functions"
      ],
      "location": "MIL UG P02: MIL in a nutshell",
      "pageURL": "content\\UserGuide\\building-application\\MIL_custom_data_types_extensions_and_portability_functions.htm",
      "text": " MIL custom data types, void pointers, extensions, and portability functions MIL features data types, constants, and functions that can improve your application's portability and operating system independence. In addition, in C++, MIL supports the standard string and vector objects to simplify handling of strings and arrays, respectively. In C++ 11 and later you can also use MIL smart identifiers to automatically manage the lifespan of MIL objects. MIL custom data types In addition to the standard data types available in C and C++, MIL introduces the following predefined data types, to ensure better compatibility and portability of MIL applications under different operating systems and to manage MIL objects: MIL_ID. Specifies a value that is a MIL identifier. The MIL_ID data type is used to identify objects (for example, buffers, systems, and contexts) which are allocated using MIL within an application. MIL_UNIQUE_..._ID (available only when using in C++ 11 or higher). Specifies a value that is a MIL smart identifier. The smart identifier data type is used to identify, and manage the lifetime of, objects which are allocated using MIL within an application. A smart identifier is similar to a std::unique_ptr, except that it owns a MIL object instead of owning allocated memory. For more information about smart identifiers, see the MIL smart identifiers subsection of this section. MIL_INT. Specifies a value that is an integer. The MIL_INT data type is used as a supplement to the more conventional long and int data types. The MIL_INT data type is a 64-bit value on a 64-bit operating system. MIL_UINT. Specifies a value that is an unsigned integer. Its data depth is the same as that of the MIL_INT data type. MIL_DOUBLE. Specifies a value that is a double precision, floating-point number. MIL_FLOAT. Specifies a value that is a single precision, floating-point number. MIL_UUID. Specifies a universally unique identifier that is used for identification purposes across unrelated systems and applications. For example, a MIL_UUID value is used as an entry key in a dataset context for the MIL Classification module. In addition to the MIL_INT and MIL_UINT data types, MIL also has signed and unsigned, fixed length versions of these data types: MIL_INT8, MIL_UINT8, MIL_INT16, MIL_UINT16, MIL_INT32, MIL_UINT32, MIL_INT64, and MIL_UINT64. MIL also introduces the following predefined data types, to ensure better compatibility and portability of applications regardless of whether they are compiled for ASCII or Unicode character sets: MIL_TEXT_CHAR. Specifies an array of characters. The MIL_TEXT_CHAR data type is used as a replacement for the more conventional char data type. MIL_STRING. Specifies a string object. This object can be used wherever an array of MIL_TEXT_CHAR, address of a MIL_TEXT_PTR, or address of a MIL_CONST_TEXT_PTR should be used. However, it should be noted that MIL_STRING cannot be used when dealing with an array of multiple strings. The MIL_STRING data type is only available in C++. A variable of this type can be manipulated like a standard C++ string (std::string). MIL_STRING_STREAM. Specifies a string stream object. The MIL_STRING_STREAM data type is only available in C++. A variable of one of this type can be manipulated like a standard C++ string stream (std::stringstream). MIL_TEXT_PTR. Specifies a pointer to an array of characters. The MIL_TEXT_PTR data type is used as a replacement for the more conventional char* data type. MIL_CONST_TEXT_PTR. Specifies a pointer to an array of constant characters. The data type is used as a replacement for the more conventional const char* data type. MIL_WINDOW_HANDLE. Specifies the handle to a window. The data type is used as a replacement for the more conventional HWND data type in Windows and the Window data type when using the Xlib library in Linux. There is a macro called MIL_TEXT which converts the provided string to the proper encoding (ASCII or Unicode) for the application. Its syntax is: MIL_TEXT(\"Text to be converted.\"). There is a macro called M_TO_STRING which converts the provided numeric data to a string with the proper encoding (ASCII or Unicode) for the application. Its syntax is: M_TO_STRING(number). This macro is only available when using C++11 (or later), and maps directly to std::to_string or std::to_wstring (depending on your project settings). MIL also features several standard objects in C++ to simplify the handling of strings and arrays, respectively. For more information, see the Strings and arrays subsection of this section. Void pointers In MIL, there are functions, predominantly M...Inquire() and M...GetResult() functions, where one (or more) of their parameters takes a void pointer. This allows for a more general API where one function (within a module) can retrieve or set information of different data types (for example, MdispInquire() can be used to retrieve the width of the display (MIL_INT) and the title of the display (array of MIL_TEXT_CHAR). The expected data type for these void pointer parameters is determined in one of two ways: The data type is intrinsically determined by the setting of another parameter. For example, consider the MbufInquire() function. When the InquireType parameter of this function is set to M_ALLOCATION_OVERSCAN_SIZE, a MIL_INT value is returned, and, therefore, the UserVarPtr parameter expects the address of a variable of type MIL_INT. However, when the InquireType parameter is set to M_ANCESTOR_ID, the UserVarPtr parameter expects the address of a variable of type MIL_ID. // Two calls to the same function where different data types are expected. // // Value1 should point to a MIL_INT /*Pointer for last parameter of MbufInquire should reference a MIL_INT*/ MIL_INT Value1; MbufInquire(BufId, M_ALLOCATION_OVERSCAN_SIZE, &amp;Value1); // /*Pointer for last parameter of MbufInquire should reference a MIL_ID*/ MIL_ID Value2; MbufInquire(BufId, M_ANCESTOR_ID, &amp;Value2); In the MIL Help, a parameter association table is used to list the independent parameter setting and the expected data type of the address to pass to its dependent void pointer parameter(s); the data type is presented in green text. If the expected data type is not that of an array, the expected data type will be shown inline. However, if it is of an array, or if, given the setting, one of multiple data types might be expected, you will be able to expand the data type information to see in which situation one data type is expected over the other, and in the case of an array, to see how large the array must be. The data type is determined by a modifier (for example, M_TYPE_MIL_DOUBLE) added to the setting of another parameter. For example, consider the MblobInquire() function. The InquireType parameter specifies type of information about which to inquire. The UserVarPtr parameter specifies the address at which to write the requested information. The UserVarPtr parameter is a void pointer, and by default requires that you pass it the address of a MIL_DOUBLE value. However, if M_TYPE_MIL_INT is added to the setting of InquireType, the UserVarPtr parameter expects the address of a variable of type MIL_INT. // Two calls to the same function where different data types are expected. // /*Pointer for last parameter of MgraInquire should reference a MIL_DOUBLE*/ MIL_DOUBLE Value3; MgraInquire(ContextGraId, M_DRAW_OFFSET_X, &amp;Value3); // /*Pointer for last parameter of MgraInquire should reference a MIL_INT*/ MIL_INT Value4; MgraInquire(ContextGraId, M_DRAW_OFFSET_X + M_TYPE_MIL_INT, &amp;Value4); The ability to modify the expected data type is typically only available for processing or analysis modules' M...Inquire() functions and M...GetResult() functions. See the function(s)' reference description to establish if the data type can be changed using a modifier. The general description of a void pointer parameter includes a complete list of the possible data types that the parameter can take. This list also includes the data types that are expected when using a modifier (M_TYPE_...). For more information concerning void parameters in languages other than C/C++, see the appropriate language-specific chapter. MIL smart identifiers Optionally, when you allocate a MIL object, you can specify to return a MIL smart identifier (MIL_UNIQUE_..._ID) instead of a standard MIL identifier (MIL_ID). To do so, pass M_UNIQUE_ID to the allocation function instead of the address of a variable in which to write the identifier. The MIL smart identifier owns the MIL object and manages its lifetime; it frees the MIL object automatically when the smart identifier goes out of scope, is destroyed, or is assigned a new value. A smart identifier can be passed to all MIL functions as though it were a standard MIL identifier (MIL_ID) except for freeing functions (such as MbufFree()) or parameters that take an array of MIL identifiers (such as the DestContainerOrImageBufArrayPtr parameter of MdigProcess()). Smart identifiers are only available when using C++11 (or later). Unlike a standard MIL identifier (MIL_ID), which can refer to any type of MIL object, you use different types of MIL smart identifiers for different types of MIL objects. For example, when you allocate a system using MsysAlloc(), you must store the returned value in a MIL_UNIQUE_SYS_ID. Attempting to assign a smart identifier to a variable of the incorrect type will cause a compile time error. To learn what type of MIL smart identifier to use for a MIL object, refer to the M_UNIQUE_ID setting in the function that allocates the object (for example, MbufAllocColor() for a color buffer). Note that using a MIL smart identifier does not guarantee type safety. For example, passing an MIL_UNIQUE_SYS_ID smart identifier to a function that requires a buffer (such as MbufInquire()) does not cause a compile time error, because the MIL_UNIQUE_SYS_ID is implicitly cast to the data type MIL_ID (which can refer to any type of MIL object). The following code snippet shows two functions that grab and save an image. The first function uses MIL_ID variables; the second function uses MIL_UNIQUE_..._ID variables. // Allocate MIL objects required to grab and save an image // using standard MIL identifiers and manual freeing. void GrabAndSave(MIL_ID MilSystem, MIL_STRING filePath) { MIL_ID MilDigitizer = MdigAlloc(MilSystem, M_DEFAULT, MIL_TEXT(\"M_DEFAULT\"), M_DEFAULT, M_NULL); MIL_ID MilBuffer = MbufAlloc2d(MilSystem, 512, 512, 8, M_IMAGE + M_GRAB + M_PROC, M_NULL); MdigGrab(MilDigitizer, MilBuffer); MbufSave(filePath, MilBuffer); MbufFree(MilBuffer); MdigFree(MilDigitizer); } // Allocate MIL objects required to grab and save an image // using MIL smart identifiers and automatic freeing. void GrabAndSaveUnique(MIL_ID MilSystem, MIL_STRING filePath) { MIL_UNIQUE_DIG_ID MilDigitizer = MdigAlloc(MilSystem, M_DEFAULT, MIL_TEXT(\"M_DEFAULT\"), M_DEFAULT, M_UNIQUE_ID); MIL_UNIQUE_BUF_ID MilBuffer = MbufAlloc2d(MilSystem, 512, 512, 8, M_IMAGE + M_GRAB + M_PROC, M_UNIQUE_ID); MdigGrab(MilDigitizer, MilBuffer); MbufSave(filePath, MilBuffer); // All objects allocated within the function are freed automatically. } To extend the lifespan of a MIL object owned by a MIL smart identifier and use the object beyond the scope of the function in which you allocated it, return the MIL smart identifier from your function. Ownership of the MIL object is transferred to the smart identifier in which you store the returned value. If you assign a new value to a smart MIL identifier, the MIL object that the MIL smart identifier previously referred to is automatically freed. For example, if you use a MIL_UNIQUE_BUF_ID variable to store the MIL identifier of a 1-band buffer, and you need to reallocate that buffer with different dimensions, you only need to store the identifier returned by MbufAlloc2d() in the same variable; this frees the existing buffer automatically. To free an existing MIL object without allocating a new MIL object, assign the value nullptr to the smart identifier. In addition to M...Alloc() functions, most other functions that allocate a MIL object can return a MIL smart identifier (for example, M...AllocResult(), M...Copy/CopyResult(), and M...Restore() functions). An exception to this rule is M...Stream() with M_RESTORE; this operation cannot return a MIL smart identifier. Note that MIL inquire functions that can return a MIL_ID never return a MIL smart identifier. For example, you can associate a LUT buffer with a display by passing its MIL smart identifier to MdispLut(). However, if you later inquire the MIL identifier of the associated LUT buffer (using MdispInquire() with M_LUT_ID), the underlying standard MIL identifier (MIL_ID) of the LUT buffer is returned. You must not pass this MIL identifier to a freeing function. Strings and arrays Strings in MIL are typically represented using arrays of type MIL_TEXT_CHAR, or a MIL_TEXT_PTR or MIL_CONST_TEXT_PTR. In C++, you can instead use a MIL_STRING. MIL_STRING is resized automatically when calling an M...Inquire() or M...GetResult() function that returns a string. This makes it easier to inquire or get such a result, because you don't need to inquire the string length, allocate an array of this size, and then inquire/get the string. It should be noted that MIL_STRING cannot be used when dealing with an array of strings, that is, if the function is returning multiple null-terminated strings into an array. In C++, all MIL functions that take an input or output array as a parameter have overloaded versions that allow you to pass a reference to a standard C++ vector (std::vector) to that parameter instead. Some output parameters allow you to pass a combination constant (for example; M_TYPE_...) to cast the returned data to a required data type. When using a vector, don't pass the combination constant; just pass a vector of the required-type. MIL will automatically return the data cast to the type of the vector. Note that for these output parameters, the vector can be the expected data type of the parameter or one of the listed cast types for that output parameter (for example M_TYPE_...). Typically, when using an input vector, MIL will automatically determine the array size based on the size of the vector, with the exception of cases where only a subset of the vector should be specified (for example, MbufPut1d()). When using a vector for an output parameter, it is not necessary to determine the size of the array before calling a function, since MIL will resize the output vector automatically. A vector overload function might call more than one MIL function. Vector overload functions might call more MIL functions in debug mode than in release mode, to validate parameters. When using vector overload functions in debug mode, you might notice an increased performance slowdown in addition to the typical performance slowdown when running in debug mode. The following code snippet illustrates how to use a standard vector (std::vector) overload function for input and output array parameters. // Get pixel values from the image. Vector is resized automatically. // Data type MIL_UINT8 is checked against the buffer data type in debug mode. std::vector&lt;MIL_UINT8&gt; Pixels; MbufGet(ImageId, Pixels); // Do some operations on the pixel values... // Put values back into the image. Size and data type are validated in debug mode. MbufPut(ImageId, Pixels); The following code snippet illustrates how to use a standard vector (std::vector) overload function that has a parameter defining the size of the array. In this case, MgraDots() is called to draw dots in an image. M_DEFAULT is passed to the NumberOfDots parameter. MIL will automatically determine the appropriate size based on the number of elements in the vector. Refer to individual function descriptions for more information on what to pass to an array size parameter. const std::vector&lt;MIL_INT&gt; DotsX {1, 4, 8, 100}; const std::vector&lt;MIL_INT&gt; DotsY {2, 5, 9, 101}; MgraDots(ContextGraId, ImageId, M_DEFAULT, DotsX, DotsY, M_DEFAULT); The following code snippet illustrates how to instantiate and use a standard vector (std::vector) when calling a function where a casting combination flag would typically be required. MimHistogram(ImageId, HistResultId); // Get histogram values. Vector is resized automatically. Data is cast to the // vector type (MIL_INT32) without having to specify a combination flag. std::vector&lt;MIL_INT32&gt; Histogram; MimGetResult(HistResultId, M_VALUE, Histogram); MIL directory constants MIL provides several string constants for accessing special directories, such as the default MIL installation, contexts, and images directories. These constants are guaranteed to be correct for the local computer, even if MIL is not installed in the default location. You can increase the portability of your MIL application by prepending these constants to strings that contain file paths, instead of using hard-coded paths which might not be correct for all computers on which your application will run. Typically, these directories are only used when accessing content related to MIL examples (except for the operating system's temporary directory). The following constants are provided: M_INSTALL_DIR. The path to the root directory of the local MIL installation. This constant is equivalent to using MappInquire() with M_MIL_DIRECTORY_INSTALL. By default on a Windows platform (for 64-bit MIL), this path is C:\\Program Files\\Matrox Imaging\\MIL. By default on a Linux platform, this path is /opt/matrox_imaging/mil. M_IMAGE_PATH. The path to the local MIL images directory. This constant is equivalent to using MappInquire() with M_MIL_DIRECTORY_IMAGES. By default on a Windows platform (for 64-bit MIL), this path is C:\\Program Files\\Matrox Imaging\\Images. By default on a Linux platform, this path is /opt/matrox_imaging/mil/images. M_CONTEXT_PATH. The path to the local MIL contexts directory. This constant is equivalent to using MappInquire() with M_MIL_DIRECTORY_CONTEXTS. By default on a Windows platform (for 64-bit MIL), this path is C:\\Program Files\\Matrox Imaging\\Contexts. By default on a Linux platform, this path is /opt/matrox_imaging/mil/contexts. M_USER_DLL_DIR. The path to the MIL folder that stores the DLLs which contain user-defined MIL slave functions. For more information on user-defined MIL functions, see the MIL Function Development module section of Chapter 67: The MIL function development module. By default on a Windows platform (for 64-bit MIL), this path is C:\\Users\\Public\\Documents\\Matrox Imaging\\MIL\\UserDLL. By default on a Linux platform, this path is /opt/matrox_imaging/mil/lib. This folder is only accessible by users in the MIL administrator group. M_TEMP_DIR. The path to the operating system's temporary directory. On a Windows platform, this is equivalent to the environment variable %TEMP%. By default on a Windows platform, this path is C:\\Users\\&lt;USERNAME&gt;\\AppData\\Local\\Temp. By default on a Linux platform, this path is /tmp. On a Linux platform, the contents of the temporary folder is erased when the computer is restarted. M_MIL_USE_SAFE_TYPE extension When using void pointers it is possible to make a mistake and pass a value with the wrong data type. These errors can cause unexpected behavior such as: stack corruption, array overflow, uninitialized returned data, and segmentation faults. MIL includes the M_MIL_USE_SAFE_TYPE extension to help you find these errors. Note that the extension is also used when validating or attempting to cast a standard vector (std::vector) or MIL_STRING type parameter. When the M_MIL_USE_SAFE_TYPE extension is enabled, an error message is returned if the data type of the variable whose address is passed to a void pointer parameter does not match the expected data type. By default, the M_MIL_USE_SAFE_TYPE extension is enabled when compiling in debug mode. Note that the M_MIL_USE_SAFE_TYPE extension is only available if you are using a C++ compiler under Windows. It is not available under Linux. You might want to skip the verification performed by the M_MIL_USE_SAFE_TYPE extension if: The data type of a value is unknown at the time the function is called. This typically occurs when the MIL function is wrapped inside another function in the application. For example: MIL_INT UserWrapperAroundMbufInquire(MIL_ID BufId, MIL_INT64 InquireType, void *UserVarPtr){ return MbufInquire(BufId, InquireType, UserVarPtr); } The data type of the value passed to a function is not one of the expected data types accepted by a function (for example, when a custom data type is defined in the application). MIL_INT8 *Data = (MIL_INT8 *)malloc(sizeof(MIL_DOUBLE) / sizeof(MIL_INT8)); MmodGetResult(ResultId, M_GENERAL, M_NUMBER, Data); Number = *((double*)Data); free(Data); To disable the M_MIL_USE_SAFE_TYPE extension entirely, include the #define M_MIL_USE_SAFE_TYPE 0 statement before the #include &lt;mil.h&gt; statement in the application code. When the extension is excluded, all MIL overloads are called without any data type verification. Portability functions In addition to the functions available in the C/C++ standard library, MIL introduces the following functions to ensure better compatibility and portability of applications regardless of whether they are compiled for ASCII or Unicode character sets: Function in the C/C++ standard library Portable MIL version of the function Description abs MIL_INT MosAbs(MIL_INT n) Calculates the absolute value of \"n\". getch MIL_INT MosGetch() Reads a character or keystroke from the standard input (keyboard). After a keystroke is read, the application instantly resumes. getchar MIL_INT MosGetchar() Reads a character from the standard input (keyboard). After a keystroke is read, the application waits for the Enter key to be pressed before resuming. kbhit MIL_INT MosKbhit() Returns a non-zero value once a keystroke is read. main MIL_INT MosMain() Specifies the first function to execute. printf MIL_INT MosPrintf(MIL_CONST_TEXT_PTR FormatString, Arg1, Arg2, ) Prints formatted data to the console. The FormatString parameter is a MIL_TEXT string that can optionally contain format specifiers that will be replaced with the subsequent arguments (Arg1, Arg2, ...). Format specifiers are introduced by the \"%\" character within the FormatString value. For example, the following code: MosPrintf(MIL_TEXT(\"A character: %c and an integer: %d\"), 'b', 523); outputs the following sentence to the console: A character: b and an integer: 523. sleep void MosSleep(MIL_INT waitTime) Suspends an application for the specified period of time (in milliseconds). sprintf_s MIL_INT MosSprintf(array of type MIL_TEXT_CHAR DstArrayPtr, MIL_INT size, MIL_CONST_TEXT_PTR FormatString, Arg1, Arg2, ) Writes formatted data to a string. The DstArrayPtr parameter specifies the array of characters in which to store the formatted data as a string. The size is the maximum size of the array of characters, including the NULL-termination character. The FormatString parameter is a MIL_TEXT string that can optionally contain format specifiers that will be replaced with the subsequent arguments (Arg1, Arg2, ...). Format specifiers are introduced by the \"%\" character within the FormatString value. For example, the following code: MosSprintf(String, MIL_TEXT(\"A character: %c and an integer: %d.\"), 'b', 523); saves the following sentence in DstArrayPtr: A character: b and an integer: 523. strcat_s MIL_INT MosStrcat(MIL_TEXT_PTR strDestination, MIL_INT size, MIL_TEXT_PTR strSource) Joins strings. strcmp MIL_INT MosStrcmp(MIL_TEXT_PTR string1, MIL_TEXT_PTR string2) Compares two strings. strcpy_s MIL_INT MosStrcpy(MIL_TEXT_PTR strDestination, MIL_INT size, MIL_TEXT_PTR strSource) Copies characters of one string to another. strlen MIL_INT MosStrlen(MIL_TEXT_PTR str) Calculates and returns the length of a string. strlwr MIL_INT MosStrlwr(MIL_TEXT_PTR str) Converts a string to lowercase. strupr MIL_INT MosStrupr(MIL_TEXT_PTR str) Converts a string to uppercase. For more information on the above-mentioned functions of the C/C++ standard library, refer to MSDN. MIL custom data types, void pointers, extensions, and portability functions MIL custom data types Void pointers MIL smart identifiers Strings and arrays MIL directory constants M_MIL_USE_SAFE_TYPE extension Portability functions ",
      "wordCount": 3638,
      "subEntries": []
    },
    {
      "id": "UG_building-application_Combination_values",
      "version": null,
      "title": "Combination values and macros",
      "subTitles": [
        "Combination values",
        "Function-like macros"
      ],
      "location": "MIL UG P02: MIL in a nutshell",
      "pageURL": "content\\UserGuide\\building-application\\Combination_values.htm",
      "text": " Combination values and macros Some MIL functions make use of combination values and macros. Combination values and macros are mechanisms by which you can specify multiple pieces of information to one parameter. Combination values Some parameters in MIL functions can take a combination of constants added together; typically these parameters take a primary constant added with what is referred to as a combination value. Combination value are used to indicate an additional setting without requiring an additional parameter or increasing the number of possible constants to cover all permutations. An example of a parameter that can take a combination of constants is the Attribute parameter of MbufAlloc...(); you can set this parameter to: M_IMAGE + M_DISP. This specifies that the function should allocate an image type buffer, and that it should be displayable. This mechanism works because in these cases, both the primary constant and the combination value are bit-encoded; that said, it is recommended that you combine them using an addition (+) operation and not a bitwise OR operation. This makes your code more legible because the combination values typically indicate an additional setting instead of an alternative setting. If using the addition operation, be careful not to mistakenly add the same combination value to the primary constant more than once. This has a cumulative effect on the respective bits, leading to what could be a technically valid, yet incorrect constant. For parameters that take combination values, you should also be careful to pass the right constants to the parameter. This is because adding the wrong constants could also lead to a technically valid, yet incorrect constant. Constants that can be combined with combination values listed in a separate table denote this fact with a plus (+) sign. If you hover over the plus (+) sign, a hover box will appear indicating the table names containing the possible combination values. If the combination value's table is only supported for a subset of the systems for which the primary constant is supported, these will be listed in the combination table and in the hover box. A combination values table is placed after the table with the last primary constant that can be combined with the values in the combination values table. A combination values table will, at the top of the table, list the primary constants that can (or must) be combined with the combination values in the table. Combination values are typically optional, but at times are required. When a combination value is required, it is indicated in the description of the primary constant and in the preamble of the combination table. In some rare cases, constants can be combined with constants in the same table; in these cases, the fact that they can be combined is indicated in text above the table (for example, the constants for the Operation parameter in MblobDraw()). Some combination values can be further combined with other combination values. An example of this is when allocating an image buffer for compressed data using MbufAlloc...(); you could pass its Attribute parameter M_IMAGE + M_COMPRESS and further combine these with an M_JPEG... constant to indicate the compression algorithm. For example, if you want to allocate an image buffer to hold JPEG2000 lossless compressed data, you would specify: M_IMAGE + M_COMPRESS + M_JPEG2000_LOSSLESS. Function-like macros Some parameters in MIL functions have their values passed through a macro (for example, M_RGB888()). These macros can take one or more parameters, and will perform some internal operation, the result of which will be returned to the parameter calling the macro. Essentially, macros are like calling a function. For example, the M_RGB888() macro takes three 8-bit values, representing each color element (red, green, and blue), and converts them to an encoded RGB value. The following is an example of setting a MIL function's parameter using a macro: MdispControl(DisplayID, M_TRANSPARENT_COLOR, M_RGB888(20,32,24)); Note that when you set a control type to a value using a macro (for example, M_TRANSPARENT_COLOR with M_RGB888()), and then you inquire this value, you need to use a different macro to decode the returned value. For example, to retrieve the red, green, and blue components of the encoded RGB value, you must use the M_RGB888_R, M_RGB888_G, and M_RGB888_B macros respectively. The following snippet shows how to use the RGB unpacking macros: //Inquire the encoded RGB value MdispInquire(DisplayId, M_TRANSPARENT_COLOR, &amp;RGBValue); //Unpack encoded RGB value into its constituent parts. RGB_R_Value = M_RGB888_R(RGBValue); RGB_G_Value = M_RGB888_G(RGBValue); RGB_B_Value = M_RGB888_B(RGBValue); Some parameters can take one of several macros. For example, the LabelOrIndex parameter of MbeadControl() can take the label and index macros (M_TEMPLATE_LABEL() and M_TEMPLATE_INDEX() respectively); these macros bit-shift values so MIL understands whether a label or an index is being specified as the value for a function's parameter. Some parameters can take a combination of macros; in such cases, the macros are bit-encoded (for example, M_SEQ_OUTPUT() + M_SEQ_DEST()). This means that they must respect the same rules that were outlined above for when combining with combination values. Strings passed directly to a MIL function are passed through the MIL_TEXT macro. This macro detects and declares the string in the proper character encoding scheme required for the application at hand. If you intend to pass a string in a variable, you must pass the variable to the parameter without enclosing the variable in the MIL_TEXT macro. The MIL_TEXT macro is different from other macros; this distinction is due to the fact that, because it is completely resolved at compile-time, it cannot take a variable as a parameter. The following snippet shows how to properly use the MIL_TEXT macro: //Using the MIL_TEXT macro on its own to specify a file path MbufSave(MIL_TEXT(\".Documents/Matrox Imaging/MIL/Examples\"), MILImageBuf); //Passing a string to the MIL_TEXT macro, which is then enclosed in a variable MIL_CONST_TEXT_PTR MILFilePath = MIL_TEXT(\".Documents/Matrox Imaging/MIL/Examples\"); //Passing the variable as the argument for the file name parameter. Beware to not enclose the variable in MIL_TEXT() MbufSave(MILFilePath, MILImageBuf); Note that the MIL_TEXT macro is only required in C and C++. For more information on dealing with strings in other languages, see the Using .NET strings with MIL section of Chapter 60: Using MIL with .NET and the MIL functions and constants in Python section of Chapter 59: Using MIL with Python. Combination values and macros Combination values Function-like macros ",
      "wordCount": 1043,
      "subEntries": []
    },
    {
      "id": "UG_building-application_Event_handling_in_MIL",
      "version": null,
      "title": "Event handling in MIL with hook-handler functions",
      "subTitles": [
        "MIL hook-type functions",
        "Events and user data",
        "Unhooking hook-handler functions",
        "MIL hook information functions"
      ],
      "location": "MIL UG P02: MIL in a nutshell",
      "pageURL": "content\\UserGuide\\building-application\\Event_handling_in_MIL.htm",
      "text": " Event handling in MIL with hook-handler functions In MIL, there are functions that take a callback function and set it up as the event handler for a specific type of event (hooks it to the event). When the event then happens, the callback function is executed. The MIL functions capable of attaching (hooking) a callback function to an event are referred to as hook-type functions (for example, the MappHookFunction() function), and the callback functions are referred to as hook-handler functions. MIL hook-type functions MIL hook-type functions allow you to execute a user-defined hook-handler function upon the occurrence of a specified event. These hook-type functions can associate a variety of events with specified hook-handler functions. The supported types of events differ based on the module and the particular hook-type function. For instance, the MappHookFunction() function allows you to, among other things, trap errors (M_ERROR_...) that occur in an application and execute a hook-handler function whenever one of these errors occur; whereas, the MdigHookFunction() allows you to execute a hook-handler function, for example, at the end of a grab. Within a hook-handler function, you can retrieve information about the event that caused the hook-handler function to be called, using a hook-information (M...GetHookInfo()) function. The various MIL hook-type functions and their corresponding hook-information functions typically conform to the following naming scheme: M...HookFunction(). M...GetHookInfo(). There are, however, a few hook-type functions that do not conform to this standard (for example, MdigFocus() and MdigProcess()). Depending on the hook-type function, you can attach multiple hook-handler functions to an event. To do so, call the hook-type function multiple times, once for each hook-handler function that you want to hook to the event. MIL automatically chains and keeps an internal list of all the associated hook-handling functions. When a function is hooked, this new function is added to the end of the list. The hook-handler functions will be executed in the order in which they were attached to the event. Note that MdigFocus() and MdigProcess() cannot attach multiple hook-handler functions. Each MIL hook-type function requires that the hook-handler function that you specify has a particular signature (or prototype); it must have the expected parameters and a particular return type. If the hook-handler function does not conform to the signature that the hook-type function expects, your application won't successfully compile. Refer to the hook-type function's reference for a description of the particular signature required. Hook-handler functions are typically executed asynchronously on a separate thread when the event deals with hardware (for example, Mdig...() and Msys...() events), or a remote computer. If the event is software related, the hook-handler function will generally be executed synchronously on the same thread as the one on which the event was triggered. The exception to this is the MbufHookFunction() function, which will have its hook-handler function executed on a separate thread if the buffer causing the event (M_MODIFIED_BUFFER) is modified by a function that executes asynchronously (for example, MimArith() executed on a processing FPGA); otherwise, the hook-handler function is executed on the same thread as the one on which the event was triggered. Note that although there is a small queue to permit a certain amount of overlap, hook-handler functions executed asynchronously should limit their execution length such that the function is executed faster than the time it takes to generate another instance of the associated event. As a general guideline, hook-handler functions should have a shorter execution period than the average period required to generate an event. Typically, the hook-handler function performs the minimum number of operations required, and if necessary, performs longer processes by launching a utility function in another thread. This is more important when dealing with hardware-related event handling but should be held as a general rule for all event handling. Events and user data Since hook-handler functions must have a very specific signature (prototype), and you might need information from your MIL application within your hook-handler function, all hook-handler functions have a parameter which takes a pointer to a variable or data structure. You can use the reference to access and/or modify the data from within the hook-handler function, upon its execution. This also allows the main application block to receive user-data from the hook-handler functions. The reference to the variable/user data structure is received in the hook-handler function as a void pointer. As such, to access the data in the hook-handler function, the pointer to the data must be cast back to the appropriate data type. If you need to pass the hook-handler function more than one piece of data, define a structure or class that can store the set of required data. For example, you can use a data structure to pass the identifier of both the source and destination image buffers on which you want the hook function to operate. /* Example of a data structure used to pass data to the hook-handler function. */ typedef struct { MIL_ID MilDigitizer; MIL_ID MilImageDisp; MIL_INT ProcessedImageCount; } HookDataStruct; Since you are passing the user data with a pointer, the user data is accessible and modifiable in both the primary application block (in which the hook-type function was called), and in the hook-handler function. Note that if the hook-handler function is executed asynchronously, care must be taken to properly synchronize the primary application block and hook-handler functions so that the data is not being modified by both functions simultaneously. For more information regarding synchronization, see the Multi-threading section of Chapter 65: Multi-processing, multi-core, and multi-threading. Unhooking hook-handler functions If the hook-handler function was hooked using a M...HookFunction() function, you can unhook the hook-handler function from its associated event. To do so, you must call the appropriate M...HookFunction() with the same parameter values that were passed in the previous call, but you must combine the hook-type (event) with M_UNHOOK so that the event is detached (unhooked) from the hook-handler function as shown below: /*Unhooking the hook-handler function*/ MbufHookFunction(MilImage, M_MODIFIED_BUFFER + M_UNHOOK, UserHookFunction, &amp;UserHookData); MIL hook information functions The hook information functions (M...GetHookInfo()) allow you to retrieve information about the event that caused the hook-handler function to be called. You can use hook information functions, for example, to determine the identifier of the buffer that triggered the event (MdigGetHookInfo() with M_MODIFIED_BUFFER + M_BUFFER_ID) so that you can perform some operation on that buffer, or to determine if a grabbed frame is corrupt (MdigGetHookInfo() with M_CORRUPTED_FRAME). The M...GetHookInfo() types of functions can only be called within the scope of a hook-handler function. Each hook information function can return information related to the event to which the hook-handler function was hooked; although, some types of information are available regardless of the event triggering the hook-handler function. Some events occur under multiple circumstances. For instance, if you hook a function to an I/O change event using MsysHookFunction() with M_IO_CHANGE, the hook-handler function will be invoked when any I/O signal changes state. To determine the particular I/O signal that caused the event, you can call MsysGetHookInfo() using M_IO_INTERRUPT_SOURCE. Based on the result, you can implement a switch statement to execute different code based on the particular I/O signal that caused the event. Another example of an event occurring under multiple circumstances is an M_GRAPHIC_MODIFIED type of event. This type of event is triggered whenever any graphic is modified in a 2D graphics list (GraListId). You could determine the modification performed on the graphic using MgraGetHookInfo() with M_GRAPHIC_CONTROL_TYPE, and implement a switch statement to execute different code based on the particular modification made to the 2D graphics list. The following code snippet is an example of a function hooked to an M_GRAB_END event using MdigHookFunction(). The hook-handler function receives user data and makes use of a hook information function: /*User's processing (hook-handler) function*/ MIL_INT MFTYPE UserHookFunction(MIL_INT HookType, MIL_ID HookId, void* HookDataPtr) { /*Void pointer to structure being cast to the structures type*/ HookDataStruct *UserHookDataPtr = (HookDataStruct *)HookDataPtr; MIL_ID ModifiedBufferId; /* Retrieve the MIL_ID of the modified buffer. */ MbufGetHookInfo(HookId, M_MODIFIED_BUFFER + M_BUFFER_ID, &amp;ModifiedBufferId); /* Increment the frame counter. */ UserHookDataPtr-&gt;ProcessedImageCount++; /* Perform an operation on the modified buffer. */ MimArith(ModifiedBufferId, M_NULL, UserHookDataPtr-&gt;MilImageDisp, M_NOT); return 0; } Since the hook-handler function receives the reference to the user-data as a void pointer, the pointer is cast back to the appropriate data type (in this case, the HookDataStruct structure defined earlier in this section) so that the structure's various elements can be accessed. To identify the buffer that was modified (written into by the grab), causing the hook-handler function to be executed, a call to MdigGetHookInfo() with M_MODIFIED_BUFFER + M_BUFFER_ID is made. The hook-handler function then performs an operation on the buffer and stores the results in the image buffer specified by the user-defined structure. Since the main application block also has access to the buffer, the results of the operation are accessible in the main application block. Event handling in MIL with hook-handler functions MIL hook-type functions Events and user data Unhooking hook-handler functions MIL hook information functions ",
      "wordCount": 1482,
      "subEntries": []
    },
    {
      "id": "UG_building-application_Porting_a_MIL_application",
      "version": null,
      "title": "Porting a 32-bit MIL application to MIL 64-bit",
      "subTitles": [
        "Modified functions",
        "Retrieving a pointer to a modified function",
        "Void pointers",
        "M_MIL_USE_SAFE_TYPE extension",
        "Project processor definitions"
      ],
      "location": "MIL UG P02: MIL in a nutshell",
      "pageURL": "content\\UserGuide\\building-application\\Porting_a_MIL_application.htm",
      "text": " Porting a 32-bit MIL application to MIL 64-bit As of MIL X 2102, MIL only supports 64-bit operating systems. For more details about supported operating systems, refer to the Requirements to run MIL section of Chapter 1: Introduction. When porting an application to MIL 64-bit, there are certain modifications that must be made to your application's code. This section explains these changes and the circumstances under which they are required. Modified functions In the 64-bit version of MIL, there are actually two versions of the following functions: M...Control(). MgraArc(). MgraArcFill(). MgraDot(). MgraLine(). MgraRect(). MgraRectFill(). MgraText(). MmetSetPosition(). MmodDefine(). MregSetLocation(). The two versions of these functions differ in the expected data types of their parameters: one version has a Double suffix, and one version has an Int64 suffix (for example, MblobControlDouble() and MblobControlInt64()). The Double version of these functions should be used when the relevant parameter (typically the ControlValue parameter) requires a MIL_DOUBLE value and the Int64 version should be used when a MIL_INT value is required. In C++ (*.cpp), the original functions are available as inline functions which will automatically call the appropriate version of the function depending on the type of parameter received. No change to your source code should be required if you are compiling your 64-bit MIL application in C++. In C (*.c), the original functions are actually macros that call the most typically required version of the function. This means that if you are compiling your MIL application in C, only minor modifications to your code will be necessary. Compiler warnings will be produced if you pass a function a double value where an integer is expected; in this case, you will need to explicitly change this function call to the proper version of the function. Retrieving a pointer to a modified function Advanced users might want to retrieve a pointer to one of the modified functions. In this case, only the Double or Int64 version should be used, since the original function is actually a macro or an overloaded function. For example, you must retrieve a pointer to MmetSetPositionDouble() or MmetSetPositionInt64(), and not MmetSetPosition(). Note that when retrieving pointers to functions, the following are also affected: MimArith() and MimArithMultiple(). For these functions, a Double version also exists; you must use it instead of the original. Note that the actual name of the exported MIL function might be slightly different than what's documented. Void pointers Most MIL functions have parameters of a fixed data type. However, there are some functions, predominantly M...Inquire() and M...GetResult() functions, where one (or more) of their parameters is a void pointer. The expected data type for these void pointer parameters is determined in one of the two ways as described in the Void pointers subsection of the MIL custom data types, void pointers, extensions, and portability functions section earlier in this chapter. For the 64-bit version of MIL, you will have to use the required custom data types documented as of MIL 9.0. For example, the following code for the 32-bit version of MIL: long SizeX; MbufInquire(BufId, M_SIZE_X, &amp;SizeX); Should be changed for the 64-bit version of MIL as follows: MIL_INT SizeX; MbufInquire(BufId, M_SIZE_X, &amp;SizeX); M_MIL_USE_SAFE_TYPE extension When using void pointers, it is possible to make a mistake and pass a value with the wrong data type. These errors can cause unexpected behavior such as: stack corruption, array overflow, uninitialized returned data, and segmentation faults. To ease the transition from 32-bit to 64-bit, use the MIL M_MIL_USE_SAFE_TYPE extension. It will help you find calls to functions whose prototypes have been modified. By default, the M_MIL_USE_SAFE_TYPE extension is enabled when compiling in debug mode. For more information about the M_MIL_USE_SAFE_TYPE extension, see the MIL custom data types, void pointers, extensions, and portability functions section earlier in this chapter. Note that this extension is not supported under Linux. Project processor definitions When porting an application to MIL 64-bit, you must verify that your project processor definitions (PPDs) include WIN64 and _AMD64 (these PPDs appear in the Properties page of your application). Your application will not compile if it is missing WIN64 and _AMD64. Not supported under Linux. Porting a 32-bit MIL application to MIL 64-bit Modified functions Retrieving a pointer to a modified function Void pointers M_MIL_USE_SAFE_TYPE extension Project processor definitions ",
      "wordCount": 709,
      "subEntries": []
    },
    {
      "id": "UG_building-application_Working_with_files",
      "version": null,
      "title": "Working with files",
      "subTitles": [
        "Moving, sharing, and searching for files",
        "Additional functionality for DMIL",
        "Importing and exporting data"
      ],
      "location": "MIL UG P02: MIL in a nutshell",
      "pageURL": "content\\UserGuide\\building-application\\Working_with_files.htm",
      "text": " Working with files MIL provides several useful functions for working with files. Using MIL functions, you can import and export images, 3D data, and MIL contexts in various formats. You can also move. copy, delete, and search for files on the local computer in an operating-system independent way, and host files on the local computer using HTTP so that they can be accessed by a web browser on a remote computer. In a DMIL application, you can also share files (including DLLs) between computers, and execute programs on a remote computer. Moving, sharing, and searching for files You can move, copy, delete, and search for files using MappFileOperation(). This function is supported for both Windows and Linux, increasing the portability of your MIL application. You can also use this function to execute a program on the local computer. MappFileOperation() is particularly useful to manage the files used by a simulated digitizer (which grabs images from a specified folder instead of a camera). You can use this function to confirm which files are present in the images folder, and to add or remove images at runtime. For more information about simulated digitizers, see the Simulated digitizer section of Chapter 27: Grabbing with your digitizer. A local computer on the network can host files using a MIL HTTP server, allocated using MobjAlloc() with M_HTTP_SERVER. Hosted files can then be accessed in a web browser by remote computers and other devices (such as smart phones and tablets). For more information, see the Hosting files on a MIL HTTP server section of Chapter 63: Hosting files on a MIL HTTP server. Additional functionality for DMIL When developing a distributed application using DMIL, you might need to share files between computers. You can specify an application context on a remote computer as a source or destination for MappFileOperation(); this allows you to easily transfer files between MIL applications with a single function call. This function is particularly useful for copying custom MIL functions created using the Function Development module (Mfunc...()). For example, you can use MappFileOperation() with M_FILE_EXISTS_MIL_USER_DLL to confirm whether a remote computer has a required user DLL, and if not, you can copy that DLL to the remote computer using M_FILE_COPY_MIL_USER_DLL. You can also use MappFileOperation() to execute a program on the remote computer. The capability to execute programs on a remote computer has security implications. You are responsible for ensuring that the program executed by the remote DMIL application is in fact the program that you requested. MappFileOperation() cannot execute a program on a remote computer unless that computer is running a connected DMIL application. Importing and exporting data You can save and load most types of MIL objects to a file, using a function from the module that you used to allocate the object. For example, you can allocate a blob context using MblobAlloc(), save it using MblobSave(), and restore it using MblobRestore(). You can also save or restore the blob context to or from a memory stream using MblobStream(). You can save and load image buffers and 3D-processable containers to and from standard file formats that are supported by a wide variety of applications (for example, PNG and BMP files for images and PLY or STL files for 3D data). You can also save a buffer or container with all of its attributes and settings, using the MIL native file format. For more information about saving and loading buffers, see the Loading a data buffer subsection of the Managing data buffers section of Chapter 23: Data buffers. Most of the information in that section also applies to 3D-processable containers. Typically, when saving and loading files with MIL, you should use the file extensions listed in the MIL file extension list section later in this chapter. Working with files Moving, sharing, and searching for files Additional functionality for DMIL Importing and exporting data ",
      "wordCount": 644,
      "subEntries": []
    },
    {
      "id": "UG_building-application_MIL_extensions",
      "version": null,
      "title": "MIL file extension list",
      "subTitles": null,
      "location": "MIL UG P02: MIL in a nutshell",
      "pageURL": "content\\UserGuide\\building-application\\MIL_extensions.htm",
      "text": " MIL file extension list The following is a list of all the various MIL file extension types that the various MIL module's functions can read from and/or write to; this includes but is not limited to saving or loading contexts, images, and result buffers. The modules that do not support saving or loading are indicated as such in the table below. Note that MIL will generally determine the compatibility of a file based on the data within the file, and not on the file extension itself. Abbreviation Module name Proprietary file extension Other file extensions Magm Advanced Geometric Matcher .magm .dxf (to define a single-definition model from a CAD DXF file) Mapp Application Not applicable Not applicable Mbead Bead .mbead, (.bcf deprecated) Not applicable Mblob Blob Analysis Not applicable Not applicable Mbuf Buffer .mbuf, .mbufc, .mim .avi, .bmp, .gendc, .png, .ply, .raw, .stl, .tiff, .jp2, .jpeg/jpg Mcal Camera Calibration .mca, .mim (if saved with an image) Not applicable Mclass Classification .mclass, .mclassd .csv, .dot, .onnx, .txt Mcode Code .mco (for a MIL Code reader context) .txt (for a code report) Mcol Color Analysis (Color Matching context) .mcol (for a color matching context) Not applicable Color Analysis (Relative Color Calibration context) .mccc (for a relative color calibration context) Not applicable Mcom Industrial Communication Not applicable Not applicable Mdig Digitizer .dcf (digitizer configuration format) Not applicable Mdisp Display .vcf Not applicable Mdlocr Deep Learning OCR .mdlocr Not applicable Mdmr SureDotOCR .mdmr (for a SureDotOCR context), .mdmrf (for a SureDotOCR font) Not applicable Medge Edge Finder .mef .dxf (for an Edge Finder CAD result buffer) Mfpga FPGA .mbf Not applicable Mfunc Function Development Not applicable .dll Mgen Data Generation Not applicable Not applicable Mgra Graphics Not applicable Not applicable Mim Image Processing .mic Not applicable Mmeas Measurement .mrk Not applicable Mmet Metrology .met Not applicable Mmod Geometric Model Finder .mmf .dxf (to define a synthetic model) Mobj MIL objects Not applicable Not applicable Mocr Optical Character Recognition .mfo Not applicable Mpat Pattern Matching .mpat, (.mod deprecated) Not applicable Mreg Registration .mreg, (.mrf deprecated) Not applicable Mseq Sequences Not applicable .avi, .mpeg4/mp4 (with H .264 encoding) Mstr String Reader .msr any system font file supported by your operating system Msys System Not applicable Not applicable Mthr Thread Not applicable Not applicable Profiler Matrox Profiler .mtrace Not applicable M3dblob 3D Blob .m3dblob Not applicable M3dim 3D Image Processing .m3dim Not applicable M3dmap 3D Reconstruction .m3d .ply, .stl M3dmeas 3D Measurement .m3dmeas Not applicable M3dmet 3D Metrology .m3dmet Not applicable M3dmod 3D Model Finder .m3dmod Not applicable M3dreg 3D Registration .m3dreg Not applicable MIL file extension list ",
      "wordCount": 433,
      "subEntries": []
    },
    {
      "id": "UG_building-application_MIL_under_Linux",
      "version": null,
      "title": "MIL under Linux",
      "subTitles": null,
      "location": "MIL UG P02: MIL in a nutshell",
      "pageURL": "content\\UserGuide\\building-application\\MIL_under_Linux.htm",
      "text": " MIL under Linux Using MIL under Linux is very similar to using it under Windows. The remaining chapters of this User Guide describe how to use MIL under Windows. For a list of the differences of using MIL under Linux, see the Working with Linux section of Chapter 61: Using MIL under Linux. The MIL Reference contains information that applies to both the Linux and Windows operating systems. To view only Linux-related information, click on the Customize Help button at the top of any reference page. In the presented page, you can select Linux as your operating system. MIL under Linux ",
      "wordCount": 103,
      "subEntries": []
    },
    {
      "id": "UG_building-application_How_to_create_a_portable_application",
      "version": null,
      "title": "How to create a portable application",
      "subTitles": null,
      "location": "MIL UG P02: MIL in a nutshell",
      "pageURL": "content\\UserGuide\\building-application\\How_to_create_a_portable_application.htm",
      "text": " How to create a portable application You can create a more portable, device-independent, and operating system-independent application if you use the following coding techniques in your application: Limit the amount of MIL system-specific code (for example, MIL system-specific control types and inquire types) in your application. Use the defaults when allocating your system and other MIL objects (for example, your digitizer, buffer, and display). By doing this, you create a more portable application, since these settings are not hard-coded in your application, and are determined when the user installs the MIL software. For more information on using the defaults, see the Using the defaults section earlier in this chapter. Use MIL's custom data types and portability functions, as outlined in the MIL custom data types, void pointers, extensions, and portability functions section earlier in this chapter, instead of their operating system-specific equivalents. Avoid operating system-specific features (for example, using MbufAlloc2d() with M_DIB, which is specific to a Windows-based operating system). How to create a portable application ",
      "wordCount": 168,
      "subEntries": []
    },
    {
      "id": "UG_building-application_MIL_with_.NET",
      "version": null,
      "title": "MIL with.NET and Python",
      "subTitles": [
        "MIL with.NET",
        "MIL with Python"
      ],
      "location": "MIL UG P02: MIL in a nutshell",
      "pageURL": "content\\UserGuide\\building-application\\MIL_with_.NET.htm",
      "text": " MIL with .NET and Python Several wrappers are included with the installation of MIL. These are the MIL.NET wrapper and the MIL Python wrapper. These wrappers allow you to make use of MIL functions while writing applications in a MIL-supported .NET language (C#), or in Python. MIL with .NET The MIL .NET wrapper is a set of classes, structures, and delegates that allows you to use MIL in a C# .NET managed environment. To work in a managed .NET environment, you must first reference the Matrox.MatroxImaginglibrary.dll assembly in Visual Studio. Using MIL with managed C# is very similar to using MIL with unmanaged C or C++, as long as you keep in mind the characteristics of managed code, specifically the common language runtime and its garbage collector. Managed code handles the automatic release of unused resources like .NET strings objects. In addition, the required size for a StringBuilder parameter is automatically established when used, and will be automatically resized if needed. When using the MIL .NET wrapper, all MIL functions and constants are exposed as methods and constants respectively of a class called MIL. For more information on writing C# code that calls MIL functions, see the MIL with .NET overview section of Chapter 60: Using MIL with .NET. MIL with Python The MIL Python wrapper is a Python library (module) that allows you to use MIL functions while writing code in Python language. To use MIL functions and constants in Python, you must reference the MIL wrapper within your application as described in the Importing required libraries and distribution of a MIL application in Python section of Chapter 59: Using MIL with Python. Using MIL with Python is very similar to using MIL with C or C++ with a few exceptions. When using the MIL Python wrapper, all MIL functions and constants are defined in the MIL Python library (module), and when used, must be preceded with \"MIL.\" throughout your Python code. For more information on writing Python code that calls MIL functions, see the MIL with Python overview section of Chapter 59: Using MIL with Python. For information on the supported versions of .NET and Python, see the whatsnew release note. MIL with.NET and Python MIL with.NET MIL with Python ",
      "wordCount": 374,
      "subEntries": []
    },
    {
      "id": "UG_building-application_Using_MIL_Addon_to_Visual_Studio",
      "version": null,
      "title": "Using MIL add-on to Visual Studio",
      "subTitles": [
        "MIL menu and toolbar",
        "F1 contextual help",
        "Statement completion"
      ],
      "location": "MIL UG P02: MIL in a nutshell",
      "pageURL": "content\\UserGuide\\building-application\\Using_MIL_Addon_to_Visual_Studio.htm",
      "text": " Using MIL add-on to Visual Studio MIL provides an extension to Microsoft Visual Studio users to assist in developing MIL applications. This includes a menu and toolbar added to Microsoft Visual Studio, as well as F1 contextual help and statement completion (IntelliSense) for projects written in C++ or C#. MIL add-on to Visual Studio is automatically installed whenever MIL is installed on a computer with a supported version of Microsoft Visual Studio. To verify that the extension has been properly installed, open the Extensions and updates dialog box in Microsoft Visual Studio; MIL add-on to Visual Studio should appear in the list presented in the dialog box. By default, all features of the MIL add-on to Visual Studio are enabled. In the MIL add-on to Visual Studio pane of the MILConfig utility (located by expanding the Benchmarks and Utilities item and selecting the MIL add-on to Visual Studio sub-item in the presented tree structure), you can enable or disable the features of the MIL add-on to Visual Studio. This pane provides a checkbox that indicates whether to enable the add-on. In addition, if the add-on is enabled, you can disable statement completion in any of the three supported languages. Disabling any of the checkboxes and clicking on the Apply button will disable those features. In this way, you can also install the add-on if it was not previously installed, which can be used if you install Microsoft Visual Studio after installing MIL and want to use the extension. Microsoft Visual Studio must be closed whenever changing the extension's settings. MIL menu and toolbar MIL add-on to Visual Studio adds a menu to Microsoft Visual Studio's menu bar called MIL. This menu allows you to access MIL tools, adjust your preferences, read documentation about the MIL add-on to Visual Studio, and change the settings of MIL add-on to Visual Studio in the MILConfig utility. Additionally, you can add a toolbar to your Microsoft Visual Studio window that contains links to MIL tools. The toolbar is not visible by default. See the Microsoft Visual Studio help to add the toolbar. F1 contextual help MIL add-on to Visual Studio provides F1 contextual help for MIL code. To see the MIL Reference page for a particular function, place your cursor on or highlight the function and press F1. This will open the MIL Help file in a window that is part of the current Microsoft Visual Studio instance. Note that this Help file will have the default saved settings (such as, MIL systems or Product settings) as that of the installed MIL Help and cannot save different (custom) settings. To see the information for a specific MIL value, place your cursor on or highlight the value and press F1. The value must be used in the correct contextual location of its corresponding function and parameter. For example, if you want to see the description for the M_BACKGROUND_COLOR value of MdispControl(), M_BACKGROUND_COLOR must be passed to the second parameter of MdispControl(). Contextual help only works on MIL values (all values that begin with M...); it will not work on text strings (values encapsulated in MIL_TEXT) and user-defined variables or numerical values. If contextual help is requested for a value and the value cannot be found, the MIL Reference page for the function will be opened instead. Contextual help can also be requested for MIL custom data types (for example, MIL_ID) or a portability function (for example, MosMain()). If you place your cursor or highlight a MIL custom data type or portability function, the Help file opens the MIL custom data types, void pointers, extensions, and portability functions section earlier in this chapter. Note that when you first open MIL Help with F1, you might need to wait a few moments before the Help file opens. Also if you are opening the MIL Help for the first time, it might open the Customize MIL Help section of Chapter 0: About MIL Help. Statement completion MIL add-on to Visual Studio provides statement completion to users writing MIL code in C++ and C#. Statement completion makes developing with MIL easier by providing quick access to MIL functions and values through IntelliSense. Statement completion for MIL will work on any file that Microsoft Visual Studio recognizes as a C++ or C# file. When you start typing in a file for the supported languages in Microsoft Visual Studio, the IntelliSense session will display all MIL functions available. Alternatively, you can use Ctrl + Spacebar to start an IntelliSense session. To add a MIL function from the displayed list, highlight it and then press the Tab key. If a function's parameter can take a MIL value as possible settings, IntelliSense can display a list of suggested MIL values that you can use. When an IntelliSense session is opened upon specifying a parameter setting in a MIL function, a tab will appear in the IntelliSense list called Suggested MIL values. If the Prioritize Suggested MIL Values item under Preferences in the MIL menu is enabled, this tab will appear by default. If it is not the default tab shown, click on the Suggested MIL Values tab or press Alt + . to bring up all the documented MIL values that can be used as a parameter setting. If you highlight an item in the displayed list, a tooltip will display the description for that MIL value, the installed MIL systems it supports, and any possible combination values (if available). If M_DEFAULT is available, it will be listed first. To add a MIL value from the displayed list, highlight it and press the Tab key. The descriptions in the Help file might be more up-to-date than those presented in the IntelliSense tooltip. Note that Suggested MIL values are not fully supported through IntelliSense when importing static members in C# with the using static directive (using static Matrox.MatroxImagingLibrary.MIL;). For parameters that require a MIL constant in C#, IntelliSense will only suggest MIL values when using explicit qualifications at the parameter level. The following example demonstrates this. MIL.M3ddispSetView(SceneDisplay, MIL.M_AUTO, MIL.M_TOP_TILTED, MIL.M_DEFAULT, MIL.M_DEFAULT, MIL.M_DEFAULT); When explicitly typing the MIL. prefix at the parameter level, IntelliSense will suggest a MIL constant for the specific parameter (for example, MIL.M_AUTO). For parameters that require a string, IntelliSense will suggest values appropriately. If you start an IntelliSense session and a suggested value has a combination value available, IntelliSense will say (combinations available) next to the value's name and the tooltip will list the possible combination values. If you select a value with combinations available and you type a +, you can start a new IntelliSense session that presents a list of the available combinations. Note, however, that if a combination value has combinations available, they will not be listed in a new IntelliSense session. If the value of a parameter is dependent on the value of another parameter, you must specify the parameter on which it is dependent first. For example, possible values in MdigControl() for the ControlValue parameter are dependent on the setting of the ControlType parameter, so you must specify a value for the ControlType parameter for IntelliSense to present a list of the possible values for the ControlValue parameter. IntelliSense will only suggest values for input parameters and for values listed in a table. Values that have not been formally documented (for example, a value mentioned in the release note of a MIL driver update) will not be displayed in IntelliSense. Any value that is not supported on the systems that you have installed will be filtered by default; to change this behavior, disable the Filter Suggested MIL Values by Installed Systems option under Preferences in the MIL menu. Although values are suggested, values such as an integer value might be possible as a parameter setting, but are not listed in IntelliSense. See the appropriate reference page for more information. Using MIL add-on to Visual Studio MIL menu and toolbar F1 contextual help Statement completion ",
      "wordCount": 1320,
      "subEntries": []
    }
  ]
}]
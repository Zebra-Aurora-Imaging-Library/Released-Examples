[{
  "id": "UG_debugging_tools",
  "version": "2024020714",
  "title": "Development and debugging tools and techniques",
  "subTitles": null,
  "location": "MIL UG P11: Miscellaneous",
  "pageURL": "content\\UserGuide\\debugging_tools\\ChapterInformation.htm",
  "text": " Chapter 64: Development and debugging tools and techniques This chapter describes various tools and techniques that can be used to debug or optimize your MIL application. Matrox Profiler and trace logs Trace logs with Matrox Profiler Generating a new trace log with Matrox Profiler Reading a trace log Trace logs to file with or without Matrox Profiler Advanced trace log options Trace logs in a multi-thread environment Trace-enabled/disabled blocks of code Trace markers Advanced memory tracing User-defined trace log Generating a new trace log under Linux Using Matrox Profiler in a Distributed MIL environment Interactive log MIL errors Types of errors API errors Production errors Detecting MIL errors Interpreting error codes, subcodes, and opcodes Asynchronous MIL functions Errors in multi-threaded applications Errors in user-defined MIL functions ",
  "wordCount": 128,
  "subEntries": [
    {
      "id": "UG_debugging_tools_Matrox_Profiler",
      "version": null,
      "title": "Matrox Profiler and trace logs",
      "subTitles": [
        "Trace logs with Matrox Profiler",
        "Generating a new trace log with Matrox Profiler",
        "Reading a trace log",
        "Trace logs to file with or without Matrox Profiler",
        "Advanced trace log options",
        "Trace logs in a multi-thread environment",
        "Trace-enabled/disabled blocks of code",
        "Trace markers",
        "Advanced memory tracing",
        "User-defined trace log",
        "Generating a new trace log under Linux",
        "Using Matrox Profiler in a Distributed MIL environment",
        "Interactive log"
      ],
      "location": "MIL UG P11: Miscellaneous",
      "pageURL": "content\\UserGuide\\debugging_tools\\Matrox_Profiler.htm",
      "text": " Matrox Profiler and trace logs To analyze your application's execution, for debugging or optimization, you can generate a MIL trace log that contains information such as when each MIL function call in each thread starts and stops. Matrox Profiler is a utility that creates and graphically displays MIL trace logs. In addition to Matrox Profiler, there are MIL functions that can create or enhance trace logs. Trace logs with Matrox Profiler Matrox Profiler is a graphical tool that generates and graphically displays trace logs. It is accessible from the tools section of the MIL Control Center when running any Microsoft Windows operating system. When running Linux, you must use a different mechanism (discussed later) to generate the trace log and then you can use Matrox Profiler under a Microsoft Windows operating system to display the trace log. For more information, see the Generating a new trace log under Linux subsection of this section. Generating a new trace log with Matrox Profiler When using Matrox Profiler to generate a new trace log, you must open the tool and start the log before you run the code that should be traced. To create a new trace log, choose Generate New Trace from the File menu of Matrox Profiler. You can also click on the New Trace icon or press Ctrl-N. The Trace Generation dialog box will appear, which you must keep open until the initialization of your MIL application (that is, a MIL application context has been allocated), although you can keep the dialog box open during the execution of your code. In the Trace Generation dialog box, you can choose to save trace information to file or to memory. Generating a trace to memory has the advantage that it is faster than generating a trace to file. Another advantage is that, as long as either your application or Matrox Profiler is open, the memory in which the trace log is allocated will remain reserved for that purpose and the trace will continue. You could close Matrox Profiler, re-open it, and pick up the same trace log to see the latest trace element (that is, the latest activity within your program). Alternatively, while keeping Matrox Profiler open, you can click on Reload at any time to see the latest activity in the trace log. This allows you to pick up the trace log in the middle of a program and evaluate it. The disadvantage of generating a trace to memory is that it is almost impossible to store the complete trace of your program within the allocated memory; at some point, the memory will get overwritten with the latest trace elements. If there are moments in the application for which you want to review the trace, you can save the data that is currently in the circular memory buffer to file using M_TRACE_SAVE_TO_FILE as shown in the Advanced memory tracing subsection of this section. On the other hand, generating a trace to file will save a complete trace of your program, starting from when the trace was enabled. For more information about saving a trace to file, see the Trace logs to file with or without Matrox Profiler subsection of this section. If you choose to generate a trace to memory, you can choose the type and size of memory in which to store the trace(s), or you can choose to use the default options. You can either choose to allocate the trace log in shared memory or non-paged memory (if the MIL non-paged memory manager driver has been installed; for more information, see the Advanced memory management section of Chapter 23: Data buffers). An advantage to allocating the trace log in non-paged memory is that, in the event of a crash, the trace can be recovered from the dump file generated by Windows (assuming that generating a kernel dump file upon a Windows crash has been enabled for your computer). By default, Matrox Profiler tracks many types of program data. You can be more selective by clicking on the Select the types of elements to include in the trace button in the Trace Generation dialog box before running your application. Note that when a MIL application context is initially allocated, MappAlloc() can be set to M_TRACE_LOG_DISABLE, which automatically disables the generation of any trace logs. Once disabled, Matrox Profiler will not be able to generate a trace log without you calling MappControl() with M_TRACE set to M_LOG_ENABLE. Note that if Matrox Profiler is not open, this will start generating a trace log to file. See the Trace logs to file with or without Matrox Profiler subsection of this section for more information. Disabling the automatic generation of a trace log with M_TRACE_LOG_DISABLE will help protect your intellectual property against reverse engineering. Reading a trace log Once a trace log has been generated, it can be examined with Matrox Profiler by clicking on Load from the Trace Generation dialog box. This will bring you to the main Matrox Profiler window in which you can evaluate your trace log. A trace log can display multiple concurrent threads, each with sequential function calls and other useful information, such as pop-up messages or MIL errors, all placed in a single time frame. The information is organized in stacks of rows, with each row representing a thread. In each row, there are blocks that represent function calls or other information. Within the blocks, there can be other blocks, such as display update blocks, as shown in the image below. These inner blocks are within a larger block because the inner blocks represent operations that are called by the outer block, and they start and stop within the time frame of the outer block. The following image displays a trace log with five threads. The top row is the first thread that allocates the other four threads. The bottom thread is not being displayed since its display was toggled using the arrow next to the thread's name; collapsing blocks allows you to examine only the threads of interest. The time frame of the trace log is found above the top thread and is measured in seconds. You can zoom in or out, expanding or contracting the time frame, using the zoom buttons in the toolbar, or by scrolling with your mouse wheel. There could be many function calls that don't appear when viewed in one time frame, and then become apparent only when zooming in on an area; if you zoom out, they will disappear again. The following image displays the same trace log as above, only with a different time frame. Note the time frame has a different number of decimal places. You can get additional information about a block by selecting it. The information includes the function call with the parameter values, the precise start and stop time for the function, and can include additional parameter details, such as a MIL_ID associated with the call. You can find this information at the bottom of the window. You can search for a particular function call or MIL_ID using the search pane on the right. Trace logs to file with or without Matrox Profiler To generate a trace log to file without Matrox Profiler, you must enable tracing by calling MappControl() with M_TRACE set to M_LOG_ENABLE. A trace log will be generated from the point in your code that this call appears until the end of the application, or until you call MappControl() with M_TRACE set to M_LOG_DISABLE, whichever comes first. The trace log is stored as a binary file that can only be read by Matrox Profiler. The trace log's file name includes the name of the application it traced, and has a .mtrace extension, located in the %temp% directory. Note that since the trace log is written to file, calls to MappControl() with M_TRACE set to M_LOG_ENABLE in your code will generate a new trace log file each time the code is run, which could fill your available storage unnecessarily. When tracing to file, you can use MappControl() with M_TRACE_SAVE_TO_FILE to force all outstanding writes to be performed to the trace log file. This allows you to access trace data even if the application crashes after the call. To generate a trace log to file with Matrox Profiler, choose Trace to file in the Trace Generation dialog box. The trace log is stored in a hidden folder called C:\\programdata\\Matrox Imaging\\Profiler. Advanced trace log options There are several MIL functions that can be helpful when generating a trace log with either Matrox Profiler or with MIL functions. These MIL functions allow you to limit the scope of the trace log to blocks of code, add user markers or sections that are read by the trace log, and get time stamps from MIL trace timer. Trace logs in a multi-thread environment By default, all threads in a multi-thread environment share the same global trace state, either enabled or disabled. If any thread calls MappControl() with M_TRACE, the global trace state is changed, which affects all threads equally. If a thread calls MappControl() with M_TRACE + M_THREAD_CURRENT set to either M_LOG_ENABLE or M_LOG_DISABLE, the thread creates its own thread trace state. The thread trace state supercedes the global trace state for that thread. For example, if the global trace state for the application is currently set to disabled, but one thread has an independent thread trace state set to enabled, the trace log will only be filled with trace data from that one thread, leaving all other threads untraced. When allocating a new thread using MthrAlloc() with M_THREAD or M_SELECTABLE_THREAD, you can choose to use the default initialization state or you can choose to disable the creation of trace logs (M_TRACE_LOG_DISABLE) for that thread. In effect this allows newly allocated traces to create an independent thread trace state. Once a thread has created its own independent thread trace state, it remains independent, regardless of changes to the global trace state. For example, if one thread calls MappControl() with M_TRACE + M_THREAD_CURRENT set to M_LOG_ENABLE, that thread will be traced. If afterwards any thread (including the independent thread) calls MappControl() with M_TRACE set to M_LOG_DISABLE, the thread with the independent thread trace state will remain enabled. Once a thread has its own thread trace state, it remains independent until the thread calls MappControl() with M_TRACE + M_THREAD_CURRENT set to M_DEFAULT. This sets the thread trace state to the global thread state, and the thread is no longer independent. Note that if the application has been set to disable all trace logs, and you allocate a new thread using MthrAlloc() with M_THREAD or M_SELECTABLE_THREAD which then calls MappControl() with M_TRACE + M_THREAD_CURRENT set to M_DEFAULT, even while running Matrox Profiler, nothing will happen because you have not enabled the global trace. Trace-enabled/disabled blocks of code By default, Matrox Profiler starts a trace upon the execution of your application and continues for the entire execution. However, your application can be configured to limit the trace to a block of code inside your application. You can create a block of code that is either trace-enabled, where only the code within the block will generate trace log data, or trace-disabled, where all your application code except that which is in the block will generate trace log data. To create a trace-enabled block of code, which will generate trace data only for the code within the block, you must first disable the trace when you allocate your application context (MappAlloc() with M_TRACE_LOG_DISABLE). Then, you can create a trace-enabled block by calling MappControl() with M_TRACE + M_THREAD_CURRENT set to M_LOG_ENABLE at the start of the block and then call MappControl() with M_TRACE + M_THREAD_CURRENT set to M_LOG_DISABLE at the end. When you run Matrox Profiler, only the portion of the code inside the block will be logged. Conversely, to keep a portion of your code from being traced while tracing the rest of your application, you can create a trace-disabled block of code. By default, Matrox Profiler will start tracing at the beginning of the application, so the first mention of the trace-disabled block is at the start of the block. At the start of the trace-disabled block of code, call MappControl() with M_TRACE + M_THREAD_CURRENT set to M_LOG_DISABLE and finish the block with MappControl() with M_TRACE + M_THREAD_CURRENT set to M_LOG_ENABLE. As expected, when generating a trace to memory, tracing continues from where it left off in the circular buffer when tracing is enabled. To determine if a thread is currently tracing a particular block of code, you can call MappInquire() with M_TRACE_ACTIVE. This inquire type will indicate whether the current thread is actively tracing (M_YES) the portion of code being executed or not (M_NO). This inquire type is recommended over using M_TRACE because it will return M_YES or M_NO as opposed to possibly returning M_DEFAULT. When creating trace-enabled/disabled blocks of code for multi-threaded applications, you typically generate trace-enabled/disabled blocks for a specific thread using M_TRACE + M_THREAD_CURRENT. Specifying M_THREAD_CURRENT when starting or stopping trace log data generation will limit the trace-enabled/disabled block of code to the thread that called it. All other threads will continue to generate or not generate trace log data, based on the global trace state. However, if you specify only M_TRACE, when a enabled/disabled block is entered, data will be logged or disabled for all threads that do not have an independent thread trace state, regardless of which thread specified the enabled/disabled block. Trace markers You can fine tune the trace log data, regardless of whether the log was generated using Matrox Profiler or with MIL functions. MappTrace() helps identify important pieces of code by creating a marker or section near or surrounding your code. Place MappTrace() next to a piece of code that needs attention. You can also create a section by calling MappTrace() twice, once before the code to observe, and once after it, setting TraceType to M_TRACE_SECTION_START and M_TRACE_SECTION_END, respectively. You can identify the marker or section by passing MappTrace() a tag (a unique value). Once the trace log is generated, you will be able to search for the markers and sections you created. For each marker or section, you can also specify a value or string to associate with it, using TraceValue and/or TraceString, respectively. Typically, these values would relate to the code that the marker or section identifies, such as a return value, intermediate result, or some other relevant value or string. You can also add additional information to the trace tag by setting TraceType to M_TRACE_SET_TAG_INFORMATION. This allows you to set a name and/or a color to associate with a particular trace tag. All trace markers or sections that have the same tag will have the same name and/or color associated with it. Advanced memory tracing In the Generating a new trace log with Matrox Profiler subsection of this section, it was discussed that one of the disadvantages of generating traces to memory is that it is almost inevitable that the reserved memory will be filled at some point and get overwritten with newer data. To evaluate sections of code that are of particular interest, you can choose to save that particular portion of the trace to file using M_TRACE_SAVE_TO_FILE. This control type will copy the contents of the trace logs' circular memory buffer into an .mtrace file, which can then be read with Matrox Profiler. This is useful when you are trying to debug a particular segment of your application. As has been previously discussed, the trace file will only contain the most recent trace elements and not the complete application due to the limitations of tracing to memory. User-defined trace log You can create your own user-defined trace log, which you can compare to the trace log created with Matrox Profiler. One way to do this is to hook a user-defined function to MappHookFunction() with HookType set to M_TRACE_START or M_TRACE_END. To compare your user-defined trace log with the trace log created with Matrox Profiler, it can be useful to add time stamps to your user-defined trace log. Insert these time stamps in your code using MappTimer() with M_TIMER_READ + M_TRACE. Note that Matrox Profiler uses MappTimer() with an M_TRACE timer to generate its internal time stamps. Generating a new trace log under Linux Matrox Profiler is a tool used to create and read trace logs, but it only functions in a Microsoft Windows environment. Under Linux, there is another tool to create the trace logs, but you will still need to run Matrox Profiler in Windows to read the trace log. To create a MIL trace log under Linux, open the MILConfig utility. From there, there is an option called MIL Profiler trace. When selected, click on the Start interactive trace button in the presented dialog. A Trace Generation dialog box appears. This dialog box instructs you to run your code while the dialog box is open. While the dialog box is open, and the code is running, a trace is generated. When you either close the dialog or terminate your running program, the trace log stops being generated and is saved in a directory whose path appears in the MILConfig utility. Using Matrox Profiler in a Distributed MIL environment When tracing a Distributed MIL cluster, you can generate trace logs, but each computer, local and remote, must run its own instance of Matrox Profiler. Each computer will generate its own trace log and will collect information specific to itself only. Note that asynchronous functions called from the local computer, but run on a remote computer, will appear to have a very short duration. This does not represent the time taken to run the function, but only the time taken to offload the function to the remote computer. The duration of that function would appear in the trace log of the remote computer on which it was run. Interactive log While troubleshooting with Matrox technical support, you might be instructed to create an interactive log, which contains a trace log. From the MILConfig utility, click on the Troubleshooting tab and then click on the Start Interactive log button. This opens a dialog box that instructs you to run your code while the dialog box is open. While the dialog box is open, and the code is running, an interactive log is generated. When you either close the dialog box or terminate your running program, the interactive log stops being generated and is saved in a directory whose path appears in the MILConfig utility. The result of running an interactive log is a Sysinfo file. This Sysinfo file cannot be read by Matrox Profiler and should be sent to Matrox for troubleshooting. Note that to limit the tracing information contained in the interactive log, you should create a block of code that is either trace-enabled, where only the code within the block will generate trace log data, or trace-disabled, where all the code except within the block will generate trace log data. For information on these code blocks, see the Trace-enabled/disabled blocks of code subsection of this section. You should use Matrox Profiler and optionally a user-defined trace log for your own tracing needs. Matrox Profiler and trace logs Trace logs with Matrox Profiler Generating a new trace log with Matrox Profiler Reading a trace log Trace logs to file with or without Matrox Profiler Advanced trace log options Trace logs in a multi-thread environment Trace-enabled/disabled blocks of code Trace markers Advanced memory tracing User-defined trace log Generating a new trace log under Linux Using Matrox Profiler in a Distributed MIL environment Interactive log ",
      "wordCount": 3255,
      "subEntries": []
    },
    {
      "id": "UG_debugging_tools_MIL_errors",
      "version": null,
      "title": "MIL errors",
      "subTitles": [
        "Types of errors",
        "API errors",
        "Production errors",
        "Detecting MIL errors",
        "Interpreting error codes, subcodes, and opcodes",
        "Asynchronous MIL functions",
        "Errors in multi-threaded applications",
        "Errors in user-defined MIL functions"
      ],
      "location": "MIL UG P11: Miscellaneous",
      "pageURL": "content\\UserGuide\\debugging_tools\\MIL_errors.htm",
      "text": " MIL errors MIL provides tools for detecting errors generated by calls to MIL functions. Types of errors MIL errors are broadly classed as either API errors which result from passing invalid values to a parameter of a MIL function, or production errors which result from unexpected events (for example, communication with your camera timing out during a grab). You can use similar techniques (detailed later in this section) to detect both types of errors. API errors An API error is a runtime error caused by an improper call to a MIL function. An API error occurs when you have passed the correct number and type of values to a MIL function (allowing you to compile your application), but one or more of the values you passed is not supported by the function. API errors must be resolved during development, before you deploy your application. You can disable MIL's internal checks for API errors using MappControl() with M_PARAMETER and M_CHECK_DISABLE. This improves the performance of your application, but will lead to undefined behavior if your application contains API errors. You should ensure that these checks are not disabled when developing, modifying, or debugging your application. The following are common examples of API errors: Passing the identifier a MIL object of the wrong type. A MIL identifier can potentially refer to any type of MIL object. However, most MIL function parameters only accept one or two types of MIL object. Passing the identifier of an object of the wrong type to a MIL function will generate a MIL error. For example, in the following code snippet, the identifier of a MIL system is incorrectly passed to MdigFree() (which requires the identifier of a MIL digitizer): /* This code will generate a runtime error */ MIL_ID MilApplication = MappAlloc(M_NULL, M_DEFAULT, M_NULL); MIL_ID MilSystem = MsysAlloc(MilApplication, M_SYSTEM_DEFAULT, M_DEFAULT, M_DEFAULT, M_NULL); MdigFree(MilSystem); Note that this error is easy to identify because the variable name MilSystem incorporates the type of the object it identifies. Typically, you should follow a similar convention when naming variables in your application. Additionally, you should only use a MIL_ID variable to store identifiers for a single type of MIL object. You can check the object type for any MIL identifier using MobjInquire() with M_OBJECT_TYPE. Passing unavailable values to dependent parameters. For many MIL functions, the value passed to one parameter changes which values can be passed to another parameter. These are referred as independent parameters and dependent parameters, respectively. Passing an unsupported value to a dependent parameter will generate a MIL error. For example, if you set the ControlType parameter of MdispControl() to M_BACKGROUND_COLOR, you can set the ControlValue parameter to a value that indicates a color (such as M_COLOR_MAGENTA). However, if you set the ControlType parameter to M_KEYBOARD_USE, different settings are available for the ControlValue parameter (such as M_ENABLE). In another example, the ImageOrGraphicListId parameter of MbufSetRegion() requires that you pass a different type of object depending on the setting of the Operation parameter. If you set the Operation parameter to M_RASTERIZE, you can set the ImageOrGraphicListId parameter to the identifier of either an image buffer or a 2D graphics list (or M_NULL). However, if you set the Operation parameter to M_NO_RASTERIZE, you must set the ImageOrGraphicListId parameter to the identifier of a 2D graphics list. Passing data of the incorrect type to void pointer parameters. Some MIL function parameters require you to pass a void * that points to data of a specific type. The required type of the data changes depending on the settings you use for other parameters. Passing a pointer to the wrong type of data can sometimes generate a MIL error. Passing a pointer to the wrong type of data does not always generate a MIL error in C. However, in C++, this type of error is detected by default using the optional M_MIL_USE_SAFE_TYPE extension. For more information, see the M_MIL_USE_SAFE_TYPE extension subsection of the MIL custom data types, void pointers, extensions, and portability functions section of Chapter 2: Building an application. For example, if you set the InquireType parameter of MbufInquire() to M_SIZE_X, you should set the UserVarPtr parameter to the address of a MIL_INT. However, if you set the InquireType parameter to M_MAX, you should set the UserVarPtr parameter to the address of a MIL_DOUBLE. Production errors A production error is a runtime error caused by unexpected circumstances (typically, a disconnected device or lack of hardware resources) that prevent a MIL function from completing its task. While you should always work to prevent production errors, it is good practice to check for these errors in your application and take appropriate action when they occur. If a production error occurs, any MIL objects you passed to the MIL function are in an undefined state (though in many cases they will not be modified). The following are common examples of production errors: Connection errors. Some MIL functions involve interaction with an external device (typically a camera). If communication with a device is interrupted before the MIL function returns (either due to an orderly disconnect or timeout), the MIL function will generate an error. Typically, functions that involve interaction with an external device are executed asynchronously. There are additional considerations for handling errors with asynchronous functions. For more information see the Asynchronous MIL functions subsection of this section. Insufficient non-paged memory. Some MIL functions, particularly those which allocate MIL objects, internally allocate non-paged memory. If insufficient free memory is available, the MIL function will generate an error. Even if there is sufficient total memory available, an error will still be generated if there is not a large enough contiguous block of non-paged memory available to allocate required internal data buffers. For more information see the Large non-paged MIL buffers subsection of the Advanced memory management section of Chapter 23: Data buffers. Storage access errors. Some MIL functions load or save files to non-volatile storage (such as a hard drive or solid state drive). If the read or write operation fails (for example, because the specified path was invalid, there is insufficient space available, or a network drive disconnected), the MIL function will generate an error. Detecting MIL errors MIL provides several means of detecting errors. Printed error messages. By default, any time MIL encounters an error it will open a dialog box to present the error message. Execution of the thread that generated the error halts until the dialog box is closed. This is useful during development, but you should typically disable it in the deployed version of your application (using MappControl() with M_ERROR). Instead, you should detect errors using the other methods described in this subsection. Checking for errors after each MIL function call. After each call to a MIL function, you can check whether an error was generated using MappGetError() with M_CURRENT. If the last MIL function call from the current thread generated an error, the error code is returned; otherwise, M_NULL_ERROR is returned. In the following example, the current error is requested after each MIL function call to determine whether the function was successful: MIL_ID MilDigitizer = MdigAlloc(MilSystem, M_DEFAULT, MIL_TEXT(\"M_DEFAULT\"), M_DEFAULT, M_NULL); MIL_INT ErrorCode = MappGetError(M_DEFAULT, M_CURRENT, M_NULL); if (ErrorCode != M_NULL_ERROR){ /* Error handling code for a failed allocation */ } MdigGrab(MilDigitizer, MilBuffer); ErrorCode = MappGetError(M_DEFAULT, M_CURRENT, M_NULL); if (ErrorCode != M_NULL_ERROR){ /* Error handling code for a failed grab */ } There are additional considerations if you call functions that are executed asynchronously. For more information see the Asynchronous MIL functions subsection of this section. Checking for errors after several MIL function calls. After calling several MIL functions in sequence, you can check whether an error was generated by any of the functions using MappGetError() with M_GLOBAL. If any MIL function call (from the current thread) generated an error since the last call to MappGetError() with M_GLOBAL, the error code of the first error that was generated is returned; otherwise, M_NULL_ERROR is returned. You can determine which function generated the error using MappGetError() with M_GLOBAL_OPCODE; for more information, see the Interpreting error codes, subcodes, and opcodes subsection of this section. It is not possible to retrieve additional information about errors other than the first error that was generated. If you need to retrieve information about all errors, you should use one of the other methods described in this section to detect those errors. In the following example, the global error is used to determine if either of two MIL functions generated an error: MappGetError(M_DEFAULT, M_GLOBAL, M_NULL); MIL_ID MilDigitizer = MdigAlloc(MilSystem, M_DEFAULT, MIL_TEXT(\"M_DEFAULT\"), M_DEFAULT, M_NULL); MdigGrab(MilDigitizer, MilBuffer); MIL_INT GlobalErrorCode = MappGetError(M_DEFAULT, M_GLOBAL, M_NULL); if (GlobalErrorCode != M_NULL_ERROR){ /* Error handling code */ } There are additional considerations if you call functions that are execute asynchronously. For more information see the Asynchronous MIL functions subsection of this section. Hooking a function to MIL errors. You can hook a function to MIL errors using MappHookFunction() with M_ERROR_CURRENT or M_ERROR_FATAL (optionally, limited to errors generated by the current thread using M_THREAD_CURRENT). When a MIL error occurs, the function you hooked is called immediately (before any other error detection mechanism is activated). This allows you to have a centralized model for handling MIL errors. Within the hook-handler function, you can use MappGetHookInfo() to learn the error code, error subcodes, and associated messages of the error that caused the hook-handler function to be called. The following line of code hooks an error handling function to all MIL errors. MappHookFunction(MilApplication, M_ERROR_CURRENT, ErrorHandlingFunction, M_NULL); The following hook-handler function prints the main error message to the console: MIL_INT MFTYPE ErrorHandlingTypeFunction(MIL_INT HookType, MIL_ID EventId, void *UserDataPtr, MIL_STRING ErrorMessage) { MappGetError(M_DEFAULT, M_CURRENT + M_MESSAGE, ErrorMessage); MosPrintf(MIL_TEXT(\"MIL Error: \"), ErrorMessage.c_str(), MIL_TEXT(\"\\n\")); return 0; } You can determine which function generated the error using MappGetHookInfo() with M_CURRENT_OPCODE; for more information, see the Interpreting error codes, subcodes, and opcodes subsection of this section. Handling exceptions. When using .NET and Python, you can request that MIL functions throw standard exceptions. To do so, use MappControl() with M_ERROR set to M_THROW_EXCEPTION. You can then use standard try/catch blocks to handle MIL errors in your application. For more information, see the Error handling section of Chapter 60: Using MIL with .NET or the Exception handling in MIL subsection of the MIL functions and constants in Python section of Chapter 59: Using MIL with Python. Interpreting error codes, subcodes, and opcodes When a MIL error is generated, information about the error is stored as a main error code and an error message, as well as between 0 and 3 error subcodes and error messages. To learn the main error code or error subcode of a MIL error, use MappGetError() with M_CURRENT or M_GLOBAL (or MappGetHookInfo() within a hook-handler function that you have hooked to error events using MappHookFunction()). To learn the message associated with the main error code or error subcode, use the M_MESSAGE combination value. In some cases, there are multiple possible main error codes for a given type of error (such as an out of memory error or device timeout error). For user-defined MIL functions and some MIL modules, it is also not guaranteed that a given error subcode is always associated with the same message (even for the same main error code). The most reliable way to determine the nature of a MIL error is to inquire the associated message. You can find the message strings used for many types of MIL errors in milerr.h. Note that, in some cases, similar errors will be associated with different error messages depending on which type of MIL system generates the error. In some cases, one of the subcode error messages indicates the name of the system that generated the error. This information is always stored in the first otherwise unused error subcode (typically, error subcode 2). You can determine which MIL function generated an error by requesting the associated MIL function opcode (using MappGetError() or MappGetHookInfo() with M_CURRENT_OPCODE or M_GLOBAL_OPCODE). To learn which function corresponds to each opcode, refer to milfunctioncode.h. In the following example, different error handling code is used depending on whether the error was generated by the allocation or grabbing function. MappGetError(M_DEFAULT, M_GLOBAL, M_NULL); MIL_ID MilDigitizer = MdigAlloc(MilSystem, M_DEFAULT, MIL_TEXT(\"M_DEFAULT\"), M_DEFAULT, M_NULL); MdigGrab(MilDigitizer, MilBuffer); MIL_INT GlobalErrorOpcode = MappGetError(M_DEFAULT, M_GLOBAL_OPCODE, M_NULL); if (GlobalErrorOpcode == M_DIG_ALLOC){ /* Error handling code for a failed allocation */ } else if (GlobalErrorOpcode == M_DIG_GRAB){ /* Error handling code for a failed grab */ } Asynchronous MIL functions Some MIL functions are executed asynchronously (especially when executed on a board or DMIL system). This means that they internally generate a new thread to complete their task, and they return before the task is completed. In general, you do not need to be aware of whether a function is executed asynchronously because synchronous MIL functions are not executed until all asynchronous functions called from the current thread have completed. Most functions that do not return a value are executed asynchronously. By default MappGetError() is executed asynchronously and therefore might not return the most recent error after a call to an asynchronous function. You can specify to execute MappGetError() synchronously using M_SYNCHRONOUS. In this case, MappGetError(), will wait for any asynchronous functions called by the current thread to complete their task before retrieving error information. When you call MappGetError() with M_SYNCHRONOUS, the function waits for completion of all asynchronous functions executing on all systems. If you have allocated multiple DMIL systems, or multiple systems that perform onboard processing (for example, using an FPGA), this can significantly impact performance of your application. Instead, you can wait for only the asynchronous functions being executed by the system associated with the last function call using MthrWait() with M_THREAD_WAIT and the ThreadOrEventId parameter set to the identifier of the system. You can then retrieve the error code for the last function by calling MappGetError() (without M_SYNCHRONOUS) immediately after. The following example calls two asynchronous MIL functions to be executed on different DMIL systems; it then waits only for the first function to be completed before requesting the error code associated with it. In this case, the operation performed by the second call to MimConvolve() might not yet be completed when the error code is retrieved. MimConvolve(DMILsystem1buffer1, DMILsystem1buffer2, M_SMOOTH); MimConvolve(DMILsystem2buffer1, DMILsystem2buffer2, M_SMOOTH); MthrWait(DMILsystem1, M_THREAD_WAIT, M_NULL); MIL_INT error = MappGetError(M_DEFAULT, M_CURRENT, M_NULL); Note that MthrWait() will not wait for grabbing operations that are performed asynchronously (for example, using MdigProcess() with M_ASYNCHRONOUS). Errors in multi-threaded applications If your application uses multiple threads, each thread must handle its own MIL errors. You can only retrieve information about errors generated within the current thread using MappGetError(). If you hook a function to MIL errors using MappHookFunction(), the thread in which an error is generated will not continue until the hook-handler function returns (the hook-handler function is executed on that thread). However, other threads are unaffected; execution of those threads will continue. Errors in user-defined MIL functions If you create a user-defined MIL function using the Mfunc...() functions, you can generate MIL errors from within the user-defined MIL function. This allows you to handle errors in both user-defined and regular MIL functions using the same mechanisms. For more information about errors in user-defined MIL functions, see the Modules, opcodes, and error handling section of Chapter 67: The MIL function development module. MIL errors Types of errors API errors Production errors Detecting MIL errors Interpreting error codes, subcodes, and opcodes Asynchronous MIL functions Errors in multi-threaded applications Errors in user-defined MIL functions ",
      "wordCount": 2560,
      "subEntries": []
    }
  ]
}]
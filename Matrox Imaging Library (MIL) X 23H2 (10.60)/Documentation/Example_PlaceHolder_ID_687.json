[{
  "id": "Example_PlaceHolder_ID",
  "version": "2024020714",
  "title": "Example_PlaceHolder_Title",
  "wordCount": 0,
  "subEntries": [
    {
      "id": "Examples_Processing_3dRegistration_Advanced3dRegistration_CPP_advanced3dregistration_cpp",
      "version": "2024020714",
      "title": "advanced3dregistration.cpp",
      "location": "Sample Code from MIL Examples",
      "text": " Top /*****************************************************************************/ /* * File name: Advanced3dRegistration.cpp * Location: See Matrox Example Launcher in the MIL Control Center * * * Synopsis: This example demonstrates the use of advanced 3D registration * controls and subsampling modes to improve the robustness, * precision, and speed in various registration scenarios. * * Copyright (C) Matrox Electronic Systems Ltd., 1992-2024. * All Rights Reserved */ #include \"CRegDisplay.h\" #include \"../../../3dUtil/C++/Display3dLinker.h\" #include &lt;mil.h&gt; #include &lt;map&gt; #include &lt;cstdlib&gt; //***************************************************************************** // Example description. //***************************************************************************** void PrintHeader() { MosPrintf(MIL_TEXT(\"[EXAMPLE NAME]\\n\")); MosPrintf(MIL_TEXT(\"Advanced3dRegistration\\n\\n\")); MosPrintf(MIL_TEXT(\"[SYNOPSIS]\\n\")); MosPrintf(MIL_TEXT(\"This example demonstrates the use of advanced 3d registration controls \\n\")); MosPrintf(MIL_TEXT(\"and subsampling modes to improve the robustness, precision, and speed in\\n\")); MosPrintf(MIL_TEXT(\"various registration scenarios. \\n\")); MosPrintf(MIL_TEXT(\"\\n\")); MosPrintf(MIL_TEXT(\"[MODULES USED]\\n\")); MosPrintf(MIL_TEXT(\"Modules used: 3D Registration, 3D Display, and 3D Graphics.\\n\\n\")); } /* Constants. */ static const MIL_INT NUM_SCANS = 2; static const MIL_INT MAX_ITERATIONS = 100; static const MIL_INT REFERENCE_INDEX = 0; static const MIL_INT TARGET_INDEX = 1; static const MIL_INT DISP_SX = 500; static const MIL_INT DISP_SY = 500; /* Defines. */ #define EXAMPLE_IMAGE_PATH M_IMAGE_PATH MIL_TEXT(\"Advanced3dRegistration/\") /* Input scanned point cloud (PLY) files. */ static const MIL_STRING PIN_MODEL = EXAMPLE_IMAGE_PATH MIL_TEXT(\"ClothesPinModel.ply\"); static const MIL_STRING PIN_SCENE = EXAMPLE_IMAGE_PATH MIL_TEXT(\"ClothesPinScene.ply\"); static const MIL_STRING PLUG_MODEL = EXAMPLE_IMAGE_PATH MIL_TEXT(\"PlugModel1.ply\"); static const MIL_STRING PLUG_SCENE = EXAMPLE_IMAGE_PATH MIL_TEXT(\"PlugScene1.ply\"); static const MIL_STRING PILLAR_MODEL = EXAMPLE_IMAGE_PATH MIL_TEXT(\"PillarModel.ply\"); static const MIL_STRING PILLAR_SCENE = EXAMPLE_IMAGE_PATH MIL_TEXT(\"PillarScene.ply\"); static const MIL_STRING COAXIAL_JACK_MODEL = EXAMPLE_IMAGE_PATH MIL_TEXT(\"CoaxialJackModel.ply\"); static const MIL_STRING COAXIAL_JACK_SCENE = EXAMPLE_IMAGE_PATH MIL_TEXT(\"CoaxialJackScene.ply\"); static const MIL_STRING AERATOR_MODEL = EXAMPLE_IMAGE_PATH MIL_TEXT(\"AeratorKeyModel.ply\"); static const MIL_STRING AERATOR_SCENE = EXAMPLE_IMAGE_PATH MIL_TEXT(\"AeratorKeyScene.ply\"); /* The colors assigned to each point cloud. */ const MIL_INT Color[NUM_SCANS] = { M_RGB888(0, 159, 255), M_RGB888(154, 77, 66) }; /* Structures.*/ struct SRegistrationStats { MIL_DOUBLE ComputationTime; MIL_DOUBLE RMSError; MIL_INT NbIteration; }; /* Functions. */ bool CheckForRequiredMILFile(MIL_STRING FileName); bool ExecuteExample(MIL_ID MilSystem, MIL_STRING BasicContextName, MIL_STRING ImprovedContextName, MIL_ID MilContextBasic, MIL_ID MilContextImproved, MIL_ID MilModelContainer, MIL_ID MilSceneContainer, CCameraOrientation InitialCameraOrientation, bool IsFinalExample = false); void ColorCloud(MIL_ID MilPointCloud, MIL_INT Col); MIL_INT64 DisplayContainer(MIL_ID MilDisplay, MIL_ID MilContainer); void SubsampleContainer(MIL_DOUBLE NeighborhoodDistance, MIL_ID MilSystem, MIL_ID MilContainerId); SRegistrationStats PerformRegistration(MIL_ID MilSystem, MIL_ID MilReference, MIL_ID MilTarget, MIL_ID MilDisplay, MIL_ID MilDisplayContainer, MIL_ID MilContext, const CCameraParameters&amp; CameraParameters); void PrintRegistrationStats(const SRegistrationStats&amp; BasicStats, const SRegistrationStats&amp; ImprovedStats); bool PairsCreationFromTargetExample(MIL_ID MilSystem); bool PairsRejectionExample(MIL_ID MilSystem); bool TargetPointLimitExample(MIL_ID MilSystem); bool GeometricSubsamplingExample(MIL_ID MilSystem); bool FullAutoExample(MIL_ID MilSystem); int MosMain() { /* Print example information in console. */ PrintHeader(); /* Allocate MIL objects. */ auto MilApplication = MappAlloc(M_NULL, M_DEFAULT, M_UNIQUE_ID); auto MilSystem = MsysAlloc(M_DEFAULT, M_SYSTEM_HOST, M_DEFAULT, M_DEFAULT, M_UNIQUE_ID); MosPrintf(MIL_TEXT(\"Press any key to start.\\n\\n\")); MosGetch(); /* Execute registrations. */ if(!PairsCreationFromTargetExample(MilSystem)) return EXIT_FAILURE; if(!PairsRejectionExample(MilSystem)) return EXIT_FAILURE; if(!TargetPointLimitExample(MilSystem)) return EXIT_FAILURE; if(!GeometricSubsamplingExample(MilSystem)) return EXIT_FAILURE; if(!FullAutoExample(MilSystem)) return EXIT_FAILURE; return 0; } //***************************************************************************** // Print example information. //***************************************************************************** void PrintExampleInfo(MIL_STRING BasicAlgorithmName, MIL_STRING BasicAlgorithmDescription, MIL_STRING ImprovedAlgorithmName, MIL_STRING ImprovedAlgorithmDescription) { MosPrintf(MIL_TEXT(\"\\n\")); MosPrintf(MIL_TEXT(\"%s Example\\t\\n\"), ImprovedAlgorithmName.c_str()); MosPrintf(MIL_TEXT(\"------------------------------------------------------------------------------\\n\")); MosPrintf(MIL_TEXT(\"[Basic]\\n\")); MosPrintf(MIL_TEXT(\"%s\\n\"), BasicAlgorithmName.c_str()); MosPrintf(MIL_TEXT(\" %s\\n\\n\"), BasicAlgorithmDescription.c_str()); MosPrintf(MIL_TEXT(\"[Improved]\\n\")); MosPrintf(MIL_TEXT(\"%s\\n\"), ImprovedAlgorithmName.c_str()); MosPrintf(MIL_TEXT(\" %s\\n\\n\"), ImprovedAlgorithmDescription.c_str()); } //***************************************************************************** // Pairs creation from target example. //***************************************************************************** bool PairsCreationFromTargetExample(MIL_ID MilSystem) { CCameraOrientation InitialCameraOrientation(-90, -90, 0); if(!CheckForRequiredMILFile(PIN_MODEL) || !CheckForRequiredMILFile(PIN_SCENE)) return false; auto MilModelContainer = MbufRestore(PIN_MODEL, MilSystem, M_UNIQUE_ID); auto MilSceneContainer = MbufRestore(PIN_SCENE, MilSystem, M_UNIQUE_ID); /* Subsample containers. */ SubsampleContainer(0.2, MilSystem, MilModelContainer); SubsampleContainer(0.2, MilSystem, MilSceneContainer); /* Define basic algorithm parameters. */ auto MilContextBasic = M3dregAlloc(MilSystem, M_PAIRWISE_REGISTRATION_CONTEXT, M_DEFAULT, M_UNIQUE_ID); M3dregControl(MilContextBasic, M_CONTEXT, M_ERROR_MINIMIZATION_METRIC, M_POINT_TO_PLANE); M3dregControl(MilContextBasic, M_DEFAULT, M_PREREGISTRATION_MODE, M_CENTROID); /* Define improved algorithm parameters. */ auto MilContextImproved = M3dregAlloc(MilSystem, M_PAIRWISE_REGISTRATION_CONTEXT, M_DEFAULT, M_UNIQUE_ID); /* Match basic algorithm settings. */ M3dregControl(MilContextImproved, M_CONTEXT, M_ERROR_MINIMIZATION_METRIC, M_POINT_TO_PLANE); M3dregControl(MilContextImproved, M_DEFAULT, M_PREREGISTRATION_MODE, M_CENTROID); /* Activate M_PAIRS_CREATION_FROM_TARGET. The algorithm will create pairs for each target point. if*/ /* source and target are too far apart.*/ M3dregControl(MilContextImproved, M_DEFAULT, M_PAIRS_CREATION_FROM_TARGET, M_AUTO); MIL_STRING BasicAlgorithmName = MIL_TEXT(\"Centered point-to-plane\"); MIL_STRING ImprovedAlgorithmName = MIL_TEXT(\"Pairs creation from target\"); PrintExampleInfo(BasicAlgorithmName, MIL_TEXT(\"Default point-to-plane settings and centroid prealignment.\"), ImprovedAlgorithmName, MIL_TEXT(\"M_PAIRS_CREATION_FROM_TARGET option set to M_AUTO.\\n\") MIL_TEXT(\"This option allows pairs to be created from target to reference, which is\\n\") MIL_TEXT(\"useful when the target and reference point clouds have very dissimilar \\n\") MIL_TEXT(\"initial positions and orientations.\")); return ExecuteExample(MilSystem, BasicAlgorithmName, ImprovedAlgorithmName, MilContextBasic, MilContextImproved, MilModelContainer, MilSceneContainer, InitialCameraOrientation); } //***************************************************************************** // Pairs rejection example. //***************************************************************************** bool PairsRejectionExample(MIL_ID MilSystem) { CCameraOrientation InitialCameraOrientation(140, -120, 0); if(!CheckForRequiredMILFile(PLUG_MODEL) || !CheckForRequiredMILFile(PLUG_SCENE)) return false; auto MilModelContainer = MbufRestore(PLUG_MODEL, MilSystem, M_UNIQUE_ID); auto MilSceneContainer = MbufRestore(PLUG_SCENE, MilSystem, M_UNIQUE_ID); /* Subsample containers. */ SubsampleContainer(0.2, MilSystem, MilModelContainer); SubsampleContainer(0.2, MilSystem, MilSceneContainer); /* Define basic algorithm parameters. */ auto MilContextBasic = M3dregAlloc(MilSystem, M_PAIRWISE_REGISTRATION_CONTEXT, M_DEFAULT, M_UNIQUE_ID); M3dregControl(MilContextBasic, M_CONTEXT, M_ERROR_MINIMIZATION_METRIC, M_POINT_TO_POINT); M3dregControl(MilContextBasic, M_DEFAULT, M_PREREGISTRATION_MODE, M_CENTROID); M3dregControl(MilContextBasic, M_ALL, M_OVERLAP, 100); /* Define improved algorithm parameters. */ auto MilContextImproved = M3dregAlloc(MilSystem, M_PAIRWISE_REGISTRATION_CONTEXT, M_DEFAULT, M_UNIQUE_ID); /* Match basic algorithm settings. */ M3dregControl(MilContextImproved, M_CONTEXT, M_ERROR_MINIMIZATION_METRIC, M_POINT_TO_POINT); M3dregControl(MilContextImproved, M_DEFAULT, M_PREREGISTRATION_MODE, M_CENTROID); M3dregControl(MilContextImproved, M_ALL, M_OVERLAP, 100); /* Activate pairs rejection. */ M3dregControl(MilContextImproved, M_ALL, M_PAIRS_REJECTION_MODE, M_ROBUST_STANDARD_DEVIATION); M3dregControl(MilContextImproved, M_ALL, M_PAIRS_REJECTION_FACTOR, 3); MIL_STRING BasicAlgorithmName = MIL_TEXT(\"Overlap 100 point-to-point\"); MIL_STRING ImprovedAlgorithmName = MIL_TEXT(\"Pairs Rejection\"); PrintExampleInfo(BasicAlgorithmName, MIL_TEXT(\"Point-to-point registration with M_OVERLAP set to 100 and\\n\") MIL_TEXT(\"centroid prealignment.\"), ImprovedAlgorithmName, MIL_TEXT(\"Robust pairs rejection settings used.\\n\") MIL_TEXT(\"In high overlap case where occlusion amount is hard to predict,\\n\") MIL_TEXT(\"pairs rejection helps to automatically reject false pairs and\\n\") MIL_TEXT(\"give a close to optimal overlap at the end of convergence.\")); return ExecuteExample(MilSystem, BasicAlgorithmName, ImprovedAlgorithmName, MilContextBasic, MilContextImproved, MilModelContainer, MilSceneContainer, InitialCameraOrientation); } //***************************************************************************** // Pairs rejection example. //***************************************************************************** bool TargetPointLimitExample(MIL_ID MilSystem) { CCameraOrientation InitialCameraOrientation(90, 180, 0); if(!CheckForRequiredMILFile(PILLAR_MODEL) || !CheckForRequiredMILFile(PILLAR_SCENE)) return false; auto MilModelContainer = MbufRestore(PILLAR_MODEL, MilSystem, M_UNIQUE_ID); auto MilSceneContainer = MbufRestore(PILLAR_SCENE, MilSystem, M_UNIQUE_ID); /* Subsample containers. */ SubsampleContainer(0.2, MilSystem, MilModelContainer); SubsampleContainer(0.2, MilSystem, MilSceneContainer); /* Define basic algorithm parameters. */ auto MilContextBasic = M3dregAlloc(MilSystem, M_PAIRWISE_REGISTRATION_CONTEXT, M_DEFAULT, M_UNIQUE_ID); M3dregControl(MilContextBasic, M_CONTEXT, M_ERROR_MINIMIZATION_METRIC, M_POINT_TO_POINT); /* Define improved algorithm parameters. */ auto MilContextImproved = M3dregAlloc(MilSystem, M_PAIRWISE_REGISTRATION_CONTEXT, M_DEFAULT, M_UNIQUE_ID); /* Match basic algorithm settings. */ M3dregControl(MilContextImproved, M_CONTEXT, M_ERROR_MINIMIZATION_METRIC, M_POINT_TO_POINT); /* Activate M_PAIRS_LIMIT_PER_TARGET_POINT_MODE. */ M3dregControl(MilContextImproved, M_DEFAULT, M_PAIRS_LIMIT_PER_TARGET_POINT_MODE, M_SINGLE); MIL_STRING BasicAlgorithmName = MIL_TEXT(\"Default point-to-point\"); MIL_STRING ImprovedAlgorithmName = MIL_TEXT(\"Target point limit\"); PrintExampleInfo(BasicAlgorithmName, MIL_TEXT(\"point-to-point registration.\"), ImprovedAlgorithmName, MIL_TEXT(\"M_PAIRS_LIMIT_PER_TARGET_POINT_MODE option set to M_SINGLE.\\n\") MIL_TEXT(\"This option pairs each reference point with a single point in the target\\n\") MIL_TEXT(\"point cloud, which is useful to fine-tune the registration while reducing\\n\") MIL_TEXT(\"the effect of noise and outliers. Recommended when the target and reference\\n\") MIL_TEXT(\"point clouds are initially close to each other.\")); return ExecuteExample(MilSystem, BasicAlgorithmName, ImprovedAlgorithmName, MilContextBasic, MilContextImproved, MilModelContainer, MilSceneContainer, InitialCameraOrientation); } //***************************************************************************** // Geometric subsampling example. //***************************************************************************** bool GeometricSubsamplingExample(MIL_ID MilSystem) { CCameraOrientation InitialCameraOrientation(-90, -90, 0); if(!CheckForRequiredMILFile(COAXIAL_JACK_MODEL) || !CheckForRequiredMILFile(COAXIAL_JACK_SCENE)) return false; auto MilModelContainer = MbufRestore(COAXIAL_JACK_MODEL, MilSystem, M_UNIQUE_ID); auto MilSceneContainer = MbufRestore(COAXIAL_JACK_SCENE, MilSystem, M_UNIQUE_ID); /* Subsample containers. */ SubsampleContainer(0.2, MilSystem, MilModelContainer); SubsampleContainer(0.2, MilSystem, MilSceneContainer); /* Define basic algorithm parameters. */ auto MilContextBasic = M3dregAlloc(MilSystem, M_PAIRWISE_REGISTRATION_CONTEXT, M_DEFAULT, M_UNIQUE_ID); M3dregControl(MilContextBasic, M_CONTEXT, M_ERROR_MINIMIZATION_METRIC, M_POINT_TO_PLANE); M3dregControl(MilContextBasic, M_ALL, M_OVERLAP, 100); /* Define improved algorithm parameters. */ auto MilContextImproved = M3dregAlloc(MilSystem, M_PAIRWISE_REGISTRATION_CONTEXT, M_DEFAULT, M_UNIQUE_ID); /* Match basic algorithm settings. */ M3dregControl(MilContextImproved, M_CONTEXT, M_ERROR_MINIMIZATION_METRIC, M_POINT_TO_PLANE); M3dregControl(MilContextImproved, M_ALL, M_OVERLAP, 100); /* Activate geometric subsampling. */ MIL_ID MilSubsampleContext = M_NULL; M3dregInquire(MilContextImproved, 1, M_SUBSAMPLE_REFERENCE_CONTEXT_ID, &amp;MilSubsampleContext); M3dregControl(MilContextImproved, 1, M_SUBSAMPLE_REFERENCE, M_ENABLE); M3dimControl(MilSubsampleContext, M_SUBSAMPLE_MODE, M_SUBSAMPLE_GEOMETRIC); M3dimControl(MilSubsampleContext, M_FRACTION_OF_POINTS, 0.3); MIL_STRING BasicAlgorithmName = MIL_TEXT(\"Overlap 100 point-to-plane\"); MIL_STRING ImprovedAlgorithmName = MIL_TEXT(\"Geometric subsampling\"); PrintExampleInfo(BasicAlgorithmName, MIL_TEXT(\"point-to-plane registration with M_OVERLAP set to 100.\"), ImprovedAlgorithmName, MIL_TEXT(\"Registration with geometric subsampling.\\n\") MIL_TEXT(\"Geometric subsampling is performed on the reference point cloud before\\n\") MIL_TEXT(\"registration. This removes featureless points that could lead to divergence\\n\") MIL_TEXT(\"or a slower convergence.\")); return ExecuteExample(MilSystem, BasicAlgorithmName, ImprovedAlgorithmName, MilContextBasic, MilContextImproved, MilModelContainer, MilSceneContainer, InitialCameraOrientation); } //***************************************************************************** // Full auto example. //***************************************************************************** bool FullAutoExample(MIL_ID MilSystem) { CCameraOrientation InitialCameraOrientation(90, -90, 0); if(!CheckForRequiredMILFile(AERATOR_MODEL) || !CheckForRequiredMILFile(AERATOR_SCENE)) return false; auto MilModelContainer = MbufRestore(AERATOR_MODEL, MilSystem, M_UNIQUE_ID); auto MilSceneContainer = MbufRestore(AERATOR_SCENE, MilSystem, M_UNIQUE_ID); /* Subsample containers. */ SubsampleContainer(0.2, MilSystem, MilModelContainer); SubsampleContainer(0.2, MilSystem, MilSceneContainer); /* Define basic algorithm parameters. */ auto MilContextBasic = M3dregAlloc(MilSystem, M_PAIRWISE_REGISTRATION_CONTEXT, M_DEFAULT, M_UNIQUE_ID); M3dregControl(MilContextBasic, M_CONTEXT, M_ERROR_MINIMIZATION_METRIC, M_POINT_TO_PLANE); M3dregControl(MilContextBasic, M_ALL, M_OVERLAP, 100); MIL_ID MilSubsampleContextBasic = M_NULL; M3dregInquire(MilContextBasic, 1, M_SUBSAMPLE_REFERENCE_CONTEXT_ID, &amp;MilSubsampleContextBasic); M3dregControl(MilContextBasic, 1, M_SUBSAMPLE_REFERENCE, M_ENABLE); /* Keep edge points. */ M3dimControl(MilSubsampleContextBasic, M_SUBSAMPLE_MODE, M_SUBSAMPLE_GEOMETRIC); M3dimControl(MilSubsampleContextBasic, M_FRACTION_OF_POINTS, 0.3); /* Define improved algorithm parameters. */ auto MilContextImproved = M3dregAlloc(MilSystem, M_PAIRWISE_REGISTRATION_CONTEXT, M_DEFAULT, M_UNIQUE_ID); /* Match basic algorithm settings. */ M3dregControl(MilContextImproved, M_CONTEXT, M_ERROR_MINIMIZATION_METRIC, M_POINT_TO_PLANE); M3dregControl(MilContextImproved, M_ALL, M_OVERLAP, 100); MIL_ID MilSubsampleContext = M_NULL; M3dregInquire(MilContextImproved, 1, M_SUBSAMPLE_REFERENCE_CONTEXT_ID, &amp;MilSubsampleContext); M3dregControl(MilContextImproved, 1, M_SUBSAMPLE_REFERENCE, M_ENABLE); /* Keep edge points. */ M3dimControl(MilSubsampleContext, M_SUBSAMPLE_MODE, M_SUBSAMPLE_GEOMETRIC); M3dimControl(MilSubsampleContext, M_FRACTION_OF_POINTS, 0.3); /* Activate M_PAIRS_CREATION_PER_REFERENCE_POINT_MODE, M_PAIRS_LIMIT_PER_TARGET_POINT_MODE, */ /* M_PAIRS_CREATION_FROM_TARGET, and M_PAIRS_REJECTION_MODE. */ M3dregControl(MilContextImproved, M_DEFAULT, M_PAIRS_CREATION_PER_REFERENCE_POINT_MODE, M_AUTO); M3dregControl(MilContextImproved, M_DEFAULT, M_PAIRS_LIMIT_PER_TARGET_POINT_MODE, M_AUTO); M3dregControl(MilContextImproved, M_DEFAULT, M_PAIRS_CREATION_FROM_TARGET, M_AUTO); M3dregControl(MilContextImproved, M_ALL, M_PAIRS_REJECTION_MODE, M_ROBUST_STANDARD_DEVIATION); MIL_STRING BasicAlgorithmName = MIL_TEXT(\"Geometric subsampling\"); MIL_STRING ImprovedAlgorithmName = MIL_TEXT(\"Full auto\"); PrintExampleInfo(BasicAlgorithmName, MIL_TEXT(\"Registration with geometric subsampling.\\n\") MIL_TEXT(\"Geometric subsampling is performed on the reference point cloud before\\n\") MIL_TEXT(\"registration. This removes featureless points that could lead to divergence\\n\") MIL_TEXT(\"or a slower convergence.\"), ImprovedAlgorithmName, MIL_TEXT(\"This algorithm sets M_PAIRS_CREATION_PER_REFERENCE_POINT_MODE,\\n\") MIL_TEXT(\"M_PAIRS_LIMIT_PER_TARGET_POINT_MODE, and M_PAIRS_CREATION_FROM_TARGET to M_AUTO.\\n\") MIL_TEXT(\"The optimal value for each of these features is calculated internally at each\\n\") MIL_TEXT(\"iteration. Pairs rejection and geometric subsampling are also used.\")); return ExecuteExample(MilSystem, BasicAlgorithmName, ImprovedAlgorithmName, MilContextBasic, MilContextImproved, MilModelContainer, MilSceneContainer, InitialCameraOrientation, true); } //***************************************************************************** // Execute the registration using a basic and then an improved algorithm. //***************************************************************************** bool ExecuteExample(MIL_ID MilSystem, MIL_STRING BasicContextName, MIL_STRING ImprovedContextName, MIL_ID MilContextBasic, MIL_ID MilContextImproved, MIL_ID MilModelContainer, MIL_ID MilSceneContainer, CCameraOrientation InitialCameraOrientation, bool IsFinalExample) { ColorCloud(MilModelContainer, Color[REFERENCE_INDEX]); ColorCloud(MilSceneContainer, Color[TARGET_INDEX]); /* Display reference and target. */ auto MilDisplay = Alloc3dDisplayId(MilSystem); if(!MilDisplay) return false; InitialCameraOrientation.ApplyToDisplay(MilDisplay); CWindowParameters RefAndTargetWindowParam(MIL_TEXT(\"Reference and Target\"), 0, 0, DISP_SX, DISP_SY); RefAndTargetWindowParam.ApplyToDisplay(MilDisplay); DisplayContainer(MilDisplay, MilModelContainer); DisplayContainer(MilDisplay, MilSceneContainer); M3ddispSetView(MilDisplay, M_VIEW_BOX, M_WHOLE_SCENE, 1.0, M_DEFAULT, M_DEFAULT); // Set the display's rotation axis center. This will keep the // behaviour of auto rotate consistent as we move its interest point. M3ddispCopy(M_VIEW_INTEREST_POINT, MilDisplay, M_ROTATION_AXIS_CENTER, M_DEFAULT); CCameraParameters MainDisplayCameraParams(MilSystem, MilDisplay); MosPrintf(MIL_TEXT(\"The reference and target point clouds are displayed.\\n\\n\")); MosPrintf(MIL_TEXT(\"Press any key to register.\\n\\n\")); MosGetch(); /* Display reference algorithm. */ auto MilDisplayBasic = Alloc3dDisplayId(MilSystem); if(!MilDisplayBasic) return false; CWindowParameters BasicWinParam(MIL_TEXT(\"Basic-\") + BasicContextName, DISP_SX, 0, DISP_SX, DISP_SY); BasicWinParam.ApplyToDisplay(MilDisplayBasic); MosPrintf(MIL_TEXT(\"Calculating basic registration... \\n\\n\")); auto MilDisplayContainerBasic = MbufAllocContainer(MilSystem, M_PROC + M_DISP, M_DEFAULT, M_UNIQUE_ID); auto BasicStats = PerformRegistration(MilSystem, MilModelContainer, MilSceneContainer, MilDisplayBasic, MilDisplayContainerBasic, MilContextBasic, MainDisplayCameraParams); BasicWinParam.m_PositionY = DISP_SY; CRegDisplay BasicRegDisplay(MilModelContainer, MilSceneContainer, MilContextBasic); if(!BasicRegDisplay.Init(BasicWinParam, MainDisplayCameraParams)) return false; /* Display algorithm to highlight. */ auto MilDisplayImproved = Alloc3dDisplayId(MilSystem); if(!MilDisplayImproved) return false; CWindowParameters ImprovedWinParam(MIL_TEXT(\"Improved-\") + ImprovedContextName, DISP_SX * 2, 0, DISP_SX, DISP_SY); ImprovedWinParam.ApplyToDisplay(MilDisplayImproved); MosPrintf(MIL_TEXT(\"Calculating improved registration... \\n\\n\")); auto MilDisplayContainerImproved = MbufAllocContainer(MilSystem, M_PROC + M_DISP, M_DEFAULT, M_UNIQUE_ID); auto ImprovedStats = PerformRegistration(MilSystem, MilModelContainer, MilSceneContainer, MilDisplayImproved, MilDisplayContainerImproved, MilContextImproved, MainDisplayCameraParams); ImprovedWinParam.m_PositionY = DISP_SY; CRegDisplay ImprovedRegDisplay(MilModelContainer, MilSceneContainer, MilContextImproved); if(!ImprovedRegDisplay.Init(ImprovedWinParam, MainDisplayCameraParams)) return false; MosPrintf(MIL_TEXT(\"The registration results are displayed.\\n\\n\")); /* Print the registration statistics. */ PrintRegistrationStats(BasicStats, ImprovedStats); /* Link the displays' views. */ CDisplayLinker DisplayLinker({MilDisplay, MilDisplayBasic, MilDisplayImproved, BasicRegDisplay.GetMilDisplayID(), ImprovedRegDisplay.GetMilDisplayID()}); /* Start display control thread. */ CDisplayController Controller; Controller.RegisterDisplay(&amp;BasicRegDisplay); Controller.RegisterDisplay(&amp;ImprovedRegDisplay); Controller.Start(IsFinalExample); return true; } //***************************************************************************** // Color the point cloud. //***************************************************************************** void ColorCloud(MIL_ID MilPointCloud, MIL_INT Col) { MIL_INT SizeX = MbufInquireContainer(MilPointCloud, M_COMPONENT_RANGE, M_SIZE_X, M_NULL); MIL_INT SizeY = MbufInquireContainer(MilPointCloud, M_COMPONENT_RANGE, M_SIZE_Y, M_NULL); MIL_ID ReflectanceId = MbufInquireContainer(MilPointCloud, M_COMPONENT_REFLECTANCE, M_COMPONENT_ID, M_NULL); if(ReflectanceId == M_NULL) { ReflectanceId = MbufAllocComponent(MilPointCloud, 3, SizeX, SizeY, 8 + M_UNSIGNED, M_IMAGE, M_COMPONENT_REFLECTANCE, M_NULL); } MbufClear(ReflectanceId, static_cast&lt;MIL_DOUBLE&gt;(Col)); } //***************************************************************************** // Display the received container. //***************************************************************************** MIL_INT64 DisplayContainer(MIL_ID MilDisplay, MIL_ID MilContainer) { MIL_INT Label = M3ddispSelect(MilDisplay, MilContainer, M_ADD, M_DEFAULT); M3ddispSelect(MilDisplay, M_NULL, M_OPEN, M_DEFAULT); return Label; } //***************************************************************************** // Subsample container. //***************************************************************************** void SubsampleContainer(MIL_DOUBLE NeighborhoodDistance, MIL_ID MilSystem, MIL_ID MilContainerId) { if(NeighborhoodDistance &gt; 0) { auto SubSamplingContext = M3dimAlloc(MilSystem, M_SUBSAMPLE_CONTEXT, M_DEFAULT, M_UNIQUE_ID); M3dimControl(SubSamplingContext, M_SUBSAMPLE_MODE, M_SUBSAMPLE_NORMAL); if(MbufInquireContainer(MilContainerId, M_COMPONENT_NORMALS_MIL, M_COMPONENT_ID, M_NULL) == M_NULL) M3dimNormals(M_NORMALS_CONTEXT_TREE, MilContainerId, MilContainerId, M_DEFAULT); M3dimControl(SubSamplingContext, M_NEIGHBORHOOD_DISTANCE, NeighborhoodDistance); M3dimSample(SubSamplingContext, MilContainerId, MilContainerId, M_DEFAULT); } } //***************************************************************************** // Perform registration. //***************************************************************************** SRegistrationStats PerformRegistration(MIL_ID MilSystem, MIL_ID Reference, MIL_ID Target, MIL_ID MilDisplay, MIL_ID MilDisplayContainer, MIL_ID MilContext, const CCameraParameters&amp; CameraParameters) { SRegistrationStats RegStats; MIL_ID MilContainerIds[NUM_SCANS]; MilContainerIds[REFERENCE_INDEX] = Reference; MilContainerIds[TARGET_INDEX] = Target; /* Allocate a 3D registration result object. */ auto MilResult = M3dregAllocResult(MilSystem, M_PAIRWISE_REGISTRATION_RESULT, M_DEFAULT, M_UNIQUE_ID); M3dregControl(MilContext, M_DEFAULT, M_NUMBER_OF_REGISTRATION_ELEMENTS, NUM_SCANS); M3dregControl(MilContext, M_DEFAULT, M_MAX_ITERATIONS, MAX_ITERATIONS); /* Calculate the time to perform the registration. */ MappTimer(M_TIMER_RESET, M_NULL); /* Perform the registration. */ M3dregCalculate(MilContext, MilContainerIds, NUM_SCANS, MilResult, M_DEFAULT); RegStats.ComputationTime = MappTimer(M_TIMER_READ, M_NULL) * 1000.0; M3dregGetResult(MilResult, 1, M_RMS_ERROR + M_TYPE_MIL_DOUBLE, &amp;RegStats.RMSError); M3dregGetResult(MilResult, 1, M_NB_ITERATIONS, &amp;RegStats.NbIteration); /* Display results. */ M3dregMerge(MilResult, MilContainerIds, NUM_SCANS, MilDisplayContainer, M_NULL, M_DEFAULT); M3ddispSelect(MilDisplay, M_NULL, M_REMOVE, M_DEFAULT); CameraParameters.ApplyToDisplay(MilDisplay); DisplayContainer(MilDisplay, MilDisplayContainer); return RegStats; } //***************************************************************************** // Print the registration statistics. //***************************************************************************** void PrintRegistrationStats(const SRegistrationStats&amp; BasicStats, const SRegistrationStats&amp; ImprovedStats) { // Print the statistics header. MosPrintf(MIL_TEXT(\"%9s %11s %8s %19s\\n\"), MIL_TEXT(\"Algorithm\"), MIL_TEXT(\"NbIteration\"), MIL_TEXT(\"RMSError\"), MIL_TEXT(\"ComputationTime(ms)\")); MosPrintf(MIL_TEXT(\"--------------------------------------------------------\\n\")); MosPrintf(MIL_TEXT(\"%9s %11d %8.3f %19.2f\\n\"), MIL_TEXT(\"Basic\"), BasicStats.NbIteration, BasicStats.RMSError, BasicStats.ComputationTime); MosPrintf(MIL_TEXT(\"%9s %11d %8.3f %19.2f\\n\\n\"), MIL_TEXT(\"Improved\"), ImprovedStats.NbIteration, ImprovedStats.RMSError, ImprovedStats.ComputationTime); } //******************************************************************************* // Checks the required files exist. //***************************************************************************** bool CheckForRequiredMILFile(MIL_STRING FileName) { MIL_INT FilePresent; MappFileOperation(M_DEFAULT, FileName, M_NULL, M_NULL, M_FILE_EXISTS, M_DEFAULT, &amp;FilePresent); if(FilePresent == M_NO) { MosPrintf(MIL_TEXT(\"\\n\") MIL_TEXT(\"The footage needed to run this example is missing. You need \\n\") MIL_TEXT(\"to obtain and apply a separate specific update to have it.\\n\\n\")); MosPrintf(MIL_TEXT(\"Press any key to end.\\n\\n\")); MosGetch(); } return (FilePresent == M_YES); } ",
      "wordCount": 2004
    },
    {
      "id": "Examples_Processing_3dRegistration_Advanced3dRegistration_CPP_cregdisplay_cpp",
      "version": "2024020714",
      "title": "cregdisplay.cpp",
      "location": "Sample Code from MIL Examples",
      "text": " Top //******************************************************************************* // // File name: CRegDisplay.cpp // Location: See Matrox Example Launcher in the MIL Control Center // // // Synopsis: Class in charge of managing the 2D/3D displays for 3D // examples. // // Copyright (C) Matrox Electronic Systems Ltd., 1992-2024. // All Rights Reserved //******************************************************************************* #include \"CRegDisplay.h\" #define KEY_UP 72 #define KEY_DOWN 80 #define KEY_RIGHT 77 #define KEY_LEFT 75 #define KEY_SKIP 224 //***************************************************************************** // Constructor. //***************************************************************************** CRegDisplay::CRegDisplay(MIL_ID MilRefContainer, MIL_ID MilTargetContainer, MIL_ID MilContext) { /* Allocate context, result, and display objects */ m_MilDrawContext = M3dregAlloc(M_DEFAULT_HOST, M_DRAW_3D_CONTEXT, M_DEFAULT, M_UNIQUE_ID); m_MilRegResult = M3dregAllocResult(M_DEFAULT_HOST, M_PAIRWISE_REGISTRATION_RESULT, M_DEFAULT, M_UNIQUE_ID); /* Configure draw settings. */ M3dregControlDraw(m_MilDrawContext, M_DRAW_OVERLAP_POINTS, M_ACTIVE, M_ENABLE); M3dregControlDraw(m_MilDrawContext, M_DRAW_OVERLAP_POINTS, M_THICKNESS, 5); M3dregControlDraw(m_MilDrawContext, M_DRAW_PAIRS, M_ACTIVE, M_ENABLE); /* Execute registration while saving information about point pairs. */ std::vector&lt;MIL_ID&gt; Containers = {MilRefContainer, MilTargetContainer}; M3dregControl(MilContext, M_CONTEXT, M_SAVE_PAIRS_INFO, M_TRUE); M3dregCalculate(MilContext, Containers, M_DEFAULT, m_MilRegResult, M_DEFAULT); M3dregControl(MilContext, M_CONTEXT, M_SAVE_PAIRS_INFO, M_FALSE); m_NumIterations = (MIL_INT)M3dregGetResult(m_MilRegResult, 1, M_NB_ITERATIONS, M_NULL); } //***************************************************************************** // Init. //***************************************************************************** bool CRegDisplay::Init(const CWindowParameters&amp; WindowParams, const CCameraParameters&amp; CameraParameters) { /* Allocate display objects */ m_MilDisplay = Alloc3dDisplayId(M_DEFAULT_HOST); if(!m_MilDisplay) return false; /* Set up display. */ WindowParams.ApplyToDisplay(m_MilDisplay); /* Open window and start display thread. */ m_Running.store(true, std::memory_order_relaxed); M3ddispSelect(m_MilDisplay, M_NULL, M_OPEN, M_DEFAULT); /* Adjust the viewpoint of the 3D display. */ CameraParameters.ApplyToDisplay(m_MilDisplay); m_MilDisplayThread = MthrAlloc(M_DEFAULT_HOST, M_THREAD, M_DEFAULT, CRegDisplay::ProcessDisplayThread, this, M_UNIQUE_ID); return true; } //***************************************************************************** // Destructor. //***************************************************************************** CRegDisplay::~CRegDisplay() { End(); } //***************************************************************************** // Close the display. //***************************************************************************** void CRegDisplay::End() { if(m_Running.load(std::memory_order_relaxed)) { /* Signal threads to end and wait. */ m_Running.store(false, std::memory_order_relaxed); if(m_MilDisplayThread != M_NULL) { MthrWait(m_MilDisplayThread, M_THREAD_END_WAIT, M_NULL); } /* Close display. */ M3ddispSelect(m_MilDisplay, M_NULL, M_CLOSE, M_DEFAULT); } } //***************************************************************************** // Update display. //***************************************************************************** MIL_UINT32 MFTYPE CRegDisplay::ProcessDisplayThread(void* pUserData) { /* Retrieve data. */ CRegDisplay&amp; Data = *(CRegDisplay*)pUserData; auto GraList = (MIL_ID)M3ddispInquire(Data.m_MilDisplay, M_3D_GRAPHIC_LIST_ID, M_NULL); MIL_INT NbIteration = (MIL_INT)M3dregGetResult(Data.m_MilRegResult, 1, M_NB_ITERATIONS, M_NULL); if(Data.m_LoopIteration &gt;= NbIteration) { Data.m_LoopIteration = 0; } MIL_INT LastDrawnIteration = -1; MIL_INT64 DrawNode = M_NULL; while(true) { MappTimer(M_TIMER_RESET, M_NULL); MIL_INT TargetIteration = (Data.m_Mode == VisualizationMode::RUN) ? Data.m_LoopIteration : Data.m_TargetIteration; if(TargetIteration != LastDrawnIteration) { M3ddispControl(Data.m_MilDisplay, M_UPDATE, M_DISABLE); /* Clear display. */ if(DrawNode) M3dgraRemove(GraList, M_ALL, M_DEFAULT); /* Draw registration result for a given iteration. */ DrawNode = M3dregDraw3d(Data.m_MilDrawContext, Data.m_MilRegResult, 1, TargetIteration, 0, GraList, M_DEFAULT, M_DEFAULT); M3ddispControl(Data.m_MilDisplay, M_UPDATE, M_ENABLE); LastDrawnIteration = TargetIteration; } MIL_DOUBLE DrawTime = MappTimer(M_TIMER_READ, M_NULL) * 1000; if(!Data.m_Running.load(std::memory_order_relaxed)) return 0; /* Delay time between 2 drawings. */ static const MIL_INT ITERATION_SHOW_TIME = 100; // in msec static const MIL_INT LAST_ITERATION_SHOW_TIME = 2000; // in msec MIL_INT ShowTime = 0; if(Data.m_Mode == VisualizationMode::RUN) { if(Data.m_LoopIteration == NbIteration - 1) { ShowTime = LAST_ITERATION_SHOW_TIME; } else { ShowTime = ITERATION_SHOW_TIME; } } if(DrawTime &lt; ShowTime) { MosSleep(ShowTime - (MIL_INT)DrawTime); } if(Data.m_Mode == VisualizationMode::RUN) { Data.m_LoopIteration++; } else { /* Even when not in run mode, we need to sync m_LoopIteration. */ Data.m_LoopIteration = Data.m_TargetIteration; } if(Data.m_LoopIteration &gt;= NbIteration) { Data.m_LoopIteration = NbIteration-1; } if(!Data.m_Running.load(std::memory_order_relaxed)) return 0; } } //***************************************************************************** // Show next step. //***************************************************************************** void CRegDisplay::ShowNextStep() { if(m_Mode == VisualizationMode::RUN) { m_TargetIteration = m_LoopIteration; } m_TargetIteration++; if(m_TargetIteration &gt; m_NumIterations - 1) { m_TargetIteration = m_NumIterations - 1; } m_Mode = VisualizationMode::SINGLE; } //***************************************************************************** // Show previous step. //***************************************************************************** void CRegDisplay::ShowPreviousStep() { if(m_Mode == VisualizationMode::RUN) { m_TargetIteration = m_LoopIteration; } m_TargetIteration--; if(m_TargetIteration &lt; 0) { m_TargetIteration = 0; } m_Mode = VisualizationMode::SINGLE; } //***************************************************************************** // Run. //***************************************************************************** void CRegDisplay::Run() { m_Mode = VisualizationMode::RUN; } MIL_ID CRegDisplay::GetMilDisplayID() { return m_MilDisplay.get(); } //***************************************************************************** // Constructor. //***************************************************************************** CDisplayController::CDisplayController(): m_Running({false}) { } //***************************************************************************** // Destructor. //***************************************************************************** CDisplayController::~CDisplayController() { End(); } //***************************************************************************** // Register display. //***************************************************************************** void CDisplayController::RegisterDisplay(CRegDisplay * Display) { m_RegisteredDisplay.push_back(Display); } //***************************************************************************** // Start. //***************************************************************************** void CDisplayController::Start(bool IsFinalDisplay) { End(); m_Running.store(true, std::memory_order_relaxed); /* Print instructions. */ MosPrintf(MIL_TEXT(\"\\n\")); MosPrintf(MIL_TEXT(\"Use Up Key to see the next iteration.\\n\")); MosPrintf(MIL_TEXT(\"Use Down Key or Left Key to see the previous iteration.\\n\")); MosPrintf(MIL_TEXT(\"Use Right Key to loop.\\n\")); MosPrintf(MIL_TEXT(\"\\n\")); if(IsFinalDisplay) MosPrintf(MIL_TEXT(\"Press any key to end.\\n\")); else MosPrintf(MIL_TEXT(\"Press any key to continue.\\n\")); MosPrintf(MIL_TEXT(\"\\n\")); m_MilControlThread = MthrAlloc(M_DEFAULT_HOST, M_THREAD, M_DEFAULT, CDisplayController::ProcessControlThread, this, M_UNIQUE_ID); MthrWait(m_MilControlThread, M_THREAD_END_WAIT, M_NULL); } //***************************************************************************** // End. //***************************************************************************** void CDisplayController::End() { if(m_Running.load(std::memory_order_relaxed)) { /* Signal threads to end and wait. */ m_Running.store(false, std::memory_order_relaxed); if(m_MilControlThread != M_NULL) { MthrWait(m_MilControlThread, M_THREAD_END_WAIT, M_NULL); } } } //***************************************************************************** // Control thread. //***************************************************************************** MIL_UINT32 MFTYPE CDisplayController::ProcessControlThread(void* pUserData) { CDisplayController&amp; Data = *(CDisplayController*)pUserData; /* Read pressed key and control visualization mode. */ while(Data.m_Running.load(std::memory_order_relaxed)) { MIL_INT Input = MosGetch(); switch(Input) { case KEY_UP: { for(MIL_UINT Index = 0; Index &lt; Data.m_RegisteredDisplay.size(); Index++) { CRegDisplay* Display = Data.m_RegisteredDisplay[Index]; if(Display != M_NULL) { Display-&gt;ShowNextStep(); } } break; } case KEY_LEFT: case KEY_DOWN: { for(MIL_UINT Index = 0; Index &lt; Data.m_RegisteredDisplay.size(); Index++) { CRegDisplay* Display = Data.m_RegisteredDisplay[Index]; if(Display != M_NULL) { Display-&gt;ShowPreviousStep(); } } break; } case KEY_RIGHT: { for(MIL_UINT Index = 0; Index &lt; Data.m_RegisteredDisplay.size(); Index++) { CRegDisplay* Display = Data.m_RegisteredDisplay[Index]; if(Display != M_NULL) { Display-&gt;Run(); } } break; } case KEY_SKIP: { break; } default: for(MIL_UINT Index = 0; Index &lt; Data.m_RegisteredDisplay.size(); Index++) { CRegDisplay* Display = Data.m_RegisteredDisplay[Index]; if(Display != M_NULL) { Display-&gt;End(); } } return 0; } } return 0; } ",
      "wordCount": 814
    }
  ]
}]
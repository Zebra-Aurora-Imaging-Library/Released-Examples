[{
  "id": "Example_PlaceHolder_ID",
  "version": "2024020714",
  "title": "Example_PlaceHolder_Title",
  "wordCount": 0,
  "subEntries": [
    {
      "id": "Examples_Processing_3dCalibration_ObjectLocalization3d_CPP_adaptivethresholder_cpp",
      "version": "2024020714",
      "title": "adaptivethresholder.cpp",
      "location": "Sample Code from MIL Examples",
      "text": " Top //***************************************************************************************/ // // File name: AdaptiveThresholder.cpp // Location: See Matrox Example Launcher in the MIL Control Center // // // Synopsis: Implements the CAdaptiveThresholder class. // // Copyright (C) Matrox Electronic Systems Ltd., 1992-2024. // All Rights Reserved #include \"common.h\" #include \"AdaptiveThresholder.h\" //***************************************************************************** // Constants. //***************************************************************************** // Number of iterations for dilation and erosion operations; define the kernel size for the // max and min operations. static const MIL_INT NB_MORPH_ITERATIONS = 6; // Minimum contrast between a pixel and the average of its surrounding to consider this // pixel as white. static const MIL_DOUBLE CONTRAST_THRESHOLD = 15.0; //***************************************************************************** // Constructor. Allocates temporary images. //***************************************************************************** CAdaptiveThresholder::CAdaptiveThresholder(MIL_ID MilSystem, MIL_INT SizeX, MIL_INT SizeY) { MbufAlloc2d(MilSystem, SizeX, SizeY, 8+M_UNSIGNED, M_IMAGE+M_PROC, &amp;m_MilMinImage); MbufAlloc2d(MilSystem, SizeX, SizeY, 8+M_UNSIGNED, M_IMAGE+M_PROC, &amp;m_MilMaxImage); } //***************************************************************************** // Destructor. Free all MIL objects. //***************************************************************************** CAdaptiveThresholder::~CAdaptiveThresholder() { MbufFree(m_MilMaxImage); MbufFree(m_MilMinImage); } //***************************************************************************** // Perform adaptive thresholding. //***************************************************************************** void CAdaptiveThresholder::Binarize(MIL_ID MilGrayscaleImage, MIL_ID MilBinarizedImage) { // Grayscale dilation is the same as finding the maximum value in a neighborhood. MimDilate(MilGrayscaleImage, m_MilMaxImage, NB_MORPH_ITERATIONS, M_GRAYSCALE); // Grayscale erosion is the same as finding the minimum value in a neighborhood. MimErode(MilGrayscaleImage, m_MilMinImage, NB_MORPH_ITERATIONS, M_GRAYSCALE); // m_MilMinImage := (Max + Min)/2 (a kind of average) MimArithMultiple(m_MilMaxImage, 2.0, m_MilMinImage, M_NULL, M_NULL, m_MilMinImage, M_WEIGHTED_AVERAGE, M_DEFAULT); // m_MilMinImage := Source - (Max + Min)/2, saturated to 0 MimArith(MilGrayscaleImage, m_MilMinImage, m_MilMinImage, M_SUB+M_SATURATION); // Binarized pixel is white if ( Source - (Max + Min)/2 ) &gt; CONTRAST_THRESHOLD MimBinarize(m_MilMinImage, MilBinarizedImage, M_FIXED+M_GREATER_OR_EQUAL, CONTRAST_THRESHOLD, M_NULL); } ",
      "wordCount": 242
    },
    {
      "id": "Examples_Processing_3dCalibration_ObjectLocalization3d_CPP_blackfiducialfinder_cpp",
      "version": "2024020714",
      "title": "blackfiducialfinder.cpp",
      "location": "Sample Code from MIL Examples",
      "text": " Top //*************************************************************************************** // // File name: BlackFiducialFinder.cpp // Location: See Matrox Example Launcher in the MIL Control Center // // // Synopsis: Implements the CBlackFiducialFinder class. // // Copyright (C) Matrox Electronic Systems Ltd., 1992-2024. // All Rights Reserved #include \"common.h\" #include \"BlackFiducialFinder.h\" // All arrays will be resized dynamically. This is the initial size of the arrays. static const MIL_INT STARTING_ARRAY_SIZE = 16; // Expected criteria of the black fiducial blob. static const MIL_DOUBLE MIN_AREA = 80.0; // in pixels static const MIL_DOUBLE MAX_AREA = 800.0; // in pixels static const MIL_DOUBLE EXPECTED_HOLES = 1.0; static const MIL_DOUBLE MIN_FERET_MAX = 12.0; // in pixels static const MIL_DOUBLE MAX_FERET_MAX = 40.0; // in pixels static const MIL_DOUBLE MAX_ROUGHNESS = 1.65; //***************************************************************************** // Constructor. Allocate and setup MIL objects. //***************************************************************************** CBlackFiducialFinder::CBlackFiducialFinder(MIL_ID MilSystem) { // Allocate and setup MIL objects for milblob. MblobAlloc(MilSystem, M_DEFAULT, M_DEFAULT, &amp;m_MilBlobContext); MblobAllocResult(MilSystem, M_DEFAULT, M_DEFAULT, &amp;m_MilBlobResult); MblobControl(m_MilBlobContext, M_FOREGROUND_VALUE, M_ZERO); MblobControl(m_MilBlobContext, M_CONNECTIVITY, M_8_CONNECTED); // Allocate dynamic arrays. AllocateArrays(STARTING_ARRAY_SIZE); } //***************************************************************************** // Destructor. Free all MIL objects and memory. //***************************************************************************** CBlackFiducialFinder::~CBlackFiducialFinder() { DestroyArrays(); MblobFree(m_MilBlobResult); MblobFree(m_MilBlobContext); } //***************************************************************************** // Find the black fiducials, i.e. black mostly circular or elliptical blobs // with exactly one white hole inside. Returns the number of fiducials. //***************************************************************************** MIL_INT CBlackFiducialFinder::Find(MIL_ID MilBinarizedImage) { // Clear context from previous call. MblobControl(m_MilBlobContext, M_ALL_FEATURES, M_DISABLE); // Set the first features in the list. MblobControl(m_MilBlobContext, M_NUMBER_OF_HOLES, M_ENABLE); // Find all black blobs. MblobCalculate(m_MilBlobContext, MilBinarizedImage, M_NULL, m_MilBlobResult); // Remove blobs that do not have exactly one hole or whose area is not in the expected range. MblobSelect(m_MilBlobResult, M_DELETE, M_AREA, M_OUT_RANGE, MIN_AREA, MAX_AREA); MblobSelect(m_MilBlobResult, M_DELETE, M_NUMBER_OF_HOLES, M_NOT_EQUAL, EXPECTED_HOLES, M_NULL); // Add other features to compute on the remaining blobs. MblobControl(m_MilBlobContext, M_FERETS, M_ENABLE); MblobControl(m_MilBlobContext, M_ROUGHNESS, M_ENABLE); // Calculate the new features only on the remaining blobs. MblobCalculate(m_MilBlobContext, MilBinarizedImage, M_NULL, m_MilBlobResult); // Remove the blobs whose max feret is not in the expected range (those that are too // elongated) or those who are not really smooth and convex. This should yield mostly // circular or elliptical black blobs with exactly one white hole inside. MblobSelect(m_MilBlobResult, M_DELETE, M_FERET_MAX_DIAMETER, M_OUT_RANGE, MIN_FERET_MAX, MAX_FERET_MAX); MblobSelect(m_MilBlobResult, M_DELETE, M_ROUGHNESS, M_GREATER, MAX_ROUGHNESS, M_NULL); // Get the number of fiducials found. MIL_INT NbBlobs; MblobGetResult(m_MilBlobResult, M_DEFAULT, M_NUMBER + M_TYPE_MIL_INT, &amp;NbBlobs); if (NbBlobs &gt; 0) { // Calculate necessary features on the found fiducials: CoG and bounding box. MblobControl(m_MilBlobContext, M_CENTER_OF_GRAVITY + M_BINARY, M_ENABLE); MblobControl(m_MilBlobContext, M_BOX, M_ENABLE); MblobCalculate(m_MilBlobContext, MilBinarizedImage, M_NULL, m_MilBlobResult); // Get the features. ReserveArraySpace(NbBlobs); MblobGetResult(m_MilBlobResult, M_DEFAULT, M_BOX_X_MIN, m_BoxXMinArray); MblobGetResult(m_MilBlobResult, M_DEFAULT, M_BOX_Y_MIN, m_BoxYMinArray); MblobGetResult(m_MilBlobResult, M_DEFAULT, M_BOX_X_MAX, m_BoxXMaxArray); MblobGetResult(m_MilBlobResult, M_DEFAULT, M_BOX_Y_MAX, m_BoxYMaxArray); MblobGetResult(m_MilBlobResult, M_DEFAULT, M_CENTER_OF_GRAVITY_X + M_BINARY, m_CoGXArray); MblobGetResult(m_MilBlobResult, M_DEFAULT, M_CENTER_OF_GRAVITY_Y + M_BINARY, m_CoGYArray); } return NbBlobs; } //***************************************************************************** // Return the necessary information to create a child buffer around the fiducial // with the given index. //***************************************************************************** void CBlackFiducialFinder::GetChildRect(MIL_INT FiducialIdx, MIL_INT* pChildOffsetX, MIL_INT* pChildOffsetY, MIL_INT* pChildSizeX, MIL_INT* pChildSizeY) { *pChildOffsetX = static_cast&lt;MIL_INT&gt;( m_BoxXMinArray[FiducialIdx] ); *pChildOffsetY = static_cast&lt;MIL_INT&gt;( m_BoxYMinArray[FiducialIdx] ); *pChildSizeX = static_cast&lt;MIL_INT&gt;( m_BoxXMaxArray[FiducialIdx]+1.0 ) - *pChildOffsetX; *pChildSizeY = static_cast&lt;MIL_INT&gt;( m_BoxYMaxArray[FiducialIdx]+1.0 ) - *pChildOffsetY; } //***************************************************************************** // If there is not enough space in the arrays, free and reallocate them. Else, // do nothing. //***************************************************************************** void CBlackFiducialFinder::ReserveArraySpace(MIL_INT MinArraySize) { if (m_ArraySize &lt; MinArraySize) { DestroyArrays(); AllocateArrays(MinArraySize); } } //***************************************************************************** // Set new size for the dynamic arrays and allocate them. //***************************************************************************** void CBlackFiducialFinder::AllocateArrays(MIL_INT ArraySize) { m_BoxXMinArray = new MIL_DOUBLE[ArraySize]; m_BoxYMinArray = new MIL_DOUBLE[ArraySize]; m_BoxXMaxArray = new MIL_DOUBLE[ArraySize]; m_BoxYMaxArray = new MIL_DOUBLE[ArraySize]; m_CoGXArray = new MIL_DOUBLE[ArraySize]; m_CoGYArray = new MIL_DOUBLE[ArraySize]; m_ArraySize = ArraySize; } //***************************************************************************** // Free the memory of the dynamic arrays. //***************************************************************************** void CBlackFiducialFinder::DestroyArrays() { delete [] m_CoGYArray; delete [] m_CoGXArray; delete [] m_BoxYMaxArray; delete [] m_BoxXMaxArray; delete [] m_BoxYMinArray; delete [] m_BoxXMinArray; } ",
      "wordCount": 602
    },
    {
      "id": "Examples_Processing_3dCalibration_ObjectLocalization3d_CPP_featurefinder_cpp",
      "version": "2024020714",
      "title": "featurefinder.cpp",
      "location": "Sample Code from MIL Examples",
      "text": " Top //***************************************************************************************/ // // File name: FeatureFinder.cpp // Location: See Matrox Example Launcher in the MIL Control Center // // // Synopsis: Implements the CFeatureFinder class. // // Copyright (C) Matrox Electronic Systems Ltd., 1992-2024. // All Rights Reserved #include \"common.h\" #include \"FeatureFinder.h\" #include \"AdaptiveThresholder.h\" #include \"BlackFiducialFinder.h\" #include \"WhiteFiducialFinder.h\" #include \"PharmacodeReader.h\" //***************************************************************************** // Structure representing one fiducial in the CAD: its pharmacode string and // its 3d position in the CAD. //***************************************************************************** struct SCADFeature { MIL_CONST_TEXT_PTR m_CodeString; MIL_DOUBLE m_PosX; MIL_DOUBLE m_PosY; MIL_DOUBLE m_PosZ; }; //***************************************************************************** // Constants. //***************************************************************************** static const SCADFeature CAD_FEATURE_ARRAY[] = {// CodeString PosX PosY PosZ {MIL_TEXT(\"16\"), 68.6, 178.9, -93.6}, {MIL_TEXT(\"17\"), 101.8, 178.8, -93.8}, {MIL_TEXT(\"18\"), 112.1, 11.0, -60.9}, {MIL_TEXT(\"20\"), 55.5, 12.6, -61.0}, {MIL_TEXT(\"22\"), 107.7, 92.6, -92.8}, {MIL_TEXT(\"26\"), 61.4, 92.5, -92.7}, {MIL_TEXT(\"64\"), 127.5, 177.5, -73.2}, {MIL_TEXT(\"65\"), 43.1, 178.6, -73.5}, {MIL_TEXT(\"66\"), 123.8, 120.8, -84.8}, {MIL_TEXT(\"67\"), 45.4, 120.2, -85.4}, {MIL_TEXT(\"68\"), 133.4, 157.5, -62.3}, {MIL_TEXT(\"69\"), 37.3, 159.1, -63.2}, {MIL_TEXT(\"72\"), 134.5, 81.2, -56.9}, {MIL_TEXT(\"73\"), 34.5, 79.7, -58.3} }; static const MIL_INT NB_CAD_FEATURES = sizeof(CAD_FEATURE_ARRAY)/sizeof(CAD_FEATURE_ARRAY[0]); //***************************************************************************** // Constructor. Allocates all necessary objects. //***************************************************************************** CFeatureFinder::CFeatureFinder(MIL_ID MilSystem, MIL_INT SizeX, MIL_INT SizeY) : m_pAdaptiveThresholder(new CAdaptiveThresholder(MilSystem, SizeX, SizeY)), m_pBlackFiducialFinder(new CBlackFiducialFinder(MilSystem)), m_pWhiteFiducialFinder(new CWhiteFiducialFinder(MilSystem)), m_pPharmacodeReader (new CPharmacodeReader (MilSystem)) { MbufAlloc2d(MilSystem, SizeX, SizeY, 1+M_UNSIGNED, M_IMAGE+M_PROC, &amp;m_MilBinarizedImage); MbufChild2d(m_MilBinarizedImage, 0, 0, 1, 1, &amp;m_MilBinarizedChild); } //***************************************************************************** // Destructor. Free all allocated objects. //***************************************************************************** CFeatureFinder::~CFeatureFinder() { delete m_pAdaptiveThresholder; delete m_pBlackFiducialFinder; delete m_pWhiteFiducialFinder; delete m_pPharmacodeReader ; MbufFree(m_MilBinarizedChild); MbufFree(m_MilBinarizedImage); } //***************************************************************************** // Find and identify all fiducials in the image, and draw them in the overlay. //***************************************************************************** void CFeatureFinder::Find(MIL_ID MilDisplay, MIL_ID MilDisplayImage, SObjectFeatures* pObjectFeatures) { // Get overlay Id. MIL_ID MilOverlayImage; MdispInquire(MilDisplay, M_OVERLAY_ID, &amp;MilOverlayImage); // Initialize output structure. pObjectFeatures-&gt;m_NumPoint = 0; // Use adaptive thresholding to binarize the image. m_pAdaptiveThresholder-&gt;Binarize(MilDisplayImage, m_MilBinarizedImage); // Find the black fiducials, i.e. black mostly circular or elliptical blobs // with exactly one white hole inside. MIL_INT NbBlackFiducials = m_pBlackFiducialFinder-&gt;Find(m_MilBinarizedImage); // For each black fiducial... for (MIL_INT BlackFiducialIdx = 0; BlackFiducialIdx &lt; NbBlackFiducials; ++BlackFiducialIdx) { // Define a rectangular region around the black fiducial. MIL_INT ChildOffsetX, ChildOffsetY, ChildSizeX, ChildSizeY; m_pBlackFiducialFinder-&gt;GetChildRect(BlackFiducialIdx, &amp;ChildOffsetX, &amp;ChildOffsetY, &amp;ChildSizeX, &amp;ChildSizeY); MbufChildMove(m_MilBinarizedChild, ChildOffsetX, ChildOffsetY, ChildSizeX, ChildSizeY, M_DEFAULT); // The white hole is expected to be approximately in the center of the region. MIL_DOUBLE ApproxWhiteBlobX = 0.5*static_cast&lt;MIL_DOUBLE&gt;(ChildSizeX+1); MIL_DOUBLE ApproxWhiteBlobY = 0.5*static_cast&lt;MIL_DOUBLE&gt;(ChildSizeY+1); // Find the center of the white hole. bool WhiteFiducialFound = m_pWhiteFiducialFinder-&gt;Find(m_MilBinarizedChild, ApproxWhiteBlobX, ApproxWhiteBlobY); MIL_DOUBLE WhiteFiducialX = m_pWhiteFiducialFinder-&gt;GetCoGX() + static_cast&lt;MIL_DOUBLE&gt;(ChildOffsetX); MIL_DOUBLE WhiteFiducialY = m_pWhiteFiducialFinder-&gt;GetCoGY() + static_cast&lt;MIL_DOUBLE&gt;(ChildOffsetY); if (WhiteFiducialFound) { // Fixture the image such that the origin is the center of gravity of the white // hole and the positive X axis is going through the pharmacode (in the direction // of the black fiducial center of gravity). McalFixture(MilDisplayImage, M_NULL, M_MOVE_RELATIVE, M_POINT_AND_DIRECTION_POINT, M_NULL, WhiteFiducialX, WhiteFiducialY, m_pBlackFiducialFinder-&gt;GetCoGX(BlackFiducialIdx), m_pBlackFiducialFinder-&gt;GetCoGY(BlackFiducialIdx)); // Now both MilDisplayImage and its overlay are fixtured. // Read the pharmacode. MIL_CONST_TEXT_PTR PharmacodeString = m_pPharmacodeReader-&gt;Read(MilDisplayImage); if ( PharmacodeString != NULL ) { // A pharmacode was read. Check that it exists in the CAD feature table. for (MIL_INT CADFeatureIdx = 0; CADFeatureIdx &lt; NB_CAD_FEATURES; ++CADFeatureIdx) { if (MosStrcmp(PharmacodeString, CAD_FEATURE_ARRAY[CADFeatureIdx].m_CodeString) == 0) { // The string was found. Copy the feature coordinates in the output structure. MIL_INT FoundFeatureIdx = pObjectFeatures-&gt;m_NumPoint; pObjectFeatures-&gt;m_XPixArray [FoundFeatureIdx] = WhiteFiducialX; pObjectFeatures-&gt;m_YPixArray [FoundFeatureIdx] = WhiteFiducialY; pObjectFeatures-&gt;m_XWorldArray[FoundFeatureIdx] = CAD_FEATURE_ARRAY[CADFeatureIdx].m_PosX; pObjectFeatures-&gt;m_YWorldArray[FoundFeatureIdx] = CAD_FEATURE_ARRAY[CADFeatureIdx].m_PosY; pObjectFeatures-&gt;m_ZWorldArray[FoundFeatureIdx] = CAD_FEATURE_ARRAY[CADFeatureIdx].m_PosZ; pObjectFeatures-&gt;m_NumPoint++; // Draw the red cross. m_pWhiteFiducialFinder-&gt;Draw(MilOverlayImage); // Draw the pharmacode label. m_pPharmacodeReader-&gt;Draw(MilOverlayImage); // No need to continue looping on the features. break; } } } } // Avoid buffer overrun. if (pObjectFeatures-&gt;m_NumPoint == MAX_NB_FEATURES) break; } // Remove image fixture by removing its associated calibration. McalAssociate(M_NULL, MilDisplayImage, M_DEFAULT); } ",
      "wordCount": 578
    },
    {
      "id": "Examples_Processing_3dCalibration_ObjectLocalization3d_CPP_objectlocalization3d_cpp",
      "version": "2024020714",
      "title": "objectlocalization3d.cpp",
      "location": "Sample Code from MIL Examples",
      "text": " Top //***************************************************************************************/ // // File name: ObjectLocalization3d.cpp // Location: See Matrox Example Launcher in the MIL Control Center // // // Synopsis: See the PrintHeader() function below for detailed description. // // Copyright (C) Matrox Electronic Systems Ltd., 1992-2024. // All Rights Reserved #include \"common.h\" #include \"FeatureFinder.h\" //**************************************************************************** // Example description. //**************************************************************************** void PrintHeader() { MosPrintf(MIL_TEXT(\"[EXAMPLE NAME]\\n\") MIL_TEXT(\"ObjectLocalization3d\\n\\n\") MIL_TEXT(\"[SYNOPSIS]\\n\") MIL_TEXT(\"This example demonstrates how the calibration module can be used to determine\\n\") MIL_TEXT(\"the 3d position and orientation of an object after locating known fiducials on\\n\") MIL_TEXT(\"the object.\\n\\n\") MIL_TEXT(\"[MODULES USED]\\n\") MIL_TEXT(\"Modules used: application, system, display, digitizer, buffer, graphic,\\n\") MIL_TEXT(\" image processing, calibration, code.\\n\\n\") MIL_TEXT(\"Press any key to start.\\n\\n\")); MosGetch(); } //**************************************************************************** // Constants. //**************************************************************************** // Directory containing all files used in this example. #define EXAMPLE_IMAGE_PATH M_IMAGE_PATH MIL_TEXT(\"ObjectLocalization3d/\") // File containing the calibration context for the camera to use. static MIL_CONST_TEXT_PTR const CALIBRATION_CONTEXT_FILE = EXAMPLE_IMAGE_PATH MIL_TEXT(\"Calib.mca\"); static MIL_CONST_TEXT_PTR const SEQ_FILE = EXAMPLE_IMAGE_PATH MIL_TEXT(\"seq.avi\"); // Colors used to draw in the overlay. static const MIL_DOUBLE COORDINATE_SYSTEM_COLOR = M_COLOR_GRAY; static const MIL_DOUBLE BOUNDING_BOX_COLOR = M_COLOR_CYAN; // Coordinates used to draw a bounding box around the object to locate. static const MIL_INT NB_VERTICES_PER_SIDE = 7; static const MIL_INT NB_CAR_VERTICES = 2*NB_VERTICES_PER_SIDE; static const MIL_DOUBLE CAR_VERTEX_X[NB_CAR_VERTICES] = { 130.1, 126.6, 115.7, 120.3, 128.6, 127.2, 135.1, 40.6, 45.4, 56.3, 49.5, 42.0, 39.5, 35.1}; static const MIL_DOUBLE CAR_VERTEX_Y[NB_CAR_VERTICES] = { 223.7, 213.3, 196.1, 82.1, 43.5, -17.7, -24.2, 221.8, 214.0, 198.1, 80.6, 41.9, -17.5, -25.3}; static const MIL_DOUBLE CAR_VERTEX_Z[NB_CAR_VERTICES] = { -21.4, -64.0, -89.9, -87.7, -64.4, -49.9, -26.7, -27.5, -63.7, -87.3, -87.7, -63.8, -50.4, -24.0}; //**************************************************************************** // Functions declarations. //**************************************************************************** bool LocateObject(MIL_ID MilCalibration, const SObjectFeatures* pObjectFeatures); void DisplayBoundingBox(MIL_ID MilDisplay, MIL_ID MilCalibration); //***************************************************************************** // Main. //***************************************************************************** int MosMain(void) { PrintHeader(); // Allocate MIL objects. MIL_ID MilApplication = MappAlloc(M_NULL, M_DEFAULT, M_NULL); MIL_ID MilSystem = MsysAlloc(M_DEFAULT, M_SYSTEM_HOST, M_DEFAULT, M_DEFAULT, M_NULL); MIL_ID MilDisplay = MdispAlloc(MilSystem, M_DEFAULT, MIL_TEXT(\"M_DEFAULT\"), M_WINDOWED, M_NULL); // Get image size from the video file. MIL_INT SizeX = MbufDiskInquire(SEQ_FILE, M_SIZE_X, M_NULL); MIL_INT SizeY = MbufDiskInquire(SEQ_FILE, M_SIZE_Y, M_NULL); // Setup display image. MIL_ID MilDisplayImage = MbufAlloc2d(MilSystem, SizeX, SizeY, 8+M_UNSIGNED, M_IMAGE+M_PROC+M_DISP, M_NULL); MbufClear(MilDisplayImage, 0.0); MdispSelect(MilDisplay, MilDisplayImage); // Prepare overlay for annotations. MdispControl(MilDisplay, M_OVERLAY, M_ENABLE); // Reload the 3d calibration context from disk. MIL_ID MilCalibration = McalRestore(CALIBRATION_CONTEXT_FILE, MilSystem, M_DEFAULT, M_NULL); if (MilCalibration != M_NULL) { MosPrintf(MIL_TEXT(\"The Tsai-based camera calibration context was restored from disk.\\n\\n\")); MosPrintf(MIL_TEXT(\"For each frame of the video sequence:\\n\") MIL_TEXT(\" - The circular fiducials are found using blob analysis (red crosses).\\n\") MIL_TEXT(\" - Each fiducial is uniquely identified by reading its bar code\\n\") MIL_TEXT(\" (green numeric labels).\\n\") MIL_TEXT(\" - The fiducials' pixel coordinates are paired with the known world\\n\") MIL_TEXT(\" coordinates using their labels.\\n\") MIL_TEXT(\" - McalList() is called to determine the position and orientation of the car.\\n\") MIL_TEXT(\" - The bounding box of the car is drawn in the overlay.\\n\\n\")); MosPrintf(MIL_TEXT(\"Press any key to exit.\\n\\n\")); // Allocate all necessary objects to search for fiducials. CFeatureFinder FeatureFinder(MilSystem, SizeX, SizeY); SObjectFeatures ObjectFeatures; // Open the video sequence and inquire some informations. MbufImportSequence(SEQ_FILE, M_AVI_MIL, M_NULL, M_NULL, M_NULL, M_NULL, M_NULL, M_OPEN); MIL_INT NbFrames = MbufDiskInquire(SEQ_FILE, M_NUMBER_OF_IMAGES, M_NULL); MIL_DOUBLE ImagePeriod; // seconds/image MbufDiskInquire(SEQ_FILE, M_FRAME_RATE, &amp;ImagePeriod); ImagePeriod = 1.0 / ImagePeriod; // Start at the first frame of the video. MIL_INT CurFrame = 0; bool MustQuit = false; while (!MustQuit) { MIL_DOUBLE StartTime = MappTimer(M_DEFAULT, M_TIMER_READ, M_NULL); // Disable display updates. MdispControl(MilDisplay, M_UPDATE, M_DISABLE); // Clear overlay. MdispControl(MilDisplay, M_OVERLAY_CLEAR, M_DEFAULT); // Load the next frame in the video sequence. MbufImportSequence(SEQ_FILE, M_AVI_MIL, M_LOAD, M_NULL, &amp;MilDisplayImage, CurFrame, 1, M_READ); // Find in the image some features of the object at known world locations. FeatureFinder.Find(MilDisplay, MilDisplayImage, &amp;ObjectFeatures); // Check that there are enough features to locate the object. if (ObjectFeatures.m_NumPoint &gt;= MIN_NB_FEATURES) { // Use the calibration module to find the position and orientation of the object. bool ObjectWasLocated = LocateObject(MilCalibration, &amp;ObjectFeatures); // Display a bounding box around the object, in the overlay. if (ObjectWasLocated) { DisplayBoundingBox(MilDisplay, MilCalibration); } } // Enable (and force) display updates. MdispControl(MilDisplay, M_UPDATE, M_ENABLE); // Go to the next frame of the video, or wrap-around (loop endlessly). if (++CurFrame == NbFrames) CurFrame = 0; // Compute elapsed time for this iteration. MIL_DOUBLE ElapsedTime; MappTimer(M_DEFAULT, M_TIMER_READ, &amp;ElapsedTime); ElapsedTime -= StartTime; // Wait until the end of the image period to keep a correct video display speed. MIL_DOUBLE WaitTime = ImagePeriod - ElapsedTime; if (WaitTime &gt; 0.0) MappTimer(M_DEFAULT, M_TIMER_WAIT, &amp;WaitTime); // Read all characters typed by the user during this iteration. while (MosKbhit()) { switch (MosGetch()) { // If user presses any key, quit this loop. case MIL_TEXT('\\r'): case MIL_TEXT('\\n'): MustQuit = true; break; } } } // Close the video file. MbufImportSequence(SEQ_FILE, M_AVI_MIL, M_NULL, M_NULL, M_NULL, M_NULL, M_NULL, M_CLOSE); } else { MosPrintf(MIL_TEXT(\"Unable to reload the calibration context.\\n\") MIL_TEXT(\"Press any key to exit.\\n\\n\")); MosGetch(); } // Free MIL objects. McalFree(MilCalibration); MbufFree(MilDisplayImage); MdispFree(MilDisplay); MsysFree(MilSystem); MappFree(MilApplication); return 0; } //***************************************************************************** // Use McalList() to find the position and orientation of the object. Returns // true if successful. //***************************************************************************** bool LocateObject(MIL_ID MilCalibration, const SObjectFeatures* pObjectFeatures) { // Disable error printing to avoid runtime errors about collinear points. MIL_INT PreviousErrorPrintingState; MappInquire(M_DEFAULT, M_ERROR, &amp;PreviousErrorPrintingState); MappControl(M_DEFAULT, M_ERROR, M_PRINT_DISABLE); // Try locating the object. McalList(MilCalibration, pObjectFeatures-&gt;m_XPixArray, pObjectFeatures-&gt;m_YPixArray, pObjectFeatures-&gt;m_XWorldArray, pObjectFeatures-&gt;m_YWorldArray, pObjectFeatures-&gt;m_ZWorldArray, pObjectFeatures-&gt;m_NumPoint, M_DISPLACE_RELATIVE_COORD, M_DEFAULT); // Re-enable error printing if necessary. MappControl(M_DEFAULT, M_ERROR, PreviousErrorPrintingState); // Check if the call was successful. MIL_INT LocateStatus = McalInquire(MilCalibration, M_CALIBRATION_STATUS, M_NULL); return (LocateStatus == M_CALIBRATED); } //***************************************************************************** // Draw a bounding box in the overlay around the object. //***************************************************************************** void DisplayBoundingBox(MIL_ID MilDisplay, MIL_ID MilCalibration) { // Get overlay Id. MIL_ID MilOverlayImage; MdispInquire(MilDisplay, M_OVERLAY_ID, &amp;MilOverlayImage); // Draw the coordinate system, i.e. the \"floor\" on which the car is found. MgraControl(M_DEFAULT, M_COLOR, COORDINATE_SYSTEM_COLOR); McalDraw(M_DEFAULT, MilCalibration, MilOverlayImage, M_DRAW_RELATIVE_COORDINATE_SYSTEM, M_DEFAULT, M_DEFAULT); // Convert the bounding box coordinates from CAD to image. MIL_DOUBLE ImageVertexX[NB_CAR_VERTICES]; MIL_DOUBLE ImageVertexY[NB_CAR_VERTICES]; McalTransformCoordinate3dList(MilCalibration, M_RELATIVE_COORDINATE_SYSTEM, M_PIXEL_COORDINATE_SYSTEM, NB_CAR_VERTICES, CAR_VERTEX_X, CAR_VERTEX_Y, CAR_VERTEX_Z, ImageVertexX, ImageVertexY, M_NULL, M_DEFAULT); MgraControl(M_DEFAULT, M_COLOR, BOUNDING_BOX_COLOR); MgraControl(M_DEFAULT, M_INPUT_UNITS, M_PIXEL); // Draw one side of the car as a single polygon. MgraLines(M_DEFAULT, MilOverlayImage, NB_VERTICES_PER_SIDE, ImageVertexX, ImageVertexY, M_NULL, M_NULL, M_POLYGON); // Draw the other side as another polygon. MgraLines(M_DEFAULT, MilOverlayImage, NB_VERTICES_PER_SIDE, ImageVertexX+NB_VERTICES_PER_SIDE, ImageVertexY+NB_VERTICES_PER_SIDE, M_NULL, M_NULL, M_POLYGON); // Draw lines between the corresponding vertices of the two polygons. MgraLines(M_DEFAULT, MilOverlayImage, NB_VERTICES_PER_SIDE, ImageVertexX, ImageVertexY, ImageVertexX+NB_VERTICES_PER_SIDE, ImageVertexY+NB_VERTICES_PER_SIDE, M_DEFAULT); } ",
      "wordCount": 1015
    },
    {
      "id": "Examples_Processing_3dCalibration_ObjectLocalization3d_CPP_pharmacodereader_cpp",
      "version": "2024020714",
      "title": "pharmacodereader.cpp",
      "location": "Sample Code from MIL Examples",
      "text": " Top //***************************************************************************************/ // // File name: PharmacodeReader.cpp // Location: See Matrox Example Launcher in the MIL Control Center // // // Synopsis: Implements the CPharmacodeReader class. // // Copyright (C) Matrox Electronic Systems Ltd., 1992-2024. // All Rights Reserved #include \"common.h\" #include \"PharmacodeReader.h\" //***************************************************************************** // Constants. //***************************************************************************** // Minimum contrast between the foreground and background in the target image. static const MIL_DOUBLE MIN_CONTRAST = 30.0; // Color used to draw the code string. static const MIL_DOUBLE CODE_STRING_COLOR = M_COLOR_GREEN; // Size of the rectangular region in which to search for the code. static const MIL_DOUBLE CODE_CHILD_WIDTH = 156.0; static const MIL_DOUBLE CODE_CHILD_HEIGHT = 60.0; //***************************************************************************** // Constructor. Allocates all necessary MIL objects and set the code context up. //***************************************************************************** CPharmacodeReader::CPharmacodeReader(MIL_ID MilSystem) { // We will use a rectangular region in fixtured (pixel) coordinates to look for the code. // This region definition will be kept in a graphic list object. MgraAllocList(MilSystem, M_DEFAULT, &amp;m_MilGraList); // Use fixtured units, i.e. M_WORLD (even if the world unit is the pixel). MgraControl(M_DEFAULT, M_INPUT_UNITS, M_WORLD); MgraRectFill(M_DEFAULT, m_MilGraList, 0.0, -CODE_CHILD_HEIGHT/2.0, CODE_CHILD_WIDTH, CODE_CHILD_HEIGHT/2.0); // Allocates the code context and its result buffer. McodeAlloc(MilSystem, M_DEFAULT, M_DEFAULT, &amp;m_MilCodeContext); McodeAllocResult(MilSystem, M_DEFAULT, &amp;m_MilCodeResult); // We look for pharmacodes. McodeModel(m_MilCodeContext, M_ADD, M_PHARMACODE, M_NULL, M_DEFAULT, M_NULL); // Add some options for a good compromise between speed and robustness. McodeControl(m_MilCodeContext, M_SCANLINE_HEIGHT, 2.0); McodeControl(m_MilCodeContext, M_SCANLINE_STEP, 2.0); McodeControl(m_MilCodeContext, M_THRESHOLD_MODE, M_ADAPTIVE); McodeControl(m_MilCodeContext, M_MINIMUM_CONTRAST, MIN_CONTRAST); // We will search the code in a rectangular region which could have any angle. McodeControl(m_MilCodeContext, M_SEARCH_ANGLE, M_ACCORDING_TO_REGION); // Initialize the code string to the empty string. m_CodeString[0] = MIL_TEXT('\\0'); } //***************************************************************************** // Destructor. Free all MIL objects. //***************************************************************************** CPharmacodeReader::~CPharmacodeReader() { McodeFree(m_MilCodeResult); McodeFree(m_MilCodeContext); MgraFree(m_MilGraList); } //***************************************************************************** // Find a pharmacode and return the code string. Works in fixtured images only. // If no code is found, returns NULL. //***************************************************************************** MIL_CONST_TEXT_PTR CPharmacodeReader::Read(MIL_ID MilImage) { MIL_CONST_TEXT_PTR CodeString = NULL; // Read code in a rectangular region near the black fiducial. MbufSetRegion(MilImage, m_MilGraList, M_DEFAULT, M_DEFAULT, M_DEFAULT); McodeRead(m_MilCodeContext, MilImage, m_MilCodeResult); MbufSetRegion(MilImage, M_NULL, M_DEFAULT, M_DELETE, M_DEFAULT); // Check that a code was read. MIL_INT NbCodes; McodeGetResult(m_MilCodeResult, M_GENERAL, M_GENERAL, M_NUMBER+M_TYPE_MIL_INT, &amp;NbCodes); if (NbCodes == 1) { // Get the code string. MIL_INT StringSize; McodeGetResult(m_MilCodeResult, 0, M_GENERAL, M_STRING + M_STRING_SIZE +M_TYPE_MIL_INT, &amp;StringSize); if (StringSize &lt;= MAX_STRING_LEN) { McodeGetResult(m_MilCodeResult, 0, M_GENERAL, M_STRING, m_CodeString); CodeString = m_CodeString; } } return CodeString; } //***************************************************************************** // Draw the code found in the last call to Read(). //***************************************************************************** void CPharmacodeReader::Draw(MIL_ID MilOverlayImage) const { // Get the position where the code was found. MIL_DOUBLE PosX, PosY; McodeGetResult(m_MilCodeResult, 0, M_GENERAL, M_POSITION_X, &amp;PosX); McodeGetResult(m_MilCodeResult, 0, M_GENERAL, M_POSITION_Y, &amp;PosY); // This position is in fixtured coordinates, so let's use M_WORLD input units. MgraControl(M_DEFAULT, M_INPUT_UNITS, M_WORLD); // Draw the code string. MgraControl(M_DEFAULT, M_COLOR, CODE_STRING_COLOR); MgraText(M_DEFAULT, MilOverlayImage, PosX, PosY, m_CodeString); } ",
      "wordCount": 452
    },
    {
      "id": "Examples_Processing_3dCalibration_ObjectLocalization3d_CPP_whitefiducialfinder_cpp",
      "version": "2024020714",
      "title": "whitefiducialfinder.cpp",
      "location": "Sample Code from MIL Examples",
      "text": " Top //*************************************************************************************** // // File name: WhiteFiducialFinder.cpp // Location: See Matrox Example Launcher in the MIL Control Center // // // Synopsis: Implements the CWhiteFiducialFinder class. // // Copyright (C) Matrox Electronic Systems Ltd., 1992-2024. // All Rights Reserved #include \"common.h\" #include \"WhiteFiducialFinder.h\" // All arrays will be resized dynamically. This is the initial size of the arrays. static const MIL_INT STARTING_ARRAY_SIZE = 8; // Expected criterion of the white fiducial blob. static const MIL_DOUBLE MIN_WHITE_AREA = 5.0; // Settings for the draw operation. static const MIL_DOUBLE CROSS_COLOR = M_COLOR_RED; static const MIL_DOUBLE CROSS_HALF_LENGTH = 3.0; //***************************************************************************** // Constructor. Allocate and setup MIL objects. //***************************************************************************** CWhiteFiducialFinder::CWhiteFiducialFinder(MIL_ID MilSystem) { // Allocate MIL objects. MblobAlloc(MilSystem, M_DEFAULT, M_DEFAULT, &amp;m_MilBlobContext); MblobAllocResult(MilSystem, M_DEFAULT, M_DEFAULT, &amp;m_MilBlobResult); // Note: these two controls must complement the CBlackFiducialFinder. MblobControl(m_MilBlobContext, M_FOREGROUND_VALUE, M_NONZERO); // complement CBlackFiducialFinder, which is M_ZERO MblobControl(m_MilBlobContext, M_CONNECTIVITY, M_4_CONNECTED); // complement CBlackFiducialFinder, which is 8-connected // Set the features once and for all. MblobControl(m_MilBlobContext, M_CENTER_OF_GRAVITY + M_BINARY, M_ENABLE); // Manage memory. AllocateArrays(STARTING_ARRAY_SIZE); m_FiducialIndex = NOT_FOUND; } //***************************************************************************** // Destructor. Free all MIL objects and memory. //***************************************************************************** CWhiteFiducialFinder::~CWhiteFiducialFinder() { DestroyArrays(); MblobFree(m_MilBlobResult); MblobFree(m_MilBlobContext); } //***************************************************************************** // Find the white fiducial, i.e. the hole in the black fiducial. // Returns true if the white fiducial is found. //***************************************************************************** bool CWhiteFiducialFinder::Find(MIL_ID MilBinarizedImage, MIL_DOUBLE ApproxBlobX, MIL_DOUBLE ApproxBlobY) { bool WhiteFiducialFound = false; // Find all white blobs in the region around the black fiducial. MblobCalculate(m_MilBlobContext, MilBinarizedImage, M_NULL, m_MilBlobResult); // Remove white blobs that are too small. MblobSelect(m_MilBlobResult, M_DELETE, M_AREA, M_LESS, MIN_WHITE_AREA, M_NULL); MIL_INT NbWhiteBlobs; MblobGetResult(m_MilBlobResult, M_DEFAULT, M_NUMBER + M_TYPE_MIL_INT, &amp;NbWhiteBlobs); if (NbWhiteBlobs &gt; 0) { // Get all white blobs CoG. ReserveArraySpace(NbWhiteBlobs); MblobGetResult(m_MilBlobResult, M_DEFAULT, M_CENTER_OF_GRAVITY_X+M_BINARY, m_CoGXArray); MblobGetResult(m_MilBlobResult, M_DEFAULT, M_CENTER_OF_GRAVITY_Y+M_BINARY, m_CoGYArray); // Find the white blob whose CoG is nearest the given approximate position. MIL_DOUBLE MinDist = DBL_MAX; for (MIL_INT BlobIdx = 0; BlobIdx &lt; NbWhiteBlobs; ++BlobIdx) { MIL_DOUBLE dx = m_CoGXArray[BlobIdx] - ApproxBlobX; MIL_DOUBLE dy = m_CoGYArray[BlobIdx] - ApproxBlobY; MIL_DOUBLE Dist = sqrt(dx*dx + dy*dy); if (Dist &lt; MinDist) { MinDist = Dist; m_FiducialIndex = BlobIdx; } } WhiteFiducialFound = true; } return WhiteFiducialFound; } //***************************************************************************** // Draw a cross on the white fiducial location, with a longer branch in the // direction of the black fiducial CoG (so that it gives the direction in // which to read the pharmacode). The image is assumed to be fixtured already. //***************************************************************************** void CWhiteFiducialFinder::Draw(MIL_ID MilOverlayImage) const { const MIL_INT NB_LINES = 2; // Draw in fixtured pixel units. MIL_DOUBLE XStart[NB_LINES] = { -CROSS_HALF_LENGTH, 0.0}; MIL_DOUBLE YStart[NB_LINES] = { 0.0, -CROSS_HALF_LENGTH}; MIL_DOUBLE XEnd [NB_LINES] = {2.0*CROSS_HALF_LENGTH, 0.0}; MIL_DOUBLE YEnd [NB_LINES] = { 0.0, CROSS_HALF_LENGTH}; MgraControl(M_DEFAULT, M_COLOR, CROSS_COLOR); MgraControl(M_DEFAULT, M_INPUT_UNITS, M_WORLD); MgraLines(M_DEFAULT, MilOverlayImage, NB_LINES, XStart, YStart, XEnd, YEnd, M_DEFAULT); } //***************************************************************************** // If there is not enough space in the arrays, free and reallocate them. Else, // do nothing. //***************************************************************************** void CWhiteFiducialFinder::ReserveArraySpace(MIL_INT MinArraySize) { if (m_ArraySize &lt; MinArraySize) { DestroyArrays(); AllocateArrays(MinArraySize); } } //***************************************************************************** // Set new size for the dynamic arrays and allocate them. //***************************************************************************** void CWhiteFiducialFinder::AllocateArrays(MIL_INT ArraySize) { m_CoGXArray = new MIL_DOUBLE[ArraySize]; m_CoGYArray = new MIL_DOUBLE[ArraySize]; m_ArraySize = ArraySize; } //***************************************************************************** // Free the memory of the dynamic arrays. //***************************************************************************** void CWhiteFiducialFinder::DestroyArrays() { delete [] m_CoGYArray; delete [] m_CoGXArray; } ",
      "wordCount": 527
    }
  ]
}]
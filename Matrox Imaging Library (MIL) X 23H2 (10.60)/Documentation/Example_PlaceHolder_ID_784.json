[{
  "id": "Example_PlaceHolder_ID",
  "version": "2024020714",
  "title": "Example_PlaceHolder_Title",
  "wordCount": 0,
  "subEntries": [
    {
      "id": "Examples_Processing_Preprocessing_CyclicalLUT_CPP_cyclicallut_cpp",
      "version": "2024020714",
      "title": "cyclicallut.cpp",
      "location": "Sample Code from MIL Examples",
      "text": " Top ///////////////////////////////////////////////////////////////////////////////////////// // // File name: CyclicalLUT.cpp // Location: See Matrox Example Launcher in the MIL Control Center // // // Synopsis: This program demonstrates how to use a cyclical LUT // to visualize small local intensity variations in an // image. // // Copyright (C) Matrox Electronic Systems Ltd., 1992-2024. // All Rights Reserved // ///////////////////////////////////////////////////////////////////////////////////////// #include &lt;mil.h&gt; #define IMAGE_FILE_COLORMAP M_IMAGE_PATH MIL_TEXT(\"CyclicalLUT/ColormapWheel.mim\") #define IMAGE_FILE_GRAYSTEPS M_IMAGE_PATH MIL_TEXT(\"CyclicalLUT/GraySteps.mim\") #define IMAGE_FILE_DEPTHMAP M_IMAGE_PATH MIL_TEXT(\"CyclicalLUT/DepthMapDIMM.mim\") //**************************************************************************** // Example description. //**************************************************************************** void PrintHeader() { MosPrintf(MIL_TEXT(\"[EXAMPLE NAME]\\n\")); MosPrintf(MIL_TEXT(\"CyclicalLUT\\n\\n\")); MosPrintf(MIL_TEXT(\"[SYNOPSIS]\\n\")); MosPrintf(MIL_TEXT(\"This program demonstrates how to use a cyclical LUT\\n\")); MosPrintf(MIL_TEXT(\"to visualize small local intensity variations in an\\n\")); MosPrintf(MIL_TEXT(\"image.\\n\\n\")); MosPrintf(MIL_TEXT(\"[MODULES USED]\\n\")); MosPrintf(MIL_TEXT(\"Modules used: application, system, display, buffer,\\n\")); MosPrintf(MIL_TEXT(\"image processing, data generation.\\n\\n\")); MosPrintf(MIL_TEXT(\"Press any key to continue.\\n\\n\")); MosGetch(); } //**************************************************************************** // Introduction. //**************************************************************************** void ShowVariousCycles(MIL_ID MilSystem, MIL_ID MilDisplay) { const auto FileName = IMAGE_FILE_COLORMAP; // Restore and display the introductory image. auto MilImage = MbufRestore(FileName, MilSystem, M_UNIQUE_ID); MdispSelect(MilDisplay, MilImage); MosPrintf(MIL_TEXT(\"Because it has matching colors on both ends, M_COLORMAP_WHEEL\\n\")); MosPrintf(MIL_TEXT(\"is well suited to be used cyclically. It is shown here with\\n\")); MosPrintf(MIL_TEXT(\"one cycle (which is the default), two cycles and seven cycles.\\n\\n\")); MosPrintf(MIL_TEXT(\"Note that, as the number of cycles increase, the perceptual\\n\")); MosPrintf(MIL_TEXT(\"color difference of the sequential values also increases. This\\n\")); MosPrintf(MIL_TEXT(\"property can help reveal image details that would be difficult\\n\")); MosPrintf(MIL_TEXT(\"to see otherwise; this will be demonstrated by the cases to come.\\n\\n\")); MosPrintf(MIL_TEXT(\"Press any key to continue.\\n\\n\")); MosGetch(); } //**************************************************************************** // Simple use case. //**************************************************************************** void EnhanceDigits(MIL_ID MilSystem, MIL_ID MilDisplay) { const auto FileName = IMAGE_FILE_GRAYSTEPS; const auto EXACT_INTENSITY_DIFFERENCE = 2.0; // Determine the dimensions of the grayscale image. auto SizeX = MbufDiskInquire(FileName, M_SIZE_X, M_NULL); auto SizeY = MbufDiskInquire(FileName, M_SIZE_Y, M_NULL); // Allocate the source and destination buffers. auto MilSrc = MbufAllocColor(MilSystem, 1, SizeX, SizeY, 8+M_UNSIGNED, M_IMAGE+M_PROC, M_UNIQUE_ID); auto MilDst = MbufAllocColor(MilSystem, 3, SizeX, SizeY, 8+M_UNSIGNED, M_IMAGE+M_DISP+M_PROC, M_UNIQUE_ID); // Load and display the grayscale image. MbufLoad(FileName, MilSrc); MbufCopy(MilSrc, MilDst); MdispSelect(MilDisplay, MilDst); MosPrintf(MIL_TEXT(\"An 8-bit monochrome image is loaded and displayed. Each square\\n\")); MosPrintf(MIL_TEXT(\"contains a digit in its foreground, but this is difficult to\\n\")); MosPrintf(MIL_TEXT(\"see, because only two gray levels separate the foreground from\\n\")); MosPrintf(MIL_TEXT(\"the background.\\n\\n\")); MosPrintf(MIL_TEXT(\"Press any key to continue.\\n\\n\")); MosGetch(); // The values to remap are in the range [0, 255]. Therefore, the LUT needs to have 256 entries. auto MilLut = MbufAllocColor(MilSystem, 3, 256, 1, 8+M_UNSIGNED, M_LUT, M_UNIQUE_ID); // Generate and apply the cyclical LUT. MgenLutFunction(MilLut, M_COLORMAP_WHEEL, M_DEFAULT, M_DEFAULT, 32 / EXACT_INTENSITY_DIFFERENCE, M_DEFAULT, M_DEFAULT, M_DEFAULT); MimLutMap(MilSrc, MilDst, MilLut); MosPrintf(MIL_TEXT(\"With the application of a cyclical LUT, the digits become easily\\n\")); MosPrintf(MIL_TEXT(\"visible. In such low contrast cases, one can try the following\\n\")); MosPrintf(MIL_TEXT(\"rule of thumb to set the number of cycles: use 32 divided by the\\n\")); MosPrintf(MIL_TEXT(\"local intensity difference between foreground and background.\\n\")); MosPrintf(MIL_TEXT(\"Note that this guideline is empirical and some experimentation is\\n\")); MosPrintf(MIL_TEXT(\"often needed to obtain adequate results.\\n\\n\")); MosPrintf(MIL_TEXT(\"Press any key to continue.\\n\\n\")); MosGetch(); } //**************************************************************************** // More realistic use case. //**************************************************************************** void EnhanceDepthMap(MIL_ID MilSystem, MIL_ID MilDisplay) { const auto FileName = IMAGE_FILE_DEPTHMAP; const auto NEUTRAL_VALUE = 128.0, AVERAGE_INTENSITY_DIFFERENCE = 4.0; // Determine the dimensions of the grayscale image. auto SizeX = MbufDiskInquire(FileName, M_SIZE_X, M_NULL); auto SizeY = MbufDiskInquire(FileName, M_SIZE_Y, M_NULL); // Allocate the source and destination buffers. auto MilSrc = MbufAllocColor(MilSystem, 1, SizeX, SizeY, 8+M_UNSIGNED, M_IMAGE+M_PROC, M_UNIQUE_ID); auto MilDst = MbufAllocColor(MilSystem, 3, SizeX, SizeY, 8+M_UNSIGNED, M_IMAGE+M_DISP+M_PROC, M_UNIQUE_ID); // Load and display the grayscale image. MbufLoad(FileName, MilSrc); MbufCopy(MilSrc, MilDst); MdispSelect(MilDisplay, MilDst); MosPrintf(MIL_TEXT(\"An 8-bit depth map image is loaded and displayed. It shows a\\n\")); MosPrintf(MIL_TEXT(\"memory module, but its label and barcode are imperceptible.\\n\\n\")); MosPrintf(MIL_TEXT(\"Press any key to continue.\\n\\n\")); MosGetch(); // The values to remap are in the range [0, 255]. Therefore, the LUT needs to have 256 entries. auto MilLut = MbufAllocColor(MilSystem, 3, 256, 1, 8+M_UNSIGNED, M_LUT, M_UNIQUE_ID); // Generate and apply the cyclical LUT. MgenLutFunction(MilLut, M_COLORMAP_WHEEL+M_LAST_GRAY, M_DEFAULT, NEUTRAL_VALUE, 32 / AVERAGE_INTENSITY_DIFFERENCE, M_DEFAULT, M_DEFAULT, M_DEFAULT); MimLutMap(MilSrc, MilDst, MilLut); MosPrintf(MIL_TEXT(\"Once more, with the application of a cyclical LUT, the subtle\\n\")); MosPrintf(MIL_TEXT(\"details become apparent. In the particular case of a depth map\\n\")); MosPrintf(MIL_TEXT(\"image, it can be desirable to exclude the invalid pixels from\\n\")); MosPrintf(MIL_TEXT(\"the remapping. This can be done by specifying a neutral value,\\n\")); MosPrintf(MIL_TEXT(\"using M_LAST_GRAY, when generating the LUT.\\n\\n\")); MosPrintf(MIL_TEXT(\"Press any key to end.\\n\\n\")); MosGetch(); } //***************************************************************************** // Main. //***************************************************************************** int MosMain(void) { auto MilApplication = MappAlloc(M_NULL, M_DEFAULT, M_UNIQUE_ID); auto MilSystem = MsysAlloc(MilApplication, M_SYSTEM_HOST, M_DEFAULT, M_DEFAULT, M_UNIQUE_ID); auto MilDisplay = MdispAlloc(MilSystem, M_DEFAULT, MIL_TEXT(\"M_DEFAULT\"), M_WINDOWED, M_UNIQUE_ID); PrintHeader(); ShowVariousCycles(MilSystem, MilDisplay); EnhanceDigits(MilSystem, MilDisplay); EnhanceDepthMap(MilSystem, MilDisplay); return 0; } ",
      "wordCount": 726
    }
  ]
}]
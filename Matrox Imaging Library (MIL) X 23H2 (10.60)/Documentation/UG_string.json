[{
  "id": "UG_string",
  "version": "2024020714",
  "title": "String Reader",
  "subTitles": null,
  "location": "MIL UG P03: 2D processing and analysis",
  "pageURL": "content\\UserGuide\\string\\ChapterInformation.htm",
  "text": " Chapter 14: String Reader This chapter explains how to perform feature-based character recognition with the MIL String Reader module. MIL String Reader module Steps to reading a string in an image Basic concepts for the MIL String Reader module Creating and customizing the fonts for a font-based context Adding and deleting fonts to the context Adding and deleting characters to the font Character representation System characters User-defined characters Source image foreground Normalize characters Space size Baseline Sorting characters Using a fontless context Enabling and disabling characters Customizing a fontless context Adding and deleting string models to the context Adding and deleting the string models Preprocess and read Saving and restoring Target image foreground Space Space width Maximum number of consecutive spaces Number of strings to read Degrees of freedom String angle and character angle String scale and character scale String aspect ratio and character aspect ratio Character's maximum baseline deviation Skew angle Rules for character placement String size Character constraints How constraints are used with string models and fonts Grammar rules Global context settings Minimum contrast Speed Timeout Encoding Scores and acceptances String acceptance, certainty, and score Character acceptance and score Character similarity Character homogeneity String target acceptance, certainty, and score Retrieving results and annotation Annotation Transformation coefficients Formatted and non-formatted results Fixing read problems using String Expert String Reader example ",
  "wordCount": 223,
  "subEntries": [
    {
      "id": "UG_string_MIL_String_Reader_module",
      "version": null,
      "title": "MIL String Reader module",
      "subTitles": null,
      "location": "MIL UG P03: 2D processing and analysis",
      "pageURL": "content\\UserGuide\\string\\MIL_String_Reader_module.htm",
      "text": " MIL String Reader module The MIL String Reader module is a set of powerful functions that allow you to perform feature-based character recognition. Unlike the MIL Optical Character Recognition module, which is template-based, String Reader's feature-based technology makes it invariant to changes in scale, aspect ratio, and contrast. It is also considerably tolerant towards variations in perspective and angle, and allows you to quickly determine why your application is not reading the string you expect. In addition, String Reader is designed to support multiple user-defined grammar rules, multi-font definitions, and fontless string reading, making applications simple to write and maintain. Given its feature-based technology, String Reader proves itself most useful when solving problems that have a limited amount of information, or information that tends to vary. For example, when writing an Automatic Number Plate Recognition (ANPR) application, you will probably have to contend with bad lighting, poor contrast, and variations in scale, perspective, and font. String Reader provides you with the tools to solve such problems. String Reader uses a set of specified string models to locate and read strings. Each string model serves as a template, defining the rules a string must follow for it to be read. String Reader reads strings in grayscale images, and provides numerous results, such as the string's score and the character's value. String Reader also offers many settings that allow you to tailor the read algorithm to meet your specific needs. For example, by adjusting the character's acceptance, you can have precise control over which strings are accepted by the read operation. You can also specify a font that the read string must match to be valid or you can specify that the read strings do not have to match any specific font. Note that if the strings you must read are made up of dot-matrix characters, use the MIL SureDotOCR module. MIL String Reader module ",
      "wordCount": 315,
      "subEntries": []
    },
    {
      "id": "UG_string_Steps_to_reading_a_string_in_an_image",
      "version": null,
      "title": "Steps to reading a string in an image",
      "subTitles": null,
      "location": "MIL UG P03: 2D processing and analysis",
      "pageURL": "content\\UserGuide\\string\\Steps_to_reading_a_string_in_an_image.htm",
      "text": " Steps to reading a string in an image The following steps provide a basic methodology for using the MIL String Reader module: For a font-based context, allocate a String Reader context to hold your string models and fonts, using MstrAlloc(). For a fontless context, restore a predefined context, using MstrRestore(). For a font-based context, add the required fonts to the context and customize them, using MstrControl() and MstrEditFont() respectively. For a fontless context, specify the general characteristics of the characters to search for in the target image, using MstrControl(). Allocate a String Reader result buffer to hold the results of the read operation, using MstrAllocResult(). Add a string model to the String Reader context, using MstrControl() with M_STRING_ADD. Note that you can add more than one string model to the context. Set the maximum number of strings to read, using MstrControl() with M_STRING_NUMBER. Set the minimum and maximum number of expected characters for the string models, using MstrControl() with M_STRING_SIZE_MIN and M_STRING_SIZE_MAX. If necessary, set character constraints, using MstrSetConstraint(). If necessary, adjust general context controls, using MstrControl(). If necessary, limit the area to be read using either a child buffer, using MbufChild...(), or define a rectangular ROI in vector format, using MbufSetRegion(). In addition, you can improve the quality of the image using the functions of some other MIL module (such as the MIL image processing function MimMorphic() with M_TOP_HAT or M_BOTTOM_HAT). Preprocess the String Reader context, using MstrPreprocess(). If necessary, fix read problems, using MstrExpert(). Perform the read operation in the specified target image, using MstrRead(). Retrieve the required results from the String Reader result buffer, using MstrGetResult(). If necessary, draw the results, using MstrDraw(). If necessary, save your String Reader context, using MstrSave() or MstrStream(). Free all your allocated objects, using MstrFree(), unless M_UNIQUE_ID was specified during allocation. Several String Reader functions require that you pass a null-terminated string array of the required characters. These characters can either be ASCII or Unicode. To specify which, use MstrControl() with M_ENCODING. Whenever you pass a string array, you must ensure that it is of the right type for the encoding scheme selected. For more information, see the Encoding subsection of the Global context settings section later in this chapter. Steps to reading a string in an image ",
      "wordCount": 379,
      "subEntries": []
    },
    {
      "id": "UG_string_Basic_concepts",
      "version": null,
      "title": "Basic concepts for the MIL String Reader module",
      "subTitles": null,
      "location": "MIL UG P03: 2D processing and analysis",
      "pageURL": "content\\UserGuide\\string\\Basic_concepts.htm",
      "text": " Basic concepts for the MIL String Reader module The basic concepts and vocabulary conventions for the MIL String Reader module are: Character. Any ASCII or Unicode symbol, such as a letter or a digit. A group of characters is used to define a font. Note that a space is not considered a character. Punctuation character. Typically categorized as characters that are not letters or numbers, such as the hyphen ('-'). To be considered part of the string, a punctuation character must fall within the range of at least one regular character's Y-size. Read region. A region in the target image enclosing the string that has been read. This region can be defined as the string's box, which includes the maximum number of spaces before and after the string. Regular character. A character that is either a letter or a number. Source image. The image from which a font can be defined. Note that fonts can also be defined from fonts installed on your system (for example, Times New Roman and Arial). Space. The space is used to delimit multiple strings that are on the same line. Strings on separate lines are automatically considered separate strings. Note that String Reader does not consider a space a normal character. A space is therefore never read. String. A linear sequence of regular characters. If the distance between two successive characters is greater than the maximum space allowed, these two characters are considered part of two separate strings. Note that characters on separate lines can never be part of the same string. String model. A data structure, within the String Reader context, that stores all the settings and constraints that control how to read one or many specific strings in the target image. String Reader context. A MIL object that stores all string models and fonts. The String Reader context also stores global read settings that apply to the character recognition algorithm. Based on the settings of the context, string models, and fonts, strings in the target image are either accepted or rejected by the read operation. String Reader font. A data structure, within the String Reader context, that stores a list of characters (ASCII or Unicode) with each character's corresponding representation. In a given font, each character must be unique. Only strings containing characters that adhere to a String Reader font can be read. String result. A string, read from the target image, that respects all the settings and constraints of a string model. Target image. The image in which to read the strings. Basic concepts for the MIL String Reader module ",
      "wordCount": 431,
      "subEntries": []
    },
    {
      "id": "UG_string_Creating_and_customizing_the_fonts_for_a_font_based_context",
      "version": null,
      "title": "Creating and customizing the fonts for a font-based context",
      "subTitles": [
        "Adding and deleting fonts to the context",
        "Adding and deleting characters to the font",
        "Character representation",
        "System characters",
        "User-defined characters",
        "Source image foreground",
        "Normalize characters",
        "Space size",
        "Baseline",
        "Sorting characters"
      ],
      "location": "MIL UG P03: 2D processing and analysis",
      "pageURL": "content\\UserGuide\\string\\Creating_and_customizing_the_fonts_for_a_font_based_context.htm",
      "text": " Creating and customizing the fonts for a font-based context Once you have allocated a String Reader font-based context, using MstrAlloc() and M_FONT_BASED, you must add at least one font to the font list of that context, and at least one character to the font. By default, the font list and the font are empty. You can add characters to the font from one of the following: System font. These characters are referred to as system characters (for example, characters added from your system's Arial font). Source image. These characters are referred to as user-defined characters (for example, characters added from a mosaic of license plates). Once a font has been added to the font list of the context, the font is automatically assigned default settings. Typically, these settings are sufficient for many applications. It is recommended that you try the defaults before changing them. However, if the default font settings do not suit your needs, you can: Set the font's character type. Normalize the font's characters to an appropriate size. Set the space size. Set the font's character baseline. Sort the font's characters. You can check the font settings by drawing the font characters in an image buffer, using MstrDraw(). Adding and deleting fonts to the context To add a font to the font list in the String Reader context, use MstrControl() with M_FONT_ADD. The fonts that you add to the String Reader context are empty; that is, they do not contain any characters. You must therefore add them. To do so, see the Adding and deleting characters to the font subsection of this section. When a font has been added to the context, it is assigned an index. Fonts are indexed using positive, consecutive integers starting at zero, and increasing by one. You can use the index to access a font. The maximum number of fonts that you can add to a String Reader context is 255. To control a font setting, you must use MstrControl() with the M_FONT_INDEX() macro set to the index of a specific font, or to all fonts (M_ALL). You can also delete a font or all fonts from the font list. To do so, use MstrControl() with M_FONT_DELETE set to the index of a specific font, or to all fonts (M_ALL). Note that when a font is deleted, its index is reassigned; that is, index values greater than that of the removed font are reduced by one. Fonts can also be given a user-defined numeric label, using MstrControl() with M_FONT_USER_LABEL. A user label can be used as a means of identifying your font, independently from its index in the String Reader context. However, user labels cannot be used as a direct replacement for the index; to retrieve the index of a font from the user label, use MstrInquire() with M_FONT_INDEX_FROM_LABEL. The user label, once converted to an index value, can be used with any String Reader function that takes an index value. All user labels must be unique integers; that is, no two user labels can have the same integer. To remove a label from a font, set the user label to M_NO_LABEL. Adding and deleting characters to the font Once you have added a font to the context, you must add characters to that font. To do so, use MstrEditFont() with M_FONT_INDEX() and M_CHAR_ADD. You cannot add a character that is smaller than 6x6 pixels. Characters can either be added from your system or from a source image. For more information, see the Character representation subsection of this section. Note that all operations that apply to the characters of a specific font are done using MstrEditFont(). After a character is added to a font, it can be accessed with its respective font's index and its own character value (ASCII or Unicode). These two values uniquely identify the character. For example, to access the character 'A' in font 0, you must use MstrEditFont() with the FontIndex parameter set to M_FONT_INDEX(), and the Param2Ptr parameter set to 'A'. Since characters are partly identified based on their own value, two characters in one font cannot have the same value. If you try to add a character with a value that already exists in a font, the existing character will be replaced by the newly added one, unless you use MstrEditFont() with M_NO_OVERWRITE. However, multiple fonts within the context can have characters with the same value, each of which is distinguished by its respective font index. To delete a character in a font, use MstrEditFont() with M_CHAR_DELETE, specifying the font's index and the character's value. Instead of passing the character value, you can also pass a null-terminated string array of all the characters to delete, or M_NULL, which will delete all characters in the font. When you add a character to a font, you can also decide its type. Its type determines whether String Reader treats the character as regular (M_REGULAR) or as punctuation (M_PUNCTUATION). Regular characters can typically be categorized as letters or numbers. A linear sequence of regular characters forms a string; that is, each regular character in a string must fall within the Y-size range of every character in that string. Punctuation characters can typically be categorized as characters that are not letters or numbers, such as the quotation (\"). To be considered part of the string, a punctuation character must fall within the range of at least one regular character's Y-size. To have String Reader automatically establish the type of the characters, use M_AUTO_COMPUTE. With this setting, String Reader will decide whether the type should be M_REGULAR or M_PUNCTUATION, based on the character's shape and numerical code. When you add characters to a font, their default character type is M_AUTO_COMPUTE. In the vast majority of cases, M_AUTO_COMPUTE will choose the correct character type. Character representation Characters in the font are referred to as either system characters or user-defined characters. This is based on how you specify their character representation when you add the characters to the font. System characters System characters are characters that have been added from a given system font, such as Arial. To add characters from a system font, use MstrEditFont() with M_CHAR_ADD and M_SYSTEM_FONT. You must also specify a null-terminated string of the characters to add from the system font, the name of the system font, and the size of the characters to add, in points (for example size 10 font). You can add the regular characters of the font (that is, 'A' to 'Z', 'a' to 'z', and '0' to '9'), as well as punctuation (such as the hyphen or the comma). The system font's name must be provided in standard U.S. English; for example, \"Arial\", \"Arial Bold\", \"Times New Roman Italic\", and \"Courier New Bold Italic\". You can find the full list of system font names with the MIL StringReader utility. User-defined characters User-defined characters are characters that have been defined from source images. When the required system font is not available, user-defined characters are the ideal solution, since all you need is an image of the characters in the required font. To add user-defined characters to the font, use MstrEditFont() with M_CHAR_ADD and M_USER_DEFINED. You must also specify the identifier of the characters' source image, and a null-terminated string with the list of characters to associate with the character representations in the image. Note that the size of the characters is automatically determined from the source image. It is recommended that you use an interactive graphic tool, such as the MIL StringReader utility or Matrox Inspector, to create new characters to add to an existing font. Typically, the characters in your list represent one string that you want to read. However, you can specify multiple strings to read by adding a space between groups of characters. Generally, you can use multiple strings when one or more of the following situations in the source image are encountered: the characters are not all on the same line, the contrast is clearly different between characters, or there is clearly a horizontal space between groups of characters. When adding user-defined characters, the character representations in the source image are taken from left to right and from top to bottom and are associated with the corresponding characters in your character list. String Reader is able to locate the characters in the source image because it assumes a Latin-based font. For example, if you want to define an 'A', String Reader will look through the source image from left to right and from top to bottom until the Latin-based character 'A' is located. If it is not located, an error is returned. For the most part, String Reader's Latin-based font definition is very useful, since it can, for example, tell the difference between a real character and background noise. However, this type of automatic font definition makes it problematic to define non-Latin-based characters, like Chinese letters, or to define an 'I' as a 'W'. You can, however, choose to add a single user-defined character that bypasses String Reader's automatic Latin-based font definition. To do so, you must combine M_USER_DEFINED with M_SINGLE. In this case, the entire source image is automatically defined as one character. For example, if your source image depicts the letter 'I', and the character in the character list is the letter 'W', then you have just added a 'W' that looks like an 'I'. Although this is not mandatory, when adding user-defined characters it is best to provide a high quality source image that ideally contains only the characters to add to the font. A good source image is especially important for a single user-defined character, which is typically added because it is, in some respect, out of the ordinary. The image should also be binarized exactly as you want. Otherwise, it will be binarized by MIL. Each potential character in the source image must be entirely connected (except for the accentuated characters, like \"è\") and should not be merged with other characters or other image objects. Also, the characters you want to add from the source image must all be approximately the same size. Even if the operation succeeds, it is recommended that you draw the characters of the font, using MstrDraw(), to ensure that every character is defined as expected. For more information, see the Annotation subsection of the Retrieving results and annotation section later in this chapter. Locating the specified characters in the source image is typically very robust. For example, you do not need to specify the specific size or location of the characters. However, if you are experiencing problems, or if you want to speed up this process, you can create a child buffer or define a rectangular M_VECTOR ROI to specify the area that contains the characters to add. For more information, see the Using child buffers, ROIs, or a copy to manipulate specific data areas section of Chapter 23: Data buffers. Source image foreground When defining characters from a source image and adding them to a font, you must be certain that the foreground is set correctly. By default, the foreground is black. You can, however, change it to white. To alter the foreground, you can combine M_USER_DEFINED with either M_FOREGROUND_BLACK or M_FOREGROUND_WHITE. This foreground setting only allows you to set the foreground of the character representations in the source image. This setting does not in any way affect the read operation, as fonts themselves do not have any foreground at all. To read characters in a target image, where the characters have a white foreground, you must explicitly set the read foreground control type of the string model to white; otherwise, you will not be able to read the characters. By default, the foreground used for the read operation is black. For more information, see the Target image foreground subsection of the Adding and deleting string models to the context section later in this chapter. Normalize characters Whether you are working with system fonts or user-defined fonts, it is not unusual for the characters to have different dimensions. In fact, fonts added from multiple system fonts, or multiple images, often create a rather chaotic group of character sizes; this can make altering some String Reader settings difficult, such as reading within a specific scale range. In this case, you should normalize the characters, with respect to a given X-size or Y-size. Since the other dimension is always scaled to maintain the same aspect ratio, this results in all the characters having the same width or height. To normalize your characters, you must first decide on the appropriate dimension. This is typically done by obtaining the size of a character with an appropriate height or width, using MstrInquire() with either M_CHAR_SIZE_X or M_CHAR_SIZE_Y. You can then use MstrEditFont() with M_CHAR_NORMALIZE and either the X-size or Y-size information to normalize the characters in the font. You can normalize a specific character in the font or all characters. In the former case, pass a null-terminated string of the characters to normalize. To normalize all the characters, pass M_NULL instead. The reference X-size or Y-size must be greater than 8 pixels. Space size The font is partly responsible for establishing the space size required to delimit multiple strings. Specifically, the space size threshold that ultimately delimits strings depends on two settings: the space width (MstrControl() with M_SPACE_WIDTH) and the maximum number of consecutive spaces (MstrControl() with M_SPACE_MAX_CONSECUTIVE). The space width is a font setting, while the maximum number of consecutive spaces is a string model setting. By default, the space width is equal to the average X-size (width) of the characters in the font, and the maximum number of consecutive spaces is equal to 3. The space size is calculated using the following equation: SpaceWidth x (MaximumNumberOfConsecutiveSpaces+1)-1. For example, if the average width of the characters is 30, the default space size would be 119 (that is, 30 x (3 + 1) - 1). Therefore, two adjacent characters that are greater than 119 pixels apart are considered part of two separate strings. Note that the space size is relative to the scale of the string. For more information, see the Space section later in this chapter. Baseline The baseline typically refers to the imaginary horizontal line on which the majority of the characters in a string rest. When you specify characters from a system font (M_SYSTEM_FONT), such as TrueType or Postscript, the baseline is, by default, taken from that font's file. In general, the relationship between the bottom of such characters and the baseline of the string is appropriate and there's usually no need to change it. Conversely, when you specify user-defined characters from an image (M_USER_DEFINED), there is no inherent baseline. Nevertheless, String Reader will still, by default, automatically compute appropriate baselines for most of these characters. When there is insufficient information to calculate the baseline, as is the case with a hyphen (-), String Reader's default behavior is to ignore that character's baseline. Given your application, ignoring the baseline might or might not be appropriate. To set a specific baseline value, you must use MstrEditFont() with M_CHAR_BASELINE. To explicitly ignore the baseline, you must set M_CHAR_BASELINE to M_NONE. Even though String Reader ignores an M_NONE baseline, all other conditions must still be respected when determining whether the character is part of the string, such as the character's scale range constraint. When specifying a specific baseline value, you must set it to reflect the distance between the bottom of the character and the baseline of the string. If the bottom of the character rests directly on the baseline of the string, which is usually the case, the value that you must set for that character's baseline is 0. However, for characters that dip below the baseline, or rise above it, 0 is not appropriate. Notice the letter 'y', apostrophe, and hyphen characters in the following string when the baseline for each character is set to 0. To move the bottom of a character in an upward direction, you must specify a negative baseline value; to move the bottom of a character in a downward direction, you must specify a positive baseline value. The amount of distance to move the character up or down is set as a percentage of the character's height. For example, to move a character up by a distance equal to twice the character's height, you must set its baseline to -200%, while to move a character down by a distance equal to 1/4 of its height, you must set its baseline to 25%. To reset characters to their automatically computed baseline, use MstrEditFont() with M_CHAR_BASELINE and M_AUTO_COMPUTE, and specify a null-terminated string of the characters. Sorting characters Characters are not always added to the font in an orderly fashion; particularly user-defined characters. It can therefore be difficult, when displaying these characters, to quickly tell which ones are missing. Also, you might want to have your characters ordered by sub-lists, such as all the digits, followed by all the letters, followed by all the symbols. To solve these problems, and any others regarding the order of your characters, String Reader provides a sort functionality. To sort the characters in the font, according to their character values, in either ascending or descending order, use MstrEditFont() with M_CHAR_SORT and either M_ASCENDING or M_DESCENDING, and a null-terminated string of the characters. Creating and customizing the fonts for a font-based context Adding and deleting fonts to the context Adding and deleting characters to the font Character representation System characters User-defined characters Source image foreground Normalize characters Space size Baseline Sorting characters ",
      "wordCount": 2918,
      "subEntries": []
    },
    {
      "id": "UG_string_Using_a_fontless_context",
      "version": null,
      "title": "Using a fontless context",
      "subTitles": [
        "Enabling and disabling characters",
        "Customizing a fontless context"
      ],
      "location": "MIL UG P03: 2D processing and analysis",
      "pageURL": "content\\UserGuide\\string\\Using_a_fontless_context.htm",
      "text": " Using a fontless context Characters have distinct features which distinguish them from one another. The String Reader module can make use of these characteristics to read strings in a target image without making use of a font. To do so, it requires that you use a predefined fontless context. You might choose to use a fontless context over a font-based context in cases where you expect to read strings in images with variable fonts. A fontless context is faster to set up than a font-based one. To use a fontless context, you need to restore, using MstrRestore(), one of the predefined context files located under the \"\\Matrox Imaging\\contexts\\\" MIL installation folder. The String Reader module comes with three predefined fontless contexts: \"FONTLESS_ANPR.msr\". A generic context useful to read a wide variety of license plate types written in Latin-based alphabets and Arabic numerals. \"FONTLESS_EUROPEAN_ANPR.msr\". A context useful to read European license plates. \"FONTLESS_MACHINE_PRINT.msr\". A special context that reads machine printed characters in Arial, Ocr-B, or other sans-serif fonts. The String Reader module can only use a fontless context to read uppercase characters and numbers. When using a fontless context, MstrInquire() with M_CONTEXT_TYPE returns M_FONTLESS. Enabling and disabling characters When you restore a fontless context, it contains information about all uppercase characters and numbers. By default, the read operation searches the image for this entire range. However, for some applications, it is preferable to search for a subset of these characters, especially when you know one of two similar looking characters will not appear. In a fontless context, characters are not added or deleted; instead, they are enabled or disabled. You can disable characters using MstrControl() with M_DISABLE_CHAR or re-enable them with M_ENABLE_CHAR. When only a few characters are needed, you can disable all characters (M_DISABLE_CHAR set to M_ALL) and then re-enable the required characters, rather than disabling characters one at a time. Customizing a fontless context After you have restored a fontless context, you need to specify the size of the characters to read. Use MstrControl() to specify the following values in pixels: A reference height (M_REF_CHAR_SIZE_Y). The width of the narrowest character (M_MIN_CHAR_SIZE_X) at the reference height. The width of the widest character (M_MAX_CHAR_SIZE_X) at the reference height. The thickness (stroke width) of a typical character (M_REF_CHAR_THICKNESS) at the reference height. If the characters vary in size, set the reference height (M_REF_CHAR_SIZE_Y) to the average value of the character set's heights. Then, specify minimum and maximum allowable scale factors based on the reference height with M_STRING_SCALE_MIN_FACTOR and M_STRING_SCALE_MAX_FACTOR. When setting M_MIN_CHAR_SIZE_X, M_MAX_CHAR_SIZE_X and M_REF_CHAR_THICKNESS, specify the width and thickness that the characters have when they have a height of M_REF_CHAR_SIZE_Y. When the read operation finds characters of a different height, size values are scaled by the ratio between the height found and the reference height. In the following example, the characters have a reference height of 41 pixels. The widest character, Q, has a width of 20 pixels, the narrowest character, 1, has a width of 11 pixels, and the thickness of the characters is 6 pixels. Using a fontless context Enabling and disabling characters Customizing a fontless context ",
      "wordCount": 521,
      "subEntries": []
    },
    {
      "id": "UG_string_Adding_and_deleting_string_models_to_the_context",
      "version": null,
      "title": "Adding and deleting string models to the context",
      "subTitles": [
        "Adding and deleting the string models",
        "Preprocess and read",
        "Saving and restoring",
        "Target image foreground"
      ],
      "location": "MIL UG P03: 2D processing and analysis",
      "pageURL": "content\\UserGuide\\string\\Adding_and_deleting_string_models_to_the_context.htm",
      "text": " Adding and deleting string models to the context Once you have added a font to the font list in the String Reader context, you must add at least one string model to the string model list in that context. By default, the string model list is empty. Each string model in the string model list represents a template, a way of locating a string in the target image. The settings in this template (string model) have been configured with defaults that are typically sufficient for many applications. It is recommended that you try the defaults first. The following sections in this chapter describe the various string model settings and how to change them. For example, you can set the minimum and maximum number of characters in the string, the maximum number of strings to locate (for an individual string model and for the String Reader context), the acceptance level for the string, and the valid range of scale. You can also set various types of character constraints, which can be used with all fonts in the String Reader context, or can be restricted to a specific font. After you have adjusted all your string model settings, you must preprocess the context before calling MstrRead(). Note that a string in the target image will only be read if it satisfies every string model criteria, and if it respects the minimum definition of a string (that is, a linear sequence of regular characters). Adding and deleting the string models To add a string model to the string model list in the String Reader context, use MstrControl() with M_STRING_ADD. The maximum number of string models that you can add to a String Reader context is 255. The read operation time can increase with the number of string models in the context. When a string model has been added to the context, it is assigned an index. String models are indexed as positive, consecutive integers starting at zero, and increasing by one. You can use the index to access a string model. To control a string model setting, you must use MstrControl() with the M_STRING_INDEX() macro set to the index of a specific string model, or to all string models. You can also delete a string model or all string models from the string model list. To do so, use MstrControl() with M_STRING_DELETE set to the index of a specific string model, or to all string models (M_ALL). Note that when a string model is deleted, its index is reassigned; that is, index values greater than that of the removed string model are reduced by one. To return the index of the string model read, use MstrGetResult() with M_STRING_MODEL_INDEX. String models can also be given a user-defined numeric label, using MstrControl() with M_STRING_USER_LABEL. A user label can be used as a means of identifying your string model, independently from its index in the String Reader context. However, user labels cannot be used as a direct replacement for the index; to retrieve the index of a string model from the user label, use MstrInquire() with M_STRING_INDEX_FROM_LABEL. The user label, once converted to an index value, can be used with any String Reader function that takes an index value. All user labels must be unique integers; that is, no two user labels can have the same integer. To remove a label from a string model, set the user label to M_NO_LABEL. Preprocess and read After you add string models and fonts to your String Reader context and before reading a string from the target image, the String Reader context must be preprocessed, otherwise an error will occur. It is during this preprocessing stage that String Reader prepares the context for the read operation by executing a number of preread calculations. To preprocess the String Reader context, use MstrPreprocess(). To read a string from the target image, use MstrRead(). Note that you might have to preprocess the String Reader context again if you change some of its control settings, such as the nominal angle of the string (M_STRING_ANGLE). To check if you need to preprocess the String Reader context, use MstrInquire() with M_PREPROCESSED. Saving and restoring When you save a String Reader context, its preprocessing information is not saved. You must therefore preprocess the context when it is restored, even if you haven't changed any of its settings. To save a String Reader context to a file, use MstrSave(). To restore the context, use MstrRestore(). Target image foreground By default, strings are read assuming that the foreground is black. If it is white, or if it can be either white or black, you must specify this information in the string model, using MstrControl() with M_FOREGROUND_VALUE. Each string model can have a different foreground color. Note that only this string model setting affects what the read operation assumes is the foreground color; the foreground set when adding a user-defined font does not. For more information, see the Source image foreground subsection of the Creating and customizing the fonts for a font-based context section earlier in this chapter. Adding and deleting string models to the context Adding and deleting the string models Preprocess and read Saving and restoring Target image foreground ",
      "wordCount": 864,
      "subEntries": []
    },
    {
      "id": "UG_string_Space",
      "version": null,
      "title": "Space",
      "subTitles": [
        "Space width",
        "Maximum number of consecutive spaces"
      ],
      "location": "MIL UG P03: 2D processing and analysis",
      "pageURL": "content\\UserGuide\\string\\Space.htm",
      "text": " Space When using the MIL String Reader module, the space is not considered a normal character. For example, you can never read a space with String Reader, nor can you set a space as a constraint to which a valid character must adhere, to be read (for more information on character constraints, see the Rules for character placement section later in this chapter). The space is used to delimit multiple strings in the target image when performing a read operation (MstrRead()). That is, the space size establishes the maximum distance between two adjacent characters before each character is considered part of two separate strings. The space size is calculated using the space width (a font setting) and the maximum number of consecutive spaces (a string model setting). For more information, see the Space size subsection of the Creating and customizing the fonts for a font-based context section earlier in this chapter. Note that, like the space, the carriage return also signifies a new string. If a character is on another line, it is automatically part of another string. If the space was treated like a normal character, there would be tricky issues to contend with, such as distinguishing the space from noise. By defining a space as the marker that separates strings, there is less chance for an incorrect read operation. For example, consider an ANPR application that must read the following target image: Since most license plates do not have any symbol between characters, and the ones that do cannot be ignored, multiple types of spaces might have to be considered for this string to be read correctly. You would not only have to account for the space that occurs between strings, but how this space might vary when noise exists (in this case, the flag). Essentially, it is simpler to decide whether or not the characters exist, rather than deciding whether or not a space exists. When a space is encountered in the target image, it is marked by String Reader and can be artificially inserted to display formatted results. For more information, see the Formatted and non-formatted results subsection of the Retrieving results and annotation section later in this chapter. Space width To set the width of the space character in the font, use MstrControl() with M_SPACE_WIDTH. By default, the space width is set to M_MEAN_CHAR_WIDTH, which is equal to the average X-size (width) of the characters in the font. You can also set the space width to M_INFINITE, which is equal to an infinite amount of space. That is, all characters on the same line are always part of the same string. In this case, however, there will never be a space character in the formatted string since the distance can never be large enough to constitute a space character. Other settings for the space width include the maximum X-size or minimum X-size character in the font, and a quarter of the maximum character width in the font. You can also set the space width to a specific value, in pixels. The space width that you set is relative to the font. Therefore, the space width is considered to be at the size of the font (that is, the point size of the characters in the font), and adjusted according to the scale and aspect ratio of the string. Maximum number of consecutive spaces To set the maximum number of consecutive spaces required for two adjacent characters to be part of two separate strings, use MstrControl() with M_SPACE_MAX_CONSECUTIVE. The default value is 3 consecutive spaces. Note that M_SPACE_MAX_CONSECUTIVE is a string model setting, while M_SPACE_WIDTH is a font setting. Therefore, each string model can have a maximum number of consecutive spaces, while all string models must adhere to their font's space width. The notion of consecutive spaces is important, since non-consecutive spaces do not cause a split in the string. Consider the following Quebec license plate. In this example, the first 3 characters are separated by a single space each, which makes them part of the same string. However, following the letter 'N', there are several consecutive spaces; if you set a maximum of one consecutive space, the '9' would be part of a different string. Based on the maximum number of spaces, this license plate can either be read as two strings, or one string with a large space between 'N' and '9'. Space Space width Maximum number of consecutive spaces ",
      "wordCount": 738,
      "subEntries": []
    },
    {
      "id": "UG_string_Number_of_strings_to_read",
      "version": null,
      "title": "Number of strings to read",
      "subTitles": null,
      "location": "MIL UG P03: 2D processing and analysis",
      "pageURL": "content\\UserGuide\\string\\Number_of_strings_to_read.htm",
      "text": " Number of strings to read You can set the maximum number of strings to read in the target image for both the String Reader context and for each individual string model in the String Reader context. For each individual string model, use MstrControl() with M_STRING_NUMBER, specifying the index of the particular string model. The default value is 1. To read all strings that adhere to a string model, set M_STRING_NUMBER to M_ALL. The number set for the String Reader context specifies the maximum total of all strings that can be read, for all string models in the context together. To set the number for a String Reader context, use MstrControl() with M_STRING_NUMBER, specifying M_CONTEXT as the index. The default value is M_ALL, which reads the maximum number of strings specified for each string model. Note that if the context's M_STRING_NUMBER value is reached, the read operation stops, regardless of any individual string model's outstanding M_STRING_NUMBER setting. Similarly, once every individual string model's M_STRING_NUMBER value is reached, the read operation stops, regardless of the context's outstanding M_STRING_NUMBER setting. For example, if you are writing an application that reads three name tags, you need three string models, one for each name. If you set M_STRING_NUMBER for the context to 1, and you set M_STRING_NUMBER for each string model to 1, then as soon as one of the name tags is read, both string number settings will be satisfied. However, if you set M_STRING_NUMBER for the context to 3 and you set M_STRING_NUMBER for each string model to 1, then the string number settings will only be satisfied when one of each name tag is read. Number of strings to read ",
      "wordCount": 280,
      "subEntries": []
    },
    {
      "id": "UG_string_Degrees_of_freedom",
      "version": null,
      "title": "Degrees of freedom",
      "subTitles": [
        "String angle and character angle",
        "String scale and character scale",
        "String aspect ratio and character aspect ratio",
        "Character's maximum baseline deviation",
        "Skew angle"
      ],
      "location": "MIL UG P03: 2D processing and analysis",
      "pageURL": "content\\UserGuide\\string\\Degrees_of_freedom.htm",
      "text": " Degrees of freedom By default, the String Reader module has been configured to conduct a fast and robust read operation, with a reasonable degree of tolerance for potential strings in the target image. However, to read unusually sized and positioned strings, you might have to change the tolerance defaults. Specifically, you might have to modify the default angle, scale, aspect ratio, baseline, and skew settings with which the strings are read. Increasing these tolerances can increase the time of the read operation. Tolerance values are always relative to applicable angle, scale, aspect ratio, and baseline values that you have set. For example, the baseline's tolerance depends on the size of the character; therefore, if a character has been scaled, the tolerance is calculated at that scale. String angle and character angle The angle of the string is the angle of the best-fit line that falls on the baseline of all the characters in that string. For example, the angle of the following string is -10°: By default, if the target image buffer has no region of interest (ROI), the String Reader module can read strings in the target image at a nominal angle of 0.0°, and with an angular tolerance of +/- 10.0°. This means that only those strings in the target image that have an angle between +10.0° and -10.0° can actually be retrieved as results. For a target image buffer with an ROI, String Reader assumes that the nominal angle of the string is the same as the angle of the ROI, with an angular tolerance of +/- 10.0°; String Reader only supports a rectangular ROI. To set (or re-set) the ROI of the target image, you must create a rectangular graphic element, using the Graphics module, that corresponds to the region and angle of the target string in the target image, and use this graphic element when calling MbufSetRegion(). To change the angular tolerance, use MstrControl() with M_STRING_ANGLE_DELTA_POS and M_STRING_ANGLE_DELTA_NEG. Valid values are between 0.0° and 10.0°. These tolerance values are relative to the nominal angle of the string. Essentially, M_STRING_ANGLE_DELTA_POS and M_STRING_ANGLE_DELTA_NEG set the possible upper (clockwise) and lower (counter-clockwise) limits of the string's angular range (relative to the nominal angle of the string). The upper limit can be described as the nominal angle + M_STRING_ANGLE_DELTA_POS, while the lower limit can be described as the nominal angle - M_STRING_ANGLE_DELTA_NEG. Strings with angles outside this angular range will not be returned as results. For example, if you know that a string in the target image will typically be located at 20.0°, but you want to allow for an angular tolerance of +/- 5° (a range of 15° to 25°), you should set M_STRING_ANGLE_DELTA_NEG and M_STRING_ANGLE_DELTA_POS to 5.0°, and set (or re-set) the ROI of the target image to 20.0°.The following animation displays this scenario. Each character within the string also has an angle. Typically, this angle value is the same as the string's angle value; however, this is not mandatory. The following example illustrates the difference between a string angle and a character angle; the characters in the string have an angle of 10°, while the angle of the string itself is 0°. To retrieve the string angle, use MstrGetResult() with M_STRING_ANGLE. To retrieve the character angle of the string, use MstrGetResult() with M_CHAR_ANGLE. Note that the String Reader algorithm is naturally robust to variations in a character's angle. However, if you expect your characters to be located between a wide angular range, it is recommended to enable calculations specific to angular-range search strategies. To do so, use MstrControl() with M_SEARCH_CHAR_ANGLE. Enabling this setting might increase the read operation's processing time. String scale and character scale The scale of the string is the median scale, in the X-direction, of each individual character in that string. By default, strings are located in the target image at a nominal scale of 1.0, with a maximum permitted scale of 2.0 and a minimum permitted scale of 0.5. This means that strings in the target image that have a scale between 0.5 and 2.0 can be returned as results. By default, the scale of each individual character within the string can vary from the scale of the string by a maximum factor of 1.1 and a minimum factor of 0.9. This means that characters that have a scale between 1.1 and 0.9 (from the string scale) can be considered part of the string. To alter the maximum (upper limit) and minimum (lower limit) permitted string and character scales, use MstrControl() with M_STRING_SCALE_MAX_FACTOR, M_STRING_SCALE_MIN_FACTOR, M_CHAR_SCALE_MAX_FACTOR, and M_CHAR_SCALE_MIN_FACTOR. Valid values for the maximum string and character scales are between 1.0 and 2.0. Valid values for the minimum string and character scales are between 0.5 and 1.0. String scales are relative to the nominal scale of the string, that is, M_STRING_SCALE x M_STRING_SCALE_MAX_FACTOR or M_STRING_SCALE_MIN_FACTOR. You can set M_STRING_SCALE with MstrControl(). Valid string scale values are between 0.25 and 4.0. Character scales are relative to the scale of the string in the target image, as calculated by String Reader. That is, CalculatedStringScale x M_CHAR_SCALE_MAX_FACTOR or M_CHAR_SCALE_MIN_FACTOR. Note that M_CHAR_SCALE_MAX_FACTOR and M_CHAR_SCALE_MIN_FACTOR define how much an individual character's scale can deviate from the string's scale. For example, you want to write an application that reads the string 'ABCD' within a scale range of 0.5 to 2.0. However, you want to ensure that the scale of each individual character in the string only ranges between 0.9 and 1.1. To do so, set M_STRING_SCALE to 1.0, M_STRING_SCALE_MAX_FACTOR and M_STRING_SCALE_MIN_FACTOR to 2.0 and 0.5, and M_CHAR_SCALE_MAX_FACTOR and M_CHAR_SCALE_MIN_FACTOR to 1.1 and 0.9. To retrieve the string scale, use MstrGetResult() with M_STRING_SCALE. To retrieve the character scale, use MstrGetResult() with M_CHAR_SCALE. Strings and characters with scales outside their respective range will not be returned as results. Note that characters that are outside the string's upper and lower limits will not be read. String aspect ratio and character aspect ratio The aspect ratio of a string is the median aspect ratio of each individual character in that string. The aspect ratio of a character is the ratio of its scale in the X-direction by its scale in the Y-direction. By default, strings are located in the target image at a nominal aspect ratio of 1.0, with a maximum permitted aspect ratio of 1.25 and a minimum permitted aspect ratio of 0.8. This means that strings in the target image that have an aspect ratio between 1.25 and 0.8 can be returned as results. By default, the aspect ratio of each individual character within the string can vary from the aspect ratio of the string by a maximum factor of 1.1, and a minimum factor of 0.9. This means that only characters that have an aspect ratio between 1.1 and 0.9 (from the string aspect ratio) can be considered part of the string. To alter the maximum (upper limit) and minimum (lower limit) permitted string and character aspect ratios, use MstrControl() with M_STRING_ASPECT_RATIO_MAX_FACTOR, M_STRING_ASPECT_RATIO_MIN_FACTOR, M_CHAR_ASPECT_RATIO_MAX_FACTOR, and M_CHAR_ASPECT_RATIO_MIN_FACTOR. Valid values for the maximum string and character aspect ratios are between 1.0 and 2.0. Valid values for the minimum string and character aspect ratios are between 0.5 and 1.0. String aspect ratios are relative to the nominal aspect ratio of the string, that is, M_STRING_ASPECT_RATIO x M_STRING_ASPECT_RATIO_MAX_FACTOR or M_STRING_ASPECT_RATIO_MIN_FACTOR. You can set M_STRING_ASPECT_RATIO with MstrControl(). Valid string aspect ratios are between 0.5 to 2.0. Character aspect ratios are relative to the aspect ratio of the string in the target image, as calculated by String Reader. That is, CalculatedStringAspectRatio x M_CHAR_ASPECT_RATIO_MAX_FACTOR or M_CHAR_ASPECT_RATIO_MIN_FACTOR. Note that M_CHAR_ASPECT_RATIO_MAX_FACTOR and M_CHAR_ASPECT_RATIO_MIN_FACTOR define how much an individual character's aspect ratio can deviate from the string's aspect ratio. For example, you want to write an application that reads the string 'ABCD' within an aspect ratio range of 0.5 to 2.0. However, you want to ensure that the aspect ratio of each individual character in the string only ranges between 0.9 and 1.1. To do so, set M_STRING_ASPECT_RATIO to 1.0, M_STRING_ASPECT_RATIO_MAX_FACTOR and M_STRING_ASPECT_RATIO_MIN_FACTOR to 2.0 and 0.5, and M_CHAR_ASPECT_RATIO_MAX_FACTOR and M_CHAR_ASPECT_RATIO_MIN_FACTOR to 1.1 and 0.9. To retrieve the string aspect ratio, use MstrGetResult() with M_STRING_ASPECT_RATIO. To retrieve the character aspect ratio, use MstrGetResult() with M_CHAR_ASPECT_RATIO. Strings and characters with aspect ratios outside their respective range will not be returned as results. Note that characters that are outside the string's upper and lower limits will not be read. Character's maximum baseline deviation In a target image, most characters in a string do not rest on significantly different baselines. However, you might encounter a target image where certain characters are significantly misaligned. In some cases, these strings are valid and you want to be able to read them. For example, when dealing with odometers, certain digits might be considerably misaligned with the other digits, yet the string is still valid, such as in the following image: The image above shows that '6' has a baseline deviation. A character's baseline deviation is the difference between the character's baseline and the baseline of the string in which it is found. A character's maximum baseline deviation is the maximum tolerable baseline deviation that a character in a string can have before it is rejected from the string. In most cases, a character's baseline deviation is calculated as a percentage of the character's height. For the example above, a baseline deviation of 15 for '6' means that 6's baseline deviates from the string's baseline by 15% of 6's height. However, for punctuation characters, the baseline deviation is calculated as a percentage of the height of the character with the largest Y-size in the font. By default, all characters are assigned a default maximum baseline deviation of 10. This value is a sufficient tolerance for most applications because characters in a string in a target image do not usually rest on significantly different baselines. However, in certain situations such as the odometer case, the default value might not be sufficient for the String Reader to accept the misaligned character. If the misaligned character's baseline deviation is more than the character's set maximum baseline deviation, the character will be rejected from the string. This is why in some cases, you must manually change the characters' maximum baseline deviation. To set the maximum baseline deviation that all characters in the string can have, use MstrControl() with M_CHAR_MAX_BASELINE_DEVIATION. Valid values are between 0 and 100. The default value is 10. To retrieve every read character's baseline deviation, use MstrGetResult() with M_CHAR_BASELINE_DEVIATION. Consider now the target image shown below. Let us assume that in the font, 'p' had its baseline defined as 26.7%, which is illustrated by the dotted line (for more information on baselines, see the Baseline subsection of the Creating and customizing the fonts for a font-based context section earlier in this chapter). We can see that in the target image, 'p' is misaligned with the other characters, and therefore there is a baseline deviation. If this baseline deviation is larger than the set maximum baseline deviation, the character will be rejected from the string. If this is the case and you want the String Reader to accept 'p', you need to increase the characters' maximum baseline deviation. As mentioned previously, the baseline deviation for punctuation characters is represented as a percentage of the height of the character with the largest Y-size in the font. This is used because the Y-size of punctuation characters is typically too small to calculate baseline deviation as a percentage of the character's height. The image below shows the string, 'wkrp-'. Suppose the hyphen's baseline was defined in the font as -250%. The target image shown has the hyphen's baseline misaligned from the other characters' baseline; therefore, there is a baseline deviation. Let us assume that 'k' is the character with the largest Y-size in the font. To calculate the baseline deviation, instead of using the height of the hyphen, String Reader uses 'k' to measure the baseline deviation. From the right side of the image below, you can see that the baseline deviation of the hyphen corresponds to 30% of k's height. If 30 is larger than the set maximum baseline deviation, the hyphen will be rejected from the string. In this case, to accept '-', you need to increase the characters' maximum baseline deviation. Note that a character's baseline deviation is represented at the scale of the target image. With non-punctuation characters, the baseline deviation is represented as a percentage of the character's height at the scale of the target image. With punctuation characters, the baseline deviation is represented as a percentage of the character with the greatest Y-size within the font, but at the scale of the string in the target image. Skew angle The term skew can be defined as a rotational deviation from the correct horizontal and vertical orientation. Typically, when dealing with characters, a skew presents itself as a lateral or horizontal lean. The String Reader algorithm is naturally robust to variations in a character's skew angle. However, if you expect your characters to be skewed with a wide angular range (for example, when dealing with significant shifts in perspective), it is recommended to enable calculations specific to angular-range skew search strategies. To do so, use MstrControl() with M_SEARCH_SKEW_ANGLE. Note that enabling this setting might increase the read operation's processing time. The skew angle for each character within a string must always be the same. To retrieve the character's skew angle, use MstrGetResult() with M_SKEW_ANGLE. Degrees of freedom String angle and character angle String scale and character scale String aspect ratio and character aspect ratio Character's maximum baseline deviation Skew angle ",
      "wordCount": 2255,
      "subEntries": []
    },
    {
      "id": "UG_string_Rules_for_character_placement",
      "version": null,
      "title": "Rules for character placement",
      "subTitles": [
        "String size",
        "Character constraints",
        "How constraints are used with string models and fonts",
        "Grammar rules"
      ],
      "location": "MIL UG P03: 2D processing and analysis",
      "pageURL": "content\\UserGuide\\string\\Rules_for_character_placement.htm",
      "text": " Rules for character placement The read operation (MstrRead()) compares each character in the target image to each character in the font and locates the best string that satisfies all your constraints. You can place constraints on the size of the string, and on the characters themselves. Used together, these constraints form the grammar rules. By setting up proper grammar rules, you can restrict the character comparison process, thereby increasing the robustness of the read operation, and lowering the possibility of false positive results. Every grammar rule that you set for a string model is referred to as the string model's grammar, while every grammar rule that you set for all string models in the String Reader context is referred to as the context's grammar. Note that you do not explicitly set grammar rules for the context. The context's grammar is formed by all the grammar rules for all the string models within that context. The space character cannot be set as a constraint and is not counted in the string size. For more information, see the Space section earlier in this chapter. String size String Reader will read the number of characters specified by the string size. For best results, the number of characters to be read in your target image should match your string size. You can set the maximum and minimum number of characters a string must have for it to be read using M_STRING_SIZE_MAX and M_STRING_SIZE_MIN. You can set these to any value greater than or equal to 1. The maximum string size can also be set to infinite (M_INFINITE). Note that if your strings are very short (a single character in length), MstrRead() might not be as robust. Character constraints To ensure that only a certain type of character (or a particular character) appears at a specific position in the string, you can apply character constraints, using MstrSetConstraint(). You can specify that a character at a specific position falls into one of the following types of characters: A digit (M_DIGIT): '0' to '9'. A letter (M_LETTER): 'a' to 'z' and 'A' to 'Z'. An uppercase letter (M_LETTER + M_UPPERCASE): 'A' to 'Z'. A lowercase letter (M_LETTER + M_LOWERCASE): 'a' to 'z'. A combination of the above types (for example, M_DIGIT + M_LETTER). Any character (M_ANY). For example, if you set the character constraint for the character at position 1 to M_DIGIT, then only if the character at position 1 is between '0' and '9' can it be considered part of the string. You can further restrict the character constraint to a specific list of characters of the specified type. This list can include special characters and punctuations (for example, 'a', '1', 'aA1', '&amp;', '-', '...'). For example, if you set the character constraint for the character at position 1 to '1', then only if the character at position 1 is '1' can it be considered part of the string. When providing a specific list of characters, you must ensure that the characters are of the correct constraint type. For example, if the specific character in the list is '1', and the constraint type is M_LETTER, an error will be generated. Also, you cannot repeat letters in your character list; that is, each letter must be unique. For example, 'AABB' is not allowed. Note that a constraint can be set for any position, even when the string to read does not contain a character at that position. For example, you can set a constraint for a position that is greater than the number of characters in the string. Such constraints are always ignored. How constraints are used with string models and fonts You can apply the constraint to a specific string model in the context, or to all string models in the context, using M_STRING_INDEX(). If it is appropriate, you can set a default (M_DEFAULT) constraint for the string model. This constraint will be used for any character in the string for which a constraint has not been explicitly set. This is useful if the majority of the characters must respect the same constraint. For example, you can have an application that reads 26 characters, all of which are digits, except for the character at position three, which is a letter. Rather than having 26 lines of code with almost identical MstrSetConstraint() calls (one for each character position), you can simplify your code by: Setting the default constraint for the string model to M_DIGIT. Setting the constraint for the character at position three to M_LETTER. The constraint is automatically used with any font in the context. To restrict the constraint to a specific font, set M_FONT_INDEX() to the index value of a specific font, and add it to the constraint (for example, M_DIGIT + M_FONT_INDEX()). This allows you to, for example, write an ANPR application that reads old and new license plates that use different fonts. Your application can specify an \"OldPlates\" string model with Font1 and a \"NewPlates\" string model with Font2. Note that the specified font index can be for a font that does not currently exist. However, if the font still does not exist at preprocessing time, an error will be generated. At preprocessing time, each character in an explicit character list constraint must exist in at least one of the fonts, otherwise an error will be generated. Grammar rules Grammar rules refer to both character constraints and string size constraints, which are typically used together in concert. For example, you have an application that reads name tags. Your grammar rules specify that the minimum string size is set to 6 and the maximum string size is set to 12. Your grammar rules also specify the following character constraints for each of your string's 12 positions: In this case, the following table lists some strings that would be either accepted or rejected for the read operation: String Read state Mr. White Accepted Mr. Orange Accepted Mr. Blonde Accepted Mr. Pink Accepted Joe Cabot Rejected Mr. Lawrence Bender Rejected Mr. X Rejected As previously mentioned, each string model in a String Reader context can have a different set of grammar rules. This gives the String Reader module a lot of versatility; it allows you to read many different types of strings within a single context. For example, you want to read two types of telephone numbers, one that starts with '514', and another that starts with '450'. You can therefore create two string models, one for each area code. In this case, the grammar rules for both string models would be exactly the same, except for the constraint placed on the first three characters: The advantage of having grammar rules can also be seen when writing an ANPR application. For example, the majority of Quebec license plates have two types of strings: three letters followed by three digits, or three digits followed by three letters. If you want to write an application that reads these license plates, you would need two string models. Each would have a maximum and minimum size of 6. One model would read letter, letter, letter, digit, digit, digit, and another model would read digit, digit, digit, letter, letter, letter. Note that, if you developed such an application using the OCR module instead of the String Reader module, it would be more complex to write, and less able to reject incorrect strings. Since the OCR module does not allow for grammar rules, the state of all characters cannot be inferred by the state of some. For example, you know that for Quebec license plates, strings that start with a digit must have three digits followed by three letters. Similarly, strings that start with a letter must have three letters followed by three digits. While String Reader can make this assumption, OCR cannot. With OCR, you would have to specify, for each character position, digit or letter. Although this would read the license plates, it might also read some strings that are not license plates (false positives). That is, if the character at position 0 is a letter, it is simply not true that the character at position 1 can be either a letter or a digit; it must be a letter. Having the ability to apply grammar rules helps you avoid such inaccuracies. Rules for character placement String size Character constraints How constraints are used with string models and fonts Grammar rules ",
      "wordCount": 1393,
      "subEntries": []
    },
    {
      "id": "UG_string_Global_context_settings",
      "version": null,
      "title": "Global context settings",
      "subTitles": [
        "Minimum contrast",
        "Speed",
        "Timeout",
        "Encoding"
      ],
      "location": "MIL UG P03: 2D processing and analysis",
      "pageURL": "content\\UserGuide\\string\\Global_context_settings.htm",
      "text": " Global context settings The global settings of a String Reader context can determine the strategy used to read all of the context's string models, which in turn, could affect the speed and robustness of the read operation (MstrRead()). To adjust the global context settings to fit your individual application's needs, use MstrControl() with M_CONTEXT. The default value for each global context setting is typically good. However, if you want to find the optimum balance between speed and robustness for a particular application, it is recommended that you experiment with different global context setting values. The global context settings include: Minimum contrast. Speed. Timeout. Maximum number of strings to read. Encoding. Space character. String separator. Scale. Skew. Unlike other global context settings of String Reader, you can set the maximum number of strings to read for both the String Reader context and each string model within the context. For more information, see the Number of strings to read section earlier in this chapter. Scale and skew have been previously discussed. For more information, see the String scale and character scale subsection of the Degrees of freedom section earlier in this chapter and the Skew angle subsection of the Degrees of freedom section earlier in this chapter. Space characters and string separators are discussed in the Formatted and non-formatted results subsection of the Retrieving results and annotation section later in this chapter. If the results of your operation are poor due to defects in the image (causing characters not to be distinguishable from some or all of the background) the image might need further processing, such as using MimMorphic() with M_TOP_HAT or M_BOTTOM_HAT. For more information, refer to the Top and bottom hat subsection of the Custom morphological operations section of Chapter 4: Advanced image processing. Minimum contrast String Reader is contrast invariant. Therefore, if a valid character exists in the target image, it will be read, regardless of whether the contrast between that character and its background is high or low. However, you might be able to speed up the read time by specifying the minimum contrast value, using MstrControl() with M_MINIMUM_CONTRAST. Valid values are between 1 and 255. The default value is 15. Any character in the target image that does not have a contrast greater than the specified minimum value will be ignored, thereby possibly increasing the speed of the read operation. Increasing the minimum contrast might make a readable character unreadable. For example, if the contrast between a valid character and its background is 25, and you set the minimum contrast to 50, that character will not be read. It is therefore important to make sure that the minimum contrast value is not causing the read operation to ignore acceptable characters. Speed You can specify the algorithm's read speed, using MstrControl() with M_SPEED. The speed can be set to M_MEDIUM or M_HIGH. The default is M_MEDIUM. Higher read speeds cause the read operation to take a greater number of shortcuts, which typically results in shorter read times, though it can also skip important information. Timeout In time critical applications, you can set a time limit, in msec, for String Reader to read using the specified string models. To do so, use MstrControl() with M_TIMEOUT. The default value is 2000 msecs. Due to certain application-dependent calculations, the actual maximum read time might vary slightly from the timeout specified. You can disable the timeout setting using M_DISABLE. After the time limit has been reached, the read operation will terminate, even if the required number of strings has not been read. Results are returned for all strings read up to the timeout. It is not possible to predict which strings will be read beforehand. To check whether the timeout limit has been reached, use MstrGetResult() with M_TIMEOUT_END. Encoding You can set the type of character encoding used by the String Reader context. To do so, use MstrControl() with M_ENCODING. The selected encoding scheme will affect the expected data type of the information that you pass to or retrieve from String Reader. For example, when adding characters to the font, using MstrEditFont() with M_CHAR_ADD, the expected data type is based on the M_ENCODING setting. The encoding schemes supported are M_ASCII and M_UNICODE. M_ASCII specifies an 8-bit ASCII standard character type, and corresponds to the char data type. This is the default value. M_UNICODE specifies a 16-bit Unicode standard character type, and corresponds to the short data type. Global context settings Minimum contrast Speed Timeout Encoding ",
      "wordCount": 745,
      "subEntries": []
    },
    {
      "id": "UG_string_Scores_and_acceptances",
      "version": null,
      "title": "Scores and acceptances",
      "subTitles": [
        "String acceptance, certainty, and score",
        "Character acceptance and score",
        "Character similarity",
        "Character homogeneity",
        "String target acceptance, certainty, and score"
      ],
      "location": "MIL UG P03: 2D processing and analysis",
      "pageURL": "content\\UserGuide\\string\\Scores_and_acceptances.htm",
      "text": " Scores and acceptances When String Reader performs a read operation, it analyzes the target image and localizes potential character candidates for each string model. The best candidates that meet the minimum definition of a string (a linear sequence of regular characters) and all user-specified constraints will be read. Every character candidate, and the string candidate to which it belongs, is given a score between 0 and 100. The higher the score, the better the candidate. These scores quantify: The similarity between the character in the target image and the corresponding character in the font. The similarity between the character in the target image and the other characters of the string in the target. The number of unread characters within the read-region of the string in the target image. String Reader allows you to set various acceptance values, which act as a threshold for the candidate's scores. If the candidate's score is equal to or above its respective acceptance value, the candidate can be read; otherwise, it cannot be read. Note that the string candidates with the highest scores above all the acceptance values will be read, up to the maximum number of strings specified. For more information on setting the maximum number of strings to read, see the Number of strings to read section earlier in this chapter. String Reader also allows you to set various string certainty values. Any string candidate with scores greater than or equal to the certainty levels is considered a certain match. Therefore, if the read operation localizes the required number of string candidates that meet all the certainty values, the read operation stops, without verifying the rest of the image for candidates with higher scores. The acceptance level represents a threshold for a score that is adequate, though you would like to check the rest of the image for better scores. The certainty level represents a threshold for a score that is so good, you need not verify that there is a better one. Since lowering the certainty usually results in less image analysis, it can speed up the read operation. However, you should set the certainty carefully, since a high certainty can stop MstrRead() prematurely, and allow the best candidates to remain unread. Acceptance and certainty values can be set for the characters, the string, and the read-region of the string in the target image. Characters also have a similarity and homogeneity setting. The default value for each of these settings is typically sufficient. However, to fit the specific needs of your application, it is recommended that you try experimenting with the values. For example, trying various acceptance values might be necessary if you have an image with an unusual amount of text that you want to ignore. Note that, although each value represents a kind of threshold for a specific score, when used in concert, they provide a great deal of versatility for accepting and rejecting strings as a whole. String acceptance, certainty, and score The string score is the average score of all the characters in the string. To set the acceptance threshold for the string score, use MstrControl() with M_STRING_ACCEPTANCE. To set the certainty threshold for the string score, use MstrControl() with M_STRING_CERTAINTY. To get the actual score of the string, use MstrGetResult() with M_STRING_SCORE. The following animation illustrates an image used to define a font, and a target image where the string 'ZEY 877' must be read. In this example, the string has a score of 91.9%. Therefore, if M_STRING_ACCEPTANCE is set to 91.9 or below, the string 'ZEY 877' will be accepted by the read operation. Character acceptance and score The character score is calculated as the average value of the character's similarity and homogeneity scores. To set the acceptance threshold for the character score, use MstrControl() with M_CHAR_ACCEPTANCE. To get the actual score of the character, use MstrGetResult() with M_CHAR_SCORE. Note that characters with character scores below the character acceptance value will not be considered part of the string, and therefore might cause the string not to be read. Note that if a character does not meet either the character similarity or homogeneity acceptance thresholds, these scores are ignored when calculating the string score (M_STRING_SCORE). Character similarity The character's similarity score quantifies how closely the character in the target image resembles the character in the font. This resemblance is based solely on how the character \"looks,\" disregarding variations in contrast, size, aspect ratio, scale, and baseline. For example, an 'A' is still an 'A', even if the 'A' in the target image is twice as big as the 'A' in the font. To set the acceptance threshold for the character's similarity score, use MstrControl() with M_CHAR_SIMILARITY_ACCEPTANCE. To get the actual similarity score of the character, use MstrGetResult() with M_CHAR_SIMILARITY_SCORE. Character homogeneity The character's homogeneity score quantifies the similarity between the character in the target image and the other characters of the string in the target image. To calculate the character's homogeneity score, many character traits are taken into account, such as variations in contrast, size, aspect ratio, scale, and baseline. If each of these characteristics (and others not mentioned) is the same between the character and all other characters of the string in the target image, the resulting homogeneity score for that character would be 100. Note, however, that this is seldom the case. To set the acceptance threshold for the character's homogeneity score, use MstrControl() with M_CHAR_HOMOGENEITY_ACCEPTANCE. To get the actual homogeneity score of the character, use MstrGetResult() with M_CHAR_HOMOGENEITY_SCORE. Since the character's homogeneity is calculated by how well the character compares to the other characters in the string, rather than how well it compares to the font, it can solve problems that cannot be resolved solely by similarity with the font. For example, in a target image, you might have characters that have high similarity scores and that, individually, are all acceptable. However, if their characteristics cause them to be out of context with the other characters in the string, you might want to reject them, based on their homogeneity score. String target acceptance, certainty, and score String Reader computes a score for the read-region of the string in the target image. This region can be defined as the string's box, which includes the maximum number of spaces before and after the string. This distance is calculated using the space width (MstrControl() with M_SPACE_WIDTH) and the maximum number of consecutive spaces (MstrControl() with M_SPACE_MAX_CONSECUTIVE). For more information, see the Space size subsection of the Creating and customizing the fonts for a font-based context section earlier in this chapter. Any unread character within the read-region in the target image will lower the string target score. An unread is any character that would ordinarily be read, if not for user-specified constraints (such as scale and grammar restrictions). The greater the number of unread readable characters in the read-region of the string in the target image, the lower the string target score will be. To get the string target score, use MstrGetResult() with M_STRING_TARGET_SCORE. To set the acceptance threshold for the string target score, use MstrControl() with M_STRING_TARGET_ACCEPTANCE. To set the certainty threshold for the string target score, use MstrControl() with M_STRING_TARGET_CERTAINTY. For example, to read the string \"SAM VOX\", you have set 'S', 'A', 'M' as the first three character constraints, and 'V', 'O', 'X' as the last three character constraints. In the following target image, it is likely that \"SAM VOX\" would be read. However, you might want the extra letters at the beginning and in the middle of the read-region of the string to cause this string not to be read. To do so, set an adequate acceptance level for the string target score (for example, 50.0). The extra letters in the string's read-region will cause this string to have a very low string target score. Scores and acceptances String acceptance, certainty, and score Character acceptance and score Character similarity Character homogeneity String target acceptance, certainty, and score ",
      "wordCount": 1325,
      "subEntries": []
    },
    {
      "id": "UG_string_Retrieving_results_and_annotation",
      "version": null,
      "title": "Retrieving results and annotation",
      "subTitles": [
        "Annotation",
        "Transformation coefficients",
        "Formatted and non-formatted results"
      ],
      "location": "MIL UG P03: 2D processing and analysis",
      "pageURL": "content\\UserGuide\\string\\Retrieving_results_and_annotation.htm",
      "text": " Retrieving results and annotation After adding at least one string model and one font to the String Reader context, and performing a successful preprocess and read operation, you would typically retrieve and draw various features of your results. To do so, use MstrGetResult() and MstrDraw(). These functions offer many different types of results and draw operations. For example, you can retrieve the aspect ratio of the characters, using M_CHAR_ASPECT_RATIO, or draw a cross at the center of the bounding box of each string's character, using M_DRAW_STRING_CHAR_POSITION. To return the index of the font of each individual character within the string, use MstrGetResult() with M_CHAR_FONT. To return the index of the character in the font for each individual character within the string, use MstrGetResult() with M_CHAR_INDEX. In either case, the index returned is the index value at the moment the MstrRead() operation is performed. Therefore, if the font list changes after the read operation has been called (for example, you add or remove a character), the index value that you retrieve might not be valid. Annotation The String Reader module allows you to draw specific features of the String Reader context or String Reader results, using MstrDraw(). For example, you can draw your string results to ensure that the read operation has read the correct characters. After each drawing operation, the optimal image size that was needed for that operation is updated. This information can be inquired using MstrInquire() with M_DRAW_LAST_SIZE_X and M_DRAW_LAST_SIZE_Y. You can also update these size constants without actually performing the drawing operation; to do so, set the destination image of MstrDraw() to M_NULL. This can be useful if you, for example, want to get the optimal image buffer size for the drawing operation. All characters are drawn according to their draw box margin, which you can set using MstrControl() with M_DRAW_BOX_MARGIN_X and M_DRAW_BOX_MARGIN_Y. These margins determine the amount of white space between each character that is drawn. The default value is 3. Note that a character has no inherent margin; that is, if these margin values are set to 0, the characters are drawn, one after the other and one above the other, with no white space. For a String Reader context, you can draw a character representation of the font in the destination image, using MstrDraw() with M_DRAW_CHAR. This is useful to ensure that the characters added to the font are correct. To do so, you must specify the explicit list of characters to draw and verify. Characters are drawn from left to right, and from top to bottom. Characters that fall outside the destination image are clipped. To draw the characters on multiple lines, a space character must be inserted to separate the strings included in the null-terminated string. It might be useful to sort the characters before you draw them, thereby making it easier to visually ascertain if all the required characters are there. For more information, see the Sorting characters subsection of the Creating and customizing the fonts for a font-based context section earlier in this chapter. String Reader offers numerous drawing operations, which, if required, can be combined to draw multiple features simultaneously. For example, you can draw the characters of the string read, a box around the string read, and a cross at the center of the bounding box of each string's character (the character position). The following image shows how drawing the position of characters of a string (M_DRAW_STRING_CHAR_POSITION) for a typical Quebec license plate is displayed: For a full list of drawing operations, see MstrDraw(). Note that characters are always drawn at the location read in the target with the correct angle, scale and aspect ratio. Transformation coefficients In addition to many other kinds of results, String Reader provides you with forward and reverse transformation coefficients. These results allow you to transform any point from the character's source image (the image from which the characters were defined) to its corresponding position in the target image (forward), or from the read position in the target image to its corresponding position in the character's source image (reverse). With this information, the equivalent position of any point of any character can be drawn. For more information, see the transformation coefficients table in MstrGetResult(). Formatted and non-formatted results Unlike String Reader, humans have a hard time processing a long string of characters uninterrupted by any space, or any indication of where one string is separated from another. To make strings easier to read, you can display formatted results. To retrieve the string as a formatted result, use MstrGetResult() with M_FORMATTED_STRING. A space character is inserted in the string each time the distance between two adjacent characters exceeds the space width (MstrControl() with M_SPACE_WIDTH), at the scale of the string. You can also retrieve the entire text read as a formatted result, using MstrGetResult() with M_TEXT. In addition to inserting space characters, string separators are also inserted in the text each time the distance between two adjacent characters exceeds the space size, which depends on the space width (at the scale of the string) and the maximum number of consecutive spaces (MstrControl() with M_SPACE_MAX_CONSECUTIVE). For more information, see the Space size subsection of the Creating and customizing the fonts for a font-based context section earlier in this chapter. Both the space character and the string separator must be set before the string is read. To retrieve the non-formatted string (no spaces or string separators added), use MstrGetResult() with M_STRING. Regardless of which result is being returned, strings are always ordered in the natural Latin-based reading order. This is the order that you read text written in a Latin-based language (left to right), such as Canadian English. As mentioned earlier in this chapter, the space is not considered a character, and is not a part of any string that has been read. However, String Reader does mark the existence of a space, and can therefore artificially insert a space and/or a string separator at the correct place. For more information, see the Space section earlier in this chapter. The default character used as the space character is ASCII 32, which is a space. You can, however, set a different character, using MstrControl() with M_SPACE_CHARACTER. Depending on the type of character encoding used by the String Reader context (specified MstrControl() with M_ENCODING) any character of that specified type (either ASCII or Unicode) can be used as the space character. You can also set M_SPACE_CHARACTER to M_NONE, which specifies no space character. The default string separator is ASCII 10, which is a new line. Therefore, when retrieving the entire text (M_TEXT), each string will be on a separate line, which makes it ideal for printing purposes. You can, however, control the string separator character, using MstrControl() with M_STRING_SEPARATOR. Depending on the type of character encoding used by the String Reader context (specified MstrControl() with M_ENCODING) any character of that specified type (either ASCII or Unicode) can be used as the string separator. You can also set M_STRING_SEPARATOR to M_NONE, which specifies no separator character. You can use MstrGetResult() to get the size of the formatted string (M_FORMATTED_STRING + M_STRING_SIZE), the size of the non-formatted string (M_STRING + M_STRING_SIZE), and the size of the entire formatted text (M_TEXT + M_STRING_SIZE). When getting the size of the formatted string, the string's characters, the inserted space characters, and the null-terminated character are included. When getting the size of the non-formatted string, only the string's characters are included. When getting the entire formatted text, all the strings' characters, all the inserted space characters, and all the string separators are included; null-terminated characters are not included. Retrieving results and annotation Annotation Transformation coefficients Formatted and non-formatted results ",
      "wordCount": 1277,
      "subEntries": []
    },
    {
      "id": "UG_string_Fixing_read_problems_using_String_Expert",
      "version": null,
      "title": "Fixing read problems using String Expert",
      "subTitles": null,
      "location": "MIL UG P03: 2D processing and analysis",
      "pageURL": "content\\UserGuide\\string\\Fixing_read_problems_using_String_Expert.htm",
      "text": " Fixing read problems using String Expert Although the String Reader module is easy to use, there are many subtleties that can occasionally cause you to receive unexpected results. For example, a string might not be read or might not be read the way you expect it to be read. If this occurs, you can use the String Expert functionality in the String Reader interactive utility, which makes a diagnosis of your String Reader settings and reports configuration problems. An alternative to using the String Reader utility is to use the String Expert functionality available using MstrExpert() from within your application. Note that the String Expert functionality is not available for a fontless context. To use the String Expert functionality in the String Reader utility, enter your String Reader settings and the string that you want to read and start String Expert. String Expert will then give a report of the errors and/or warnings that have been detected. Errors inform you why the string is not being read or why the string being read might not be what you expect. Warnings inform you that, although the string is being read, it is at the limit of one or more of your settings. You can choose to have String Expert only produce error reports or only warning reports but the default setting is to produce both error and warning reports. String Expert will also show you the string model associated with the specified error and/or warning. String Expert will give reports on a wide range of problems, such as an improperly set font or string model setting, as well as incorrect characters in your font or improper character constraints. For example, you might want to read a license plate that must consist of 3 letters and 3 digits, such as the license plates shown below. However, when you try to read the string from a correct source image, the string cannot be located. To establish the problem, enter the string that you expect to read (in this case, 'ZEY877') and start String Expert. When you get the error report, you might get a message saying that the string model reference scale is too high. In this case, you should lower the string scale and perform the read operation again. Now, it should finally read your string. Another example might be that you want to read the string 'YRH900', but did not add the correct characters to the font. However, based on your string model acceptance levels, you have a valid read operation, although the string read is not what it should be. Depending on your settings and the actual characters in your font, an 'R' can be read as an 'A', or the numerical '0' character can be read as the alphabetical 'O' character. By using the String Expert functionality and getting the error report for this situation, you will receive a message saying that the target string contains one or more characters that are not defined in your font. Upon adding these characters to the font, the read operation will then produce the results you expect. As mentioned previously, an alternative to using the String Expert functionality in the String Reader utility is using MstrExpert(). You might want to use this approach if you wanted to debug from within your application. To produce the error/warning report, pass MstrExpert() the string to read and the target image. You can also choose to only obtain an error report or only a warning report. After calling MstrExpert(), you can get the errors and/or warnings that have been detected, using MstrGetResult(). To get the actual error or warning message, use MstrGetResult() with M_REPORT_ERRORS or M_REPORT_WARNINGS. To retrieve the total number of errors or warnings, use MstrGetResult() with M_REPORT_NUMBER_OF_ERRORS or M_REPORT_NUMBER_OF_WARNINGS. To retrieve the string associated with either a general error or warning, use MstrInquire() with M_REPORT_STRING. Fixing read problems using String Expert ",
      "wordCount": 649,
      "subEntries": []
    },
    {
      "id": "UG_string_An_example",
      "version": null,
      "title": "String Reader example",
      "subTitles": null,
      "location": "MIL UG P03: 2D processing and analysis",
      "pageURL": "content\\UserGuide\\string\\An_example.htm",
      "text": " String Reader example The String Reader example MStr.cpp illustrates how to define a font from an image with a mosaic of sample Quebec license plates. Two string models are then defined and their controls are set to read two valid types of Quebec license plates: three letters followed by three numbers, or three numbers followed by three letters. A valid license plate reading is then performed in a target image containing a car on the road. The example also displays the score of the string that was read, and the duration of the read operation. mstr.cpp To run this example, use the Matrox Example Launcher in the MIL Control Center. String Reader example ",
      "wordCount": 115,
      "subEntries": []
    }
  ]
}]
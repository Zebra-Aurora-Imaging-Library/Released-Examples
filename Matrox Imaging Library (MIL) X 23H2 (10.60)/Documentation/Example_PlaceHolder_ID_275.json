[{
  "id": "Example_PlaceHolder_ID",
  "version": "2024020714",
  "title": "Example_PlaceHolder_Title",
  "wordCount": 0,
  "subEntries": [
    {
      "id": "Examples_Processing_3dReconstruction_CameraLaserCalibration_CPP_cameralasercalibration_cpp",
      "version": "2024020714",
      "title": "cameralasercalibration.cpp",
      "location": "Sample Code from MIL Examples",
      "text": " Top //*************************************************************************************** // // File name: CameraLaserCalibration.cpp // Location: See Matrox Example Launcher in the MIL Control Center // // // Synopsis: This program contains an example of camera-laser calibration using milcal and // mil3dmap modules. See the PrintHeader() function below for detailed description. // // Printable calibration grids in PDF format can be found in your \"Matrox Imaging/Images/\" // directory. // // When considering a laser-based 3D reconstruction system, the file \"3D Setup Helper.xls\" // can be used to accelerate prototyping by choosing an adequate hardware configuration // (angle, distance, lens, camera, ...). The file is located in your // \"Matrox Imaging/Tools/\" directory. // // Copyright (C) Matrox Electronic Systems Ltd., 1992-2024. // All Rights Reserved //*************************************************************************************** #include &lt;mil.h&gt; #include \"interactiveexample.h\" #include \"standaloneexample.h\" #include &lt;cstdlib&gt; #define SAVE_PATH MIL_TEXT(\"\") //**************************************************************************** // Example description. //**************************************************************************** void PrintHeader() { MosPrintf(MIL_TEXT(\"[EXAMPLE NAME]\\n\") MIL_TEXT(\"CameraLaserCalibration\\n\\n\") MIL_TEXT(\"[SYNOPSIS]\\n\") MIL_TEXT(\"This example demonstrates how to create a robust calibration of a\\n\") MIL_TEXT(\"3D reconstruction setup consisting of a camera and a laser line\\n\") MIL_TEXT(\"(sheet-of-light).\\n\\n\") MIL_TEXT(\"[MODULES USED]\\n\") MIL_TEXT(\"Modules used: Application, System, Display, Digitizer, Buffer, Graphics,\\n\") MIL_TEXT(\" Image Processing, Calibration, 3D Reconstruction.\\n\\n\")); } //***************************************************************************** // File names // Name of the camera calibration file to save (or to reload). static MIL_CONST_TEXT_PTR const CAMERA_CALIBRATION_FILE = SAVE_PATH MIL_TEXT(\"MilCalibration.mca\"); // Name of the image file of the calibration grid to save. static MIL_CONST_TEXT_PTR const CALIBRATION_GRID_FILE = SAVE_PATH MIL_TEXT(\"CalibrationGrid.mim\"); // Name of the 3D reconstruction context file to save. static MIL_CONST_TEXT_PTR const CALIBRATION_3D_FILE = SAVE_PATH MIL_TEXT(\"MilLaser.m3d\"); // Pattern for file name of the images of laser lines used to calibrate the // 3D reconstruction context. static MIL_CONST_TEXT_PTR const REFERENCE_PLANE_FILE_PATTERN = SAVE_PATH MIL_TEXT(\"ReferencePlane%d.mim\"); //***************************************************************************** // Parameters for McalGrid(). Depends on the calibration grid used. static const MIL_INT ROW_NUMBER = 15; static const MIL_INT COLUMN_NUMBER = 16; static const MIL_DOUBLE ROW_SPACING = 5.0; // in mm static const MIL_DOUBLE COLUMN_SPACING = 5.0; // in mm static const MIL_INT GRID_TYPE = M_CIRCLE_GRID; //***************************************************************************** // Parameters used during 3D reconstruction setup calibration. // Z-position of the first reference plane. static const MIL_DOUBLE INITIAL_CALIBRATION_DEPTH = 0.0; // in mm // Z difference between consecutive reference planes. This is negative to indicate that // each reference plane is higher that the previous one (since the Z axis points downwards). static const MIL_DOUBLE CALIBRATION_DEPTH_PER_PLANE = -12.0; // in mm // Conversion constant that could be used to generate depth maps in M_DEPTH_CORRECTION mode. // It allows to convert from a world Z position to an output depth map gray level. static const MIL_DOUBLE GRAY_LEVEL_PER_WORLD_UNIT = -1000.0; // in gray level/mm //***************************************************************************** // Functions declarations. //***************************************************************************** MIL_ID CalibrateCamera (CExampleInterface* pExample); bool DiagnoseCameraCalibration (CExampleInterface* pExample, MIL_ID MilCalibration); void SetupLineExtractionParameters(CExampleInterface* pExample, MIL_INT CalibrationMode, MIL_INT* pMinContrast); bool CalibrateLaser (CExampleInterface* pExample, MIL_ID MilLaser, MIL_ID MilCameraCalibration); bool DiagnoseFullCalibration (CExampleInterface* pExample, MIL_ID MilLaser); bool DiagnoseDepthCalibration (CExampleInterface* pExample, MIL_ID MilLaser); //***************************************************************************** // Main. //***************************************************************************** int MosMain(void) { // Print example description. PrintHeader(); bool RunInteractiveExample = CExampleInterface::AskInteractiveExample(); // Allocate MIL objects: application, system, display and digitizer (if needed). CExampleInterface* pExample; if (RunInteractiveExample) pExample = new CInteractiveExample; else pExample = new CStandAloneExample; // If any allocation failed (mainly, the system or digitizer), then exit now. if (!pExample-&gt;IsValid()) { MosPrintf(MIL_TEXT(\"Unable to allocate all MIL objects (system, display, digitizer).\\n\\n\") MIL_TEXT(\"Press any key to exit.\\n\\n\")); MosGetch(); delete pExample; return EXIT_FAILURE; } // Choose 3dmap mode. MIL_INT CalibrationMode = pExample-&gt;AskCalibrationMode(); // Calibrate the camera if needed. MIL_ID MilCameraCalibration = M_NULL; if (CalibrationMode == M_CALIBRATED_CAMERA_LINEAR_MOTION) MilCameraCalibration = CalibrateCamera(pExample); // Allocate display image buffer, select it to display and prepare overlay for // annotations if not done already. pExample-&gt;ShowDisplay(); // Choose values for M_MINIMUM_CONTRAST. For now, this example leave M_PEAK_WIDTH_NOMINAL // and M_PEAK_WIDTH_DELTA to their default values. MIL_INT MinContrast; SetupLineExtractionParameters(pExample, CalibrationMode, &amp;MinContrast); // Calibration loop until successful. bool CalibrationSuccessful = false; while (!CalibrationSuccessful) { // Create a new 3d reconstruction context. MIL_ID MilLaser = M3dmapAlloc(pExample-&gt;GetMilSystem(), M_LASER, CalibrationMode, M_NULL); MIL_ID MilLocatePeakContext; M3dmapInquire(MilLaser, M_DEFAULT, M_LOCATE_PEAK_1D_CONTEXT_ID+M_TYPE_MIL_ID, &amp;MilLocatePeakContext); MimControl(MilLocatePeakContext, M_MINIMUM_CONTRAST, MinContrast); // Call calibration routine. CalibrationSuccessful = CalibrateLaser(pExample, MilLaser, MilCameraCalibration); // If calibration succeeded, save the 3d reconstruction context before exiting. if (CalibrationSuccessful) { pExample-&gt;HideDisplay(); M3dmapSave(CALIBRATION_3D_FILE, MilLaser, M_DEFAULT); MosPrintf(MIL_TEXT(\"Calibration was successful.\\n\") MIL_TEXT(\"3D reconstruction context was saved as '\")); MosPrintf(CALIBRATION_3D_FILE); MosPrintf(MIL_TEXT(\"'\\n\\nPress any key to exit.\\n\\n\")); MosGetch(); } M3dmapFree(MilLaser); } // Free MIL objects. if (MilCameraCalibration != M_NULL) McalFree(MilCameraCalibration); delete pExample; return 0; } //***************************************************************************** // Allocates a new camera calibration context and grabs a calibration grid to // calibrate it. The resulting calibration context is returned when successful. //***************************************************************************** MIL_ID CalibrateCamera(CExampleInterface* pExample) { MosPrintf(MIL_TEXT(\"Calibrating the camera\\n\") MIL_TEXT(\"======================\\n\\n\")); // First, let's look if there is a calibration file in local directory. // Try to reload it, and if it works, ask user if he wants it. MIL_ID MilCalibration = pExample-&gt;TryToReloadCameraCalibration(CAMERA_CALIBRATION_FILE); if (MilCalibration == M_NULL) { // Allocate display image buffer, select it to display and prepare overlay for // annotations if not done already. pExample-&gt;ShowDisplay(); // The calibration context was not reloaded, create one here. // Allocate calibration context in 3D mode. McalAlloc(pExample-&gt;GetMilSystem(), M_TSAI_BASED, M_DEFAULT, &amp;MilCalibration); // Calibration loop until successful. bool CalibrationSuccessful = false; while (!CalibrationSuccessful) { // Grab continuously until user presses any key. pExample-&gt;CopyInOverlay(CExampleInterface::eCalibrateCameraImage); pExample-&gt;GrabCalibrationGrid(); // Calibrate the camera. MappControl(M_DEFAULT, M_ERROR, M_PRINT_DISABLE); McalGrid(MilCalibration, pExample-&gt;GetMilDisplayImage(), 0.0, 0.0, 0.0, ROW_NUMBER, COLUMN_NUMBER, ROW_SPACING, COLUMN_SPACING, M_DEFAULT, GRID_TYPE); MappControl(M_DEFAULT, M_ERROR, M_PRINT_ENABLE); MIL_INT CalibrationStatus = McalInquire(MilCalibration, M_CALIBRATION_STATUS, M_NULL); switch (CalibrationStatus) { case M_CALIBRATED: // When calibration is successful, use diagnostic functionalities to ensure // it is accurate. CalibrationSuccessful = DiagnoseCameraCalibration(pExample, MilCalibration); break; case M_GRID_NOT_FOUND: MosPrintf(MIL_TEXT(\"The camera calibration failed because the grid was not found.\\n\\n\")); break; case M_PLANE_ANGLE_TOO_SMALL: MosPrintf(MIL_TEXT(\"The camera calibration failed because the camera's optical axis is not\\n\") MIL_TEXT(\"sufficiently inclined (inclination should be at least 30 degrees).\\n\\n\")); break; default: MosPrintf(MIL_TEXT(\"Calibration failed for unexpected reasons.\\n\\n\")); break; } pExample-&gt;PauseInStandAloneMode(); if (!CalibrationSuccessful) MosPrintf(SEPARATOR); // Clear overlay. MdispControl(pExample-&gt;GetMilDisplay(), M_OVERLAY_CLEAR, M_DEFAULT); } pExample-&gt;HideDisplay(); // Save objects related to camera calibration. McalSave(CAMERA_CALIBRATION_FILE, MilCalibration, M_DEFAULT); MbufSave(CALIBRATION_GRID_FILE, pExample-&gt;GetMilDisplayImage()); MosPrintf(MIL_TEXT(\"The camera calibration was successful. The calibration context was saved as\\n'\")); MosPrintf(CAMERA_CALIBRATION_FILE); MosPrintf(MIL_TEXT(\"' and the calibration grid image was saved as\\n'\")); MosPrintf(CALIBRATION_GRID_FILE); MosPrintf(MIL_TEXT(\"'.\\n\\nPress any key to continue.\\n\\n\")); MosGetch(); } return MilCalibration; } //***************************************************************************** // Use diagnostic functionalities to ensure given camera calibration context is // accurate. If so, return true. //***************************************************************************** bool DiagnoseCameraCalibration(CExampleInterface* pExample, MIL_ID MilCalibration) { // Both conditions must be true for the camera calibration to be good. bool ExtractionIsAccurate = false; bool CalibrationIsAccurate = false; // Draw calibration points in green. MgraControl(M_DEFAULT, M_COLOR, M_COLOR_GREEN); McalDraw(M_DEFAULT, MilCalibration, pExample-&gt;GetMilOverlayImage(), M_DRAW_IMAGE_POINTS + M_DRAW_CALIBRATION_ERROR, M_DEFAULT, M_DEFAULT); pExample-&gt;CopyInOverlay(CExampleInterface::eCalibrateCameraImage); MosPrintf(MIL_TEXT(\"Calibration points extracted from the image are displayed in green.\\n\\n\")); // Asks user if extraction is OK. ExtractionIsAccurate = pExample-&gt;AskIfFeatureExtractionAccurate(); if (ExtractionIsAccurate) { // Show some error information. MIL_DOUBLE AveragePixelError, MaximumPixelError, AverageWorldError, MaximumWorldError; McalInquire(MilCalibration, M_AVERAGE_PIXEL_ERROR, &amp;AveragePixelError); McalInquire(MilCalibration, M_MAXIMUM_PIXEL_ERROR, &amp;MaximumPixelError); McalInquire(MilCalibration, M_AVERAGE_WORLD_ERROR, &amp;AverageWorldError); McalInquire(MilCalibration, M_MAXIMUM_WORLD_ERROR, &amp;MaximumWorldError); MosPrintf(MIL_TEXT(\"Calibration points, transformed using the calibration context, are shown\\nin red.\\n\")); MosPrintf(MIL_TEXT(\"Pixel error\\n average: %.3g pixels\\n maximum: %.3g pixels\\n\"), AveragePixelError, MaximumPixelError); MosPrintf(MIL_TEXT(\"World error\\n average: %.3g mm\\n maximum: %.3g mm\\n\\n\"), AverageWorldError, MaximumWorldError); // Draw coordinate system in gray. MgraControl(M_DEFAULT, M_COLOR, M_COLOR_LIGHT_GRAY); McalDraw(M_DEFAULT, MilCalibration, pExample-&gt;GetMilOverlayImage(), M_DRAW_ABSOLUTE_COORDINATE_SYSTEM+M_DRAW_AXES, M_DEFAULT, M_DEFAULT); // Draw calibration points in red. MgraControl(M_DEFAULT, M_COLOR, M_COLOR_RED); McalDraw(M_DEFAULT, MilCalibration, pExample-&gt;GetMilOverlayImage(), M_DRAW_WORLD_POINTS, M_DEFAULT, M_DEFAULT); pExample-&gt;CopyInOverlay(CExampleInterface::eCalibrateCameraImage); // Asks user if calibration is accurate, i.e. if red and green marks coincide. CalibrationIsAccurate = pExample-&gt;AskIfCameraCalibrationAccurate(); } // Calibration is OK if user answered YES to both questions. return (ExtractionIsAccurate &amp;&amp; CalibrationIsAccurate); } //***************************************************************************** // Choose values for M_MINIMUM_CONTRAST. //***************************************************************************** void SetupLineExtractionParameters(CExampleInterface* pExample, MIL_INT CalibrationMode, MIL_INT* pMinContrast) { MosPrintf(MIL_TEXT(\"Setting up the laser line extraction parameters\\n\") MIL_TEXT(\"===============================================\\n\\n\")); // Create a child for green annotations. MgraControl(M_DEFAULT, M_COLOR, 255.0); MIL_ID MilOverlayGreenBand = MbufChildColor(pExample-&gt;GetMilOverlayImage(), M_GREEN, M_NULL); // Create 3dmap objects. MIL_ID MilLaser = M3dmapAlloc(pExample-&gt;GetMilSystem(), M_LASER, CalibrationMode, M_NULL); MIL_ID MilCalibScan = M3dmapAllocResult(pExample-&gt;GetMilSystem(), M_LASER_CALIBRATION_DATA, M_DEFAULT, M_NULL); MIL_ID MilLocatePeakContext; M3dmapInquire(MilLaser, M_DEFAULT, M_LOCATE_PEAK_1D_CONTEXT_ID+M_TYPE_MIL_ID, &amp;MilLocatePeakContext); // Initialize M_MINIMUM_CONTRAST variable to the module default value. MimInquire(MilLocatePeakContext, M_MINIMUM_CONTRAST+M_TYPE_MIL_INT, pMinContrast); pExample-&gt;PrintExplanationForMinContrast(); // Loop until user is satisfied with the M_MINIMUM_CONTRAST setting. bool IsFinished = false; while (!IsFinished) { // Allow user to change M_MINIMUM_CONTRAST by using (1,2,4,5); any key breaks from the loop. // This is not a blocking call. IsFinished = pExample-&gt;AskMinContrastAdjust(pMinContrast); // Grabs a single image of the laser line. pExample-&gt;GrabLaserLineToAdjustContrast(); // Extract laser line from grabbed image, using current value for M_MINIMUM_CONTRAST. MimControl(MilLocatePeakContext, M_MINIMUM_CONTRAST, *pMinContrast); M3dmapAddScan(MilLaser, MilCalibScan, pExample-&gt;GetMilDisplayImage(), M_NULL, M_NULL, M_DEFAULT, M_DEFAULT); // Draw extracted line (temporarily disable overlay for faster refresh rate). MdispControl(pExample-&gt;GetMilDisplay(), M_UPDATE, M_DISABLE); MdispControl(pExample-&gt;GetMilDisplay(), M_OVERLAY_CLEAR, M_DEFAULT); M3dmapDraw(M_DEFAULT, MilCalibScan, MilOverlayGreenBand, M_DRAW_PEAKS_LAST, M_DEFAULT, M_DEFAULT); pExample-&gt;CopyInOverlay(CExampleInterface::eAdjustMinContrastImage); MdispControl(pExample-&gt;GetMilDisplay(), M_UPDATE, M_ENABLE); pExample-&gt;PauseInStandAloneMode(); // Remove extracted line to avoid accumulating useless data. M3dmapClear(MilCalibScan, M_DEFAULT, M_REMOVE_LAST_SCAN, M_DEFAULT); } MosPrintf(MIL_TEXT(\"\\n\\n\")); // Clear overlay. MbufFree(MilOverlayGreenBand); MdispControl(pExample-&gt;GetMilDisplay(), M_OVERLAY_CLEAR, M_DEFAULT); // Free MIL objects. M3dmapFree(MilCalibScan); M3dmapFree(MilLaser); } //***************************************************************************** // Grab images of laser lines at different heights to calibrate a given 3d // reconstruction context. If it is M_CALIBRATED_CAMERA_LINEAR_MOTION, then // the camera calibration context is also passed as parameter, else it is M_NULL. //***************************************************************************** bool CalibrateLaser(CExampleInterface* pExample, MIL_ID MilLaser, MIL_ID MilCameraCalibration) { MosPrintf(MIL_TEXT(\"Calibrating the 3D reconstruction setup\\n\") MIL_TEXT(\"=======================================\\n\\n\")); // Create a child for green annotations. MgraControl(M_DEFAULT, M_COLOR, 255.0); MIL_ID MilOverlayGreenBand = MbufChildColor(pExample-&gt;GetMilOverlayImage(), M_GREEN, M_NULL); MIL_INT SizeX = MbufInquire(pExample-&gt;GetMilDisplayImage(), M_SIZE_X, M_NULL); MIL_INT SizeY = MbufInquire(pExample-&gt;GetMilDisplayImage(), M_SIZE_Y, M_NULL); // Inquire the calibration mode to set up some different behaviors. MIL_INT CalibrationMode = M3dmapInquire(MilLaser, M_DEFAULT, M_LASER_CONTEXT_TYPE, M_NULL); // In M_CALIBRATED_CAMERA_LINEAR_MOTION mode: // - If only one reference plane is used, the laser plane is assumed to be perfectly vertical. // - Corrected depths are given in world units. // In M_DEPTH_CORRECTION mode: // - At least two reference planes are needed. // - Corrected depths are given in desired gray levels of the eventual output depth maps. // -&gt; Because of this, we initialize a factor to allow converting real heights to gray levels. MIL_INT MinReferencePlanes; MIL_DOUBLE Factor; if (CalibrationMode == M_CALIBRATED_CAMERA_LINEAR_MOTION) { MinReferencePlanes = 1; Factor = 1.0; // keep heights in mm. } else { MinReferencePlanes = 2; Factor = GRAY_LEVEL_PER_WORLD_UNIT; // transform heights from mm to gray levels. } // To show some useful diagnostic informations, we need to know the number of \"columns\" // in which to locate the laser line. This depends on the M_SCAN_LANE_DIRECTION setting. MIL_ID MilLocatePeakContext; M3dmapInquire(MilLaser, M_DEFAULT, M_LOCATE_PEAK_1D_CONTEXT_ID+M_TYPE_MIL_ID, &amp;MilLocatePeakContext); MIL_INT Orientation = MimInquire(MilLocatePeakContext, M_SCAN_LANE_DIRECTION, M_NULL); MIL_INT NbColumns = (Orientation == M_VERTICAL ? SizeX : SizeY); // Allocate the result that will be used to calibrate the 3d reconstruction context. MIL_ID MilCalibScan = M3dmapAllocResult(pExample-&gt;GetMilSystem(), M_LASER_CALIBRATION_DATA, M_DEFAULT, M_NULL); // If you need more that 1024 reference planes, you should control M_MAX_FRAMES here. MIL_INT MaxReferencePlanes = M3dmapInquire(MilCalibScan, M_DEFAULT, M_MAX_FRAMES, M_NULL); // This will be used to count the number of reference planes used until now. MIL_INT ReferencePlaneIndex = 0; // Loop to add more reference planes until the user is satisfied. bool ReadyToCalibrate = false; while (!ReadyToCalibrate) { // Computed the hardcoded depth of the current reference plane. // Change INITIAL_CALIBRATION_DEPTH and CALIBRATION_DEPTH_PER_PLANE to suit your needs. MIL_DOUBLE CalibrationDepth = INITIAL_CALIBRATION_DEPTH + ReferencePlaneIndex*CALIBRATION_DEPTH_PER_PLANE; // Verify that the maximum number of reference planes has not been reached. bool MaxPlaneIsReached = (ReferencePlaneIndex &gt;= MaxReferencePlanes); if (CalibrationMode == M_DEPTH_CORRECTION) { // It is not possible to provide a value outside the depth map range to // M_CORRECTED_DEPTH in M_DEPTH_CORRECTION mode. if (Factor*CalibrationDepth &lt; 0.0 || Factor*CalibrationDepth &gt; 65534.0) MaxPlaneIsReached = true; } // Break the loop if we have the maximum number of reference planes. if (MaxPlaneIsReached) { MosPrintf(MIL_TEXT(\"The maximum number of reference planes of this example has been reached.\\n\") MIL_TEXT(\"Please modify the source code to use more reference planes.\\n\\n\") MIL_TEXT(\"Press any key to continue.\\n\\n\")); MosGetch(); break; } // If we already have enough planes to calibrate, then ask the user if he wants to stop. bool ShouldAskIfFinished = (ReferencePlaneIndex &gt;= MinReferencePlanes); // Grabs continuously until the user Press any key to add a new reference plane // or 's' if he has enough reference planes and wants to stop. pExample-&gt;CopyInOverlay(CExampleInterface::eCalibrateLaserImage); ReadyToCalibrate = pExample-&gt;GrabCalibrationLaserLine(ReferencePlaneIndex, CalibrationDepth, ShouldAskIfFinished); if (!ReadyToCalibrate) { // Add a new reference plane. First set the calibration depth of the plane. M3dmapControl(MilLaser, M_DEFAULT, M_CORRECTED_DEPTH, Factor*CalibrationDepth); // Extract the laser line and draw it in the overlay. M3dmapAddScan(MilLaser, MilCalibScan, pExample-&gt;GetMilDisplayImage(), M_NULL, M_NULL, M_DEFAULT, M_DEFAULT); M3dmapDraw(M_DEFAULT, MilCalibScan, MilOverlayGreenBand, M_DRAW_PEAKS_LAST, M_DEFAULT, M_DEFAULT); pExample-&gt;CopyInOverlay(CExampleInterface::eCalibrateLaserImage); // Print the number of columns where the laser line could not be detected. MIL_INT NbColumnsWithMissingData; M3dmapGetResult(MilCalibScan, M_DEFAULT, M_NUMBER_OF_MISSING_DATA_LAST_SCAN + M_TYPE_MIL_INT, &amp;NbColumnsWithMissingData); MosPrintf(MIL_TEXT(\"Extracted laser line is displayed in green.\\n\")); MosPrintf(MIL_TEXT(\"Number of columns with missing data: %4d / %d (%.1f%%)\\n\\n\"), (int)NbColumnsWithMissingData, (int)NbColumns, 100.0*static_cast&lt;MIL_DOUBLE&gt;(NbColumnsWithMissingData)/static_cast&lt;MIL_DOUBLE&gt;(NbColumns)); // Asks the user if he is satisfied with the laser line extraction. bool ExtractionIsAccurate = pExample-&gt;AskIfLineExtractionAccurate(); pExample-&gt;PauseInStandAloneMode(); // Clear the overlay. MdispControl(pExample-&gt;GetMilDisplay(), M_OVERLAY_CLEAR, M_DEFAULT); if (ExtractionIsAccurate) { // If the image is OK, save it. const MIL_INT MAX_FILENAME_LENGTH = 32; MIL_TEXT_CHAR ImageName[MAX_FILENAME_LENGTH]; MosSprintf(ImageName, MAX_FILENAME_LENGTH, REFERENCE_PLANE_FILE_PATTERN, (int)ReferencePlaneIndex); MbufSave(ImageName, pExample-&gt;GetMilDisplayImage()); MosPrintf(MIL_TEXT(\"Image was saved as '%s'\\n\\n\"), ImageName); ++ReferencePlaneIndex; } else { // Image is not OK, remove it from the result. M3dmapClear(MilCalibScan, M_DEFAULT, M_REMOVE_LAST_SCAN, M_DEFAULT); } MosPrintf(SEPARATOR); } } // Calibrate the 3d reconstruction context using the result with all the extracted laser // lines that were kept by the user and using the camera calibration context, if necessary. MappControl(M_DEFAULT, M_ERROR, M_PRINT_DISABLE); M3dmapCalibrate(MilLaser, MilCalibScan, MilCameraCalibration, M_DEFAULT); MappControl(M_DEFAULT, M_ERROR, M_PRINT_ENABLE); MIL_INT CalibrationStatus = M3dmapInquire(MilLaser, M_DEFAULT, M_CALIBRATION_STATUS, M_NULL); bool CalibrationSuccessful = false; switch (CalibrationStatus) { case M_CALIBRATED: // When calibration is successful, use diagnostic functionalities to ensure // it is accurate. if (CalibrationMode == M_CALIBRATED_CAMERA_LINEAR_MOTION) CalibrationSuccessful = DiagnoseFullCalibration(pExample, MilLaser); else CalibrationSuccessful = DiagnoseDepthCalibration(pExample, MilLaser); break; case M_LASER_LINE_NOT_DETECTED: MosPrintf(MIL_TEXT(\"Calibration failed because laser line could not be detected in the calibration\\n\") MIL_TEXT(\"image.\\n\\n\")); break; case M_NOT_ENOUGH_MEMORY: MosPrintf(MIL_TEXT(\"Calibration failed because there was not enough available memory.\\n\\n\")); break; default: MosPrintf(MIL_TEXT(\"Calibration failed for unexpected reasons.\\n\\n\")); break; } pExample-&gt;PauseInStandAloneMode(); // Clear overlay. MbufFree(MilOverlayGreenBand); MdispControl(pExample-&gt;GetMilDisplay(), M_OVERLAY_CLEAR, M_DEFAULT); // Free MIL objects. M3dmapFree(MilCalibScan); // Returns whether the given 3d reconstruction context has been successfully calibrated or not. return CalibrationSuccessful; } //***************************************************************************** // Use diagnostic functionalities to ensure the accuracy of the given 3d // reconstruction context in M_CALIBRATED_CAMERA_LINEAR_MOTION mode. If it is // accurate, return true. //***************************************************************************** bool DiagnoseFullCalibration(CExampleInterface* pExample, MIL_ID MilLaser) { // Clear display and overlay. MbufClear(pExample-&gt;GetMilDisplayImage(), 0.0); MdispControl(pExample-&gt;GetMilDisplay(), M_OVERLAY_CLEAR, M_DEFAULT); // Show fitted lines in red. MgraControl(M_DEFAULT, M_COLOR, M_COLOR_RED); M3dmapDraw(M_DEFAULT, MilLaser, pExample-&gt;GetMilOverlayImage(), M_DRAW_CALIBRATION_LINES, M_DEFAULT, M_DEFAULT); // Show all extracted laser lines in green. MgraControl(M_DEFAULT, M_COLOR, 255.0); MIL_ID MilOverlayGreenBand = MbufChildColor(pExample-&gt;GetMilOverlayImage(), M_GREEN, M_NULL); M3dmapDraw(M_DEFAULT, MilLaser, MilOverlayGreenBand, M_DRAW_CALIBRATION_PEAKS, M_DEFAULT, M_DEFAULT); MbufFree(MilOverlayGreenBand); MosPrintf(MIL_TEXT(\"The laser plane has been fitted on the extracted laser line(s).\\n\") MIL_TEXT(\" Green: extracted laser line(s).\\n\") MIL_TEXT(\" Red: expected line(s) on the fitted laser plane.\\n\\n\")); // Print fit RMS error. MIL_DOUBLE FitRMSError; M3dmapInquire(MilLaser, M_DEFAULT, M_FIT_RMS_ERROR, &amp;FitRMSError); MosPrintf(MIL_TEXT(\"Fit RMS error: %.3g mm\\n\\n\"), FitRMSError); // Ask user if he is satisfied with the calibration. bool CalibrationIsAccurate = pExample-&gt;AskIfLaserCalibrationAccurate(); return CalibrationIsAccurate; } //***************************************************************************** // Use diagnostic functionalities to ensure the accuracy of the given 3d // reconstruction context in M_DEPTH_CORRECTION mode. If it is accurate, // return true. //***************************************************************************** bool DiagnoseDepthCalibration(CExampleInterface* pExample, MIL_ID MilLaser) { // Clear display and overlay. MbufClear(pExample-&gt;GetMilDisplayImage(), 0.0); MdispControl(pExample-&gt;GetMilDisplay(), M_OVERLAY_CLEAR, M_DEFAULT); // Show all different image regions according to their calibration state. MgraControl(M_DEFAULT, M_COLOR, M_COLOR_GREEN); M3dmapDraw(M_DEFAULT, MilLaser, pExample-&gt;GetMilOverlayImage(), M_DRAW_REGION_VALID , M_DEFAULT, M_DEFAULT); MgraControl(M_DEFAULT, M_COLOR, M_COLOR_YELLOW); M3dmapDraw(M_DEFAULT, MilLaser, pExample-&gt;GetMilOverlayImage(), M_DRAW_REGION_INTERPOLATED, M_DEFAULT, M_DEFAULT); MgraControl(M_DEFAULT, M_COLOR, M_COLOR_GRAY); M3dmapDraw(M_DEFAULT, MilLaser, pExample-&gt;GetMilOverlayImage(), M_DRAW_REGION_UNCALIBRATED, M_DEFAULT, M_DEFAULT); MgraControl(M_DEFAULT, M_COLOR, M_COLOR_RED); M3dmapDraw(M_DEFAULT, MilLaser, pExample-&gt;GetMilOverlayImage(), M_DRAW_REGION_MISSING_DATA, M_DEFAULT, M_DEFAULT); MgraControl(M_DEFAULT, M_COLOR, M_COLOR_MAGENTA); M3dmapDraw(M_DEFAULT, MilLaser, pExample-&gt;GetMilOverlayImage(), M_DRAW_REGION_INVERTED , M_DEFAULT, M_DEFAULT); MgraControl(M_DEFAULT, M_COLOR, M_COLOR_WHITE); M3dmapDraw(M_DEFAULT, MilLaser, pExample-&gt;GetMilOverlayImage(), M_DRAW_CALIBRATION_PEAKS , M_DEFAULT, M_DEFAULT); MosPrintf(MIL_TEXT(\"The calibration state of each pixel of the camera image is shown:\\n\") MIL_TEXT(\" Green: Calibrated region (will generate corrected depths)\\n\") MIL_TEXT(\" Gray: Uncalibrated region (will generate missing data)\\n\") MIL_TEXT(\" Cause: outside the region between lowest and highest planes.\\n\") MIL_TEXT(\" Yellow: Interpolated region (will generate less accurate depths)\\n\") MIL_TEXT(\" Cause: some laser line pixels were missed.\\n\") MIL_TEXT(\" Red: Missing calibration data (will generate missing data)\\n\") MIL_TEXT(\" Cause: some laser line pixels were missed on lowest or highest plane.\\n\") MIL_TEXT(\" Magenta: Inversion (could generate erroneous depths)\\n\") MIL_TEXT(\" Cause: some laser line pixels of a lower reference plane were\\n\") MIL_TEXT(\" detected above a higher reference plane.\\n\\n\")); // Print some diagnostic informations. MIL_INT NbColumns = M3dmapInquire(MilLaser, M_DEFAULT, M_NUMBER_OF_COLUMNS , M_NULL); MIL_INT NbColumnsWithMissingData = M3dmapInquire(MilLaser, M_DEFAULT, M_NUMBER_OF_COLUMNS_WITH_MISSING_DATA, M_NULL); MIL_INT NbColumnsWithInversions = M3dmapInquire(MilLaser, M_DEFAULT, M_NUMBER_OF_COLUMNS_WITH_INVERSIONS , M_NULL); MosPrintf(MIL_TEXT(\"Number of columns with missing data: %4d / %d (%.1f%%)\\n\") MIL_TEXT(\"Number of columns with inversions: %4d / %d (%.1f%%)\\n\\n\"), (int)NbColumnsWithMissingData, (int)NbColumns, 100.0*static_cast&lt;MIL_DOUBLE&gt;(NbColumnsWithMissingData)/static_cast&lt;MIL_DOUBLE&gt;(NbColumns), (int)NbColumnsWithInversions, (int)NbColumns, 100.0*static_cast&lt;MIL_DOUBLE&gt;(NbColumnsWithInversions)/static_cast&lt;MIL_DOUBLE&gt;(NbColumns)); // Ask user if he is satisfied with the calibration. bool CalibrationIsAccurate = pExample-&gt;AskIfLaserCalibrationAccurate(); return CalibrationIsAccurate; } ",
      "wordCount": 2666
    },
    {
      "id": "Examples_Processing_3dReconstruction_CameraLaserCalibration_CPP_exampleinterface_cpp",
      "version": "2024020714",
      "title": "exampleinterface.cpp",
      "location": "Sample Code from MIL Examples",
      "text": " Top //*************************************************************************************** // // File name: exampleinterface.cpp // Location: See Matrox Example Launcher in the MIL Control Center // // // Synopsis: Implementation for CExampleInterface (implementation common to subclasses). // // Copyright (C) Matrox Electronic Systems Ltd., 1992-2024. // All Rights Reserved #include &lt;mil.h&gt; #include \"exampleinterface.h\" //***************************************************************************** // Constants. //***************************************************************************** // Set this to 0 if you wish to remove the images pasted in the overlay. #define ENABLE_IMAGES_IN_OVERLAY 1 // File names of images that will be pasted in the overlay. static MIL_CONST_TEXT_PTR const OVERLAY_IMAGE_FILES[] = { EXAMPLE_IMAGE_PATH MIL_TEXT(\"CalibrateCameraImage.mim\"), // corresponds to CExampleInterface::eCalibrateCameraImage EXAMPLE_IMAGE_PATH MIL_TEXT(\"AdjustMinIntensityImage.mim\"), // corresponds to CExampleInterface::eAdjustMinContrastImage EXAMPLE_IMAGE_PATH MIL_TEXT(\"CalibrateLaserImage.mim\") // corresponds to CExampleInterface::eCalibrateLaserImage }; // File name of an image used to frame the images to be pasted in the overlay. static MIL_CONST_TEXT_PTR const FRAME_IMAGE_FILE = EXAMPLE_IMAGE_PATH MIL_TEXT(\"frame.mim\"); // Transparency color of the overlay. static const MIL_DOUBLE DEFAULT_TRANSPARENT_COLOR = M_RGB888(16,0,0); // Transparency color of the frame image. static const MIL_DOUBLE FRAME_TRANSPARENT_COLOR = M_RGB888(227,0,227); // Size of the border in the camera image (used when pasting in the overlay). static const MIL_INT FRAME_BORDER = 5; // in pixels // Maximum ratio of picture to paste in the overlay with respect to camera image size. static const MIL_DOUBLE MAX_PICTURE_RATIO = 0.25; //***************************************************************************** // Constructor. Allocates MIL application, system and display. //***************************************************************************** CExampleInterface::CExampleInterface(MIL_CONST_TEXT_PTR SystemDescriptor, MIL_INT64 BufAttr) : m_BufferAttribute(BufAttr), m_SizeX ( 0 ), m_SizeY ( 0 ), m_OverlayOffsetX ( 0 ), m_OverlayOffsetY ( 0 ), m_CalibrationMode( 0 ), m_MilApplication (M_NULL ), m_MilSystem (M_NULL ), m_MilDisplay (M_NULL ), m_MilDisplayImage(M_NULL ), m_MilOverlayImage(M_NULL ) { // Allocate application. MappAlloc(M_NULL, M_DEFAULT, &amp;m_MilApplication); // Allocate system (SystemDescriptor depends on subclass). MsysAlloc(M_DEFAULT, SystemDescriptor, M_DEFAULT, M_DEFAULT, &amp;m_MilSystem); // Allocate display. MdispAlloc(m_MilSystem, M_DEFAULT, MIL_TEXT(\"M_DEFAULT\"), M_WINDOWED, &amp;m_MilDisplay); for (MIL_INT i = 0 ; i &lt; eNbOverlayImages; i++) { m_MilOverlayPictures[i] = M_NULL; } } //***************************************************************************** // Destructor, free all MIL objects. //***************************************************************************** CExampleInterface::~CExampleInterface() { for (MIL_INT i = 0; i &lt; eNbOverlayImages; ++i) { if (m_MilOverlayPictures[i] != M_NULL) MbufFree(m_MilOverlayPictures[i]); } if (m_MilDisplayImage != M_NULL) MbufFree(m_MilDisplayImage); if (m_MilDisplay != M_NULL) MdispFree(m_MilDisplay); if (m_MilSystem != M_NULL) MsysFree(m_MilSystem); if (m_MilApplication != M_NULL) MappFree(m_MilApplication); } //***************************************************************************** // Prompts the user for the example type to use (will determine which subclass // will be instantiated in main code). //***************************************************************************** bool CExampleInterface::AskInteractiveExample() { MosPrintf(MIL_TEXT(\"You can run this example with images:\\n\") MIL_TEXT(\" 1. Reloaded from disk (STAND-ALONE)\\n\") MIL_TEXT(\" 2. Grabbed using a camera (INTERACTIVE)\\n\\n\") MIL_TEXT(\"Your choice (1 or 2): \")); MIL_INT Choice = 0; while (Choice == 0) { switch (MosGetch()) { case MIL_TEXT('1'): Choice = 1; MosPrintf(MIL_TEXT(\"1. STAND-ALONE\\n\\n\")); break; case MIL_TEXT('2'): Choice = 2; MosPrintf(MIL_TEXT(\"2. INTERACTIVE\\n\\n\")); break; } } bool IsInteractive = (Choice == 2); return IsInteractive; } //***************************************************************************** // Prompts the user for the 3d reconstruction context type to use. //***************************************************************************** MIL_INT CExampleInterface::AskCalibrationMode() { MosPrintf(MIL_TEXT(\"Choose a calibration mode:\\n\") MIL_TEXT(\" 1. M_DEPTH_CORRECTION\\n\") MIL_TEXT(\" 2. M_CALIBRATED_CAMERA_LINEAR_MOTION\\n\\n\") MIL_TEXT(\"Your choice (1 or 2): \")); MIL_INT CalibrationMode = M_NULL; while (CalibrationMode == M_NULL) { switch (MosGetch()) { case MIL_TEXT('1'): CalibrationMode = M_DEPTH_CORRECTION; MosPrintf(MIL_TEXT(\"1. M_DEPTH_CORRECTION\\n\\n\") MIL_TEXT(\"For this calibration mode, the following steps will be executed:\\n\") MIL_TEXT(\" - Setting up the laser line extraction parameters.\\n\") MIL_TEXT(\" - Calibrating the 3d reconstruction setup.\\n\\n\")); break; case MIL_TEXT('2'): CalibrationMode = M_CALIBRATED_CAMERA_LINEAR_MOTION; MosPrintf(MIL_TEXT(\"2. M_CALIBRATED_CAMERA_LINEAR_MOTION\\n\\n\") MIL_TEXT(\"For this calibration mode, the following steps will be executed:\\n\") MIL_TEXT(\" - Calibrating the camera.\\n\") MIL_TEXT(\" - Setting up the laser line extraction parameters.\\n\") MIL_TEXT(\" - Calibrating the 3d reconstruction setup.\\n\\n\")); break; } } MosPrintf(MIL_TEXT(\"Press any key to continue.\\n\\n\")); MosGetch(); m_CalibrationMode = CalibrationMode; return CalibrationMode; } //***************************************************************************** // Show the display window and enables its overlay. If it is the first time the // function is called, the display image will also be allocated. Also, all images // that will be pasted in the overlay are loaded from disk and \"framed\". //***************************************************************************** void CExampleInterface::ShowDisplay() { // Only do this on the first call. if (m_MilDisplayImage == M_NULL) { // Allocate display image (m_BufferAttribute - M_NULL or M_GRAB - depends on subclass). MbufAlloc2d(m_MilSystem, m_SizeX, m_SizeY, 8+M_UNSIGNED, M_IMAGE+M_PROC+M_DISP+m_BufferAttribute, &amp;m_MilDisplayImage); MbufClear(m_MilDisplayImage, 0.0); // Set overlay transparent color. MdispControl(m_MilDisplay, M_TRANSPARENT_COLOR, DEFAULT_TRANSPARENT_COLOR); // Set up images to be pasted in the overlay. // Determine size of the images. MIL_INT PictureSizeX, PictureSizeY; DeterminePictureSize(&amp;PictureSizeX, &amp;PictureSizeY); // Load frame image for overlay and resize it to picture size. MIL_ID MilFrameOriginalImage = MbufRestore(FRAME_IMAGE_FILE, m_MilSystem, M_NULL); MIL_ID MilFrameImage = MbufAllocColor(m_MilSystem, 3, PictureSizeX, PictureSizeY, 8+M_UNSIGNED, M_IMAGE+M_PROC+M_DISP, M_NULL); MimResize(MilFrameOriginalImage, MilFrameImage, M_FILL_DESTINATION, M_FILL_DESTINATION, M_NEAREST_NEIGHBOR); MbufFree(MilFrameOriginalImage); // Load overlay images that will be used later, resize them and frame them. for (MIL_INT i = 0; i &lt; eNbOverlayImages; ++i) { // Load and resize image. MIL_ID MilOriginalImage = MbufRestore(OVERLAY_IMAGE_FILES[i], m_MilSystem, M_NULL); MbufAllocColor(m_MilSystem, 3, PictureSizeX, PictureSizeY, 8+M_UNSIGNED, M_IMAGE+M_PROC+M_DISP, &amp;m_MilOverlayPictures[i]); MimResize(MilOriginalImage, m_MilOverlayPictures[i], M_FILL_DESTINATION, M_FILL_DESTINATION, M_BICUBIC); MbufFree(MilOriginalImage); // Adds the frame to the overlay images. Only pixels that are not transparent are copied. MbufCopyCond(MilFrameImage, m_MilOverlayPictures[i], MilFrameImage, M_NOT_EQUAL, FRAME_TRANSPARENT_COLOR); } // Free the frame image. MbufFree(MilFrameImage); // Precompute position to copy the overlay images (top-right corner of overlay). m_OverlayOffsetX = m_SizeX - PictureSizeX - FRAME_BORDER; m_OverlayOffsetY = FRAME_BORDER; } // Select image to display. MdispSelect(m_MilDisplay, m_MilDisplayImage); // Prepare for overlay annotations. MdispControl(m_MilDisplay, M_OVERLAY, M_ENABLE); MdispInquire(m_MilDisplay, M_OVERLAY_ID, &amp;m_MilOverlayImage); } //***************************************************************************** // Disables the overlay and hide the display window. //***************************************************************************** void CExampleInterface::HideDisplay() { // Disable overlay. m_MilOverlayImage = M_NULL; MdispControl(m_MilDisplay, M_OVERLAY, M_DISABLE); // Hide display. MdispSelect(m_MilDisplay, M_NULL); } //***************************************************************************** // Used in main code to paste an image in the overlay according to the current // action the user should be doing. //***************************************************************************** void CExampleInterface::CopyInOverlay(EOverlayImage eOverlayImage) { #if ENABLE_IMAGES_IN_OVERLAY MbufCopyClip(m_MilOverlayPictures[eOverlayImage], m_MilOverlayImage, m_OverlayOffsetX, m_OverlayOffsetY); #endif } //***************************************************************************** // Used by subclasses to set image size. //***************************************************************************** void CExampleInterface::SetImageSize(MIL_INT SizeX, MIL_INT SizeY) { m_SizeX = SizeX; m_SizeY = SizeY; } //***************************************************************************** // Returns true if MIL objects in the base class have been allocated successfully. //***************************************************************************** bool CExampleInterface::IsValidBase() const { bool IsValid = ( m_MilApplication != M_NULL &amp;&amp; m_MilSystem != M_NULL &amp;&amp; m_MilDisplay != M_NULL ); return IsValid; } //***************************************************************************** // Chooses the size of the images to paste in the overlay according to the // camera image size. //***************************************************************************** void CExampleInterface::DeterminePictureSize(MIL_INT* pPictureSizeX, MIL_INT* pPictureSizeY) const { // Initialize size with actual picture size. MIL_INT PictureSizeX = MbufDiskInquire(FRAME_IMAGE_FILE, M_SIZE_X, M_NULL); MIL_INT PictureSizeY = MbufDiskInquire(FRAME_IMAGE_FILE, M_SIZE_Y, M_NULL); MIL_DOUBLE ResizeFactor = 1.0; // Both PictureSizeX and PictureSizeY must be smaller than 1/4 the camera image size. if (PictureSizeX &gt; m_SizeX * MAX_PICTURE_RATIO) { ResizeFactor = m_SizeX * MAX_PICTURE_RATIO / PictureSizeX; } if (PictureSizeY &gt; m_SizeY * MAX_PICTURE_RATIO) { MIL_DOUBLE ResizeFactorY = m_SizeY * MAX_PICTURE_RATIO / PictureSizeY; if (ResizeFactorY &lt; ResizeFactor) ResizeFactor = ResizeFactorY; } // Fill output variables. *pPictureSizeX = static_cast&lt;MIL_INT&gt;( PictureSizeX * ResizeFactor ); *pPictureSizeY = static_cast&lt;MIL_INT&gt;( PictureSizeY * ResizeFactor ); } ",
      "wordCount": 1078
    },
    {
      "id": "Examples_Processing_3dReconstruction_CameraLaserCalibration_CPP_interactiveexample_cpp",
      "version": "2024020714",
      "title": "interactiveexample.cpp",
      "location": "Sample Code from MIL Examples",
      "text": " Top //*************************************************************************************** // // File name: interactiveexample.cpp // Location: See Matrox Example Launcher in the MIL Control Center // // // Synopsis: Implementation for CInteractiveExample. // // Copyright (C) Matrox Electronic Systems Ltd., 1992-2024. // All Rights Reserved #include &lt;mil.h&gt; #include \"interactiveexample.h\" //***************************************************************************** // Constructor. //***************************************************************************** CInteractiveExample::CInteractiveExample() : CExampleInterface(M_SYSTEM_DEFAULT, M_GRAB), m_MilDigitizer(M_NULL) { // Allocate digitizer. MdigAlloc(GetMilSystem(), M_DEFAULT, MIL_TEXT(\"M_DEFAULT\"), M_DEFAULT, &amp;m_MilDigitizer); if (m_MilDigitizer != M_NULL) { // Get image size from digitizer (from DCF). MIL_INT SizeX = MdigInquire(m_MilDigitizer, M_SIZE_X, M_NULL); MIL_INT SizeY = MdigInquire(m_MilDigitizer, M_SIZE_Y, M_NULL); SetImageSize(SizeX, SizeY); } } //***************************************************************************** // Destructor, free subclass-specific MIL objects. //***************************************************************************** CInteractiveExample::~CInteractiveExample() { if (m_MilDigitizer != M_NULL) MdigFree(m_MilDigitizer); } //***************************************************************************** // Indicates if all MIL objects are initialized correctly. //***************************************************************************** bool CInteractiveExample::IsValid() const { bool IsValid = IsValidBase(); if (m_MilDigitizer == M_NULL) IsValid = false; return IsValid; } //***************************************************************************** // Used to pause the execution in the stand-alone version, does nothing here. //***************************************************************************** void CInteractiveExample::PauseInStandAloneMode() const { // Do nothing in interactive mode. } //***************************************************************************** // Explain how to adjust M_MINIMUM_CONTRAST value. //***************************************************************************** void CInteractiveExample::PrintExplanationForMinContrast() const { MosPrintf(MIL_TEXT(\"Activate the laser line and adjust the camera's aperture (or exposure) to\\n\") MIL_TEXT(\"easily distinguish the laser line from the background. Then, adjust the\\n\") MIL_TEXT(\"minimum contrast value to extract the laser line correctly.\\n\\n\") MIL_TEXT(\"Extracted laser line is displayed in green.\\n\") MIL_TEXT(\"Use '1' and '2' to decrease/increase M_MINIMUM_CONTRAST in increments of 10,\\n\") MIL_TEXT(\"or '4' and '5' to use increments of 1.\\n\") MIL_TEXT(\"Press any key when you are satisfied with the extraction results.\\n\\n\")); } //***************************************************************************** // Adjust M_MINIMUM_CONTRAST value when user use (1,2,4,5). //***************************************************************************** bool CInteractiveExample::AskMinContrastAdjust(MIL_INT* pMinContrast) { const MIL_INT BIG_INCREMENT = 10; const MIL_INT SMALL_INCREMENT = 1; // The while loop is to empty the IO buffer, if necessary. bool AskQuit = false; while (MosKbhit()) { switch (MosGetch()) { case MIL_TEXT('1'): *pMinContrast -= BIG_INCREMENT; break; case MIL_TEXT('2'): *pMinContrast += BIG_INCREMENT; break; case MIL_TEXT('4'): *pMinContrast -= SMALL_INCREMENT; break; case MIL_TEXT('5'): *pMinContrast += SMALL_INCREMENT; break; case MIL_TEXT('\\r'): // any key case MIL_TEXT('\\n'): // any key AskQuit = true; break; } // Bring back M_MINIMUM_CONTRAST in the range [0,255] if (*pMinContrast &lt; 0) *pMinContrast = 0; else if (*pMinContrast &gt; 255) *pMinContrast = 255; } MosPrintf(MIL_TEXT(\"\\rM_MINIMUM_CONTRAST: %3d\"), (int)(*pMinContrast)); return AskQuit; } //***************************************************************************** // Prompts user for yes/no //***************************************************************************** bool CInteractiveExample::AskIfFeatureExtractionAccurate() { return AskYesNo(MIL_TEXT(\"Is the feature extraction accurate (y/n)? \")); } //***************************************************************************** // Prompts user for yes/no //***************************************************************************** bool CInteractiveExample::AskIfCameraCalibrationAccurate() { return AskYesNo(MIL_TEXT(\"Is the camera calibration accurate (y/n)? \")); } //***************************************************************************** // Prompts user for yes/no //***************************************************************************** bool CInteractiveExample::AskIfLineExtractionAccurate() { return AskYesNo(MIL_TEXT(\"Is the laser line extraction accurate (y/n)? \")); } //***************************************************************************** // Prompts user for yes/no //***************************************************************************** bool CInteractiveExample::AskIfLaserCalibrationAccurate() { return AskYesNo(MIL_TEXT(\"Is the calibration of the 3d reconstruction setup accurate (y/n)? \")); } //***************************************************************************** // Checks if there is a camera calibration file present in the current directory. // If so, and if it is a valid camera calibration, asks the user if he wants to // use it instead of calibrating the camera again. //***************************************************************************** MIL_ID CInteractiveExample::TryToReloadCameraCalibration(MIL_CONST_TEXT_PTR CalibrationFileName) const { // This will be the calibration context to return. MIL_ID MilCalibration = M_NULL; // First, let's look if there is a calibration file in local directory. // Try to reload it, and if it works, ask user if he wants it. MappControl(M_DEFAULT, M_ERROR, M_PRINT_DISABLE); McalRestore(CalibrationFileName, GetMilSystem(), M_DEFAULT, &amp;MilCalibration); MappControl(M_DEFAULT, M_ERROR, M_PRINT_ENABLE); if (MilCalibration != M_NULL) { // Calibration context has been reloaded. Verify that it is calibrated in 3d. bool UseReloadedCalibration = false; MIL_INT CalibrationStatus = McalInquire(MilCalibration, M_CALIBRATION_STATUS, M_NULL); MIL_INT CalibrationMode = McalInquire(MilCalibration, M_CALIBRATION_MODE , M_NULL); if ( CalibrationStatus == M_CALIBRATED &amp;&amp; (CalibrationMode == M_TSAI_BASED || CalibrationMode == M_3D_ROBOTICS) ) { // Calibration is appropriate, ask user if he wants to use it. MosPrintf(MIL_TEXT(\"Camera calibration file '\")); MosPrintf(CalibrationFileName); MosPrintf(MIL_TEXT(\"' has been found in the current\\ndirectory. \")); UseReloadedCalibration = AskYesNo(MIL_TEXT(\"Do you want to reload this calibration context (y/n)? \")); } if (!UseReloadedCalibration) { // Calibration is not appropriate or user does not want to use it, so free it. McalFree(MilCalibration); MilCalibration = M_NULL; MosPrintf(SEPARATOR); } } return MilCalibration; } //***************************************************************************** // Grabs continuously until user presses a key. //***************************************************************************** void CInteractiveExample::GrabCalibrationGrid() { MosPrintf(MIL_TEXT(\"Put the 15x16 calibration grid at Z=0 mm.\\n\") MIL_TEXT(\"Press any key to calibrate.\\n\\n\")); MdigGrabContinuous(m_MilDigitizer, GetMilDisplayImage()); MosGetch(); MdigHalt(m_MilDigitizer); } //***************************************************************************** // Grabs a single image. //***************************************************************************** void CInteractiveExample::GrabLaserLineToAdjustContrast() { MdigGrab(m_MilDigitizer, GetMilDisplayImage()); } //***************************************************************************** // Grabs continuously until user presses a key. //***************************************************************************** bool CInteractiveExample::GrabCalibrationLaserLine(MIL_INT ReferencePlaneIndex, MIL_DOUBLE CalibrationDepth, bool ShouldAskIfFinished) { // Prints message according to calibration mode (to account for the minimum number of reference planes to use). MosPrintf(MIL_TEXT(\"Set up the reference plane #%d at Z=%.3g mm.\\n\"), (int)ReferencePlaneIndex, CalibrationDepth); if (ShouldAskIfFinished) MosPrintf(MIL_TEXT(\"Press any key to add this plane, or 's' to stop adding reference planes.\\n\\n\")); else MosPrintf(MIL_TEXT(\"Press any key to add this plane.\\n\\n\")); // Grabs until a key is pressed. MdigGrabContinuous(m_MilDigitizer, GetMilDisplayImage()); MIL_INT UserChar = MosGetch(); MdigHalt(m_MilDigitizer); // If it is possible that there are no more plane AND the user pressed 's', indicates // to caller that we are ready to call M3dmapCalibrate(). bool ReadyToCalibrate = false; if (ShouldAskIfFinished &amp;&amp; (UserChar == MIL_TEXT('s') || UserChar == MIL_TEXT('S'))) { ReadyToCalibrate = true; if (ReferencePlaneIndex == 1) { MosPrintf(MIL_TEXT(\"Since a single reference plane is used, the laser plane is assumed to be\\n\") MIL_TEXT(\"vertical. Press any key to continue.\\n\\n\")); MosGetch(); } } return ReadyToCalibrate; } //***************************************************************************** // Prompts user for yes/no //***************************************************************************** bool CInteractiveExample::AskYesNo(MIL_CONST_TEXT_PTR QuestionString) { MosPrintf(QuestionString); while (true) { switch (MosGetch()) { case MIL_TEXT('y'): case MIL_TEXT('Y'): MosPrintf(MIL_TEXT(\"YES\\n\\n\")); return true; case MIL_TEXT('n'): case MIL_TEXT('N'): MosPrintf(MIL_TEXT(\"NO\\n\\n\")); return false; } } } ",
      "wordCount": 898
    },
    {
      "id": "Examples_Processing_3dReconstruction_CameraLaserCalibration_CPP_standaloneexample_cpp",
      "version": "2024020714",
      "title": "standaloneexample.cpp",
      "location": "Sample Code from MIL Examples",
      "text": " Top //*************************************************************************************** // // File name: standaloneexample.cpp // Location: See Matrox Example Launcher in the MIL Control Center // // // Synopsis: Implementation for CStandAloneExample. // // Copyright (C) Matrox Electronic Systems Ltd., 1992-2024. // All Rights Reserved #include &lt;mil.h&gt; #include \"standaloneexample.h\" //***************************************************************************** // Constants. //***************************************************************************** // File names of calibration grid images used to calibrate the camera. static MIL_CONST_TEXT_PTR const CALIBRATION_GRID_FILES[] = { EXAMPLE_IMAGE_PATH MIL_TEXT(\"CalibrationGrid_notfound.mim\"), EXAMPLE_IMAGE_PATH MIL_TEXT(\"CalibrationGrid_perpendicular.mim\"), EXAMPLE_IMAGE_PATH MIL_TEXT(\"CalibrationGrid_inaccurate.mim\"), EXAMPLE_IMAGE_PATH MIL_TEXT(\"CalibrationGrid_ok.mim\") }; // File name of laser line image used to adjust M_MINIMUM_CONTRAST. static MIL_CONST_TEXT_PTR const LASER_LINE_TO_ADJUST_CONTRAST_FILE = EXAMPLE_IMAGE_PATH MIL_TEXT(\"LineExtract.mim\"); // File names of laser line images used to calibrate a M_DEPTH_CORRECTION // 3d reconstruction context. static MIL_CONST_TEXT_PTR const DEPTH_CALIBRATION_LASER_LINE_FILES[] = { // First M_DEPTH_CORRECTION calibration, with missing data. EXAMPLE_IMAGE_PATH MIL_TEXT(\"Depth_CalibPlane0.mim\"), EXAMPLE_IMAGE_PATH MIL_TEXT(\"Depth_CalibPlane1.mim\"), EXAMPLE_IMAGE_PATH MIL_TEXT(\"Depth_CalibPlane2_missing.mim\"), EXAMPLE_IMAGE_PATH MIL_TEXT(\"Depth_CalibPlane3.mim\"), EXAMPLE_IMAGE_PATH MIL_TEXT(\"Depth_CalibPlane4_missing.mim\"), M_NULL, // indicates that there are no more planes. // Second M_DEPTH_CORRECTION calibration, with inversion. EXAMPLE_IMAGE_PATH MIL_TEXT(\"Depth_CalibPlane0.mim\"), EXAMPLE_IMAGE_PATH MIL_TEXT(\"Depth_CalibPlane1.mim\"), EXAMPLE_IMAGE_PATH MIL_TEXT(\"Depth_CalibPlane2_curved.mim\"), EXAMPLE_IMAGE_PATH MIL_TEXT(\"Depth_CalibPlane3.mim\"), EXAMPLE_IMAGE_PATH MIL_TEXT(\"Depth_CalibPlane4.mim\"), M_NULL, // indicates that there are no more planes. // Third M_DEPTH_CORRECTION calibration, OK. EXAMPLE_IMAGE_PATH MIL_TEXT(\"Depth_CalibPlane0.mim\"), EXAMPLE_IMAGE_PATH MIL_TEXT(\"Depth_CalibPlane1.mim\"), EXAMPLE_IMAGE_PATH MIL_TEXT(\"Depth_CalibPlane2.mim\"), EXAMPLE_IMAGE_PATH MIL_TEXT(\"Depth_CalibPlane3.mim\"), EXAMPLE_IMAGE_PATH MIL_TEXT(\"Depth_CalibPlane4.mim\"), M_NULL // indicates that there are no more planes. }; // File names of laser line images used to calibrate a M_CALIBRATED_CAMERA_LINEAR_MOTION // 3d reconstruction context. static MIL_CONST_TEXT_PTR const FULL_CALIBRATION_LASER_LINE_FILES[] = { // First M_CALIBRATED_CAMERA_LINEAR_MOTION calibration, inaccurate (curved plane). EXAMPLE_IMAGE_PATH MIL_TEXT(\"Full_CalibPlane0_curved.mim\"), M_NULL, // indicates that there are no more planes. // Second M_CALIBRATED_CAMERA_LINEAR_MOTION calibration, inaccurate (one tilted plane). EXAMPLE_IMAGE_PATH MIL_TEXT(\"Full_CalibPlane0.mim\"), EXAMPLE_IMAGE_PATH MIL_TEXT(\"Full_CalibPlane1_tilted.mim\"), EXAMPLE_IMAGE_PATH MIL_TEXT(\"Full_CalibPlane2.mim\"), M_NULL, // indicates that there are no more planes. // Third M_CALIBRATED_CAMERA_LINEAR_MOTION calibration, OK. EXAMPLE_IMAGE_PATH MIL_TEXT(\"Full_CalibPlane0.mim\"), EXAMPLE_IMAGE_PATH MIL_TEXT(\"Full_CalibPlane1.mim\"), EXAMPLE_IMAGE_PATH MIL_TEXT(\"Full_CalibPlane2.mim\"), M_NULL // indicates that there are no more planes. }; // Number of images used to adjust M_MINIMUM_CONTRAST. static const MIL_INT NB_LASER_LINE_TO_ADJUST_MINIMUM_CONTRAST = 3; // Status messages used during M_MINIMUM_CONTRAST adjustment. static MIL_CONST_TEXT_PTR const MINIMUM_CONTRAST_STRINGS[NB_LASER_LINE_TO_ADJUST_MINIMUM_CONTRAST] = { MIL_TEXT(\"The laser line (in green) is not \") MIL_TEXT(\"fully extracted; there are\\ncolumns where the laser line is not detected, as \") MIL_TEXT(\"shown by the missing\\nannotations. This setting is too high.\\n\\n\"), MIL_TEXT(\"The laser line (in green) is\") MIL_TEXT(\"detected at unpredictable positions\\nin columns where the laser line is not\") MIL_TEXT(\"visible. This setting is too low.\\n\\n\"), MIL_TEXT(\"The laser line is fully\\n\") MIL_TEXT(\"and correctly extracted. This setting is just right.\\n\\n\") }; // M_MINIMUM_CONTRAST values to try. static const MIL_INT MINIMUM_CONTRAST_VALUES[NB_LASER_LINE_TO_ADJUST_MINIMUM_CONTRAST] = {204, 5, 100}; // Number of custom messages printed during camera calibration. static const MIL_INT NB_CAMERA_CALIBRATION_STRINGS = 2; // Status messages used during camera calibration. static MIL_CONST_TEXT_PTR const CAMERA_CALIBRATION_STRINGS[NB_CAMERA_CALIBRATION_STRINGS] = { MIL_TEXT(\"Red and green marks are too far apart; the camera calibration is inaccurate\\n\") MIL_TEXT(\"(in this case, the calibration grid is not planar).\\n\") MIL_TEXT(\"A new calibration must be performed.\\n\\n\"), MIL_TEXT(\"The camera calibration is accurate.\\n\\n\") }; // Status messages used during M_DEPTH_CORRECTION 3d reconstruction context calibration, // after each laser line is extracted. static MIL_CONST_TEXT_PTR const DEPTH_LINE_EXTRACTION_STRINGS[] = { // First M_DEPTH_CORRECTION calibration, with missing data. MIL_TEXT(\"\"), MIL_TEXT(\"\"), MIL_TEXT(\"The gap in the laser line will result in more inaccuracies in that region.\\n\\n\"), MIL_TEXT(\"\"), MIL_TEXT(\"Since this is the highest reference plane, the gap in the laser line will\\n\") MIL_TEXT(\"reduce the calibrated region, resulting in more missing data.\\n\\n\"), // Second M_DEPTH_CORRECTION calibration, with inversion. MIL_TEXT(\"\"), MIL_TEXT(\"\"), MIL_TEXT(\"This reference surface is not planar. Moreover, note that in some columns\\n\") MIL_TEXT(\"the laser line will appear higher than for the next reference plane.\\n\\n\"), MIL_TEXT(\"In some columns the laser line is lower than its position for the previous\\n\") MIL_TEXT(\"plane: this will result in an inaccurate calibration.\\n\\n\"), MIL_TEXT(\"\"), MIL_TEXT(\"\"), // Third M_DEPTH_CORRECTION calibration, OK. MIL_TEXT(\"\"), MIL_TEXT(\"\"), MIL_TEXT(\"\"), MIL_TEXT(\"\"), MIL_TEXT(\"\") }; // Number of loop iterations to calibrate the M_DEPTH_CORRECTION 3d reconstruction context. static const MIL_INT NB_DEPTH_LASER_CALIBRATIONS = 3; // Status messages used during M_DEPTH_CORRECTION 3d reconstruction context calibration, // indicating if the resulting calibration is accurate or not. static MIL_CONST_TEXT_PTR const DEPTH_LASER_CALIBRATION_STRINGS[NB_DEPTH_LASER_CALIBRATIONS] = { MIL_TEXT(\"The calibration of the 3d reconstruction setup is inaccurate because there are\\n\") MIL_TEXT(\"missing data in planes #2 and #4. A new calibration must be performed.\\n\\n\"), MIL_TEXT(\"The calibration of the 3d reconstruction setup is inaccurate because, for some\\n\") MIL_TEXT(\"columns, the laser line of plane #2 appears higher than the laser line\\n\") MIL_TEXT(\"of plane #3. A new calibration must be performed.\\n\\n\"), MIL_TEXT(\"The calibration of the 3d reconstruction setup is accurate.\\n\\n\") }; // Status messages used during M_CALIBRATED_CAMERA_LINEAR_MOTION 3d reconstruction context // calibration, after each laser line is extracted. static MIL_CONST_TEXT_PTR const FULL_LINE_EXTRACTION_STRINGS[] = { // First M_CALIBRATED_CAMERA_LINEAR_MOTION calibration, inaccurate (curved plane). MIL_TEXT(\"The laser line is extracted accurately, but it will result in an inaccurate\\n\") MIL_TEXT(\"calibration because the reference surface is not a plane at Z=0 mm.\\n\\n\"), // Second M_CALIBRATED_CAMERA_LINEAR_MOTION calibration, inaccurate (one tilted plane). MIL_TEXT(\"\"), MIL_TEXT(\"The laser line is extracted accurately, but will result in an inaccurate\\n\") MIL_TEXT(\"calibration because the reference surface is not a horizontal plane at\\n\") MIL_TEXT(\"Z=-12 mm.\\n\\n\"), MIL_TEXT(\"\"), // Third M_CALIBRATED_CAMERA_LINEAR_MOTION calibration, OK. MIL_TEXT(\"\"), MIL_TEXT(\"\"), MIL_TEXT(\"\") }; // Number of loop iterations to calibrate the M_CALIBRATED_CAMERA_LINEAR_MOTION 3d reconstruction context. static const MIL_INT NB_FULL_LASER_CALIBRATIONS = 3; // Status messages used during M_CALIBRATED_CAMERA_LINEAR_MOTION 3d reconstruction context // calibration, indicating if the resulting calibration is accurate or not. static MIL_CONST_TEXT_PTR const FULL_LASER_CALIBRATION_STRINGS[] = { MIL_TEXT(\"The calibration of the 3d reconstruction setup is inaccurate: the reference\\n\") MIL_TEXT(\"surface must be a plane at the expected height and in this case, the surface\\n\") MIL_TEXT(\"is not planar. A new calibration must be performed.\\n\\n\"), MIL_TEXT(\"The calibration of the 3d reconstruction setup is inaccurate: the reference\\n\") MIL_TEXT(\"surfaces must be planes at expected heights and in this case, the reference\\n\") MIL_TEXT(\"plane #1 is not parallel to the others. A new calibration must be performed.\\n\\n\"), MIL_TEXT(\"The calibration of the 3d reconstruction setup is accurate.\\n\\n\") }; bool CheckForRequiredMILFile(MIL_CONST_TEXT_PTR FileName); //***************************************************************************** // Constructor. //***************************************************************************** CStandAloneExample::CStandAloneExample() : CExampleInterface(M_SYSTEM_HOST, M_NULL), // M_NULL =&gt; no need for M_GRAB m_CalibrationGridCounter (0), m_LaserLineToAdjustContrastCounter(0), m_CalibrationLaserLineCounter (0), m_CameraCalibrationCounter (0), m_LineExtractionCounter (0), m_LaserCalibrationCounter (0) { if(!CheckForRequiredMILFile(CALIBRATION_GRID_FILES[0])) { return; } // Get image size from calibration grid image file. MIL_INT SizeX = MbufDiskInquire(CALIBRATION_GRID_FILES[0], M_SIZE_X, M_NULL); MIL_INT SizeY = MbufDiskInquire(CALIBRATION_GRID_FILES[0], M_SIZE_Y, M_NULL); SetImageSize(SizeX, SizeY); MosPrintf(MIL_TEXT(\"This example shows each step of a 3d reconstruction setup calibration.\\n\") MIL_TEXT(\"For each step, examples of failed and inaccurate calibrations will be shown,\\n\") MIL_TEXT(\"and the diagnosis steps will be explained.\\n\\n\")); } //***************************************************************************** // Destructor. //***************************************************************************** CStandAloneExample::~CStandAloneExample() { } //***************************************************************************** // Indicates if all MIL objects are initialized correctly. //***************************************************************************** bool CStandAloneExample::IsValid() const { return (IsValidBase() &amp;&amp; CExampleInterface::m_SizeX &gt; 0); } //***************************************************************************** // Used to pause the execution in the stand-alone version. //***************************************************************************** void CStandAloneExample::PauseInStandAloneMode() const { MosPrintf(MIL_TEXT(\"Press any key to continue.\\n\\n\")); MosGetch(); } //***************************************************************************** // Explain how to adjust M_MINIMUM_CONTRAST value. //***************************************************************************** void CStandAloneExample::PrintExplanationForMinContrast() const { MosPrintf(MIL_TEXT(\"The minimum contrast value must be adjusted to extract the laser line\\n\") MIL_TEXT(\"correctly.\\n\\n\")); } //***************************************************************************** // Choose a value of M_MINIMUM_CONTRAST and explain the consequences (according to // iteration). The function returns true at the last iteration. //***************************************************************************** bool CStandAloneExample::AskMinContrastAdjust(MIL_INT* pMinContrast) { *pMinContrast = MINIMUM_CONTRAST_VALUES[m_LaserLineToAdjustContrastCounter]; MosPrintf(MIL_TEXT(\"In this image, M_MINIMUM_CONTRAST is set to %d. \\n\"), (int)(*pMinContrast)); MosPrintf(MINIMUM_CONTRAST_STRINGS[m_LaserLineToAdjustContrastCounter]); bool AskQuit = (m_LaserLineToAdjustContrastCounter == NB_LASER_LINE_TO_ADJUST_MINIMUM_CONTRAST-1); ++m_LaserLineToAdjustContrastCounter; return AskQuit; } //***************************************************************************** // Returns true if laser line extraction is assumed to be accurate. //***************************************************************************** bool CStandAloneExample::AskIfFeatureExtractionAccurate() { return true; // Assume laser line extraction is always accurate. } //***************************************************************************** // Tells if the camera calibration is accurate or not, and why (according to // iteration). Returns true if it is accurate. //***************************************************************************** bool CStandAloneExample::AskIfCameraCalibrationAccurate() { MosPrintf(CAMERA_CALIBRATION_STRINGS[m_CameraCalibrationCounter]); bool Answer = (m_CameraCalibrationCounter == NB_CAMERA_CALIBRATION_STRINGS-1); ++m_CameraCalibrationCounter; return Answer; } //***************************************************************************** // Prints informational message on laser line extraction (according to // iteration). Returns true if laser line extraction is assumed to be // accurate. //***************************************************************************** bool CStandAloneExample::AskIfLineExtractionAccurate() { if (GetCalibrationMode() == M_DEPTH_CORRECTION) MosPrintf(DEPTH_LINE_EXTRACTION_STRINGS[m_LineExtractionCounter]); else MosPrintf(FULL_LINE_EXTRACTION_STRINGS[m_LineExtractionCounter]); ++m_LineExtractionCounter; return true; // Assume laser line extraction is always accurate. } //***************************************************************************** // Tells if the camera calibration is accurate or not, and why (according to // iteration). Returns true if it is accurate. //***************************************************************************** bool CStandAloneExample::AskIfLaserCalibrationAccurate() { bool Answer; if (GetCalibrationMode() == M_DEPTH_CORRECTION) { MosPrintf(DEPTH_LASER_CALIBRATION_STRINGS[m_LaserCalibrationCounter]); Answer = (m_LaserCalibrationCounter == NB_DEPTH_LASER_CALIBRATIONS-1); } else { MosPrintf(FULL_LASER_CALIBRATION_STRINGS[m_LaserCalibrationCounter]); Answer = (m_LaserCalibrationCounter == NB_FULL_LASER_CALIBRATIONS-1); } ++m_LaserCalibrationCounter; return Answer; } //***************************************************************************** // Stub function, useful only in interactive mode. //***************************************************************************** MIL_ID CStandAloneExample::TryToReloadCameraCalibration(MIL_CONST_TEXT_PTR CalibrationFileName) const { // Never reload a camera calibration in stand-alone mode. return M_NULL; } //***************************************************************************** // Reloads image used for camera calibration (according to iteration). //***************************************************************************** void CStandAloneExample::GrabCalibrationGrid() { MosPrintf(MIL_TEXT(\"The calibration grid is placed at Z=0 mm.\\n\\n\")); MbufLoad(CALIBRATION_GRID_FILES[m_CalibrationGridCounter++], GetMilDisplayImage()); } //***************************************************************************** // Reloads image used to adjust M_MINIMUM_CONTRAST. //***************************************************************************** void CStandAloneExample::GrabLaserLineToAdjustContrast() { MbufLoad(LASER_LINE_TO_ADJUST_CONTRAST_FILE, GetMilDisplayImage()); } //***************************************************************************** // Reloads image used for 3d reconstruction context calibration, according to // iteration. If there are no more plane, the function returns true. //***************************************************************************** bool CStandAloneExample::GrabCalibrationLaserLine(MIL_INT ReferencePlaneIndex, MIL_DOUBLE CalibrationDepth, bool ShouldAskIfFinished) { MIL_CONST_TEXT_PTR CalibrationLaserLineFile; if (GetCalibrationMode() == M_DEPTH_CORRECTION) CalibrationLaserLineFile = DEPTH_CALIBRATION_LASER_LINE_FILES[m_CalibrationLaserLineCounter]; else CalibrationLaserLineFile = FULL_CALIBRATION_LASER_LINE_FILES[m_CalibrationLaserLineCounter]; ++m_CalibrationLaserLineCounter; bool ReadyToCalibrate; if (CalibrationLaserLineFile != M_NULL) { MosPrintf(MIL_TEXT(\"Reference plane #%d is expected to be at Z=%.3g mm.\\n\\n\"), (int)ReferencePlaneIndex, CalibrationDepth); MbufLoad(CalibrationLaserLineFile, GetMilDisplayImage()); ReadyToCalibrate = false; } else { ReadyToCalibrate = true; } return ReadyToCalibrate; } //**************************************************************************** // Check for required files to run the example. //**************************************************************************** bool CheckForRequiredMILFile(MIL_CONST_TEXT_PTR FileName) { MIL_INT FilePresent; MappFileOperation(M_DEFAULT, FileName, M_NULL, M_NULL, M_FILE_EXISTS, M_DEFAULT, &amp;FilePresent); if(FilePresent == M_NO) { MosPrintf(MIL_TEXT(\"\\n\") MIL_TEXT(\"The file needed to run this example is missing. You need \\n\") MIL_TEXT(\"to obtain and apply a separate specific update to have it.\\n\\n\")); MosPrintf(MIL_TEXT(\"Press any key to end.\\n\\n\")); MosGetch(); } return (FilePresent == M_YES); } ",
      "wordCount": 1520
    }
  ]
}]
[{
  "id": "Example_PlaceHolder_ID",
  "version": "2024020714",
  "title": "Example_PlaceHolder_Title",
  "wordCount": 0,
  "subEntries": [
    {
      "id": "Examples_Processing_3dMeasurement_3dMeasOverview_CPP_3dmeasoverview_cpp",
      "version": "2024020714",
      "title": "3dmeasoverview.cpp",
      "location": "Sample Code from MIL Examples",
      "text": " Top //*************************************************************************************** // // File name: 3dMeasOverview.cpp // Location: See Matrox Example Launcher in the MIL Control Center // // // Synopsis: This example demonstrates how to use the 3dmeas module to locate single or // multiple tansitions in 3D depth maps. The example also shows how // transitions found along a provided template can be fitted into a measured // geometry. A simple profiling example is presented first, showing how to find // transitions directly from depth map rows which represent a collection of // profiles. Secondly, an example will show how one or multiple transitions can // be found along a path, illustrating the various parameters that can be tuned // to control how the profile to analyze is generated from the path. Finally, // a demonstration will show how to find and fit a segment on transitions // along a given reference template. // // Copyright (C) Matrox Electronic Systems Ltd., 1992-2024. // All Rights Reserved //*************************************************************************************** #include \"Util.h\" #include \"../../../3dUtil/C++/Display3dLinker.h\" //*************************************************************************************** // Example files. //*************************************************************************************** static const MIL_STRING PROFILE_OBJECT = M_IMAGE_PATH MIL_TEXT(\"3dMeasOverview/ProfileReferenceObject.mim\"); static const MIL_STRING PROFILE_DEPTH_MAP = M_IMAGE_PATH MIL_TEXT(\"3dMeasOverview/ProfileDepthMap.mim\"); static const MIL_STRING PATH_DEPTH_MAP = M_IMAGE_PATH MIL_TEXT(\"3dMeasOverview/PathDepthMap.mim\"); static const MIL_STRING TEMPLATE_DEPTH_MAP = M_IMAGE_PATH MIL_TEXT(\"3dMeasOverview/TemplateDepthMap.mim\"); //*************************************************************************************** // Constants. //*************************************************************************************** // Profile example constants. static const MIL_INT PROFILE_DISP_3D_SIZE_X = 640; static const MIL_INT PROFILE_DISP_ZOOM_X = 3; static const MIL_INT PROFILE_DISP_ZOOM_Y = 20; static const MIL_DOUBLE PROFILE_GAP_THRESHOLDS[] = {0, 5, 75}; // Path example constants. static const MIL_INT PATH_DISP_3D_SIZE_X = 770; static const MIL_INT PATH_DISP_ZOOM_X = 2; static const MIL_INT PATH_DISP_ZOOM_Y = 2; static const MIL_INT PATH_DEPTH_MAP_OPACITY = 10; static const MIL_INT PATH_PROFILE_DRAW_THICKNESS = 3; static const MIL_DOUBLE PATH_PROFILE_THICKNESS[] = {5, 15}; static const MIL_DOUBLE PATH_MIN_VALID_PERCENTAGE[] = {80, 40, 0}; static const MIL_DOUBLE PATH_GAP_THRESHOLD = 10; static const MIL_DOUBLE PATH_SHARP_DEPTH = 10; static const MIL_DOUBLE PATH_SAMPLE_SIZES[] = {3, 0.25}; static const MIL_DOUBLE PATH_PROFILE_FILTER_SMOOTHNESS = 95; // Template example constants. static const MIL_INT TEMPLATE_DISP_3D_SIZE_X = 640; static const MIL_INT TEMPLATE_DISP_ZOOM_X = 3; static const MIL_INT TEMPLATE_DISP_ZOOM_Y = 3; static const MIL_DOUBLE TEMPLATE_PROF_LENGTH = 10; static const MIL_DOUBLE TEMPLATE_PROF_NUMBER = 5; static const MIL_DOUBLE TEMPLATE_PROF_THICKNESS[] = {1, 25}; static const MIL_DOUBLE TEMPLATE_PROF_SPACING[] = {1.0, 0.5, 2.0}; static const MIL_DOUBLE TEMPLATE_PROF_POS_REL[] = {0, -40, 40}; static const MIL_DOUBLE TEMPLATE_SINGLE_NUMBER = 6; static const MIL_DOUBLE TEMPLATE_SINGLE_LENGTH = 20; static const MIL_DOUBLE TEMPLATE_SINGLE_POS_REL = -20; static const MIL_DOUBLE TEMPLATE_STRENGTH_MIN_VAR = 8; static const MIL_DOUBLE TEMPLATE_FIT_DISTANCE = 3; static const MIL_INT NB_CASES = 3; //*************************************************************************************** // Function declaration. //*************************************************************************************** MIL_UNIQUE_3DDISP_ID Alloc3dDisplayId(MIL_ID MilSystem); bool CheckForRequiredMILFile(MIL_STRING FileName); bool ProfileExample(MIL_ID MilSystem); bool PathExample(MIL_ID MilSystem); bool TemplateExample(MIL_ID MilSystem); void DrawContext(MIL_ID MilContext, SDisplays&amp; Display, MIL_INT ObjectIndex, MIL_INT DrawTemplateOrPath); void DrawResult(MIL_ID MilResult, MIL_INT ObjectIndex, MIL_ID MilDrawContext, SDisplays&amp; Display, MIL_INT DrawOperations); void FindMarkersAndDraw(MIL_ID MilContext, MIL_ID MilDepthMap, MIL_ID MilResult, MIL_ID MilDrawContext, SDisplays&amp; Display, const SNamedControlList&amp; ControlList, MIL_INT DrawOperations); void FitMarkersAndDraw(MIL_ID MilFitContext, MIL_ID MilFindContext, MIL_ID MilDepthMap, MIL_ID MilResult, MIL_ID MilDrawContext, SDisplays&amp; Display, const SNamedControlList&amp; ControlList, MIL_INT DrawOperations); //*************************************************************************************** // Example description. //*************************************************************************************** void PrintHeader() { MosPrintf(MIL_TEXT(\"[EXAMPLE NAME]\\n\")); MosPrintf(MIL_TEXT(\"3dMeasOverview\\n\\n\")); MosPrintf(MIL_TEXT(\"[SYNOPSIS]\\n\")); MosPrintf(MIL_TEXT(\"This example demonstrates how to use the 3dmeas module to locate\\n\") MIL_TEXT(\"single or multiple transitions in 3d depth map data. The example\\n\") MIL_TEXT(\"also shows how transitions found along a provided template can be\\n\") MIL_TEXT(\"fitted into a measured geometry. A simple profiling example is\\n\") MIL_TEXT(\"presented first, showing how to find transitions directly from\\n\") MIL_TEXT(\"depth map rows which represent a collection of profiles.\\n\") MIL_TEXT(\"Secondly, an example will show how one or multiple transitions can\\n\") MIL_TEXT(\"be found along a path, illustrating the various parameters that\\n\") MIL_TEXT(\"can be tuned to control how the profile to analyze is generated\\n\") MIL_TEXT(\"from the path. Finally, an example will show how to find and fit\\n\") MIL_TEXT(\"a segment on transitions along a given reference template.\\n\\n\")); MosPrintf(MIL_TEXT(\"[MODULES USED]\\n\")); MosPrintf(MIL_TEXT(\"Modules used: Application, System, Buffer, Graphics,\\n\") MIL_TEXT(\"3D Measurement, 3D Geometry, 3D Display, and 3D Graphics.\\n\\n\")); } //*************************************************************************************** // Main. //*************************************************************************************** int MosMain() { // Print Header. PrintHeader(); // Allocate MIL objects. auto MilApplication = MappAlloc(M_NULL, M_DEFAULT, M_UNIQUE_ID); auto MilSystem = MsysAlloc(M_DEFAULT, M_SYSTEM_HOST, M_DEFAULT, M_DEFAULT, M_UNIQUE_ID); // Check for the required example files. if(!CheckForRequiredMILFile(PROFILE_OBJECT)) return EXIT_FAILURE; // Run the profile example. MosPrintf(MIL_TEXT(\"--------------------------- Profile example ---------------------------\\n\\n\")); if(!ProfileExample(MilSystem)) return EXIT_FAILURE; // Run the path example. MosPrintf(MIL_TEXT(\"---------------------------- Path example -----------------------------\\n\\n\")); if(!PathExample(MilSystem)) return EXIT_FAILURE; // Run the template example. MosPrintf(MIL_TEXT(\"-------------------------- Template example ---------------------------\\n\\n\")); if(!TemplateExample(MilSystem)) return EXIT_FAILURE; } //*************************************************************************************** // Runs the example of extracting the transitions in a depth map by treating each row // as a profile to process. //*************************************************************************************** bool ProfileExample(MIL_ID MilSystem) { // Restore the reference object depth map. auto MilReferenceObject = MbufImport(PROFILE_OBJECT, M_MIL_TIFF + M_WITH_CALIBRATION, M_RESTORE, MilSystem, M_UNIQUE_ID); // Restore the depth map representing the object's profiles. auto MilProfilesDepthMap = MbufImport(PROFILE_DEPTH_MAP, M_MIL_TIFF + M_WITH_CALIBRATION, M_RESTORE, MilSystem, M_UNIQUE_ID); // Get the size of the displayed profile image. auto ProfileImageSizeY = MbufInquire(MilProfilesDepthMap, M_SIZE_Y, M_NULL); auto ProfileDisplaySizeY = ProfileImageSizeY * PROFILE_DISP_ZOOM_Y; // Setup the displays. SDisplays AllDisplays[NB_CASES]; std::vector&lt;MIL_ID&gt; Display3dIds(NB_CASES); for(MIL_INT d = 0; d &lt; NB_CASES; d++) { SDisplays&amp; Display = AllDisplays[d]; MIL_INT DisplayOffsetY = d * (ProfileDisplaySizeY + WINDOW_OFFSET); if(!Display.Alloc(MilSystem, TEMPLATE_DISP_3D_SIZE_X, ProfileDisplaySizeY, DisplayOffsetY)) return false; Display3dIds[d] = Display.MilDisplay3d; Display.SetupDisplay(MIL_TEXT(\"ProfileReferenceObject\"), MIL_TEXT(\"ProfileDepthMap\")); // Disable the updates. Display.DisableUpdate(); // Select the reference object on the 3D display. Display.SelectDepthMap3d(MilReferenceObject); M3ddispSetView(Display.MilDisplay3d, M_AUTO, M_BOTTOM_TILTED, M_DEFAULT, M_DEFAULT, M_DEFAULT); M3ddispSetView(Display.MilDisplay3d, M_AZIMUTH, 315, M_DEFAULT, M_DEFAULT, M_DEFAULT); // Select the profile depth map on both the 3D and 2D display. auto ProfilesLabel = M3ddispSelect(Display.MilDisplay3d, MilProfilesDepthMap, M_ADD, M_DEFAULT); M3dgraControl(Display.MilGraList3d, ProfilesLabel, M_COLOR_COMPONENT, M_NULL); MdispZoom(Display.MilDisplay2d, PROFILE_DISP_ZOOM_X, PROFILE_DISP_ZOOM_Y); MdispSelect(Display.MilDisplay2d, MilProfilesDepthMap); // Do not show the extra displays. if(d != 0) Display.Hide(); // Enable the updates. Display.EnableUpdate(); } // Synchronize the displays. CDisplayLinker DisplayLinker(Display3dIds); // Print the example description. MosPrintf(MIL_TEXT(\"A point cloud depicting a complete object is displayed along with a\\n\") MIL_TEXT(\"depth map representing profiles of that object. All transitions\\n\") MIL_TEXT(\"will be extracted from the profiles with default settings.\\n\\n\")); WaitForKey(); // Allocate a 3dmeas draw context. auto MilDrawContext = M3dmeasAlloc(MilSystem, M_DRAW_3D_PROFILE_CONTEXT, M_DEFAULT, M_UNIQUE_ID); M3dmeasControlDraw(MilDrawContext, M_DRAW_PROFILE_EXTRACTED, M_ACTIVE, M_ENABLE); // Allocate profile context and result. SNamedControlList FindControls = {M_DEFAULT_TEMPLATE}; auto MilContext = M3dmeasAlloc(MilSystem, M_FIND_MARKER_PROFILE_CONTEXT, M_DEFAULT, M_UNIQUE_ID); auto MilResult = M3dmeasAllocResult(MilSystem, M_FIND_MARKER_PROFILE_RESULT, M_DEFAULT, M_UNIQUE_ID); // Select the draw operations. MIL_INT DrawOperations = M_DRAW_TEMPLATE + M_DRAW_PROFILE_REGION_DIRECTION + M_DRAW_MARKERS; // Find all markers with any polarity. FindControls.Controls = {CDEF(M_MARKER_NUMBER, M_ALL), CDEF(M_MARKER_POLARITY, M_ANY)}; FindMarkersAndDraw(MilContext, MilProfilesDepthMap, MilResult, MilDrawContext, AllDisplays[0], FindControls, DrawOperations); // Find all markers with positive polarity. FindControls.Controls = {CDEF(M_MARKER_POLARITY, M_POSITIVE)}; FindMarkersAndDraw(MilContext, MilProfilesDepthMap, MilResult, MilDrawContext, AllDisplays[1], FindControls, DrawOperations); // Find all markers with negative polarity. FindControls.Controls = {CDEF(M_MARKER_POLARITY, M_NEGATIVE)}; FindMarkersAndDraw(MilContext, MilProfilesDepthMap, MilResult, MilDrawContext, AllDisplays[2], FindControls, DrawOperations); MosPrintf(MIL_TEXT(\"The polarity of the transitions can be specified.\\n\")); MosPrintf(MIL_TEXT(\"Displayed are the M_ANY, M_POSITIVE, and M_NEGATIVE transitions.\\n\\n\")); WaitForKey(); // Find the strongest marker. FindControls.Controls = {CDEF(M_MARKER_NUMBER, 1), CDEF(M_MARKER_POLARITY, M_ANY), CDEF(M_MARKER_SELECTION, M_STRONGEST)}; FindMarkersAndDraw(MilContext, MilProfilesDepthMap, MilResult, MilDrawContext, AllDisplays[0], FindControls, DrawOperations); // Find the first marker. FindControls.Controls = {CDEF(M_MARKER_SELECTION, M_POSITION_FIRST)}; FindMarkersAndDraw(MilContext, MilProfilesDepthMap, MilResult, MilDrawContext, AllDisplays[1], FindControls, DrawOperations); // Find the last marker. FindControls.Controls = {CDEF(M_MARKER_SELECTION, M_POSITION_LAST)}; FindMarkersAndDraw(MilContext, MilProfilesDepthMap, MilResult, MilDrawContext, AllDisplays[2], FindControls, DrawOperations); MosPrintf(MIL_TEXT(\"It is possible to limit the number of transitions.\\n\")); MosPrintf(MIL_TEXT(\"Some selection policies are available to choose which transition\\n\")); MosPrintf(MIL_TEXT(\"to return if there are more possibilities than requested.\\n\")); MosPrintf(MIL_TEXT(\"Displayed are markers found with the M_STRONGEST,\\n\")); MosPrintf(MIL_TEXT(\"M_POSITION_FIRST and M_POSITION_LAST selections, separately.\\n\\n\")); WaitForKey(); // Apply generic controls for this case. FindControls.Controls = {CDEF(M_MARKER_SELECTION, M_DEFAULT), CVAL(M_MARKER_NUMBER, M_ALL)}; FindControls.ApplyControls(MilContext); // Find all edge markers. FindControls.Controls = {CDEF(M_MARKER_TRANSITION, M_EDGE)}; FindMarkersAndDraw(MilContext, MilProfilesDepthMap, MilResult, MilDrawContext, AllDisplays[0], FindControls, DrawOperations); // Find all invalid markers. FindControls.Controls = {CDEF(M_MARKER_TRANSITION, M_INVALID)}; FindMarkersAndDraw(MilContext, MilProfilesDepthMap, MilResult, MilDrawContext, AllDisplays[1], FindControls, DrawOperations); // Find all edge or invalid markers. FindControls.Controls = {CDEF(M_MARKER_TRANSITION, M_EDGE_OR_INVALID)}; FindMarkersAndDraw(MilContext, MilProfilesDepthMap, MilResult, MilDrawContext, AllDisplays[2], FindControls, DrawOperations); MosPrintf(MIL_TEXT(\"The type of transitions can also be specified.\\n\")); MosPrintf(MIL_TEXT(\"Displayed are all markers found with the M_EDGE, M_INVALID,\\n\")); MosPrintf(MIL_TEXT(\"and M_EDGE_OR_INVALID transitions.\\n\\n\")); WaitForKey(); // Find all edge markers without any gap filling. FindControls.Controls = {CDEF(M_MARKER_TRANSITION, M_EDGE), CVAL(M_PROFILE_GAP_FILL_THRESHOLD, PROFILE_GAP_THRESHOLDS[0])}; FindMarkersAndDraw(MilContext, MilProfilesDepthMap, MilResult, MilDrawContext, AllDisplays[0], FindControls, DrawOperations); // Find all edge markers with small gap filling. FindControls.Controls = {CVAL(M_PROFILE_GAP_FILL_THRESHOLD, PROFILE_GAP_THRESHOLDS[1])}; FindMarkersAndDraw(MilContext, MilProfilesDepthMap, MilResult, MilDrawContext, AllDisplays[1], FindControls, DrawOperations); // Find all edge markers with some large gap filling. FindControls.Controls = {CVAL(M_PROFILE_GAP_FILL_THRESHOLD, PROFILE_GAP_THRESHOLDS[2])}; FindMarkersAndDraw(MilContext, MilProfilesDepthMap, MilResult, MilDrawContext, AllDisplays[2], FindControls, DrawOperations); MosPrintf(MIL_TEXT(\"It is possible to enable some gap filling to fill missing data\\n\")); MosPrintf(MIL_TEXT(\"gaps in the profile.\\n\")); MosPrintf(MIL_TEXT(\"Displays are all markers found with filled gaps with sizes less than\\n\")); for(MIL_INT i = 0; i &lt; NB_CASES; ++i) { MosPrintf(MIL_TEXT(\"%.1f\"), PROFILE_GAP_THRESHOLDS[i]); if(PROFILE_GAP_THRESHOLDS[i] == 0) { MosPrintf(MIL_TEXT(\" (i.e. no gap filling)\")); } MosPrintf(MIL_TEXT(\", \")); if(i == NB_CASES - 2) MosPrintf(MIL_TEXT(\"and \")); } MosPrintf(MIL_TEXT(\"respectively.\\n\\n\")); WaitForKey(); return true; } //*************************************************************************************** // Runs the example that finds transitions along a path defined by a geometry. //*************************************************************************************** bool PathExample(MIL_ID MilSystem) { // Restore the depth map. auto MilDepthMap = MbufImport(PATH_DEPTH_MAP, M_MIL_TIFF + M_WITH_CALIBRATION, M_RESTORE, MilSystem, M_UNIQUE_ID); // Get the size of the displayed depth map image. auto DepthMapSizeY = MbufInquire(MilDepthMap, M_SIZE_Y, M_NULL); auto DepthMapDispSizeY = DepthMapSizeY * PATH_DISP_ZOOM_Y; // Allocate path context and result. SNamedControlList FindControls = {M_PATH_INDEX(0)}; auto MilContext = M3dmeasAlloc(MilSystem, M_FIND_MARKER_PATH_CONTEXT, M_DEFAULT, M_UNIQUE_ID); auto MilResult = M3dmeasAllocResult(MilSystem, M_FIND_MARKER_PATH_RESULT, M_DEFAULT, M_UNIQUE_ID); // Allocate and define the line geometry that represents the path. auto MilPathGeo = M3dgeoAlloc(MilSystem, M_GEOMETRY, M_DEFAULT, M_UNIQUE_ID); M3dgeoLine(MilPathGeo, M_TWO_POINTS, -38.34, -124.61, -30, 43.41, -126.61, -30, M_DEFAULT, M_DEFAULT); M3dmeasDefine(MilContext, MilPathGeo, M_DEFAULT, M_DEFAULT, M_ADD, M_DEFAULT, M_EDGE_OR_INVALID, M_DEFAULT, M_DEFAULT, M_DEFAULT, M_DEFAULT, M_NULL, M_DEFAULT); // Allocate a 3dmeas draw context. auto MilDrawContext = M3dmeasAlloc(MilSystem, M_DRAW_3D_PATH_CONTEXT, M_DEFAULT, M_UNIQUE_ID); M3dmeasControlDraw(MilDrawContext, M_DRAW_MARKERS, M_COLOR, M_COLOR_DARK_GREEN); // Allocate a single 3D graphic list for the depth map. auto MilDepthMapGraList = M3dgraAlloc(MilSystem, M_DEFAULT, M_UNIQUE_ID); auto DepthMapLabel = M3dgraAdd(MilDepthMapGraList, M_DEFAULT, MilDepthMap, M_NO_LINK); SetupColorMap(MilDepthMapGraList); // Setup the displays. SDisplays AllDisplays[NB_CASES]; std::vector&lt;MIL_ID&gt; Display3dIds(NB_CASES); for(MIL_INT d = 0; d &lt; NB_CASES; d++) { SDisplays&amp; Display = AllDisplays[d]; MIL_INT DisplayOffsetY = d * (DepthMapDispSizeY + WINDOW_OFFSET); if(!Display.Alloc(MilSystem, PATH_DISP_3D_SIZE_X, DepthMapDispSizeY, DisplayOffsetY)) return false; Display3dIds[d] = Display.MilDisplay3d; Display.SetupDisplay(MIL_TEXT(\"FindPathDepthMap\"), MIL_TEXT(\"FindPathDepthMap\")); // Disable the updates. Display.DisableUpdate(); // Select the depth map on the 3D display, focusing on the path. M3ddispSelect(Display.MilDisplay3d, MilDepthMapGraList, M_ADD, M_DEFAULT); M3ddispSelect(Display.MilDisplay3d, M_NULL, M_OPEN, M_DEFAULT); M3ddispSetView(Display.MilDisplay3d, M_INTEREST_POINT, -0.56, -130, -38, M_DEFAULT); M3ddispSetView(Display.MilDisplay3d, M_AZIM_ELEV_ROLL, 293.69, -22.27, 176.10, M_DEFAULT); M3ddispSetView(Display.MilDisplay3d, M_DISTANCE, 120, M_DEFAULT, M_DEFAULT, M_DEFAULT); // Select the depth map on the 2D display and set the size of the display if required. MdispZoom(Display.MilDisplay2d, PATH_DISP_ZOOM_X, PATH_DISP_ZOOM_Y); MdispSelect(Display.MilDisplay2d, MilDepthMap); // Draw the context annotations. DrawContext(MilContext, Display, M_PATH_INDEX(0), M_DRAW_PATH); // Do not show the extra displays. if(d != 0) Display.Hide(); // Enable the updates. Display.EnableUpdate(); } // Synchronize the displays. CDisplayLinker DisplayLinker(Display3dIds); // Print the example description. MosPrintf(MIL_TEXT(\"A depth map with a pixel size aspect ratio has been restored.\\n\")); MosPrintf(MIL_TEXT(\"A line geometry is used to define a path on which transitions\\n\")); MosPrintf(MIL_TEXT(\"edge or invalid, will be extracted.\\n\\n\")); WaitForKey(); // Make all the depth map of the 3D display semi-transparent. M3dgraControl(MilDepthMapGraList, DepthMapLabel, M_OPACITY, PATH_DEPTH_MAP_OPACITY); // Setup the draw context. M3dmeasControlDraw(MilDrawContext, M_DRAW_PROFILE_EXTRACTED, M_ACTIVE, M_ENABLE); M3dmeasControlDraw(MilDrawContext, M_DRAW_PROFILE_EXTRACTED, M_APPEARANCE, M_POINTS); M3dmeasControlDraw(MilDrawContext, M_DRAW_PROFILE_EXTRACTED, M_THICKNESS, PATH_PROFILE_DRAW_THICKNESS); M3dmeasControlDraw(MilDrawContext, M_DRAW_PROFILE_RESPONSE, M_ACTIVE, M_ENABLE); // Select the draw operations. MIL_INT DrawOperations = M_DRAW_TEMPLATE + M_DRAW_PROFILE_REGION + M_DRAW_PROFILE_REGION_DIRECTION + M_DRAW_MARKERS; // Find all the markers of any polarity with default thickness and sample size. FindControls.Controls = {CDEF(M_MARKER_NUMBER, M_ALL), CDEF(M_MARKER_POLARITY, M_ANY)}; FindMarkersAndDraw(MilContext, MilDepthMap, MilResult, MilDrawContext, AllDisplays[0], FindControls, DrawOperations); // Find all the markers with a profile thickness of a minimum of 5 pixel size. FindControls.Controls = {CVAL(M_PROFILE_THICKNESS, PATH_PROFILE_THICKNESS[0])}; FindMarkersAndDraw(MilContext, MilDepthMap, MilResult, MilDrawContext, AllDisplays[1], FindControls, DrawOperations); // Find all the markers with a given profile thickness and a sample size of one pixel in x-direction. FindControls.Controls = {CVAL(M_PROFILE_THICKNESS, PATH_PROFILE_THICKNESS[1]), CVAL(M_PROFILE_SAMPLE_SIZE, 1), CDEF(M_PROFILE_SAMPLE_SIZE_MODE, M_RELATIVE_TO_PIXEL_SIZE_X)}; FindMarkersAndDraw(MilContext, MilDepthMap, MilResult, MilDrawContext, AllDisplays[2], FindControls, DrawOperations); MosPrintf(MIL_TEXT(\"The transitions are found in a profile that is extracted by\\n\")); MosPrintf(MIL_TEXT(\"sampling and projecting the points inside a region of a certain\\n\")); MosPrintf(MIL_TEXT(\"thickness. By default, the thickness and sampling size are equal to\\n\")); MosPrintf(MIL_TEXT(\"the minimum pixel size of the depth map.\\n\")); MosPrintf(MIL_TEXT(\"Displayed are the extracted profile and the found markers\\n\")); MosPrintf(MIL_TEXT(\"with different thicknesses and sampling sizes.\\n\")); MosPrintf(MIL_TEXT(\"The profile path, the extracted profile, and its response\\n\")); MosPrintf(MIL_TEXT(\"are displayed in magenta, yellow, and blue, respectively.\\n\\n\")); WaitForKey(); // Find the markers with the default setting FindControls.Controls = {CDEF(M_MARKER_TRANSITION, M_EDGE_OR_INVALID)}; FindMarkersAndDraw(MilContext, MilDepthMap, MilResult, MilDrawContext, AllDisplays[0], FindControls, DrawOperations); // Find the markers with the default setting FindControls.Controls = {CDEF(M_MARKER_TRANSITION, M_INVALID)}; FindMarkersAndDraw(MilContext, MilDepthMap, MilResult, MilDrawContext, AllDisplays[1], FindControls, DrawOperations); // Find the markers with the default setting FindControls.Controls = {CDEF(M_MARKER_TRANSITION, M_EDGE)}; FindMarkersAndDraw(MilContext, MilDepthMap, MilResult, MilDrawContext, AllDisplays[2], FindControls, DrawOperations); MosPrintf(MIL_TEXT(\"It is possible to choose the type of transition to find.\\n\")); MosPrintf(MIL_TEXT(\"Displayed are all markers found with M_EDGE, M_INVALID, and\\n\")); MosPrintf(MIL_TEXT(\"M_EDGE_OR_INVALID types of transition.\\n\\n\")); WaitForKey(); // Find the markers with the default setting FindControls.Controls = {CVAL(M_PROFILE_MIN_VALID_PERCENTAGE, PATH_MIN_VALID_PERCENTAGE[0])}; FindMarkersAndDraw(MilContext, MilDepthMap, MilResult, MilDrawContext, AllDisplays[0], FindControls, DrawOperations); FindControls.Controls = {CVAL(M_PROFILE_MIN_VALID_PERCENTAGE, PATH_MIN_VALID_PERCENTAGE[1])}; FindMarkersAndDraw(MilContext, MilDepthMap, MilResult, MilDrawContext, AllDisplays[1], FindControls, DrawOperations); FindControls.Controls = {CVAL(M_PROFILE_MIN_VALID_PERCENTAGE, PATH_MIN_VALID_PERCENTAGE[2])}; FindMarkersAndDraw(MilContext, MilDepthMap, MilResult, MilDrawContext, AllDisplays[2], FindControls, DrawOperations); MosPrintf(MIL_TEXT(\"When extracting the profile, it is possible to specify the \\n\")); MosPrintf(MIL_TEXT(\"percentage of valid points needed for a given sample to be valid.\\n\")); MosPrintf(MIL_TEXT(\"Displayed are the extracted profile and found markers\\n\")); MosPrintf(MIL_TEXT(\"with different minimum valid percentages.\\n\\n\")); WaitForKey(); FindControls.Controls = {CVAL(M_PROFILE_GAP_FILL_THRESHOLD, PATH_GAP_THRESHOLD)}; FindMarkersAndDraw(MilContext, MilDepthMap, MilResult, MilDrawContext, AllDisplays[0], FindControls, DrawOperations); FindControls.Controls = {CDEF(M_PROFILE_GAP_FILL_SHARP_ELEVATION, M_MIN), CVAL(M_PROFILE_GAP_FILL_SHARP_ELEVATION_DEPTH, PATH_SHARP_DEPTH)}; FindMarkersAndDraw(MilContext, MilDepthMap, MilResult, MilDrawContext, AllDisplays[1], FindControls, DrawOperations); FindControls.Controls = {CDEF(M_PROFILE_GAP_FILL_SHARP_ELEVATION, M_MAX), CVAL(M_PROFILE_GAP_FILL_SHARP_ELEVATION_DEPTH, PATH_SHARP_DEPTH)}; FindMarkersAndDraw(MilContext, MilDepthMap, MilResult, MilDrawContext, AllDisplays[2], FindControls, DrawOperations); MosPrintf(MIL_TEXT(\"It is possible to enable some gap filling to fill missing data\\n\")); MosPrintf(MIL_TEXT(\"gaps in the profile. The gaps are filled if they are larger\\n\")); MosPrintf(MIL_TEXT(\"than a given threshold. The filling is either done by\\n\")); MosPrintf(MIL_TEXT(\"interpolating linearly with the valid values before and after or by\\n\")); MosPrintf(MIL_TEXT(\"propagating either value if the elevation is greater than a\\n\")); MosPrintf(MIL_TEXT(\"certain depth.\\n\")); MosPrintf(MIL_TEXT(\"Displayed are the extracted profile and found markers with\\n\")); MosPrintf(MIL_TEXT(\"different gap filling configurations.\\n\\n\")); WaitForKey(); MIL_DOUBLE GapThresholdInSamples = PATH_GAP_THRESHOLD / PATH_SAMPLE_SIZES[0]; FindControls.Controls = {CVAL(M_PROFILE_SAMPLE_SIZE, PATH_SAMPLE_SIZES[0]), CVAL(M_PROFILE_GAP_FILL_THRESHOLD, GapThresholdInSamples)}; FindMarkersAndDraw(MilContext, MilDepthMap, MilResult, MilDrawContext, AllDisplays[0], FindControls, DrawOperations); GapThresholdInSamples = PATH_GAP_THRESHOLD / PATH_SAMPLE_SIZES[1]; FindControls.Controls = {CVAL(M_PROFILE_SAMPLE_SIZE, PATH_SAMPLE_SIZES[1]), CVAL(M_PROFILE_GAP_FILL_THRESHOLD, GapThresholdInSamples)}; FindMarkersAndDraw(MilContext, MilDepthMap, MilResult, MilDrawContext, AllDisplays[1], FindControls, DrawOperations); FindControls.Controls = {CVAL(M_PROFILE_FILTER_SMOOTHNESS, PATH_PROFILE_FILTER_SMOOTHNESS)}; FindMarkersAndDraw(MilContext, MilDepthMap, MilResult, MilDrawContext, AllDisplays[2], FindControls, DrawOperations); MosPrintf(MIL_TEXT(\"Finally, the sample size can be controlled so that the\\n\")); MosPrintf(MIL_TEXT(\"extracted profile has fewer or more samples.\\n\")); MosPrintf(MIL_TEXT(\"Changing the sample size often requires adapting the filter\\n\")); MosPrintf(MIL_TEXT(\"smoothness to have a proper response.\\n\")); MosPrintf(MIL_TEXT(\"Displayed are the extracted profiles and markers with\\n\")); MosPrintf(MIL_TEXT(\"different profile sizes. The last profile's smoothness is\\n\")); MosPrintf(MIL_TEXT(\"increased to have a more appropriate profile response.\\n\\n\")); WaitForKey(); return true; } //*************************************************************************************** // Runs the example that finds markers of a template and fits a geometry. //*************************************************************************************** bool TemplateExample(MIL_ID MilSystem) { // Restore the depth map. auto MilDepthMap = MbufImport(TEMPLATE_DEPTH_MAP, M_MIL_TIFF + M_WITH_CALIBRATION, M_RESTORE, MilSystem, M_UNIQUE_ID); // Get the size of the displayed depth map image. auto DepthMapSizeY = MbufInquire(MilDepthMap, M_SIZE_Y, M_NULL); auto DepthMapDisplaySizeY = DepthMapSizeY * TEMPLATE_DISP_ZOOM_Y; // Allocate find template context and result. SNamedControlList FindControls = {M_TEMPLATE_INDEX(0)}; auto MilContext = M3dmeasAlloc(MilSystem, M_FIND_MARKER_TEMPLATE_CONTEXT, M_DEFAULT, M_UNIQUE_ID); auto MilResult = M3dmeasAllocResult(MilSystem, M_FIND_MARKER_TEMPLATE_RESULT, M_DEFAULT, M_UNIQUE_ID); // Define the template from the line geometry. auto MilTemplateGeo = M3dgeoAlloc(MilSystem, M_GEOMETRY, M_DEFAULT, M_UNIQUE_ID); M3dgeoLine(MilTemplateGeo, M_TWO_POINTS, -31.5, -99.67, -30, -31.5, -149.55, -30, M_DEFAULT, M_DEFAULT); M3dmeasDefine(MilContext, MilTemplateGeo, M_DEFAULT, M_DEFAULT, M_ADD, M_DEFAULT, M_EDGE, M_DEFAULT, M_DEFAULT, M_DEFAULT, M_DEFAULT, M_NULL, M_DEFAULT); // Allocate a 3dmeas draw context. auto MilDrawContext = M3dmeasAlloc(MilSystem, M_DRAW_3D_TEMPLATE_CONTEXT , M_DEFAULT, M_UNIQUE_ID); // Do a find with the default settings so that we can draw some template information // in the 3D display. M3dmeasFindMarker(MilContext, MilDepthMap, MilResult, M_DEFAULT); // Setup the displays. SDisplays AllDisplays[NB_CASES]; std::vector&lt;MIL_ID&gt; Display3dIds(NB_CASES); for(MIL_INT d = 0; d &lt; NB_CASES; d++) { SDisplays&amp; Display = AllDisplays[d]; MIL_INT DisplayOffsetY = d * (DepthMapDisplaySizeY + WINDOW_OFFSET); if(!Display.Alloc(MilSystem, PROFILE_DISP_3D_SIZE_X, DepthMapDisplaySizeY, DisplayOffsetY)) return false; Display3dIds[d] = Display.MilDisplay3d; Display.SetupDisplay(MIL_TEXT(\"FindTemplateDepthMap\"), MIL_TEXT(\"FindTemplateDepthMap\")); // Disable the updates. Display.DisableUpdate(); // Select the depth map on the 3d display. Display.SelectDepthMap3d(MilDepthMap); M3ddispSetView(Display.MilDisplay3d, M_AUTO, M_BOTTOM_TILTED, M_DEFAULT, M_DEFAULT, M_DEFAULT); M3ddispSetView(Display.MilDisplay3d, M_AZIMUTH, 315, M_DEFAULT, M_DEFAULT, M_DEFAULT); // Draw the template and projected template in the 3D display. M3dmeasControlDraw(MilDrawContext, M_ALL, M_ACTIVE, M_DISABLE); M3dmeasControlDraw(MilDrawContext, M_DRAW_TEMPLATE, M_ACTIVE, M_ENABLE); M3dmeasControlDraw(MilDrawContext, M_DRAW_TEMPLATE_PROJECTED, M_ACTIVE, M_ENABLE); M3dmeasDraw3d(MilDrawContext, MilResult, M_TEMPLATE_INDEX(0), M_PROFILE_INDEX(M_ALL), M_DEFAULT, Display.MilGraList3d, Display.AnnotationsNode, M_DEFAULT); // Select the depth map on the 2D display. MdispZoom(Display.MilDisplay2d, TEMPLATE_DISP_ZOOM_X, TEMPLATE_DISP_ZOOM_Y); MdispSelect(Display.MilDisplay2d, MilDepthMap); // Draw the template. Display.DrawMeas2dAll(MilContext, M_TEMPLATE_INDEX(0), M_DRAW_TEMPLATE, M_COLOR_MAGENTA, 1); // Do not show the extra displays. if(d != 0) Display.Hide(); // Enable the updates. Display.EnableUpdate(); } // Synchronize the displays. CDisplayLinker DisplayLinker(Display3dIds); MosPrintf(MIL_TEXT(\"A depth map with a pixel size aspect ratio has been restored.\\n\")); MosPrintf(MIL_TEXT(\"A line geometry is used to define a path on which (edge\\n\")); MosPrintf(MIL_TEXT(\"or invalid) transitions will be extracted.\\n\\n\")); // Print the example description. MosPrintf(MIL_TEXT(\"A depth map has been restored and a line geometry template has\\n\")); MosPrintf(MIL_TEXT(\"been defined where a segment transition is expected.\\n\")); MosPrintf(MIL_TEXT(\"Although the segment is defined in 3D, the search is actually done\\n\")); MosPrintf(MIL_TEXT(\"in 2D to find a projected segment.\\n\\n\")); WaitForKey(); // Reset the context to default. M3dmeasControlDraw(MilDrawContext, M_ALL, M_ACTIVE, M_DEFAULT); // Select the draw operations. MIL_INT DrawOperations = M_DRAW_TEMPLATE + M_DRAW_PROFILE_REGION + M_DRAW_PROFILE_REGION_DIRECTION + M_DRAW_MARKERS; // Find the template markers in the default number of profiles. FindControls.Controls = {CVAL(M_TEMPLATE_PROFILE_LENGTH, TEMPLATE_PROF_LENGTH), CDEF(M_MARKER_POLARITY, M_ANY)}; FindMarkersAndDraw(MilContext, MilDepthMap, MilResult, MilDrawContext, AllDisplays[0], FindControls, DrawOperations); // Find the template markers in more profiles. FindControls.Controls = {CVAL(M_TEMPLATE_PROFILE_NUMBER_VALUE, TEMPLATE_PROF_NUMBER)}; FindMarkersAndDraw(MilContext, MilDepthMap, MilResult, MilDrawContext, AllDisplays[1], FindControls, DrawOperations); // Hide unused displays. AllDisplays[2].Hide(); MosPrintf(MIL_TEXT(\"Markers that should be on the projected template are found in\\n\")); MosPrintf(MIL_TEXT(\"profiles extracted perpendicularly to the template.\\n\")); MosPrintf(MIL_TEXT(\"The number of profiles can be controlled.\\n\")); MosPrintf(MIL_TEXT(\"Displayed are all template markers found with different number\\n\")); MosPrintf(MIL_TEXT(\"of profiles.\\n\\n\")); WaitForKey(); // Find the template markers in profiles extracted with a small thickness. FindControls.Controls = {CVAL(M_PROFILE_THICKNESS, TEMPLATE_PROF_THICKNESS[0]), CDEF(M_PROFILE_THICKNESS_MODE, M_RELATIVE_TO_PIXEL_SIZE_MIN)}; FindMarkersAndDraw(MilContext, MilDepthMap, MilResult, MilDrawContext, AllDisplays[0], FindControls, DrawOperations); // Find the template markers in profiles extrated with a large thickness. FindControls.Controls = {CVAL(M_PROFILE_THICKNESS, TEMPLATE_PROF_THICKNESS[1]), CDEF(M_PROFILE_THICKNESS_MODE, M_RELATIVE_TO_PIXEL_SIZE_MIN)}; FindMarkersAndDraw(MilContext, MilDepthMap, MilResult, MilDrawContext, AllDisplays[1], FindControls, DrawOperations); // Find the template markers in profiles extracted with a thickness of exactly one spacing. FindControls.Controls = {CVAL( M_PROFILE_THICKNESS, 1), CDEF(M_PROFILE_THICKNESS_MODE, M_RELATIVE_TO_SPACING)}; FindMarkersAndDraw(MilContext, MilDepthMap, MilResult, MilDrawContext, AllDisplays[2], FindControls, DrawOperations); MosPrintf(MIL_TEXT(\"Additionally, the thickness of the profiles can be specified,\\n\")); MosPrintf(MIL_TEXT(\"either with a user-defined value or relative to the spacing between profiles.\\n\")); MosPrintf(MIL_TEXT(\"Displayed are two user-defined thicknesses and a relative thickness.\\n\\n\")); WaitForKey(); // Apply generic controls for this case. FindControls.Controls = {CVAL(M_PROFILE_THICKNESS, TEMPLATE_PROF_THICKNESS[1]), CDEF(M_PROFILE_THICKNESS_MODE, M_RELATIVE_TO_PIXEL_SIZE_MIN), CDEF(M_TEMPLATE_PROFILE_NUMBER_MODE, M_SPACING), CDEF(M_TEMPLATE_PROFILE_SPACING_MODE, M_RELATIVE_TO_THICKNESS)}; FindControls.ApplyControls(MilContext); // Find the template markers with the profiles spaced relative to the thickness. FindControls.Controls = {CVAL(M_TEMPLATE_PROFILE_SPACING, TEMPLATE_PROF_SPACING[0])}; FindMarkersAndDraw(MilContext, MilDepthMap, MilResult, MilDrawContext, AllDisplays[0], FindControls, DrawOperations); FindControls.Controls = {CVAL(M_TEMPLATE_PROFILE_SPACING, TEMPLATE_PROF_SPACING[1])}; FindMarkersAndDraw(MilContext, MilDepthMap, MilResult, MilDrawContext, AllDisplays[1], FindControls, DrawOperations); FindControls.Controls = {CVAL(M_TEMPLATE_PROFILE_SPACING, TEMPLATE_PROF_SPACING[2])}; FindMarkersAndDraw(MilContext, MilDepthMap, MilResult, MilDrawContext, AllDisplays[2], FindControls, DrawOperations); MosPrintf(MIL_TEXT(\"Inversely, the profile number can be set according to a specified spacing.\\n\")); MosPrintf(MIL_TEXT(\"Displayed are the template profiles with a number of profiles based on a\\n\")); MosPrintf(MIL_TEXT(\"spacing, which itself is defined relative to the thickness.\\n\\n\")); WaitForKey(); // Find the template markers with the profiles position moved relative to the template. FindControls.Controls = {CVAL(M_TEMPLATE_PROFILE_POSITION_RELATIVE, TEMPLATE_PROF_POS_REL[0])}; FindMarkersAndDraw(MilContext, MilDepthMap, MilResult, MilDrawContext, AllDisplays[0], FindControls, DrawOperations); FindControls.Controls = {CVAL(M_TEMPLATE_PROFILE_POSITION_RELATIVE, TEMPLATE_PROF_POS_REL[1])}; FindMarkersAndDraw(MilContext, MilDepthMap, MilResult, MilDrawContext, AllDisplays[1], FindControls, DrawOperations); FindControls.Controls = {CVAL(M_TEMPLATE_PROFILE_POSITION_RELATIVE, TEMPLATE_PROF_POS_REL[2])}; FindMarkersAndDraw(MilContext, MilDepthMap, MilResult, MilDrawContext, AllDisplays[2], FindControls, DrawOperations); MosPrintf(MIL_TEXT(\"The position of the profiles are centered on the template by \\n\")); MosPrintf(MIL_TEXT(\"default. It is possible to offset their position as a percentage\\n\")); MosPrintf(MIL_TEXT(\"of their length.\\n\")); MosPrintf(MIL_TEXT(\"Displayed are the template profiles with different relative\\n\")); MosPrintf(MIL_TEXT(\"positions.\\n\\n\")); WaitForKey(); // Find the template markers with the profiles extraction data unconstrained. FindControls.Controls = {CDEF(M_TEMPLATE_EXTENDED_SEARCH, M_ENABLE)}; FindMarkersAndDraw(MilContext, MilDepthMap, MilResult, MilDrawContext, AllDisplays[0], FindControls, DrawOperations); // Find the template markers with the profiles extraction data // constrained to be withtin the template. FindControls.Controls = {CDEF(M_TEMPLATE_EXTENDED_SEARCH, M_DISABLE)}; FindMarkersAndDraw(MilContext, MilDepthMap, MilResult, MilDrawContext, AllDisplays[1], FindControls, DrawOperations); // Hide unused displays. AllDisplays[2].Hide(); MosPrintf(MIL_TEXT(\"In some situations, it can be preferable to constrain the\\n\")); MosPrintf(MIL_TEXT(\"profile extraction so that it does not use data beyond the limits\\n\")); MosPrintf(MIL_TEXT(\"of the template. A control allows to enforce this constraint.\\n\\n\")); WaitForKey(); // Find the template markers with one profile length and position set to specific values. MIL_INT SINGLE_PROFILE_INDEX = M_PROFILE_INDEX(3); FindControls.Controls = { CDEF(M_TEMPLATE_PROFILE_NUMBER_MODE, M_USER_DEFINED), CVAL(M_TEMPLATE_PROFILE_NUMBER_VALUE, TEMPLATE_SINGLE_NUMBER), CVALP(M_TEMPLATE_PROFILE_LENGTH, TEMPLATE_SINGLE_LENGTH, SINGLE_PROFILE_INDEX), CDEFP(M_TEMPLATE_PROFILE_LENGTH_SOURCE, M_PROFILE, SINGLE_PROFILE_INDEX), CVALP(M_TEMPLATE_PROFILE_POSITION_RELATIVE, TEMPLATE_SINGLE_POS_REL, SINGLE_PROFILE_INDEX), CDEFP(M_TEMPLATE_PROFILE_POSITION_SOURCE, M_PROFILE, SINGLE_PROFILE_INDEX) }; FindControls.ApplyControls(MilContext); FindControls.Controls = {}; FindMarkersAndDraw(MilContext, MilDepthMap, MilResult, MilDrawContext, AllDisplays[0], FindControls, DrawOperations); // Hide unused displays. AllDisplays[1].Hide(); AllDisplays[2].Hide(); MosPrintf(MIL_TEXT(\"If required, it is also possible to control the length and\\n\")); MosPrintf(MIL_TEXT(\"position of individual profiles. Note that this is only available\\n\")); MosPrintf(MIL_TEXT(\"when the number of profiles is set to a user-defined value.\\n\\n\")); WaitForKey(); // Select the draw operations for the fit. DrawOperations = M_DRAW_PROFILE_REGION + M_DRAW_PROFILE_REGION_DIRECTION + M_DRAW_MARKERS + M_DRAW_FIT_MARKERS; // Fit with the default parameters. SNamedControlList FitControls = {M_DEFAULT}; auto MilFitContext = M3dmeasAlloc(MilSystem, M_FIT_CONTEXT, M_DEFAULT, M_UNIQUE_ID); FitMarkersAndDraw(MilFitContext, M_NULL, M_NULL, MilResult, MilDrawContext, AllDisplays[0], FitControls, DrawOperations); // Fit with a specified fit distance. FitControls.Controls = {CDEF(M_FIT_DISTANCE_MODE, M_RELATIVE_TO_SAMPLING), CVAL(M_FIT_DISTANCE, TEMPLATE_FIT_DISTANCE)}; FitMarkersAndDraw(MilFitContext, M_NULL, M_NULL, MilResult, MilDrawContext, AllDisplays[1], FitControls, DrawOperations); // Set the strength minimum-variation in order to extract strong transitions // that are close to each other. M3dmeasControl(MilContext, M_TEMPLATE_INDEX(0), M_DEFAULT, M_MARKER_STRENGTH_MIN_VAR, TEMPLATE_STRENGTH_MIN_VAR); // Find and fit simultaneously. FitMarkersAndDraw(MilFitContext, MilContext, MilDepthMap, MilResult, MilDrawContext, AllDisplays[2], FitControls, DrawOperations); MosPrintf(MIL_TEXT(\"Once the markers are found, it is possible to fit a segment on the\\n\")); MosPrintf(MIL_TEXT(\"projected markers positions. An automatic fit distance is used by \\n\")); MosPrintf(MIL_TEXT(\"default which excludes some markers from the fit (in red).\\n\")); MosPrintf(MIL_TEXT(\"It is possible to modify the fit distance if desired.\\n\")); MosPrintf(MIL_TEXT(\"Alternatively, the find and fit can also be done simultaneously,\\n\")); MosPrintf(MIL_TEXT(\"the marker in each profile chosen to get the best fit result.\\n\")); MosPrintf(MIL_TEXT(\"Displayed are the fitted segments using an automatic fit distance,\\n\")); MosPrintf(MIL_TEXT(\"a user-defined fit distance, and a simultaneous find and fit.\\n\\n\")); MosPrintf(MIL_TEXT(\"Press any key to end.\\n\\n\")); MosGetch(); return true; } //*************************************************************************************** // Draws the annotations from a context. //*************************************************************************************** void DrawContext(MIL_ID MilContext, SDisplays&amp; Display, MIL_INT ObjectIndex, MIL_INT DrawTemplateOrPath) { Display.DrawMeas2dAll(MilContext, ObjectIndex, DrawTemplateOrPath, M_COLOR_MAGENTA, 1); Display.DrawMeas2dAll(MilContext, ObjectIndex, M_DRAW_PROFILE_REGION, M_COLOR_MAGENTA, 1); Display.DrawMeas2dAll(MilContext, ObjectIndex, M_DRAW_PROFILE_REGION_DIRECTION, M_COLOR_MAGENTA, 1); } //*************************************************************************************** // Draws the results. //*************************************************************************************** void DrawResult(MIL_ID MilResult, MIL_INT ObjectIndex, MIL_ID MilDrawContext, SDisplays&amp; Display, MIL_INT DrawOperations) { // Clear the annotations. Display.ClearAnnotations(); // Draw the template. if(DrawOperations &amp; M_DRAW_TEMPLATE) Display.DrawMeas2dAll(MilResult, ObjectIndex, M_DRAW_TEMPLATE, M_COLOR_MAGENTA, 1); // Draw the profile region. if(DrawOperations &amp; M_DRAW_PROFILE_REGION_DIRECTION) Display.DrawMeas2dAll(MilResult, ObjectIndex, M_DRAW_PROFILE_REGION_DIRECTION, M_COLOR_MAGENTA, 1); if(DrawOperations &amp; M_DRAW_PROFILE_REGION) Display.DrawMeas2dAll(MilResult, ObjectIndex, M_DRAW_PROFILE_REGION, M_COLOR_MAGENTA, 1); // Draw the markers. if(DrawOperations &amp; M_DRAW_MARKERS) Display.DrawMeas2dAll(MilResult, ObjectIndex, M_DRAW_MARKERS, M_COLOR_GREEN, 1); // Draw the fit. if(DrawOperations &amp; M_DRAW_FIT_MARKERS) { Display.DrawMeas2dAll(MilResult, M_TEMPLATE_INDEX(0), M_DRAW_FIT_GEOMETRY, M_COLOR_YELLOW, 1); Display.DrawMeas2dAll(MilResult, M_TEMPLATE_INDEX(0), M_DRAW_FIT_MARKERS, M_COLOR_GREEN, 1); Display.DrawMeas2dAll(MilResult, M_TEMPLATE_INDEX(0), M_DRAW_FIT_MARKERS_OUTLIERS, M_COLOR_RED, 1); } // Draw all the 3D annotations. Display.DrawMeas3dAll(MilDrawContext, MilResult, ObjectIndex); } //*************************************************************************************** // Finds the markers and draws the annotations in the display. //*************************************************************************************** void FindMarkersAndDraw(MIL_ID MilContext, MIL_ID MilDepthMap, MIL_ID MilResult, MIL_ID MilDrawContext, SDisplays&amp; Display, const SNamedControlList&amp; ControlList, MIL_INT DrawOperations) { // Set the controls and find the markers. ControlList.ApplyControls(MilContext); M3dmeasFindMarker(MilContext, MilDepthMap, MilResult, M_DEFAULT); // Draw the result. DrawResult(MilResult, ControlList.ObjectIndex, MilDrawContext, Display, DrawOperations); // Draw the controls that were applied. ControlList.DrawControls(Display.MilGraList2d); // Show the display. Display.Show(); } //*************************************************************************************** // Fits the markers and draw the annotations in the display. //*************************************************************************************** void FitMarkersAndDraw(MIL_ID MilFitContext, MIL_ID MilFindContext, MIL_ID MilDepthMap, MIL_ID MilResult, MIL_ID MilDrawContext, SDisplays&amp; Display, const SNamedControlList&amp; ControlList, MIL_INT DrawOperations) { // Set the controls and find the markers. ControlList.ApplyControls(MilFitContext); M3dmeasFit(MilFitContext, MilFindContext, MilDepthMap, MilResult, M_DEFAULT); // Draw the result. DrawResult(MilResult, ControlList.ObjectIndex, MilDrawContext, Display, DrawOperations); // Draw the controls that were applied. SNamedControlList ControlListWithMode = ControlList; ControlListWithMode.Controls.insert(ControlListWithMode.Controls.begin(), {{{0, MIL_TEXT(\"Function\")}, {0, MilFindContext ? MIL_TEXT(\"M3dmeasFit() Only\") : MIL_TEXT(\"M3dmeasFindMarker() + M3dmeasFit()\")}}}); ControlListWithMode.DrawControls(Display.MilGraList2d); // Show the display. Display.Show(); } //*************************************************************************************** // Allocates the displays for the example. //*************************************************************************************** bool SDisplays::Alloc(MIL_ID MilSystem, MIL_INT SizeX, MIL_INT SizeY, MIL_INT WindowInitialPosY /* = 0*/) { // Allocate the 3D display. MilDisplay3d = Alloc3dDisplayId(MilSystem); if(MilDisplay3d == M_NULL) return false; M3ddispControl(MilDisplay3d, M_SIZE_X, SizeX); M3ddispControl(MilDisplay3d, M_SIZE_Y, SizeY); M3ddispControl(MilDisplay3d, M_WINDOW_INITIAL_POSITION_Y, WindowInitialPosY); MilGraList3d = M3ddispInquire(MilDisplay3d, M_3D_GRAPHIC_LIST_ID, M_NULL); // Allocate the 2D display. MilDisplay2d = MdispAlloc(MilSystem, M_DEFAULT, MIL_TEXT(\"\"), M_DEFAULT, M_UNIQUE_ID); MilGraList2d = MgraAllocList(MilSystem, M_DEFAULT, M_UNIQUE_ID); MdispControl(MilDisplay2d, M_ASSOCIATED_GRAPHIC_LIST_ID, MilGraList2d); MdispControl(MilDisplay2d, M_WINDOW_INITIAL_POSITION_X, SizeX); MdispControl(MilDisplay2d, M_WINDOW_INITIAL_POSITION_Y, WindowInitialPosY); // Allocate a graphic context. MilGraContext = MgraAlloc(MilSystem, M_UNIQUE_ID); MgraControl(MilGraContext, M_INPUT_UNITS, M_WORLD); return true; } //*************************************************************************************** // Setups the displays by giving them names and clearing their graphic lists. //*************************************************************************************** void SDisplays::SetupDisplay(MIL_CONST_TEXT_PTR Display3dName, MIL_CONST_TEXT_PTR Display2dName) { MdispControl(MilDisplay2d, M_TITLE, Display2dName); M3ddispControl(MilDisplay3d, M_TITLE, Display3dName); MgraClear(M_DEFAULT, MilGraList2d); M3dgraRemove(MilGraList3d, M_ALL, M_DEFAULT); AnnotationsNode = M3dgraNode(MilGraList3d, M_DEFAULT, M_DEFAULT, M_DEFAULT); } //*************************************************************************************** // Shows the displays. //*************************************************************************************** void SDisplays::Show() const { MdispControl(MilDisplay2d, M_WINDOW_SHOW, M_ENABLE); M3ddispControl(MilDisplay3d, M_WINDOW_SHOW, M_ENABLE); } //*************************************************************************************** // Hides the displays. //*************************************************************************************** void SDisplays::Hide() const { MdispControl(MilDisplay2d, M_WINDOW_SHOW, M_DISABLE); M3ddispControl(MilDisplay3d, M_WINDOW_SHOW, M_DISABLE); } //*************************************************************************************** // Disables the display updates. //*************************************************************************************** void SDisplays::DisableUpdate() const { Update(M_DISABLE); } //*************************************************************************************** // Enables the display updates. //*************************************************************************************** void SDisplays::EnableUpdate() const { Update(M_ENABLE); } //*************************************************************************************** // Changes the update state of the displays to the specified value. //*************************************************************************************** void SDisplays::Update(MIL_INT Update) const { MdispControl(MilDisplay2d, M_UPDATE, Update); M3ddispControl(MilDisplay3d, M_UPDATE, Update); } //*************************************************************************************** // Clears the annotations by removing the annotation node and returning a new one. //*************************************************************************************** void SDisplays::ClearAnnotations() { MgraClear(M_DEFAULT, MilGraList2d); M3dgraRemove(MilGraList3d, AnnotationsNode, M_DEFAULT); AnnotationsNode = M3dgraNode(MilGraList3d, M_DEFAULT, M_DEFAULT, M_DEFAULT); } //*************************************************************************************** // Draws a 2D annotation on the display for all the profiles. //*************************************************************************************** void SDisplays::DrawMeas2dAll(MIL_ID MilMeasObject, MIL_INT64 TemplateOrPathIndex, MIL_INT Operation, MIL_INT Color, MIL_INT Thickness) { DrawMeas2d(MilMeasObject, TemplateOrPathIndex, M_PROFILE_INDEX(M_ALL), M_ALL, Operation, Color, Thickness); } //*************************************************************************************** // Draws a 3D annotation on the display for all the profiles. //*************************************************************************************** void SDisplays::DrawMeas3dAll(MIL_ID MilDrawContext, MIL_ID Mil3dMeasResult, MIL_INT64 TemplateOrPathIndex) { DrawMeas3d(MilDrawContext, Mil3dMeasResult, TemplateOrPathIndex, M_PROFILE_INDEX(M_ALL), M_ALL); } //*************************************************************************************** // Draws a single 2D annotations on the displays. //*************************************************************************************** void SDisplays::DrawMeas2d(MIL_ID Mil3dMeasObject, MIL_INT64 TemplateOrPathIndex, MIL_INT64 ProfileIndex, MIL_INT64 MarkerIndex, MIL_INT Operation, MIL_INT Color, MIL_INT Thickness) { MgraColor(MilGraContext, Color); MgraControl(MilGraContext, M_LINE_THICKNESS, Thickness); M3dmeasDraw(MilGraContext, Mil3dMeasObject, MilGraList2d, Operation, TemplateOrPathIndex, ProfileIndex, MarkerIndex, M_DEFAULT); } //*************************************************************************************** // Draws a single 3D annotations on the displays. //*************************************************************************************** void SDisplays::DrawMeas3d(MIL_ID MilDrawContext, MIL_ID Mil3dMeasResult, MIL_INT64 TemplateOrPathIndex, MIL_INT64 ProfileIndex, MIL_INT64 MarkerIndex) { M3dmeasDraw3d(MilDrawContext, Mil3dMeasResult, TemplateOrPathIndex, ProfileIndex, MarkerIndex, MilGraList3d, AnnotationsNode, M_DEFAULT); } //*************************************************************************************** // Selects the depth map on the 3D display and sets the color map LUT. //*************************************************************************************** void SDisplays::SelectDepthMap3d(MIL_ID MilDepthMap) { M3ddispSelect(MilDisplay3d, MilDepthMap, M_SELECT, M_DEFAULT); SetupColorMap(MilGraList3d); } //*************************************************************************************** // Applies the list of controls to the context. //*************************************************************************************** void SNamedControlList::ApplyControls(MIL_ID MilContext) const { for(const auto&amp; control : Controls) { M3dmeasControl(MilContext, ObjectIndex, control.ProfileIndex, control.Flag.Value, control.Value.Value); } } //*************************************************************************************** // Applies the list of controls to the context. //*************************************************************************************** void SNamedControlList::DrawControls(MIL_ID MilGraList) const { MIL_STRING_STREAM ControlStream; ControlStream &lt;&lt; MIL_TEXT(\" \"); for(const auto&amp; c : Controls) { ControlStream &lt;&lt; c.Flag.Name &lt;&lt; MIL_TEXT(\": \"); if(c.Value.Name == MIL_TEXT(\"\")) ControlStream &lt;&lt; c.Value.Value; else ControlStream &lt;&lt; c.Value.Name; ControlStream &lt;&lt; MIL_TEXT(\" \"); } MgraControl(M_DEFAULT, M_INPUT_UNITS, M_DISPLAY); MgraText(M_DEFAULT, MilGraList, 0, 0, ControlStream.str()); MgraControl(M_DEFAULT, M_INPUT_UNITS, M_DEFAULT); } //*************************************************************************************** // Allocates a 3D display and returns its MIL identifier. //*************************************************************************************** MIL_UNIQUE_3DDISP_ID Alloc3dDisplayId(MIL_ID MilSystem) { MappControl(M_DEFAULT, M_ERROR, M_PRINT_DISABLE); auto MilDisplay3D = M3ddispAlloc(MilSystem, M_DEFAULT, MIL_TEXT(\"M_DEFAULT\"), M_DEFAULT, M_UNIQUE_ID); MappControl(M_DEFAULT, M_ERROR, M_PRINT_ENABLE); if(!MilDisplay3D) { MosPrintf(MIL_TEXT(\"\\n\") MIL_TEXT(\"The current system does not support the 3D display.\\n\") MIL_TEXT(\"Press any key to end.\\n\")); MosGetch(); } return MilDisplay3D; } //*************************************************************************************** // Checks the required files exist. //*************************************************************************************** bool CheckForRequiredMILFile(MIL_STRING FileName) { MIL_INT FilePresent; MappFileOperation(M_DEFAULT, FileName, M_NULL, M_NULL, M_FILE_EXISTS, M_DEFAULT, &amp;FilePresent); if(FilePresent == M_NO) { MosPrintf(MIL_TEXT(\"\\n\") MIL_TEXT(\"The footage needed to run this example is missing. You need \\n\") MIL_TEXT(\"to obtain and apply a separate specific update to have it.\\n\\n\")); MosPrintf(MIL_TEXT(\"Press any key to end.\\n\\n\")); MosGetch(); } return (FilePresent == M_YES); } ",
      "wordCount": 4345
    }
  ]
}]
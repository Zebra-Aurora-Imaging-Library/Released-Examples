[{
  "id": "UG_3D_Display_and_graphics",
  "version": "2024020714",
  "title": "3D Display and graphics",
  "subTitles": null,
  "location": "MIL UG P06: 3D related information",
  "pageURL": "content\\UserGuide\\3D_Display_and_graphics\\ChapterInformation.htm",
  "text": " Chapter 43: 3D Display and graphics This chapter describes how to use 3D displays and graphics. 3D display and graphics overview Steps to display 3D data Basic concepts for 3D display Color and display settings for 3D data Point size Opacity Coloring points Dynamic range Applying LUTs Meshed point cloud containers Manipulating the view View settings Fundamental settings that control the view position and rotation Alternative view settings View orientation and distance Zooming Level of detail Azimuth, elevation, roll, and distance Orbit, up-vector, and distance Scrolling View box View matrix Other 3D display controls Changing the background Rotation indicator Auto-rotation Depth sorting Annotating the 3D display Types of graphics Positions of 3D graphics Point picking Display settings for 3D graphics Clipping 3D graphics that extend infinitely Working with texture images of polygon 3D graphics Texture mapping 3D graphics lists Structure of a 3D graphics list Controlling settings for multiple 3D graphics Copying multiple 3D graphics Removing multiple 3D graphics Changing the positions of multiple 3D graphics Render layers Setting defaults for 3D graphics added to a 3D graphics list Interactive 3D graphics Handle graphics Hooking a function to a 3D graphics list event ",
  "wordCount": 195,
  "subEntries": [
    {
      "id": "UG_3D_Display_and_graphics_3D_Display_and_graphics_overview",
      "version": null,
      "title": "3D display and graphics overview",
      "subTitles": null,
      "location": "MIL UG P06: 3D related information",
      "pageURL": "content\\UserGuide\\3D_Display_and_graphics\\3D_Display_and_graphics_overview.htm",
      "text": " 3D display and graphics overview You can display point cloud containers and fully corrected depth map image buffers in a window on the desktop using a MIL 3D display. You can also display 3D annotations (3D graphics such as cubes, cylinders, axes and text) in a 3D display. There are additional hardware requirements to use MIL 3D displays. For more information, see the Hardware requirements subsection of the Requirements to run MIL section of Chapter 1: Introduction. 3D displays are rendered in real-time, meaning that you can manipulate the view to show point clouds and 3D annotations from any angle. By default, the view in a 3D display can be changed interactively using the mouse and keyboard. Optionally, you can use M3ddispSetView() to manually change the view within your application. A 3D display shows everything in its default 3D graphics list. To show a 3D-displayable point cloud container or fully-corrected depth map image buffer in a 3D display, you must add it to any of that 3D display's associated graphics lists (either using M3ddispSelect(), M3ddispSelectWindow(), or M3dgraAdd()). By default, any subsequent changes to the 3D-displayable point cloud container or fully-corrected depth map image buffer will be shown in the 3D display; M3dgraAdd() used with M_NO_LINK adds an unlinked 3D-displayable point cloud container or fully-corrected depth map. A 3D-displayable point cloud or depth map can be included in the 3D graphics list of any number of 3D displays. Unlike 2D displays, each 3D display has a default 3D graphics list that is allocated and freed along with the 3D display. You can add or remove a 3D graphics list from a 3D display that you have allocated yourself. You can copy 3D graphics from any 3D graphics list to any of the 3D display's associated 3D graphics lists using M3dgraCopy(). A 3D graphics list can be associated with multiple displays at the same time. A 3D graphics list has a tree structure of 3D graphics, at the top of which is an invisible 3D graphic called the root node. The position and orientation of a 3D graphic is determined by its transformation matrix, which is applied relative to its parent in the tree structure. When a parent 3D graphic is moved, all of its descendents are moved accordingly. The root node always has the identity transformation matrix. You must specify the parent 3D graphic when you create 3D graphics or add 3D-displayable containers or fully corrected depth map image buffers, using functions from the M3dgra...() module. 3D display and graphics overview ",
      "wordCount": 422,
      "subEntries": []
    },
    {
      "id": "UG_3D_Display_and_graphics_Steps_to_display_3D_data",
      "version": null,
      "title": "Steps to display 3D data",
      "subTitles": null,
      "location": "MIL UG P06: 3D related information",
      "pageURL": "content\\UserGuide\\3D_Display_and_graphics\\Steps_to_display_3D_data.htm",
      "text": " Steps to display 3D data The following steps provide a typical methodology to show 3D data in a MIL 3D display: Allocate a 3D display on the same system as your 3D-displayable point cloud container or depth map image buffer, using M3ddispAlloc(). Select the 3D-displayable point cloud container or depth map image buffer to the 3D display or add a 3D graphics list to the 3D display, using M3ddispSelect() or M3ddispSelectWindow(). If you select a point cloud container that is not natively 3D-displayable, MIL will compensate and internally convert it to a 3D-displayable format if possible. For more information about what makes a container 3D-displayable, see the Preparing a container for display or processing section of Chapter 41: 3D Containers. If the point cloud container ceases to be 3D-displayable (for example, because its range component is removed), it will not be shown in the display until it becomes 3D-displayable again. You can also select an empty container with the M_DISP attribute (in which you plan to grab 3D data) to the display. Repeat step 2 for all point cloud containers or depth map image buffers that you want to display. In this case, call M3ddispSelect() or M3ddispSelectWindow() with M_ADD to prevent the containers or image buffers you have already added to the 3D display's 3D graphics list from being removed. Optionally, change the view of the display either using the keyboard/mouse controls or using M3ddispSetView(). If you want to annotate the 3D display, inquire the identifier of its internal 3D graphics list, using M3ddispInquire() with M_3D_GRAPHIC_LIST_ID. Then, add graphic objects to the 3D graphics list using the functions in the M3dgra...() module. When you no longer want to show a container or depth map image buffer, remove it from the 3D display's internal 3D graphics list using M3ddispSelect() or M3ddispSelectWindow() with M_REMOVE. When you no longer want to show the 3D display, close it using M3ddispSelect() or M3ddispSelectWindow() with M_CLOSE. When the 3D display is no longer required, free it using M3ddispFree(), unless M_UNIQUE_ID was specified during allocation. Steps to display 3D data ",
      "wordCount": 345,
      "subEntries": []
    },
    {
      "id": "UG_3D_Display_and_graphics_Basic_concepts_for_3D_display",
      "version": null,
      "title": "Basic concepts for 3D display",
      "subTitles": null,
      "location": "MIL UG P06: 3D related information",
      "pageURL": "content\\UserGuide\\3D_Display_and_graphics\\Basic_concepts_for_3D_display.htm",
      "text": " Basic concepts for 3D display The basic concepts and vocabulary conventions when dealing with 3D displays are: 3D display. A MIL object used to show 3D data and annotations in a window. 3D graphic. A MIL object that is shown in a 3D display. 3D graphics list. A MIL object that holds 3D graphics, including 3D graphics that are associated with 3D-displayable point cloud containers or depth map image buffers. Default 3D graphics list. The 3D graphics list associated with a 3D display. This association can never be changed. A 3D display's default 3D graphics list is automatically allocated and freed at the same time as the 3D display. Handle graphic. A 3D graphic that can be rotated or translated with the mouse in a 3D display. View. Your field of view in the 3D space of your 3D display. The view always looks from the viewpoint to the interest point. Viewpoint. The position from which the view is looking. Interest point. The position the view is looking at. This point is always at the center of the window. Up-vector. A unit vector that indicates which direction is up for the view. FoV angle (field-of-view angle). An angle used to determine the size of the view. FoV angle is analogous to the focal length of a camera. A 3D display has horizontal and vertical FoV angles, which always have the same aspect ratio as the size of the window. Increasing the FoV angle has the effect of zooming the view out and exaggerating perspective distortion at the edges of the view. Root node. The 3D graphic at the top of the descendent hierarchy of a 3D graphics list. All 3D graphics in a 3D graphics list are descendents of the root node. Basic concepts for 3D display ",
      "wordCount": 299,
      "subEntries": []
    },
    {
      "id": "UG_3D_Display_and_graphics_Color_and_display_settings_for_3D_data",
      "version": null,
      "title": "Color and display settings for 3D data",
      "subTitles": [
        "Point size",
        "Opacity",
        "Coloring points",
        "Dynamic range",
        "Applying LUTs",
        "Meshed point cloud containers"
      ],
      "location": "MIL UG P06: 3D related information",
      "pageURL": "content\\UserGuide\\3D_Display_and_graphics\\Color_and_display_settings_for_3D_data.htm",
      "text": " Color and display settings for 3D data When you select a 3D-displayable point cloud container or fully-corrected depth map image buffer to a 3D display (using M3ddispSelect(), M3ddispSelectWindow(), or M3dgraAdd()), a linked point cloud 3D graphic with the graphic type M_GRAPHIC_TYPE_POINT_CLOUD is added to the 3D graphics list. Fully-corrected depth map image buffers are internally converted to 3D-displayable point cloud containers when they are selected to a 3D display. The word points in this section can therefore also refer to the pixels of a fully-corrected depth map image buffer. Unlike other types of 3D graphics, a point cloud 3D graphic is continually updated to reflect changes in the linked 3D-displayable point cloud container or depth map image buffer. You can change how a point cloud 3D graphic is shown in the display using M3dgraControl() with the label of the point cloud 3D graphic. If a single 3D-displayable container or fully-corrected depth map image buffer is shown in multiple 3D displays (or multiple times in the same 3D display), you can change these settings independently for each point cloud 3D graphic. Note that when using M3dgraAdd(), you can specify to create an unlinked copy of the 3D-displayable point cloud container or depth map image buffer by using M_NO_LINK. You can specify the displayed size and opacity of each point, and how the color of each point is determined (optionally by applying a LUT). If you select a point cloud container to a 3D display and it has a valid mesh component, you can also specify how the mesh is shown in the 3D display. Point size Points are represented as squares in a 3D display. You can specify the displayed size of the points (in number of pixels) using M3dgraControl() with M_THICKNESS. Points are always shown with sides of this length, regardless of how close they are in the view. Opacity You can specify the opacity of the points using M3dgraControl() with M_OPACITY. An opacity of 100 means that the point cloud 3D graphic is completely opaque, while an opacity of 0 means that the point cloud 3D graphic is completely transparent. Coloring points If you select a point cloud container to a 3D display, its points are displayed with the color of their corresponding intensity or reflectance component value. You can specify to color the points based on a different component of the container using M3dgraControl() with M_COLOR_COMPONENT, or to use only a single band of a component using M_COLOR_COMPONENT_BAND. For example, if you specify to use the third band (Z-coordinates) of the range component, points that have higher Z-coordinates will be shown brighter. This can be useful for emphasizing height differences. Points converted from a depth map image buffer are colored based on their height. You can display points with a single solid color using M_COLOR_COMPONENT to M_NULL. All points will then have the color specified by M_COLOR. Dynamic range In some cases, the data that you use to color your points might not use all of the available dynamic range. For example, the intensity component might only have values between 20 and 30, even if it is an 8-bit buffer than can hold 256 possible values. The difference between these grayscale values would be difficult to discern when shown in the 3D display. You can improve visibility of this difference by specifying the dynamic range of the point color values using M3dgraControl() with M_COLOR_LIMITS. The source color values of each point will be normalized to this scale when determining what color to show (for example, if the maximum value is set to 30 then any intensity component value of 30 or higher will be shown as pure white). The default value for M_COLOR_LIMITS is M_BUFFER_LIMITS, which uses the full available dynamic range of the component. You can specify that MIL will automatically determine the dynamic range from the extremes of the data by setting M_COLOR_LIMITS to M_DATA_EXTREMES_GLOBAL or M_DATA_EXTREMES_PER_BAND. If you change M_COLOR_LIMITS to M_USER_DEFINED, you can use M_COLOR_LIMITS_MIN and M_COLOR_LIMITS_MAX to specify values manually. You cannot manually specify a different minimum/maximum per band. To use different values for each band, you must specify M_DATA_EXTREMES_PER_BAND. Applying LUTs You can use a LUT to color the points of a point cloud graphic. To quickly apply a LUT that maps the point cloud range component's Z-band to establish the color of the corresponding point, use M3ddispLut(). Alternatively, enable M_COLOR_USE_LUT using M3dgraControl(), and set the required component and band with M_COLOR_COMPONENT and M_COLOR_COMPONENT_BAND, respectively. The default LUT is M_COLORMAP_TURBO. Other predefined LUTs are available, or you can specify a user-defined LUT buffer. To change the LUT used for a point cloud graphic, use either M3ddispLut() or M3dgraCopy() with the point cloud graphic's label. Note that M3ddispLut() is useful for the most common scenario, that of applying color to the third band (Z-band) of the point cloud's range component. You cannot change the component or band that M3ddispLut() uses; you can only specify which LUT and to which point cloud graphic(s) it applies. For any other settings, use M3dgraControl() and M3dgraCopy() as described above. Meshed point cloud containers You can display a 3D-displayable meshed point cloud container as a full 3D model, or as a standard point cloud. By default, triangles in the mesh are shown as filled polygons in the 3D display. If there are points that are not part of the mesh, those points are still shown as squares. You can change how mesh data in the point cloud container is shown using M3dgraControl() with M_APPEARANCE: You can specify that triangles in the mesh are shown as filled polygons in the 3D display, using M_SOLID. If a color component is set for the 3D graphic (using M3dgraControl() with M_COLOR_COMPONENT) the triangles of the mesh are colored by interpolating between the colors of their vertices. Otherwise, the color of all of the triangles is set using M3dgraControl() with M_FILL_COLOR. You can specify that edges of the mesh are shown as lines in the 3D display, using M_WIREFRAME. If a color component is set for the 3D graphic (using M3dgraControl() with M_COLOR_COMPONENT) the lines of the wireframe are colored by interpolating between the colors of their vertices. Otherwise, the color of all of the lines is set using M3dgraControl() with M_COLOR. The lines are always shown with the thickness (in pixels) indicated by M_THICKNESS, regardless of how close they are in the view. You can specify that triangles and edges of the mesh are shown as filled polygons and wireframes simultaneously in the 3D display, using M_SOLID_WITH_WIREFRAME. The filled polygons are shown with the visible edges of the wireframe on top. The color and thickness settings used with M_SOLID and M_WIREFRAME are also used with this mode. You can specify that the mesh is ignored, using M_POINTS. The point cloud is shown as though it has no associated mesh information. Color and display settings for 3D data Point size Opacity Coloring points Dynamic range Applying LUTs Meshed point cloud containers ",
      "wordCount": 1160,
      "subEntries": []
    },
    {
      "id": "UG_3D_Display_and_graphics_Manipulating_the_view",
      "version": null,
      "title": "Manipulating the view",
      "subTitles": [
        "View settings",
        "Fundamental settings that control the view position and rotation",
        "Alternative view settings",
        "View orientation and distance",
        "Zooming",
        "Level of detail",
        "Azimuth, elevation, roll, and distance",
        "Orbit, up-vector, and distance",
        "Scrolling",
        "View box",
        "View matrix",
        "Other 3D display controls",
        "Changing the background",
        "Rotation indicator",
        "Auto-rotation",
        "Depth sorting"
      ],
      "location": "MIL UG P06: 3D related information",
      "pageURL": "content\\UserGuide\\3D_Display_and_graphics\\Manipulating_the_view.htm",
      "text": " Manipulating the view MIL 3D graphics are 3D shapes that can be viewed from any angle (this includes 3D graphics associated with depth map image buffers and 3D-displayable containers). A 3D graphics list is a collection of these 3D shapes. When a 3D display is shown, a specific view of the contents of the 3D graphics list is rendered on the screen. You can manipulate the view of a 3D display, either interactively using the keyboard and mouse or within your application using M3ddispSetView() and M3ddispControl(). You can change the keyboard control bindings, or disable the ability to manipulate the view interactively, using M3ddispControl() with M_ACTION_KEY_... or M_KEYBOARD_USE / M_MOUSE_USE, respectively. View settings The view is defined by 4 fundamental settings, set using M3ddispControl() and M3ddispSetView(). All other operations that you can perform using M3ddispSetView() are alternate methods for changing the fundamental settings. For example, the M_ROLL operation modifies the view's M_UP_VECTOR control type setting. Fundamental settings that control the view position and rotation The following fundamental view settings are available with M3ddispSetView(). M_VIEWPOINT: The position from which the view is looking. M_INTEREST_POINT: The position the view is looking at. This point is always at the center of the window. M_UP_VECTOR: The vector which defines what is \"up\" for the view. This vector is normalized and perpendicular to the view's line of sight. If you specify an up-vector that is not perpendicular to the line of sight, an appropriate, valid vector will automatically be calculated. These settings define the position and rotation of your view, as shown in the following image: M_FOV_HORIZONTAL_ANGLE / M_FOV_VERTICAL_ANGLE: The angles which determine how wide the view is. Increasing one of these angles has an effect similar to using a wider angle lens on a camera. To prevent distortion, MIL automatically updates these angles to have the same ratio as the horizontal and vertical resolution of the window. For example, if the user increases the horizontal window size, the horizontal FoV will automatically be increased proportionally. Alternative view settings You can use operations in M3ddispSetView() to define the viewpoint, interest point, and up-vector based on alternative models. You can use any combination of these models to manipulate the view in your 3D display. For example, you can set the initial view using M_VIEW_BOX, and then use M_AZIMUTH to rotate the viewpoint around the interest point. If one of the operations described below could achieve the specified result by moving either the viewpoint or interest point (for example, M_VIEW_ORIENTATION), the viewpoint will be moved unless the combination value M_MOVE_INTEREST_POINT is used. View orientation and distance You can define the view by specifying the orientation of the viewpoint relative to the interest point using the M_VIEW_ORIENTATION operation. Either choose from the preset orientations or specify your own orientation vector. You can select a preset orientation using keyboard keys or using M3ddispSetView() (for example, with M_BOTTOM_TILTED). The available preset orientations are as follows: Preset view Keyboard key Use M3ddispSetView() with Bottom tilted 1 M_BOTTOM_TILTED Bottom 2 M_BOTTOM_VIEW Front 3 M_FRONT_VIEW Left 4 M_LEFT_VIEW Rear 5 M_REAR_VIEW Right 6 M_RIGHT_VIEW Top tilted 7 M_TOP_TILTED Top 8 M_TOP_VIEW You can enable or disable the keyboard controls using M3ddispControl() with M_KEYBOARD_USE. Alternatively, you can specify your own orientation vector. The vector that you specify is normalized and multiplied by M_DISTANCE, and the view is changed so that the viewpoint is offset from the interest point by the resulting vector. Similarly, you can use M_DISTANCE to change the distance between the viewpoint and interest point without changing the view orientation. Zooming Zooming moves the viewpoint towards the interest point (zooming in) or moves the viewpoint away from the interest point (zooming out). The following is a list of default keyboard and mouse bindings that allow you to perform zooming or reset the view to the default position and orientation. The table also shows the constants that you can use with M3ddispSetView() to perform these actions programmatically. Action Keyboard button Mouse control Use M3ddispSetView() with Zoom in/out + or - Roll up/down with mouse wheel M_ZOOM or M_DISTANCE Reset view Home key None None The action of zooming will affect the value returned by M3ddispGetView() with M_DISTANCE. Level of detail You can use levels of detail (LoDs) to change the number of points displayed in the 3D display. Degraded LoDs are shown when the 3D display is zoomed out to maintain a similar point density and when manipulating the display. Using LoDs can increase performance while interacting with a 3D display. LoDs are only used for 3D graphics with M_APPEARANCE set to M_POINTS. LoDs are generated once per graphic, per display. If you show the same 3D graphic twice in one display, the LoDs are generated and stored twice. LoDs are regenerated any time the graphic, or one of the LoD related controls is modified. Opacity is automatically adjusted to maintain a similar appearance. For example, if the opacity is 20 and the currently used LoD has half as many points as the native LoD, we will use an opacity of 40 instead. Azimuth, elevation, roll, and distance You can define the view in a spherical model that is always aligned with the working coordinate system of the 3D display using operations such as M_AZIM_ELEV_ROLL. Using this model, the viewpoint is always a fixed distance (specified using M_DISTANCE) from the interest point. M_AZIMUTH is the rotation (between 0 and 360 degrees) around the interest point in the plane that intersects the interest point and is parallel to the XY-plane of the working coordinate system of the 3D display. M_ELEVATION is the vertical rotation (between -90 and 90 degrees) around the interest point. M_ROLL is the rotation (between 0 and 360 degrees) of the view around pole described by the viewpoint and interest point. The up-vector is determined based on the elevation and roll. Note that for elevation settings that are close to 90 or -90, MIL cannot deterministically calculate the azimuth and roll of the view. In this case, inquiring the azimuth or roll will return practically random values. Similarly, setting the azimuth or roll with the combination value M_COMPOSE_WITH_CURRENT will not produce reliable results. By moving the view point, you can roll the view left or right as well as rotate the view up, down, left or right. The following is a list of the default keyboard and mouse bindings that allow you to perform rolls and rotations. The table also shows the constants that you can use with M3ddispSetView() to perform these actions programmatically. Action Keyboard button Mouse control Use M3ddispSetView() with Roll left/right Left or Right arrow +Alt Hold mouse wheel and drag M_ROLL Rotate up/down Up or Down arrow +Alt +Shift None M_ELEVATION Rotate left/right Left or Right arrow +Alt +Shift None M_AZIMUTH Orbit, up-vector, and distance You can define the view in a spherical model that is relative to the current position and orientation of the view using M_ORBIT_HORIZONTAL and M_ORBIT_VERTICAL. Using this model, the viewpoint is always a fixed distance (specified using M_DISTANCE) from the interest point. When you use M_ORBIT_VERTICAL, the viewpoint orbits around the interest point in the direction of the up-vector by the specified number of degrees. When you use M_ORBIT_HORIZONTAL, the viewpoint orbits around the interest point in the direction perpendicular the up-vector by the specified number of degrees. Unlike azimuth and elevation, vertical and horizontal orbit are always specified relative to the current position and orientation of the view. For example, repeatedly using M3ddispSetView() with M_ORBIT_HORIZONTAL and the value 90 will repeatedly orbit the viewpoint around the interest point, in 90 degree increments. The following animation shows the effect of setting the horizontal and vertical orbit of the view, in relation to the up-vector and the working coordinate system of the 3D display. The following is a list of the default keyboard and mouse bindings that allow you to perform orbits. The table also shows the constants that you can use with M3ddispSetView() to perform these actions programmatically. Action Keyboard button Mouse control Use M3ddispSetView() with Orbit up/down Up or Down arrow keys Left-click and drag vertically M_ORBIT_VERTICAL Orbit left/right Left or Right arrow keys Left-click and drag horizontally M_ORBIT_HORIZONTAL Scrolling Scrolling works by moving both the viewpoint and the interest point in a certain direction. The following is a list of scrolls that can be performed in the display and their corresponding default keyboard and mouse bindings. The table also shows the constants that you can use with M3ddispSetView() to perform these actions programmatically. Action Keyboard button Mouse control Use M3ddispSetView() with Scroll left/right Left or Right arrow +Shift Right-click and drag horizontally M_TRANSLATE (Param 1) Scroll in/out Up or Down arrow +Alt None M_TRANSLATE (Param 2) Scroll up/down Up or Down arrow +Shift Right-click and drag vertically M_TRANSLATE (Param 3) View box You can configure the view to show either the whole scene or only a specified area of it. To view the whole scene, use M3ddispSetView() with M_VIEW_BOX set to M_WHOLE_SCENE. This establishes a hypothetical box that encompasses everything in the 3D display's 3D graphics list, and ensures that it is all visible. Alternatively, you can define the view to show only things within a specified area using the M_VIEW_BOX operation and specifying a 3D box geometry object (previously allocated using M3dgeoAlloc() and, for example, defined using M3dgeoBox()). The M_VIEW_BOX operation keeps the viewpoint and interest point in the same orientation relative to each other (M_VIEW_ORIENTATION does not change), but moves the viewpoint and interest point such that the interest point is at the center of the scene/box geometry object, and the viewpoint is the correct distance away to show the entire region defined by the box. View matrix You can define the view by specifying a transformation matrix using M_VIEW_MATRIX. If the transformation matrix is the identity matrix, the viewpoint will be at (0,0,1), with the interest point at the origin (0,0,0) and an up-vector of (0,1,0). This can also be thought of as a direct top-down view, with the up-vector aligned with the Y-axis. You can store the current transformation matrix of the view using M3ddispCopy(), and then restore the same view later using M3ddispSetView() with M_VIEW_MATRIX. Other 3D display controls You can define other aspects of the 3D display, including the background, rotation indicator, whether the view rotates automatically, and the depth sorting mode. Changing the background By default, the background of a 3D display is a vertical gradient with colors suitable for viewing most objects. Optionally, you can change the background settings using M3ddispControl(). You can change the background mode with M_BACKGROUND_MODE. You can specify to show the background as a solid color with the M_SINGLE_COLOR setting, or to show a background image using the M_BACKGROUND_IMAGE setting. You can change the colors of the background with the M_BACKGROUND_COLOR and M_BACKGROUND_COLOR_GRADIENT settings. When the background is a gradient, M_BACKGROUND_COLOR is the color at the top of the 3D display and M_BACKGROUND_COLOR_GRADIENT is the color at the bottom of the 3D display. To set the background image, copy an 8-bit unsigned image buffer to the 3D display using M3ddispCopy() with M_BACKGROUND_IMAGE. If the background image has a different aspect ratio than the window, the image will be stretched in the 3D display. You can determine the size and number of bands of the current background image buffer using M3ddispInquire() with M_BACKGROUND_IMAGE_SIZE_.... Rotation indicator You can enable a visual indicator of the orientation of the view, using M3ddispControl() with M_ROTATION_INDICATOR. The rotation indicator is always positioned at the interest point and is always rotated so that it is aligned with the working coordinate system of the 3D display. Auto-rotation You can have the view automatically rotate around a specified axis, using M3ddispControl() with M_AUTO_ROTATE. This is useful for showing a whole 3D scene without user input. By default, the view auto-rotates around the first 3D graphic added to the internal 3D graphics list of the 3D display. You can change the auto-rotation axis using M3ddispCopy() with M_ROTATION_AXIS and the MIL identifier of a 3D line geometry object. Note that both the viewpoint and the interest point move during auto-rotation. Some users might be disoriented by the view rotating around an axis that does not intersect the interest point, especially when the rotation indicator is enabled. The following table shows the default keyboard binding that allows you to perform auto-rotation. It also shows the function and constant to use if you want to perform this action programmatically. Action Keyboard button Use M3ddispControl() with Auto-rotate R key M_AUTO_ROTATE Depth sorting The depth sorting mode determines how MIL resolves transparency errors related to semi-opaque (semi-transparent) 3D graphics that are shown in the 3D display. You can set the depth sorting mode using M3ddispControl(), with M_TRANSPARENCY_SORT_MODE. The default depth sorting mode is depth peeling (M_DEPTH_PEELING), which resolves most transparency sorting errors. GPU usage might increase when depth peeling is enabled and there is a single complex semi-opaque 3D graphic or multiple semi-opaque 3D graphics in the 3D graphics list. However, depth peeling generally does not increase GPU usage unless there are visible transparency errors to be resolved. If enabling depth peeling does not provide acceptable performance, you can set M_TRANSPARENCY_SORT_MODE to M_FAST for fast depth sorting. Fast depth sorting offers maximum performance, but can exhibit significant visual errors when showing semi-opaque 3D graphics, particularly if they intersect with other graphics. For example, in the following case where there is a single complex semi-opaque 3D graphic, depth peeling resolves most transparency errors, whereas fast depth sorting permits transparency errors. Note that depth sorting can alter the appearance of both opaque and semi-opaque co-planar surfaces (for example, if you create two plane graphics with the same position and normal). Manipulating the view View settings Fundamental settings that control the view position and rotation Alternative view settings View orientation and distance Zooming Level of detail Azimuth, elevation, roll, and distance Orbit, up-vector, and distance Scrolling View box View matrix Other 3D display controls Changing the background Rotation indicator Auto-rotation Depth sorting ",
      "wordCount": 2328,
      "subEntries": []
    },
    {
      "id": "UG_3D_Display_and_graphics_Annotating_the_3D_display",
      "version": null,
      "title": "Annotating the 3D display",
      "subTitles": [
        "Types of graphics",
        "Positions of 3D graphics",
        "Point picking",
        "Display settings for 3D graphics",
        "Clipping 3D graphics that extend infinitely",
        "Working with texture images of polygon 3D graphics",
        "Texture mapping"
      ],
      "location": "MIL UG P06: 3D related information",
      "pageURL": "content\\UserGuide\\3D_Display_and_graphics\\Annotating_the_3D_display.htm",
      "text": " Annotating the 3D display You can annotate a 3D display by adding 3D graphics to its 3D graphics list or adding external 3D graphics lists, using functions from the M3dgra...() module. A 3D graphic is a fully 3D object that has a position and orientation in the scene, defined by its transformation matrix and the transformation matrix of its parent graphic. When you create a 3D graphic, you must add it to a 3D graphics list as a child of another 3D graphic. For more information on 3D graphics lists and the 3D graphics hierarchy, see the 3D graphics lists section later in this chapter. You can remove an existing 3D graphic using M3dgraRemove(). Types of graphics You can add the following kinds of 3D graphics: Types of MIL 3D graphics A point cloud graphic, generated from a 3D-displayable point cloud container or fully corrected depth map image buffer, using M3dgraAdd(), M3ddispSelect(), or M3ddispSelectWindow(). By default, it is linked to the container or image buffer. A meshed point cloud graphic, generated from a meshed 3D-displayable point cloud container, using M3dgraAdd(), M3ddispSelect(), or M3ddispSelectWindow(). By default, it is linked to the container. A dots graphic, generated from coordinate arrays, using M3dgraDots(). Note that a dots graphic is not generated from a container or image buffer. A box, using M3dgraBox(). A cylinder, using M3dgraCylinder(). A sphere, using M3dgraSphere(). An axis, using M3dgraAxis(). A line, using M3dgraLine(). One or more lines using M3dgraLines() An arc, using M3dgraArc(). A plane, using M3dgraPlane(). A grid, using M3dgraGrid(), with M_APPEARANCE set to M_WIREFRAME. A filled grid, using M3dgraGrid(), with M_APPEARANCE set to M_SOLID. A polygon, using M3dgraPolygon(). A rectangle, using M3dgraRect() A textured polygon, using M3dgraPolygon(). A textured polygon with portions cut-out, using M3dgraPolygon() with an M_KEYING_COLOR specified. 3D Text, using M3dgraText(). You can also add a node, an invisible 3D graphic you can use to organize other 3D graphics in the 3D graphics list, using M3dgraNode(). Positions of 3D graphics Every 3D graphic has a transformation matrix that determines the position and rotation of the 3D graphic in the 3D display. Some functions that create 3D graphics require you to specify the transformation matrix, while others determine the transformation matrix from another property that you must specify (such as the start position and end position of a line 3D graphic). Some 3D graphics (such as point clouds) are always created with the identity transformation matrix. You can change the transformation matrix of an existing 3D graphic using M3dgraCopy() with M_TRANSFORMATION_MATRIX. Each 3D graphic has a local coordinate system, with a local origin. For example, the local origin of a box 3D graphic is always at the center of the box, and its coordinate system is rotated to match the boxes orientation. When you create a new 3D graphic, you must specify its position and rotation relative to the parent. If the new 3D graphic's position and rotation are specified by a transformation matrix, the transformation matrix you specify will be applied relative to the parent's transformation matrix. If the new 3D graphic's position and rotation are specified by other properties (such as X, Y, and Z-coordinates), those properties are interpreted within the coordinate system of the parent 3D graphics object. Any subsequent changes to the transformation matrix of the parent 3D graphic also change the position and orientation of the child 3D graphic. When you set the transformation matrix of a 3D graphic using M3dgraCopy(), you can specify to use the passed transformation matrix to transform the 3D graphic within the absolute coordinate system, instead of within the coordinate system of the parent 3D graphic. To do this, specify M_RELATIVE_TO_ROOT. MIL calculates the correct transformation matrix within the coordinate system of the parent so that the 3D graphic has the specified transformation matrix in the absolute coordinate system. The local origin and orientation of a 3D graphic's coordinate system is always determined by its transformation matrix. Changing the transformation matrix of the 3D graphic also alters the local origin and orientation of its coordinate system. To determine the local origin and orientation of a particular type of 3D graphic, refer to the function used to create it. Point picking You might want to obtain information about graphics at the mouse's position in a 3D display. In this case, you must allocate a picking context, using M3ddispAlloc() and a 3D picking result buffer, using M3ddispAlloc(). After picking a 3D graphic, using M3ddispPick(), you can retrieve results, such as graphic type, pixel or 3D position, or distance from the view point, using M3ddispGetResult(). Display settings for 3D graphics Each 3D graphic has settings that determine how it is shown in the 3D display. You can change these settings using M3dgraControl(). You can specify the following for most 3D graphics: How the polygons of the 3D graphic are displayed (if the 3D graphic is polygonal), using M_APPEARANCE. You can specify to show filled polygons, a wireframe, filled polygons with a wireframe on top, or only the vertices that define the polygons. The color of the points/dots and lines of the 3D graphic, using M_COLOR. The thickness (in pixels) of the points/dots and lines, using M_THICKNESS. Points/dots are shown as squares; this setting determines the length of each side. The color of the faces (polygons) of the 3D graphic, using M_FILL_COLOR. This setting applies to most 3D graphics when M_APPEARANCE is set to M_SOLID or M_SOLID_WITH_WIREFRAME. How complex the automatically generated mesh of the 3D graphic is, using M_GRAPHIC_RESOLUTION. A higher resolution 3D graphic is displayed using more polygons. This makes the surface of the 3D graphic appear smoother. Displaying a large number of high-resolution 3D graphics might require a more powerful GPU to maintain acceptable performance. The opacity of the 3D graphic, using M_OPACITY. An opacity of 100 means that the 3D graphic is completely opaque, while an opacity of 0 means that the 3D graphic is completely transparent. What type of shading (if any) is used to render the 3D graphic, using M_SHADING (or M_TEXT_SHADING for text 3D graphics). Shaded 3D graphics are shown brighter or darker depending on the viewing angle, giving a visual indication of depth relative to the view in the 3D display. Different types of shading use different models to determine the brightness of each position on the surface of the 3D graphic. In general, this changes how smooth the surface of the 3D graphic appears to be. Whether the 3D graphic is shown in the 3D display, using M_VISIBLE. Clipping 3D graphics that extend infinitely Some types of 3D graphics (such as planes and cylinders) can be added with settings such that they extend infinitely. Every 3D graphics list has a clipping box that limits the size of these 3D graphics. For example, if you add a plane 3D graphic with Size set to M_INFINITE the created plane is clipped to the area that is within the current clipping box of the 3D graphics list. Changes to the clipping box of a 3D graphics list are not applied retroactively to existing 3D graphics, only to 3D graphics added subsequently. By default the clipping box of a 3D graphics list is equal to the bounding box of all 3D graphics currently in the list. You can set the clipping box of a 3D graphics list manually using M3dgraCopy() with SrcMilObjectId set to the MIL identifier of a box 3D geometry object (created using M3dgeoAlloc() and defined using M3dgeoBox()). You can restore the default behavior using M3dgraCopy() with SrcMilObjectId set to M_WHOLE_SCENE. Working with texture images of polygon 3D graphics You can choose to give a polygon 3D graphic an image buffer as a texture when you add it to a 3D graphics list using M3dgraPolygon(), or using M3dgraCopy() with M_COLOR_TEXTURE. If you set M_COLOR_USE_TEXTURE is set to M_TRUE, the polygon is shown with its texture instead of a solid color. Optionally, you can use M_KEYING_COLOR to specify that one color value in the texture is instead shown as transparent. Texture mapping When you add a polygon graphic with a texture to a 3D graphics list using M3dgraPolygon(), you can optionally specify the texture coordinates used to map the texture onto the polygon. If you do not specify texture coordinates, MIL will determine the texture mapping automatically. Typically, you should only use automatic texture mapping for polygons that are rectangles or right-angle triangles with the same aspect ratio as the texture. Otherwise, the texture will be displayed with distortion, as shown in this image. For cases where automatic texture mapping produces warping, you can use texture coordinates to manually specify what position in the texture image buffer each vertex is mapped to. For example, if the first texture coordinate is (5,12), the first vertex is mapped to the center of the pixel at position (5,12) in the texture image buffer, and so on. The faces of the polygon are colored by interpolating between the specified positions. This animation shows how different texture coordinates affect how the texture is shown on an isosceles triangle polygon. Play speed: Default (x1.0) Quarter (x0.25) Half (x0.5) Double (x2.0) Start position: Current image First image Looping: Continuous play Single iteration 1 of 4 Annotating the 3D display Types of graphics Positions of 3D graphics Point picking Display settings for 3D graphics Clipping 3D graphics that extend infinitely Working with texture images of polygon 3D graphics Texture mapping ",
      "wordCount": 1560,
      "subEntries": []
    },
    {
      "id": "UG_3D_Display_and_graphics_3D_graphics_lists",
      "version": null,
      "title": "3D graphics lists",
      "subTitles": [
        "Structure of a 3D graphics list",
        "Controlling settings for multiple 3D graphics",
        "Copying multiple 3D graphics",
        "Removing multiple 3D graphics",
        "Changing the positions of multiple 3D graphics",
        "Render layers",
        "Setting defaults for 3D graphics added to a 3D graphics list"
      ],
      "location": "MIL UG P06: 3D related information",
      "pageURL": "content\\UserGuide\\3D_Display_and_graphics\\3D_graphics_lists.htm",
      "text": " 3D graphics lists You can annotate a 3D display by adding 3D graphics to its 3D graphics list, using functions from the M3dgra...() module. You can also allocate a 3D graphics list that is not associated with a 3D display using M3dgraAlloc(). Structure of a 3D graphics list A 3D graphics list has a node-based tree structure; each 3D graphic (except the root node) has a parent 3D graphic that partially defines its position and orientation. You can also use the tree structure to control multiple 3D graphics with a single call to M3dgraControl(), copy multiple 3D graphics with a single call to M3dgraCopy(), and remove multiple 3D graphics with a single call to M3dgraRemove(). The top of every 3D graphics list tree structure is a M_GRAPHIC_TYPE_NODE 3D graphic called the root node. The root node always has the identity transformation matrix. When you add a 3D graphic to a 3D graphics list, you must specify the label of the parent graphic. You can use M_ROOT_NODE to specify the root node. A point cloud 3D graphic added to the 3D graphics list using M3ddispSelect() or M3ddispSelectWindow() is always added as a child of the root node. Controlling settings for multiple 3D graphics You can control the settings for a 3D graphic and all of its descendents using M3dgraControl() with M_RECURSIVE. This is useful for creating groups of 3D graphics that should have the same settings. For example, you can create a node type graphic using M3dgraNode(), then label the displayed data by creating text 3D graphics (using M3dgraText()) that are children of the node 3D graphic. You can enable or disable visibility for all of these labels at once, using M3dgraControl() with the label of the node 3D graphic, M_VISIBLE, and M_RECURSIVE. Note that this works even though the node 3D graphic itself does not support the M_VISIBLE setting. Copying multiple 3D graphics You can copy a 3D graphic and/or all of its descendents using M3dgraCopy() with M_GRAPHIC the label of the source 3D graphic to copy, and the label of the destination 3D graphic (in the same 3D graphics list, or a different one) to be the parent of the copy. If you specify M_RECURSIVE, all descendents of the source 3D graphic are also copied. The hierarchy of the source 3D graphics is maintained in the copies; the source 3D graphic is copied as a child of the destination 3D graphic, and the children of the source 3D graphic are copied as children of that copy. If you specify M_CHILDREN_ONLY, only the descendents of the source 3D graphic are copied. The children of the source 3D graphic are copied as children of the destination 3D graphic; the hierarchy is maintained for their descendents. Removing multiple 3D graphics You can remove a 3D graphic using M3dgraRemove(). This also removes all of the 3D graphic's descendents. Changing the positions of multiple 3D graphics You can change the transformation matrix of a 3D graphic using M3dgraCopy() with M_TRANSFORMATION_MATRIX. The position and orientation of a 3D graphic is determined by adding its transformation matrix to the transformation matrix of its ancestors. You can therefore change the position and/or orientation of multiple 3D graphics by altering the transformation matrix of their parent. For example, you can add the 3D graphics used to annotate a particular point cloud as children of the point cloud 3D graphic. If you change the transformation matrix of the point cloud 3D graphic, all of the annotations automatically move with it. Render layers Normally 3D objects are rendered with proper respect for depth; that is, if one object is in front of another, it will properly occlude the other object. However, sometimes it is desirable to ensure that a 3D object is always drawn on top of the others, regardless of the actual position of each object. This is achieved by putting different objects on different \"layers\", where graphics on higher levels are always drawn completely in front of graphics on lower layers. Graphics on the same layer are rendered with proper respect for depth. This is useful, for example, to create label text that is always visible in the 3D display, regardless of the view of the scene. Setting defaults for 3D graphics added to a 3D graphics list You can control the default values for 3D graphics added to a 3D graphics list using M3dgraControl() with M_DEFAULT_SETTINGS. Any 3D graphics that you subsequently add to the 3D graphics list will be created with these settings. You can set the default colormap LUT of the 3D graphics list using M3dgraCopy() with M_DEFAULT_SETTINGS. For example, you can copy the M_COLORMAP_HOT colormap into the 3D graphics list so that subsequent point cloud graphics will, by default, use this colormap. If you change the default, it will not affect the 3D graphics that are already in the 3D graphics list. 3D graphics lists Structure of a 3D graphics list Controlling settings for multiple 3D graphics Copying multiple 3D graphics Removing multiple 3D graphics Changing the positions of multiple 3D graphics Render layers Setting defaults for 3D graphics added to a 3D graphics list ",
      "wordCount": 853,
      "subEntries": []
    },
    {
      "id": "UG_3D_Display_and_graphics_Interactive_3D_graphics",
      "version": null,
      "title": "Interactive 3D graphics",
      "subTitles": [
        "Handle graphics",
        "Hooking a function to a 3D graphics list event "
      ],
      "location": "MIL UG P06: 3D related information",
      "pageURL": "content\\UserGuide\\3D_Display_and_graphics\\Interactive_3D_graphics.htm",
      "text": " Interactive 3D graphics You can interactively edit box graphics. This can be useful to, for example, interactively define a box graphic that covers a required region, and then use the graphic to define a 3D box geometry that delimits a required region. Note you can only interactively edit box graphics. The following steps provide a basic methodology for enabling and controlling interactivity with box graphics: Inquire the identifier of the internal 3D graphics list of a 3D display, using M3ddispInquire() with M_3D_GRAPHIC_LIST_ID. Note that a 3D display is always associated with the same 3D graphics list, which is automatically allocated and freed at the same time as the 3D display. To display the contents of another 3D graphics list on a 3D display, you can copy the contents of the source 3D graphics list into the 3D display's internal 3D graphics list using M3dgraCopy(). Add or draw a box graphic into the internal 3D graphics list of the 3D display. You can add a box graphic to the 3D graphics list using M3dgraBox(). Alternatively, you can draw a box graphic, using M...Draw3d(). If necessary, change how the box graphic will appear when editable using M3dgraControl() with M_EDITABLE_...(). Optionally, hook a function to the 3D graphics list event caused each time the box graphic is interactively modified, using M3dgraHookFunction() with M_EDITABLE_GRAPHIC_MODIFIED. Make the graphic interactive using M3dgraControl() with M_EDITABLE. This adds handles to the box when it is displayed so that you can modify it interactively. Only one box graphic is editable at a time. When the graphic is editable interactively, you can re-size the graphic, move the graphic's position, or rotate the graphic. To resize the graphic, click and drag on a scaling handle (shown as a brown cube on each face). To move the graphic's position, click and drag on one of its axes (or an axis arrowhead). To rotate the graphic, click and drag on one of the curved arcs that sit at the center of the displayed box graphic. If necessary, you can change which box graphic is editable, by disabling interactivity for one and enabling it for another, using M3dgraControl() with M_EDITABLE. The following animation shows how the graphic is manipulated with the mouse. The selectable handles of an interactively editable box graphic make it easily identifiable. To change the graphic's color, appearance, and opacity, use M3dgraControl() with M_EDITABLE_COLOR, M_EDITABLE_APPEARANCE, and M_EDITABLE_OPACITY, respectively. These control types apply to the 3D graphics list, so the specified settings will apply even when you switch to a different interactively editable graphic. Handle graphics It is possible to specify that a 3D graphic is a handle, meaning it can be either translated or rotated using the mouse. You can also specify a target graphic for the handle. When the handle is interacted with, its motion is applied to the target. You can specify several different handles that are all children of one root node and have their motion applied to that shared node. Note that the target is not required to be the parent of the handle graphics. Hooking a function to a 3D graphics list event The MIL 3D Graphics module allows you to hook a function to a 3D graphics list event using M3dgraHookFunction() with M_EDITABLE_GRAPHIC_MODIFIED; the associated function will automatically be triggered whenever the interactive box graphic is modified. For example, the hooked function can use the new position and size of the box graphic to reposition and resize a box geometry object used for cropping, using M3dgraCopy() with M_GEOMETRY. For an example of using M3dgraHookFunction() in an application with an interactive box graphic, see: m3dgrainteractive.cpp To run this example, use the Matrox Example Launcher in the MIL Control Center. You can also hook a function to a handle graphic event using M3dgraHookFunction() with M_HANDLE_GRAPHIC_CLICKED, M_HANDLE_GRAPHIC_ROTATED, or M_HANDLE_GRAPHIC_TRANSLATED; the associated function will automatically be triggered whenever the handle graphic is clicked, rotated, or translated respectively. Note that if the handle graphic is a target, M3dgraGetHookInfo() will return information about the target graphic rather than the handle graphic that was manipulated. Interactive 3D graphics Handle graphics Hooking a function to a 3D graphics list event ",
      "wordCount": 689,
      "subEntries": []
    }
  ]
}]
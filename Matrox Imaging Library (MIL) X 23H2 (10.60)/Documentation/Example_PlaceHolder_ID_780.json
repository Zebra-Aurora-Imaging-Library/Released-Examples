[{
  "id": "Example_PlaceHolder_ID",
  "version": "2024020714",
  "title": "Example_PlaceHolder_Title",
  "wordCount": 0,
  "subEntries": [
    {
      "id": "Examples_Processing_Classification_ClassAnomalyDetectionCompleteTrain_CPP_classanomalydetectioncompletetrain_cpp",
      "version": "2024020714",
      "title": "classanomalydetectioncompletetrain.cpp",
      "location": "Sample Code from MIL Examples",
      "text": " Top //************************************************************************************* // // File name: ClassAnomalyDetectionCompleteTrain.cpp // Location: See Matrox Example Launcher in the MIL Control Center // // // Synopsis: This program uses the classification module to train // a context that can detect anomalies on the top of glass bottles. // // Note: GPU training can be enabled with a MIL update for 64-bit. // This can dramatically increase the training speed. // // Copyright (C) Matrox Electronic Systems Ltd., 1992-2024. // All Rights Reserved #include &lt;mil.h&gt; #include &lt;windows.h&gt; #include &lt;algorithm&gt; #include &lt;cstdlib&gt; //============================================================================== // Example description. //============================================================================== void PrintHeader() { MosPrintf( MIL_TEXT(\"[EXAMPLE NAME]\\n\") MIL_TEXT(\"ClassAnomalyDetectionCompleteTrain\\n\\n\") MIL_TEXT(\"[SYNOPSIS]\\n\") MIL_TEXT(\"This example trains an anomaly detection classifier to detect\\n\") MIL_TEXT(\"defects on the top of glass bottles.\\n\") MIL_TEXT(\"The first step imports the dataset.\\n\\n\") MIL_TEXT(\"Only defect-free images are required for training the classifier.\\n\") MIL_TEXT(\"The training dataset is used to learn the representation of defect-free images.\\n\") MIL_TEXT(\"The development dataset is used to determine the threshold.\\n\") MIL_TEXT(\"Optionally, we can use a test dataset with anomalous images to obtain\\n\") MIL_TEXT(\"a more optimal threshold.\\n\") MIL_TEXT(\"There are no labeling requirements for the train and development datasets.\\n\") MIL_TEXT(\"The only requirement is that they contain no anomalous images.\\n\") MIL_TEXT(\"The test dataset is only labeled to compute statistics on it.\\n\") MIL_TEXT(\"It can be labeled as a classification or segmentation dataset\\n\") MIL_TEXT(\"depending on the type of statistics desired.\\n\\n\") MIL_TEXT(\"The second step crops the images of the dataset.\\n\\n\") MIL_TEXT(\"This is done to speed up training and inference time, as well\\n\") MIL_TEXT(\"as reduce the memory requirements of the training.\\n\\n\") MIL_TEXT(\"The third step trains the classifier context.\\n\\n\") MIL_TEXT(\"The final step performs predictions on a test dataset using the trained anomaly\\n\") MIL_TEXT(\"detection classifier as a final check of its performance.\\n\\n\") MIL_TEXT(\"[MODULES USED]\\n\") MIL_TEXT(\"Modules used: application, system, display, buffer,\\n\") MIL_TEXT(\"graphic, classification, blob, geometric model finder.\\n\\n\")); } //============================================================================== // Constants. //============================================================================== #define EXAMPLE_IMAGE_ROOT_PATH M_IMAGE_PATH MIL_TEXT(\"Classification/BottleInspection/\") #define EXAMPLE_DATASET_ROOT_PATH EXAMPLE_IMAGE_ROOT_PATH MIL_TEXT(\"trainset\") #define EXAMPLE_TEST_DATASET_ROOT_PATH EXAMPLE_IMAGE_ROOT_PATH MIL_TEXT(\"testset\") #define EXAMPLE_TRAINED_CONTEXT_FILENAME MIL_TEXT(\"BottleInspection.mclass\") #define EXAMPLE_PRETRAINED_PATH EXAMPLE_IMAGE_ROOT_PATH EXAMPLE_TRAINED_CONTEXT_FILENAME #define EXAMPLE_TRAIN_DESTINATION_PATH MIL_TEXT(\"Train/\") #define EXAMPLE_ANOMALY_DETECTION_FOLDER_PATH MIL_TEXT(\"AnomalyFolder/\") #define SIZE_X 525 #define SIZE_Y 525 #define SAMPLES_FIXED_SIZE 500 #define SAMPLING_MODE M_GLOBAL_SAMPLING // Try M_ITERATIVE_SAMPLING if running out of memory #define MINI_BATCHES_PER_SAMPLING 20 // and maximize the mini batches per sampling to utilize GPU memory. //#define RESIZE_IMAGES // Uncomment this if you want to resize to the above image size instead of crop. //#define SKIP_MOD_FIND // Uncomment this if you are using your own dataset. //============================================================================== // Enums. //============================================================================== enum EDrawModes: MIL_INT { eDrawHeatmap, eDrawMask, eDrawContour, eDrawReconstructed, eNumDrawModes, }; class CTrainEvolutionDashboard; //============================================================================== // Structs. //============================================================================== struct SPredictedEntryData { SPredictedEntryData(MIL_INT NbEntries) : m_NbEntries(NbEntries) { } MIL_INT m_NbEntries = 0; }; struct SSampleAddedHookData { SSampleAddedHookData(MIL_INT SamplesPerIteration, CTrainEvolutionDashboard* pTrainDashboard) : m_SamplesPerIteration(SamplesPerIteration) , m_pTrainDashboard(pTrainDashboard) {} CTrainEvolutionDashboard* m_pTrainDashboard = nullptr; MIL_INT m_NumberOfIterations {0}; MIL_INT m_SamplesPerIteration; MIL_DOUBLE m_IterationTime = 0.0; }; struct SPrepareEntryPreHookData { SPrepareEntryPreHookData(MIL_ID MilSystem) { // Allocate and setup the module finder model. // This will find rings in the images so that we can crop around the center of them. m_ModCtx = MmodAlloc(MilSystem, M_GEOMETRIC, M_DEFAULT, M_UNIQUE_ID); m_ModRes = MmodAllocResult(MilSystem, M_DEFAULT, M_UNIQUE_ID); MmodDefine(m_ModCtx, M_RING, M_ANY, 184.5, 230.0, M_DEFAULT, M_DEFAULT); MmodControl(m_ModCtx, M_CONTEXT, M_SPEED, M_LOW); MmodControl(m_ModCtx, M_CONTEXT, M_NUMBER, 1); MmodControl(m_ModCtx, M_CONTEXT, M_SEARCH_ANGLE_RANGE, M_DISABLE); MmodPreprocess(m_ModCtx, M_DEFAULT); } MIL_UNIQUE_MOD_ID m_ModCtx; MIL_UNIQUE_MOD_ID m_ModRes; }; //============================================================================== // Classes. //============================================================================== class CTrainEvolutionDashboard { public: CTrainEvolutionDashboard( MIL_ID MilSystem, MIL_ID TrainCtx, MIL_INT NbTrainImages, MIL_INT TrainImageSizeX, MIL_INT TrainImageSizeY, MIL_INT TrainEngineUsed, const MIL_STRING&amp; TrainEngineDescription); ~CTrainEvolutionDashboard(); void AddSampleData( MIL_DOUBLE SampleLoss, MIL_INT SampleIdx, MIL_INT IterationIdx, MIL_INT NbSamplePerIteration, MIL_DOUBLE IterationBench); MIL_ID GetDashboardBufId() const { return m_DashboardBufId; } private: void UpdateSampleLoss(MIL_DOUBLE Loss); void UpdateSampleLossGraph( MIL_DOUBLE SampleLoss, MIL_INT SampleIdx, MIL_INT IterationIdx, MIL_INT NbSamplePerIteration); void UpdateProgression( MIL_INT SampleIdx, MIL_INT IterationIdx, MIL_INT NbSamplePerIteration); void DrawSectionSeparators(); void DrawBufferFrame(MIL_ID BufId, MIL_INT FrameThickness); void InitializeSampleLossGraph(); void WriteGeneralTrainInfo( MIL_INT SamplesFixedSize, MIL_INT TrainImageSizeX, MIL_INT TrainImageSizeY, MIL_INT TrainEngineUsed, const MIL_STRING&amp; TrainEngineDescription); MIL_INT GetNbIterations( MIL_ID TrainCtx, MIL_INT NbTrainImages) const; MIL_UNIQUE_BUF_ID m_DashboardBufId {M_NULL}; MIL_UNIQUE_GRA_ID m_TheGraContext {M_NULL}; MIL_UNIQUE_BUF_ID m_LossInfoBufId {M_NULL}; MIL_UNIQUE_BUF_ID m_LossGraphBufId {M_NULL}; MIL_UNIQUE_BUF_ID m_ProgressionInfoBufId {M_NULL}; MIL_INT m_NbIterations {0}; MIL_INT m_DashboardWidth {0}; MIL_INT m_LastSampleLossPosX {0}; MIL_INT m_LastSampleLossPosY {0}; MIL_INT m_YPositionForSampleLossText {0}; MIL_DOUBLE m_IterationBench {-1.0}; // Constants useful for the graph. const MIL_INT GRAPH_SIZE_X {600}; const MIL_INT GRAPH_SIZE_Y {400}; const MIL_INT GRAPH_TOP_MARGIN {30}; const MIL_INT MARGIN {50}; const MIL_INT SAMPLES_REGION_HEIGHT {190}; const MIL_INT PROGRESSION_INFO_REGION_HEIGHT {100}; const MIL_INT LOSS_MAX {100}; const MIL_INT LOSS_MIN {0}; const MIL_DOUBLE COLOR_GENERAL_INFO {M_RGB888(0, 176, 255)}; const MIL_DOUBLE COLOR_SAMPLE_INFO {M_COLOR_GREEN}; const MIL_DOUBLE COLOR_PROGRESS_BAR {M_COLOR_DARK_GREEN}; }; class CDatasetViewer { public: CDatasetViewer( MIL_ID MilSystem, MIL_ID Dataset, bool DisplayGT); CDatasetViewer( MIL_ID MilSystem, MIL_ID Dataset, bool DisplayGT, MIL_DOUBLE UpperThreshold, MIL_DOUBLE LowerThreshold, const std::vector&lt;MIL_UUID&gt;&amp; IncorrectPredictions); void ViewDataset(); private: void DrawGroundTruthText(); void DrawPredictionText(); void PrintControls() const; void DrawBlobReconstruction(MIL_ID DestBuf); std::pair&lt;MIL_INT, MIL_INT&gt; GetImageSize() const; EDrawModes CycleDisplayMode(); bool ProcessUserInputControl(); void DrawOverlayImage(); void DrawOverlayText(); void DrawPredictionIntoOverlay(); void IncrementImageIndex(); void DecrementImageIndex(); void UpdateEntryIndexAndKey(); void ToggleIncorrectPrediction(); bool IsEntryAnomalous() const; MIL_INT GetNbImages() const; bool NoIncorrectPredictionsToDisplay() const; private: bool m_DisplayGT {false}; bool m_DisplayIncorrectPrediction {false}; const MIL_ID m_System {}; const MIL_ID m_Dataset {}; MIL_UNIQUE_BUF_ID m_ScoresBuf {}; MIL_UNIQUE_BUF_ID m_UpperThresholdMaskBuf {}; MIL_UNIQUE_BUF_ID m_LowerThresholdMaskBuf {}; MIL_UNIQUE_BUF_ID m_BlobReconstructedMaskBuf {}; MIL_UNIQUE_DISP_ID m_Display {}; MIL_UNIQUE_BUF_ID m_DisplayBuffer {}; MIL_UNIQUE_BUF_ID m_GroundTruthImageBuf {}; MIL_UNIQUE_BUF_ID m_GTLut {}; MIL_UNIQUE_GRA_ID m_GraDrawCtx {}; MIL_ID m_MilOverlay {}; MIL_UNIQUE_GRA_ID m_DisGraList {}; MIL_UNIQUE_GRA_ID m_GraTextCtx {}; const MIL_INT m_YMargin {15}; const MIL_INT m_TextHeight {20}; const MIL_INT m_TextMargin {20}; const MIL_INT m_OpacityIncrement {10}; MIL_INT m_TextYPos {0}; MIL_INT m_ImageSizeX {0}; MIL_INT m_ImageSizeY {0}; MIL_DOUBLE m_Opacity {50.0}; MIL_DOUBLE m_UpperThreshold {}; MIL_DOUBLE m_LowerThreshold {}; std::vector&lt;MIL_UUID&gt; m_IncorrectPredictions; std::vector&lt;MIL_INT&gt; m_ClassAnomalous; MIL_INT m_NbClasses {0}; MIL_INT m_NbEntries {0}; MIL_INT m_EntryIndex {0}; MIL_INT m_ImageIndex {0}; MIL_UUID m_EntryKey {M_DEFAULT_KEY}; MIL_STRING m_IndexText; MIL_STRING m_OverlayText; MIL_STRING m_GroundTruthText; MIL_STRING m_PredictionText; EDrawModes m_DisplayPred {EDrawModes::eDrawHeatmap}; }; //============================================================================== // Functions. //============================================================================== MIL_INT CnnTrainEngineDLLInstalled(MIL_ID MilSystem); bool IsTrainingSupportedOnPlatform(MIL_ID MilSystem); void LoadDatasets(MIL_ID MilSystem, MIL_ID Dataset, MIL_ID TestDataset, bool SkipTrain); void PrepareDatasets( MIL_ID MilSystem, MIL_ID TrainDataset, MIL_ID DevDataset, MIL_ID TestDataset, MIL_INT SizeX, MIL_INT SizeY, MIL_ID PreparedTrainDataset, MIL_ID PreparedDevDataset, MIL_ID PreparedTestDataset, bool SkipTrain); void CreateDir(MIL_STRING DirectoryPath); MIL_STRING GetExampleCurrentDirectory(); void PredictUsingTrainedContext( MIL_ID MilSystem, MIL_ID MilDisplay, MIL_ID TrainedCtx, MIL_ID TestDataset); void PrintTrainStatusMessage(MIL_INT Status); void PrintStatCalculateStatusMessage(MIL_INT Status); MIL_STRING ConvertPrepareDataStatusToStr(MIL_INT Status); MIL_STRING ConvertPredictEntryStatusToStr(MIL_INT Status); void SetTrainControls(MIL_ID TrainCtx); MIL_UNIQUE_CLASS_ID TrainTheModel( MIL_ID MilSystem, MIL_ID MilDisplay, MIL_ID PreparedTrainDataset, MIL_ID PreparedDevDataset); void GenerateGroundTruthImageLut(MIL_ID LutBufId); bool AskSkipTraining(); bool AskComputePixelStats(); MIL_DOUBLE ComputeLowerThreshold( MIL_INT Status, MIL_ID StatRes); MIL_INT ComputeStats( MIL_ID MilSystem, MIL_ID StatCtx, MIL_ID StatRes, MIL_ID Dataset, bool IsImageLevel); std::vector&lt;MIL_UUID&gt; GetIncorrectPredictions( MIL_ID StatRes); //============================================================================== // Hook functions. //============================================================================== MIL_INT MFTYPE HookPrepareEntryPreFunc(MIL_INT /*HookType*/, MIL_ID EventId, void* pUserData); MIL_INT MFTYPE HookNumPreparedEntriesFunc(MIL_INT /*HookType*/, MIL_ID EventId, void* pUserData); MIL_INT MFTYPE HookSampleAddedTrainingFunc(MIL_INT /*HookType*/, MIL_ID EventId, void* pUserData); MIL_INT MFTYPE HookPredictedEntryFunc(MIL_INT /*HookType*/, MIL_ID EventId, void* pUserData); //============================================================================== // Main. //============================================================================== int MosMain() { PrintHeader(); MIL_UNIQUE_APP_ID MilApplication = MappAlloc(M_NULL, M_DEFAULT, M_UNIQUE_ID); MIL_UNIQUE_SYS_ID MilSystem = MsysAlloc(M_DEFAULT, M_SYSTEM_HOST, M_DEFAULT, M_DEFAULT, M_UNIQUE_ID); MIL_UNIQUE_DISP_ID MilDisplay = MdispAlloc(MilSystem, M_DEFAULT, MIL_TEXT(\"M_DEFAULT\"), M_DEFAULT, M_UNIQUE_ID); const bool SkipTrain = AskSkipTraining(); if(!SkipTrain &amp;&amp; !IsTrainingSupportedOnPlatform(MilSystem)) { MosPrintf(MIL_TEXT(\"Press any key to end.\\n\")); MosGetch(); return EXIT_FAILURE; } MosPrintf(MIL_TEXT(\"\\n***************************************************************\\n\")); MosPrintf(MIL_TEXT(\"IMPORTING THE DATASETS...\")); MosPrintf(MIL_TEXT(\"\\n***************************************************************\\n\")); MIL_UNIQUE_CLASS_ID Dataset = MclassAlloc(MilSystem, M_DATASET_IMAGES, M_DEFAULT, M_UNIQUE_ID); MIL_UNIQUE_CLASS_ID TestDataset = MclassAlloc(MilSystem, M_DATASET_IMAGES, M_DEFAULT, M_UNIQUE_ID); LoadDatasets(MilSystem, Dataset, TestDataset, SkipTrain); MIL_UNIQUE_CLASS_ID TrainDataset = MclassAlloc(MilSystem, M_DATASET_IMAGES, M_DEFAULT, M_UNIQUE_ID); MIL_UNIQUE_CLASS_ID DevDataset = MclassAlloc(MilSystem, M_DATASET_IMAGES, M_DEFAULT, M_UNIQUE_ID); MclassSplitDataset(M_SPLIT_ANO_CONTEXT_FIXED_SEED, Dataset, TrainDataset, DevDataset, 50, M_NULL, M_DEFAULT); MIL_UNIQUE_CLASS_ID PreparedTrainDataset = MclassAlloc(MilSystem, M_DATASET_IMAGES, M_DEFAULT, M_UNIQUE_ID); MIL_UNIQUE_CLASS_ID PreparedDevDataset = MclassAlloc(MilSystem, M_DATASET_IMAGES, M_DEFAULT, M_UNIQUE_ID); MIL_UNIQUE_CLASS_ID PreparedTestDataset = MclassAlloc(MilSystem, M_DATASET_IMAGES, M_DEFAULT, M_UNIQUE_ID); PrepareDatasets( MilSystem, TrainDataset, DevDataset, TestDataset, SIZE_X, SIZE_Y, PreparedTrainDataset, PreparedDevDataset, PreparedTestDataset, SkipTrain); MIL_UNIQUE_CLASS_ID TrainedCtx; if(SkipTrain) { MosPrintf(MIL_TEXT(\"\\n***************************************************************\\n\")); MosPrintf(MIL_TEXT(\"RESTORING A PRETRAINED CONTEXT...\")); MosPrintf(MIL_TEXT(\"\\n***************************************************************\\n\")); TrainedCtx = MclassRestore(EXAMPLE_PRETRAINED_PATH, MilSystem, M_DEFAULT, M_UNIQUE_ID); MosPrintf(MIL_TEXT(\"Successfully restored the trained context.\\n\\n\")); } else { MosPrintf(MIL_TEXT(\"\\n***************************************************************\\n\")); MosPrintf(MIL_TEXT(\"TRAINING... THIS WILL TAKE SOME TIME...\")); MosPrintf(MIL_TEXT(\"\\n***************************************************************\\n\")); TrainedCtx = TrainTheModel(MilSystem, MilDisplay, PreparedTrainDataset, PreparedDevDataset); } if(TrainedCtx) { MosPrintf(MIL_TEXT(\"\\n***************************************************************\\n\")); MosPrintf(MIL_TEXT(\"PREDICTING USING THE TRAINED CONTEXT...\")); MosPrintf(MIL_TEXT(\"\\n***************************************************************\\n\")); PredictUsingTrainedContext(MilSystem, MilDisplay, TrainedCtx, PreparedTestDataset); MosPrintf(MIL_TEXT(\"\\n*******************************************************\\n\")); MosPrintf(MIL_TEXT(\"COMPUTING METRICS ON THE TESTSET...\\n\")); MosPrintf(MIL_TEXT(\"*******************************************************\\n\\n\")); const bool ComputePixelStats = AskComputePixelStats(); MIL_UNIQUE_CLASS_ID StatCtx = MclassAlloc(MilSystem, M_STAT_ANO, M_DEFAULT, M_UNIQUE_ID); MIL_UNIQUE_CLASS_ID StatRes = MclassAllocResult(MilSystem, M_STAT_ANO_RESULT, M_DEFAULT, M_UNIQUE_ID); const bool IsImageLevel = true; const MIL_INT Status = ComputeStats(MilSystem, StatCtx, StatRes, PreparedTestDataset, IsImageLevel); const MIL_DOUBLE LowerThreshold = ComputeLowerThreshold(Status, StatRes); const std::vector&lt;MIL_UUID&gt; IncorrectPredictions = GetIncorrectPredictions(StatRes); if(ComputePixelStats) { ComputeStats(MilSystem, StatCtx, StatRes, PreparedTestDataset, !IsImageLevel); } MosPrintf(MIL_TEXT(\"\\nPress any key to continue...\\n\")); MosGetch(); MosPrintf(MIL_TEXT(\"\\n*******************************************************\\n\")); MosPrintf(MIL_TEXT(\"VIEWING THE PREDICTED TEST DATASET...\")); MosPrintf(MIL_TEXT(\"\\n*******************************************************\")); // Upper threshold will just use the default value. const MIL_DOUBLE UpperThreshold = 50.0; const bool DisplayGroundTruthFirst = true; CDatasetViewer DatasetViewer( MilSystem, PreparedTestDataset, !DisplayGroundTruthFirst, UpperThreshold, LowerThreshold, IncorrectPredictions); DatasetViewer.ViewDataset(); } else { MosPrintf(MIL_TEXT(\"\\nTraining has not completed properly!\\n\")); MosPrintf(MIL_TEXT(\"Press any key to end.\\n\")); MosGetch(); return EXIT_FAILURE; } MosPrintf(MIL_TEXT(\"Press any key to end...\\n\")); MosGetch(); return 0; } //============================================================================== CTrainEvolutionDashboard::CTrainEvolutionDashboard( MIL_ID MilSystem, MIL_ID TrainCtx, MIL_INT NbTrainImages, MIL_INT TrainImageSizeX, MIL_INT TrainImageSizeY, MIL_INT TrainEngineUsed, const MIL_STRING&amp; TrainEngineDescription) { m_NbIterations = GetNbIterations(TrainCtx, NbTrainImages); const MIL_INT GraphBoxWidth = GRAPH_SIZE_X + 2 * MARGIN; const MIL_INT GraphBoxHeight = GRAPH_SIZE_Y + GRAPH_TOP_MARGIN + MARGIN; m_DashboardWidth = GraphBoxWidth; const MIL_INT DashboardHeight = GraphBoxHeight + SAMPLES_REGION_HEIGHT + PROGRESSION_INFO_REGION_HEIGHT; m_DashboardBufId = MbufAllocColor(MilSystem, 3, m_DashboardWidth, DashboardHeight, 8 + M_UNSIGNED, M_IMAGE + M_PROC + M_DISP, M_UNIQUE_ID); MbufClear(m_DashboardBufId, M_COLOR_BLACK); m_TheGraContext = MgraAlloc(MilSystem, M_UNIQUE_ID); const MIL_INT GraphYPosition = SAMPLES_REGION_HEIGHT; const MIL_INT ProgressionInfoYPosition = GraphYPosition + GraphBoxHeight; // Create child buffers for the different sections of the dashboard. m_LossInfoBufId = MbufChild2d(m_DashboardBufId, 0, 0, GraphBoxWidth, SAMPLES_REGION_HEIGHT, M_UNIQUE_ID); m_LossGraphBufId = MbufChild2d(m_DashboardBufId, 0, GraphYPosition, GraphBoxWidth, GraphBoxHeight, M_UNIQUE_ID); m_ProgressionInfoBufId = MbufChild2d(m_DashboardBufId, 0, ProgressionInfoYPosition, m_DashboardWidth, PROGRESSION_INFO_REGION_HEIGHT, M_UNIQUE_ID); DrawSectionSeparators(); InitializeSampleLossGraph(); MIL_INT SamplesFixesSize = 0; MclassInquire(TrainCtx, M_DEFAULT, M_SAMPLES_FIXED_SIZE + M_TYPE_MIL_INT, &amp;SamplesFixesSize); if(SamplesFixesSize == M_DEFAULT) { MclassInquire(TrainCtx, M_DEFAULT, M_SAMPLES_FIXED_SIZE + M_TYPE_MIL_INT + M_DEFAULT, &amp;SamplesFixesSize); } WriteGeneralTrainInfo(SamplesFixesSize, TrainImageSizeX, TrainImageSizeY, TrainEngineUsed, TrainEngineDescription); } //============================================================================== CTrainEvolutionDashboard::~CTrainEvolutionDashboard() { m_TheGraContext = M_NULL; m_LossInfoBufId = M_NULL; m_LossGraphBufId = M_NULL; m_ProgressionInfoBufId = M_NULL; m_DashboardBufId = M_NULL; } //============================================================================== void CTrainEvolutionDashboard::AddSampleData( MIL_DOUBLE SampleLoss, MIL_INT SampleIdx, MIL_INT IterationIdx, MIL_INT NbSamplePerIteration, MIL_DOUBLE IterationBench) { m_IterationBench = IterationBench; UpdateSampleLoss(SampleLoss); UpdateSampleLossGraph(SampleLoss, SampleIdx, IterationIdx, NbSamplePerIteration); UpdateProgression(SampleIdx, IterationIdx, NbSamplePerIteration); } //============================================================================== MIL_INT CTrainEvolutionDashboard::GetNbIterations( MIL_ID TrainCtx, MIL_INT NbTrainImages) const { MIL_INT TrainMode = 0; MclassInquire(TrainCtx, M_DEFAULT, M_TRAIN_MODE + M_TYPE_MIL_INT, &amp;TrainMode); // When the train mode is M_ITERATIVE_SAMPLING, each iteration will contain // M_MINI_BATCHES_PER_SAMPLING; to compute how many images will be in each sampling, // we simply multiply the mini batches per sampling by the mini batch size. // From there, we can determine the number of iterations simply by dividing the number of // train images by the number of images per sampling. if(TrainMode == M_ITERATIVE_SAMPLING) { MIL_INT MiniBatchSize = 0; MclassInquire(TrainCtx, M_DEFAULT, M_MINI_BATCH_SIZE + M_TYPE_MIL_INT, &amp;MiniBatchSize); if(MiniBatchSize == M_DEFAULT) { MclassInquire(TrainCtx, M_DEFAULT, M_MINI_BATCH_SIZE + M_TYPE_MIL_INT + M_DEFAULT, &amp;MiniBatchSize); } MIL_INT MiniBatchesPerSampling = 0; MclassInquire(TrainCtx, M_DEFAULT, M_MINI_BATCHES_PER_SAMPLING + M_TYPE_MIL_INT, &amp;MiniBatchesPerSampling); const MIL_INT ImagesPerSampling = MiniBatchSize * MiniBatchesPerSampling; return static_cast&lt;MIL_INT&gt;(std::ceil(static_cast&lt;MIL_DOUBLE&gt;(NbTrainImages) / static_cast&lt;MIL_DOUBLE&gt;(ImagesPerSampling))); } // When the training is M_GLOBAL_SAMPLING, there will always be only 1 iteration. else { return 1; } } //============================================================================== void CTrainEvolutionDashboard::UpdateSampleLoss(MIL_DOUBLE SampleLoss) { const MIL_INT TextMargin = MARGIN - 10; MgraControl(m_TheGraContext, M_COLOR, COLOR_SAMPLE_INFO); MIL_TEXT_CHAR LossText[512]; MosSprintf(LossText, 512, MIL_TEXT(\"Current train loss value: %11.7lf\"), SampleLoss); MgraText(m_TheGraContext, m_LossInfoBufId, TextMargin, m_YPositionForSampleLossText, LossText); } //============================================================================== void CTrainEvolutionDashboard::UpdateSampleLossGraph( MIL_DOUBLE SampleLoss, MIL_INT SampleIdx, MIL_INT IterationIdx, MIL_INT NbSamplePerIteration) { const MIL_INT NbSamples = m_NbIterations * NbSamplePerIteration; const MIL_INT CurSample = IterationIdx * NbSamplePerIteration + SampleIdx; const MIL_DOUBLE XRatio = static_cast&lt;MIL_DOUBLE&gt;(CurSample) / static_cast&lt;MIL_DOUBLE&gt;(NbSamples); const MIL_INT CurSampleLossPosX = MARGIN + static_cast&lt;MIL_INT&gt;(XRatio * static_cast&lt;MIL_DOUBLE&gt;(GRAPH_SIZE_X)); const MIL_INT MaxVal = LOSS_MAX; const MIL_INT NbTick = LOSS_MAX - LOSS_MIN; // Saturate to the highest value of the graph. SampleLoss = std::min&lt;MIL_DOUBLE&gt;(SampleLoss, static_cast&lt;MIL_DOUBLE&gt;(MaxVal)); const MIL_DOUBLE YRatio = SampleLoss / MaxVal; const MIL_INT CurSampleLossPosY = GRAPH_TOP_MARGIN + static_cast&lt;MIL_INT&gt;((1.0 - YRatio) * static_cast&lt;MIL_DOUBLE&gt;(GRAPH_SIZE_Y)); MgraControl(m_TheGraContext, M_COLOR, COLOR_SAMPLE_INFO); if(IterationIdx == 0 &amp;&amp; SampleIdx == 0) { MgraDot(m_TheGraContext, m_LossGraphBufId, CurSampleLossPosX, CurSampleLossPosY); } else { MgraLine(m_TheGraContext, m_LossGraphBufId, m_LastSampleLossPosX, m_LastSampleLossPosY, CurSampleLossPosX, CurSampleLossPosY); } m_LastSampleLossPosX = CurSampleLossPosX; m_LastSampleLossPosY = CurSampleLossPosY; MgraControl(m_TheGraContext, M_COLOR, COLOR_GENERAL_INFO); // To clear the previous information. MgraText(m_TheGraContext, m_LossGraphBufId, MARGIN, GRAPH_TOP_MARGIN + GRAPH_SIZE_Y + 25, MIL_TEXT(\" \")); MIL_TEXT_CHAR SampleText[512]; MosSprintf(SampleText, 512, MIL_TEXT(\"Iteration %d :: Sample %d\"), IterationIdx, SampleIdx); MgraText(m_TheGraContext, m_LossGraphBufId, MARGIN, GRAPH_TOP_MARGIN + GRAPH_SIZE_Y + 25, SampleText); } //============================================================================== void CTrainEvolutionDashboard::UpdateProgression(MIL_INT SampleIdx, MIL_INT IterationIdx, MIL_INT NbSamplePerIteration) { const MIL_INT YMargin = 20; const MIL_INT TextHeight = 30; const MIL_INT NbSamples = m_NbIterations * NbSamplePerIteration; const MIL_INT NbSamplesDone = IterationIdx * NbSamplePerIteration + SampleIdx + 1; const MIL_INT NbSamplesRemaining = NbSamples - NbSamplesDone - 1; // Update estimated remaining time. MgraControl(m_TheGraContext, M_COLOR, COLOR_GENERAL_INFO); // Time is estimated using the first full iteration so let's wait until we see how long it takes. if(IterationIdx == 0) { MgraText(m_TheGraContext, m_ProgressionInfoBufId, MARGIN, YMargin, MIL_TEXT(\"Estimated remaining time: N/A\")); } else { const MIL_DOUBLE SampleBenchMean = m_IterationBench / static_cast&lt;MIL_DOUBLE&gt;(NbSamplePerIteration); const MIL_DOUBLE RemainingTime = SampleBenchMean * static_cast&lt;MIL_DOUBLE&gt;(NbSamplesRemaining); MIL_TEXT_CHAR RemainingTimeText[512]; MosSprintf(RemainingTimeText, 512, MIL_TEXT(\"Estimated remaining time: %8.0lf seconds\"), RemainingTime); if(NbSamplesDone == NbSamples) { MgraText(m_TheGraContext, m_ProgressionInfoBufId, MARGIN, YMargin, MIL_TEXT(\"Training completed! \")); } else { MgraText(m_TheGraContext, m_ProgressionInfoBufId, MARGIN, YMargin, RemainingTimeText); } } // Update the progression bar. const MIL_INT ProgressionBarWidth = m_DashboardWidth - 2 * MARGIN; const MIL_INT ProgressionBarHeight = 30; MgraControl(m_TheGraContext, M_COLOR, COLOR_GENERAL_INFO); MgraRectFill(m_TheGraContext, m_ProgressionInfoBufId, MARGIN, YMargin + TextHeight, MARGIN + ProgressionBarWidth, YMargin + TextHeight + ProgressionBarHeight); const MIL_DOUBLE PercentageComplete = static_cast&lt;MIL_DOUBLE&gt;(NbSamplesDone) / static_cast&lt;MIL_DOUBLE&gt;(NbSamples); const MIL_INT PercentageCompleteWidth = static_cast&lt;MIL_INT&gt;(PercentageComplete * ProgressionBarWidth); MgraControl(m_TheGraContext, M_COLOR, COLOR_PROGRESS_BAR); MgraRectFill(m_TheGraContext, m_ProgressionInfoBufId, MARGIN, YMargin + TextHeight, MARGIN + PercentageCompleteWidth, YMargin + TextHeight + ProgressionBarHeight); } //============================================================================== void CTrainEvolutionDashboard::DrawSectionSeparators() { // Draw a frame for the whole dashboard. DrawBufferFrame(m_DashboardBufId, 4); // Draw a frame for each section. DrawBufferFrame(m_LossInfoBufId, 2); DrawBufferFrame(m_LossGraphBufId, 2); DrawBufferFrame(m_ProgressionInfoBufId, 2); } //============================================================================== void CTrainEvolutionDashboard::DrawBufferFrame(MIL_ID BufId, MIL_INT FrameThickness) { const MIL_ID SizeX = MbufInquire(BufId, M_SIZE_X, M_NULL); const MIL_ID SizeY = MbufInquire(BufId, M_SIZE_Y, M_NULL); MgraControl(m_TheGraContext, M_COLOR, COLOR_GENERAL_INFO); MgraRectFill(m_TheGraContext, BufId, 0, 0, SizeX - 1, FrameThickness - 1); MgraRectFill(m_TheGraContext, BufId, SizeX - FrameThickness, 0, SizeX - 1, SizeY - 1); MgraRectFill(m_TheGraContext, BufId, 0, SizeY - FrameThickness, SizeX - 1, SizeY - 1); MgraRectFill(m_TheGraContext, BufId, 0, 0, FrameThickness - 1, SizeY - 1); } //============================================================================== void CTrainEvolutionDashboard::InitializeSampleLossGraph() { // Draw axis. MgraControl(m_TheGraContext, M_COLOR, M_COLOR_WHITE); MgraRect(m_TheGraContext, m_LossGraphBufId, MARGIN, GRAPH_TOP_MARGIN, MARGIN + GRAPH_SIZE_X, GRAPH_TOP_MARGIN + GRAPH_SIZE_Y); MgraControl(m_TheGraContext, M_TEXT_ALIGN_HORIZONTAL, M_RIGHT); const MIL_INT LossRange = LOSS_MAX - LOSS_MIN; const MIL_INT TickIncrement = LossRange / 10; const MIL_DOUBLE TickRatio = TickIncrement / 100.0; MIL_DOUBLE TickNum = 0.0; for(MIL_INT i = LOSS_MAX; i &gt;= LOSS_MIN; i -= TickIncrement) { MIL_TEXT_CHAR CurTickText[128]; MosSprintf(CurTickText, 128, MIL_TEXT(\"%d\"), i); const MIL_INT TickYPos = static_cast&lt;MIL_INT&gt;(TickNum * TickRatio * GRAPH_SIZE_Y); MgraText(m_TheGraContext, m_LossGraphBufId, MARGIN - 5, GRAPH_TOP_MARGIN + TickYPos - 7, CurTickText); MgraText(m_TheGraContext, m_LossGraphBufId, GRAPH_SIZE_X + MARGIN + 25, GRAPH_TOP_MARGIN + TickYPos - 7, CurTickText); if((i != LOSS_MAX) &amp;&amp; (i != LOSS_MIN)) { MgraLine(m_TheGraContext, m_LossGraphBufId, MARGIN, GRAPH_TOP_MARGIN + TickYPos, MARGIN + 5, GRAPH_TOP_MARGIN + TickYPos); MgraLine(m_TheGraContext, m_LossGraphBufId, GRAPH_SIZE_X + MARGIN - 5, GRAPH_TOP_MARGIN + TickYPos, GRAPH_SIZE_X + MARGIN, GRAPH_TOP_MARGIN + TickYPos); } TickNum = TickNum + 1.0; } MgraControl(m_TheGraContext, M_TEXT_ALIGN_HORIZONTAL, M_LEFT); const MIL_INT NbIterationTick = std::min&lt;MIL_INT&gt;(m_NbIterations, 10); const MIL_INT IterationTickValue = m_NbIterations / NbIterationTick; for(MIL_INT CurTick = 1; CurTick &lt;= m_NbIterations; CurTick += IterationTickValue) { const MIL_DOUBLE Percentage = static_cast&lt;MIL_DOUBLE&gt;(CurTick) / static_cast&lt;MIL_DOUBLE&gt;(m_NbIterations); const MIL_INT XOffset = static_cast&lt;MIL_INT&gt;(Percentage * GRAPH_SIZE_X); MgraText(m_TheGraContext, m_LossGraphBufId, MARGIN + XOffset, GRAPH_TOP_MARGIN + GRAPH_SIZE_Y + 5, M_TO_STRING(CurTick - 1)); MgraLine(m_TheGraContext, m_LossGraphBufId, MARGIN + XOffset, GRAPH_TOP_MARGIN + GRAPH_SIZE_Y - 5, MARGIN + XOffset, GRAPH_TOP_MARGIN + GRAPH_SIZE_Y); } } //============================================================================== void CTrainEvolutionDashboard::WriteGeneralTrainInfo( MIL_INT SamplesFixedSize, MIL_INT TrainImageSizeX, MIL_INT TrainImageSizeY, MIL_INT TrainEngineUsed, const MIL_STRING&amp; TrainEngineDescription) { MgraControl(m_TheGraContext, M_BACKGROUND_MODE, M_OPAQUE); MgraControl(m_TheGraContext, M_BACKCOLOR, M_COLOR_BLACK); MgraControl(m_TheGraContext, M_TEXT_ALIGN_HORIZONTAL, M_LEFT); const MIL_INT YMargin = 15; const MIL_INT TextHeight = 20; const MIL_INT TextMargin = MARGIN - 10; MIL_INT TextYPos = YMargin; MgraControl(m_TheGraContext, M_COLOR, COLOR_GENERAL_INFO); MIL_TEXT_CHAR TheString[512]; if(TrainEngineUsed == M_CPU) { MosSprintf(TheString, 512, MIL_TEXT(\"Training is being performed on the CPU\")); } else { MosSprintf(TheString, 512, MIL_TEXT(\"Training is being performed on the GPU\")); } MgraText(m_TheGraContext, m_LossInfoBufId, TextMargin, TextYPos, TheString); TextYPos += TextHeight; MosSprintf(TheString, 512, MIL_TEXT(\"Engine: %s\"), TrainEngineDescription.c_str()); MgraText(m_TheGraContext, m_LossInfoBufId, TextMargin, TextYPos, TheString); TextYPos += TextHeight; MosSprintf(TheString, 512, MIL_TEXT(\"Train image size: %dx%d\"), TrainImageSizeX, TrainImageSizeY); MgraText(m_TheGraContext, m_LossInfoBufId, TextMargin, TextYPos, TheString); TextYPos += TextHeight; MosSprintf(TheString, 512, MIL_TEXT(\"Number of iterations: %d\"), m_NbIterations); MgraText(m_TheGraContext, m_LossInfoBufId, TextMargin, TextYPos, TheString); TextYPos += TextHeight; MosSprintf(TheString, 512, MIL_TEXT(\"Number of samples: %d\"), SamplesFixedSize); MgraText(m_TheGraContext, m_LossInfoBufId, TextMargin, TextYPos, TheString); TextYPos += TextHeight; // The loss will be drawn under later on, so we retain its position. m_YPositionForSampleLossText = TextYPos; } //============================================================================== CDatasetViewer::CDatasetViewer(MIL_ID MilSystem, MIL_ID Dataset, bool DisplayGT) : m_System(MilSystem) , m_Dataset(Dataset) , m_DisplayGT(DisplayGT) { MclassInquire(m_Dataset, M_DEFAULT, M_NUMBER_OF_CLASSES + M_TYPE_MIL_INT, &amp;m_NbClasses); MclassInquire(m_Dataset, M_DEFAULT, M_NUMBER_OF_ENTRIES + M_TYPE_MIL_INT, &amp;m_NbEntries); // Create a lookup table to know which classes are anomalous. m_ClassAnomalous.resize(m_NbClasses, M_FALSE); for(MIL_INT ClassIndex = 0; ClassIndex &lt; m_NbClasses; ++ClassIndex) { MclassInquire(m_Dataset, M_CLASS_INDEX(ClassIndex), M_ANOMALOUS + M_TYPE_MIL_INT, &amp;m_ClassAnomalous[ClassIndex]); } // Get the image size for the dataset. const std::pair&lt;MIL_INT, MIL_INT&gt; ImageSize = GetImageSize(); m_ImageSizeX = ImageSize.first; m_ImageSizeY = ImageSize.second; m_Display = MdispAlloc(m_System, M_DEFAULT, MIL_TEXT(\"M_DEFAULT\"), M_DEFAULT, M_UNIQUE_ID); // Allocate and select the display buffer. m_DisplayBuffer = MbufAllocColor(m_System, 3, m_ImageSizeX, m_ImageSizeY, 8 + M_UNSIGNED, M_IMAGE + M_PROC + M_DISP, M_UNIQUE_ID); MbufClear(m_DisplayBuffer, M_COLOR_BLACK); MdispSelect(m_Display, m_DisplayBuffer); // Get the display overlay id. m_MilOverlay = MdispInquire(m_Display, M_OVERLAY_ID, M_NULL); // Create and associate the graphic list to display. m_DisGraList = MgraAllocList(m_System, M_DEFAULT, M_UNIQUE_ID); MdispControl(m_Display, M_ASSOCIATED_GRAPHIC_LIST_ID, m_DisGraList); // We need a 1-band buffer for the ground truth image and a LUT to display it nicely. m_GroundTruthImageBuf = MbufAlloc2d(m_System, m_ImageSizeX, m_ImageSizeY, 8 + M_UNSIGNED, M_IMAGE + M_PROC, M_UNIQUE_ID); m_GTLut = MbufAllocColor(m_System, 3, 256, 1, 8 + M_UNSIGNED, M_LUT, M_UNIQUE_ID); GenerateGroundTruthImageLut(m_GTLut); // Allocated buffers necessary to perform blob reconstruction. m_UpperThresholdMaskBuf = MbufAlloc2d(m_System, m_ImageSizeX, m_ImageSizeY, 8 + M_UNSIGNED, M_IMAGE + M_PROC, M_UNIQUE_ID); m_LowerThresholdMaskBuf = MbufAlloc2d(m_System, m_ImageSizeX, m_ImageSizeY, 8 + M_UNSIGNED, M_IMAGE + M_PROC, M_UNIQUE_ID); m_BlobReconstructedMaskBuf = MbufAlloc2d(m_System, m_ImageSizeX, m_ImageSizeY, 8 + M_UNSIGNED, M_IMAGE + M_PROC, M_UNIQUE_ID); m_ScoresBuf = MbufAlloc2d(m_System, m_ImageSizeX, m_ImageSizeY, 32 + M_FLOAT, M_IMAGE + M_PROC, M_UNIQUE_ID); // Allocate and set graphic contexts for draws. m_GraDrawCtx = MgraAlloc(m_System, M_UNIQUE_ID); MgraControl(m_GraDrawCtx, M_COLOR, M_COLOR_RED); m_GraTextCtx = MgraAlloc(m_System, M_UNIQUE_ID); MgraControl(m_GraTextCtx, M_COLOR, M_COLOR_WHITE); } //============================================================================== CDatasetViewer::CDatasetViewer( MIL_ID MilSystem, MIL_ID Dataset, bool DisplayGT, MIL_DOUBLE UpperThreshold, MIL_DOUBLE LowerThreshold, const std::vector&lt;MIL_UUID&gt;&amp; IncorrectPredictions) : CDatasetViewer::CDatasetViewer(MilSystem, Dataset, DisplayGT) { m_UpperThreshold = UpperThreshold; m_LowerThreshold = LowerThreshold; m_IncorrectPredictions = IncorrectPredictions; } //============================================================================== void CDatasetViewer::ViewDataset() { PrintControls(); bool Exit {false}; while(!Exit) { // Disable display refreshing until all draws are complete. MdispControl(m_Display, M_UPDATE, M_DISABLE); // Reset the overlay and graphic list for updated draws. MbufClear(m_MilOverlay, 0); MgraClear(M_DEFAULT, m_DisGraList); if(NoIncorrectPredictionsToDisplay()) { MbufClear(m_DisplayBuffer, 0.0); } else { // Load the current entry into the display buffer. MIL_STRING EntryImagePathAbs {}; MclassInquireEntry(m_Dataset, m_EntryIndex, m_EntryKey, M_DEFAULT, M_ENTRY_IMAGE_PATH_ABS, EntryImagePathAbs); MbufLoad(EntryImagePathAbs, m_DisplayBuffer); // Update the display opacity. MdispControl(m_Display, M_OVERLAY_OPACITY, m_Opacity); DrawOverlayImage(); } DrawOverlayText(); // Change the graphic list input units to display units so that zooming // in and out won't change the size and location of the text. MgraControlList(m_DisGraList, M_ALL, M_DEFAULT, M_INPUT_UNITS, M_DISPLAY); // Refresh display. MdispControl(m_Display, M_UPDATE, M_ENABLE); Exit = ProcessUserInputControl(); } } //============================================================================== void CDatasetViewer::PrintControls() const { MosPrintf(MIL_TEXT(\"\\nThe different prediction overlays are as follows:\\n\")); MosPrintf(MIL_TEXT(\"Predicted heatmap: Anomalous scores are projected onto a heatmap\\n\")); MosPrintf(MIL_TEXT(\"Predicted mask: Anomalous mask using default threshold\\n\")); MosPrintf(MIL_TEXT(\"Predicted contour mask: Anomalous blob contour using default threshold\\n\")); MosPrintf(MIL_TEXT(\"Predicted blob reconstruction mask:\\n\")); MosPrintf(MIL_TEXT(\"Blob reconstruction using stats from testset\\n\")); MosPrintf(MIL_TEXT(\"This is done by using the default threshold blobs as seeds\\n\")); MosPrintf(MIL_TEXT(\"then obtaining the lower threshold by computing the lowest\\n\")); MosPrintf(MIL_TEXT(\"possible value that still results in zero image false positives.\\n\")); MosPrintf(MIL_TEXT(\"\\nHere are the dataset viewer controls:\\n\")); MosPrintf(MIL_TEXT(\"n: Display next image\\n\")); MosPrintf(MIL_TEXT(\"p: Display previous image\\n\")); MosPrintf(MIL_TEXT(\"i: Increase the opacity\\n\")); MosPrintf(MIL_TEXT(\"d: Decrease the opacity\\n\")); MosPrintf(MIL_TEXT(\"t: Toggle between GT and prediction overlay\\n\")); MosPrintf(MIL_TEXT(\"m: Cycle the prediction overlay\\n\")); MosPrintf(MIL_TEXT(\"f: Toggle between viewing the entire dataset or just the incorrect predictions\\n\")); MosPrintf(MIL_TEXT(\"e: Exit\\n\\n\")); MosPrintf(MIL_TEXT(\"Select a dataset viewer control:\\n\")); } //============================================================================== void CDatasetViewer::DrawOverlayImage() { if(m_DisplayGT) { MclassDrawEntry(M_DEFAULT, m_Dataset, m_GroundTruthImageBuf, M_GROUND_TRUTH_IMAGE, m_EntryIndex, m_EntryKey, M_ANOMALY_DETECTION, M_DEFAULT, M_NULL, M_DEFAULT); // Map the ground truth image to more human friendly colors. MimLutMap(m_GroundTruthImageBuf, m_MilOverlay, m_GTLut); m_OverlayText = MIL_TEXT(\"Ground truth\"); } else { MIL_INT PredictInfo {M_FALSE}; MclassGetResultEntry(m_Dataset, m_EntryIndex, m_EntryKey, M_ANOMALY_DETECTION, M_DEFAULT, M_PREDICT_INFO + M_TYPE_MIL_INT, &amp;PredictInfo); if(PredictInfo == M_TRUE) { DrawPredictionIntoOverlay(); } else { m_OverlayText = MIL_TEXT(\"No prediction to display\"); } } } //============================================================================== void CDatasetViewer::DrawOverlayText() { m_TextYPos = m_YMargin; if(NoIncorrectPredictionsToDisplay()) { m_IndexText = MIL_TEXT(\"No Incorrect Predictions!\"); MgraText(m_GraTextCtx, m_DisGraList, m_TextMargin, m_TextYPos, m_IndexText); } else { if(m_DisplayIncorrectPrediction) { m_IndexText = MIL_TEXT(\"Incorrect Prediction \"); } else { m_IndexText = MIL_TEXT(\"Entry Index \"); } m_IndexText += M_TO_STRING(m_ImageIndex) + MIL_TEXT(\" / \") + M_TO_STRING(GetNbImages() - 1); MgraText(m_GraTextCtx, m_DisGraList, m_TextMargin, m_TextYPos, m_IndexText); m_TextYPos += m_TextHeight; MgraText(m_GraTextCtx, m_DisGraList, m_TextMargin, m_TextYPos, m_OverlayText); DrawGroundTruthText(); DrawPredictionText(); } } //============================================================================== MIL_INT CDatasetViewer::GetNbImages() const { if(m_DisplayIncorrectPrediction) { return m_IncorrectPredictions.size(); } else { return m_NbEntries; } } //============================================================================== void CDatasetViewer::DrawPredictionIntoOverlay() { switch(m_DisplayPred) { default: case EDrawModes::eNumDrawModes: case EDrawModes::eDrawMask: MclassDrawEntry(m_GraDrawCtx, m_Dataset, m_MilOverlay, M_DRAW_ANOMALY_MASK, m_EntryIndex, m_EntryKey, M_ANOMALY_DETECTION, M_DEFAULT, M_NULL, M_DEFAULT); m_OverlayText = MIL_TEXT(\"Predicted mask\"); break; case EDrawModes::eDrawContour: // Clear overlay and remove opacity so that the contour clearly outlines the defect MdispControl(m_Display, M_OVERLAY_CLEAR, M_DEFAULT); MdispControl(m_Display, M_OVERLAY_OPACITY, 100.0); MclassDrawEntry(m_GraDrawCtx, m_Dataset, m_MilOverlay, M_DRAW_ANOMALY_CONTOUR_MASK, m_EntryIndex, m_EntryKey, M_ANOMALY_DETECTION, M_DEFAULT, M_NULL, M_DEFAULT); m_OverlayText = MIL_TEXT(\"Predicted contour mask\"); break; case EDrawModes::eDrawHeatmap: MclassDrawEntry(m_GraDrawCtx, m_Dataset, m_MilOverlay, M_DRAW_ANOMALY_HEATMAP, m_EntryIndex, m_EntryKey, M_ANOMALY_DETECTION, M_DEFAULT, M_NULL, M_DEFAULT); m_OverlayText = MIL_TEXT(\"Predicted heatmap\"); break; case EDrawModes::eDrawReconstructed: MclassDrawEntry(m_GraDrawCtx, m_Dataset, m_ScoresBuf, M_DRAW_ANOMALY_SCORES, m_EntryIndex, m_EntryKey, M_ANOMALY_DETECTION, M_DEFAULT, M_NULL, M_DEFAULT); DrawBlobReconstruction(m_MilOverlay); m_OverlayText = MIL_TEXT(\"Predicted blob reconstruction mask\"); break; } } //============================================================================== void CDatasetViewer::DrawGroundTruthText() { const bool EntryIsAnomalous = IsEntryAnomalous(); m_TextYPos += m_TextHeight; if(EntryIsAnomalous == M_YES) { m_GroundTruthText = MIL_TEXT(\"Ground Truth: Anomalous\"); } else { m_GroundTruthText = MIL_TEXT(\"Ground Truth: Good\"); } MgraText(m_GraTextCtx, m_DisGraList, m_TextMargin, m_TextYPos, m_GroundTruthText); } //============================================================================== // An entry is considered to be anomalous if at least one of the regions // is assigned to an anomalous class index ground truth. bool CDatasetViewer::IsEntryAnomalous() const { MIL_INT NbRegions = 0; MclassInquireEntry(m_Dataset, m_EntryIndex, m_EntryKey, M_DEFAULT, M_NUMBER_OF_REGIONS + M_TYPE_MIL_INT, &amp;NbRegions); for(MIL_INT RegionIndex = 0; RegionIndex &lt; NbRegions; ++RegionIndex) { MIL_INT ClassIndexGroundTruth = 0; MclassInquireEntry(m_Dataset, m_EntryIndex, m_EntryKey, M_REGION_INDEX(RegionIndex), M_CLASS_INDEX_GROUND_TRUTH + M_TYPE_MIL_INT, &amp;ClassIndexGroundTruth); if(ClassIndexGroundTruth != M_DONT_CARE_CLASS &amp;&amp; m_ClassAnomalous[ClassIndexGroundTruth] == M_TRUE) { return true; break; } } return false; } //============================================================================== void CDatasetViewer::DrawPredictionText() { MIL_INT AnoResultsAvailable {M_NO}; MclassGetResultEntry(m_Dataset, m_EntryIndex, m_EntryKey, M_ANOMALY_DETECTION, M_DEFAULT, M_PREDICT_INFO + M_TYPE_MIL_INT, &amp;AnoResultsAvailable); if(AnoResultsAvailable) { m_TextYPos += m_TextHeight; MIL_INT ImagePredictedAnomalous {M_NO}; MclassGetResultEntry(m_Dataset, m_EntryIndex, m_EntryKey, M_ANOMALY_DETECTION, M_DEFAULT, M_IMAGE_PREDICTED_ANOMALOUS + M_TYPE_MIL_INT, &amp;ImagePredictedAnomalous); if(ImagePredictedAnomalous == M_YES) { m_PredictionText = MIL_TEXT(\"Prediction: Anomalous\"); } else { m_PredictionText = MIL_TEXT(\"Prediction: Good\"); } MgraText(m_GraTextCtx, m_DisGraList, m_TextMargin, m_TextYPos, m_PredictionText); } } //============================================================================== // The masks obtained with a lower threshold will have more true positives, // at the expense of more false positives as well. The mask obtained with // the higher threshold is used as a seed to filter out these false positives. //============================================================================== void CDatasetViewer::DrawBlobReconstruction(MIL_ID DestBuf) { MimBinarize(m_ScoresBuf, m_UpperThresholdMaskBuf, M_FIXED + M_GREATER_OR_EQUAL, m_UpperThreshold, M_NULL); MimBinarize(m_ScoresBuf, m_LowerThresholdMaskBuf, M_FIXED + M_GREATER_OR_EQUAL, m_LowerThreshold, M_NULL); MblobReconstruct(m_LowerThresholdMaskBuf, m_UpperThresholdMaskBuf, m_BlobReconstructedMaskBuf, M_RECONSTRUCT_FROM_SEED, M_DEFAULT); MbufClearCond(DestBuf, 255, 0, 255, m_BlobReconstructedMaskBuf, M_NOT_EQUAL, 0); } //============================================================================== std::pair&lt;MIL_INT, MIL_INT&gt; CDatasetViewer::GetImageSize() const { MIL_STRING EntryImagePathAbs {}; MclassInquireEntry(m_Dataset, 0, M_DEFAULT_KEY, M_DEFAULT, M_ENTRY_IMAGE_PATH_ABS, EntryImagePathAbs); const MIL_INT SizeX = MbufDiskInquire(EntryImagePathAbs, M_SIZE_X, M_NULL); const MIL_INT SizeY = MbufDiskInquire(EntryImagePathAbs, M_SIZE_Y, M_NULL); return {SizeX, SizeY}; } //============================================================================== EDrawModes CDatasetViewer::CycleDisplayMode() { const MIL_INT IntDrawMode = static_cast&lt;MIL_INT&gt;(m_DisplayPred) + 1; return static_cast&lt;EDrawModes&gt;(IntDrawMode % EDrawModes::eNumDrawModes); } //============================================================================== void CDatasetViewer::UpdateEntryIndexAndKey() { if(!m_IncorrectPredictions.empty() &amp;&amp; m_DisplayIncorrectPrediction) { m_EntryKey = m_IncorrectPredictions[m_ImageIndex]; } else { m_EntryIndex = m_ImageIndex; } } //============================================================================== bool CDatasetViewer::NoIncorrectPredictionsToDisplay() const { return m_DisplayIncorrectPrediction &amp;&amp; m_IncorrectPredictions.empty(); } //============================================================================== void CDatasetViewer::IncrementImageIndex() { if(NoIncorrectPredictionsToDisplay()) { return; } const MIL_INT LastImageIndex = GetNbImages() - 1; m_ImageIndex = (m_ImageIndex == LastImageIndex) ? LastImageIndex : ++m_ImageIndex; UpdateEntryIndexAndKey(); } //============================================================================== void CDatasetViewer::DecrementImageIndex() { if(NoIncorrectPredictionsToDisplay()) { return; } m_ImageIndex = (m_ImageIndex == 0) ? 0 : --m_ImageIndex; UpdateEntryIndexAndKey(); } //============================================================================== void CDatasetViewer::ToggleIncorrectPrediction() { m_DisplayIncorrectPrediction = !m_DisplayIncorrectPrediction; if(m_IncorrectPredictions.empty()) { return; } else if(m_DisplayIncorrectPrediction) { m_EntryIndex = M_DEFAULT; m_EntryKey = m_IncorrectPredictions[0]; m_ImageIndex = 0; } else { m_EntryKey = M_DEFAULT_KEY; m_EntryIndex = 0; m_ImageIndex = 0; } } //============================================================================== // This function waits for the next user input control and returns whether or // not to exit the dataset viewer. bool CDatasetViewer::ProcessUserInputControl() { const char KeyVal = (char)MosGetch(); switch(KeyVal) { case 'N': case 'n': IncrementImageIndex(); break; case 'P': case 'p': DecrementImageIndex(); break; case 'I': case 'i': if(m_Opacity + m_OpacityIncrement &lt;= 100.0) { m_Opacity += m_OpacityIncrement; } break; case 'D': case 'd': if(m_Opacity - m_OpacityIncrement &gt;= 0.0) { m_Opacity -= m_OpacityIncrement; } break; case 'E': case 'e': return true; break; case 'T': case 't': m_DisplayGT = !m_DisplayGT; break; case 'M': case 'm': m_DisplayPred = CycleDisplayMode(); break; case 'F': case 'f': ToggleIncorrectPrediction(); break; default: break; } return false; } //============================================================================== MIL_INT CnnTrainEngineDLLInstalled(MIL_ID MilSystem) { MIL_UNIQUE_CLASS_ID TrainCtx = MclassAlloc(MilSystem, M_TRAIN_DET, M_DEFAULT, M_UNIQUE_ID); MIL_INT IsInstalled {M_FALSE}; MclassInquire(TrainCtx, M_DEFAULT, M_TRAIN_ENGINE_IS_INSTALLED + M_TYPE_MIL_INT, &amp;IsInstalled); return IsInstalled; } //============================================================================== bool AskSkipTraining() { MosPrintf(MIL_TEXT(\"\\nTo skip the training and proceed directly to prediction press &lt;s&gt;.\\n\")); MosPrintf(MIL_TEXT(\"Press any other key to continue.\\n\\n\")); char KeyVal = (char)MosGetch(); bool SkipTrain = false; switch (KeyVal) { case 'S': case 's': SkipTrain = true; MosPrintf(MIL_TEXT(\"Skipping the training.\\n\")); break; } return SkipTrain; } //============================================================================== bool AskComputePixelStats() { MosPrintf(MIL_TEXT(\"If you wish to compute pixel-level stats press &lt;y&gt;.\\n\")); MosPrintf(MIL_TEXT(\"Press any other key to continue with image-level stats only.\\n\\n\")); const char KeyVal = (char)MosGetch(); bool ComputePixelStats = false; switch (KeyVal) { case 'Y': case 'y': ComputePixelStats = true; break; default: break; } return ComputePixelStats; } //============================================================================== bool IsTrainingSupportedOnPlatform(MIL_ID MilSystem) { MIL_ID MilSysOwnerApp {M_NULL}; MsysInquire(MilSystem, M_OWNER_APPLICATION, &amp;MilSysOwnerApp); MIL_INT SysPlatformBitness {M_NULL}; MappInquire(MilSysOwnerApp, M_PLATFORM_BITNESS, &amp;SysPlatformBitness); MIL_INT SysOsType {M_NULL}; MappInquire(MilSysOwnerApp, M_PLATFORM_OS_TYPE, &amp;SysOsType); const bool SupportedTrainingPlatform = ((SysPlatformBitness == 64) &amp;&amp; (SysOsType == M_OS_WINDOWS)); if(!SupportedTrainingPlatform) { MosPrintf(MIL_TEXT(\"\\n***** MclassTrain() is available only for Windows 64-bit platforms. *****\\n\")); return false; } if(!CnnTrainEngineDLLInstalled(MilSystem)) { MosPrintf(MIL_TEXT(\"\\n***** MclassTrain() cannot run; no train engine is installed. *****\\n\")); return false; } return true; } //============================================================================== void LoadDatasets(MIL_ID MilSystem, MIL_ID Dataset, MIL_ID TestDataset, bool SkipTrain) { if(!SkipTrain) { MclassImport(EXAMPLE_DATASET_ROOT_PATH, M_IMAGE_DATASET_FOLDER, Dataset, M_DEFAULT, M_COMPLETE, M_DEFAULT); } MclassImport(EXAMPLE_TEST_DATASET_ROOT_PATH, M_IMAGE_DATASET_FOLDER, TestDataset, M_DEFAULT, M_COMPLETE, M_DEFAULT); if(!SkipTrain) { MosPrintf(MIL_TEXT(\"The original images are very large; they will be cropped for training.\\n\")); MosPrintf(MIL_TEXT(\"Press &lt;v&gt; to view the original training dataset.\\n\")); MosPrintf(MIL_TEXT(\"Press any other key to continue...\\n\")); char KeyVal = (char)MosGetch(); if ((KeyVal == 'v' || KeyVal == 'V')) { MosPrintf(MIL_TEXT(\"\\n\\n*******************************************************\\n\")); MosPrintf(MIL_TEXT(\"VIEWING THE ORIGINAL TRAINING DATASET...\\n\")); MosPrintf(MIL_TEXT(\"*******************************************************\")); CDatasetViewer DatasetViewer(MilSystem, Dataset, true); DatasetViewer.ViewDataset(); } } MosPrintf(MIL_TEXT(\"The datasets were successfully imported.\\n\\n\")); } //============================================================================== void PrepareDatasets( MIL_ID MilSystem, MIL_ID TrainDataset, MIL_ID DevDataset, MIL_ID TestDataset, MIL_INT SizeX, MIL_INT SizeY, MIL_ID PreparedTrainDataset, MIL_ID PreparedDevDataset, MIL_ID PreparedTestDataset, bool SkipTrain) { MIL_UNIQUE_CLASS_ID PrpDataCtx = MclassAlloc(MilSystem, M_PREPARE_IMAGES_SEG, M_DEFAULT, M_UNIQUE_ID); // Resize controls. MclassControl(PrpDataCtx, M_DEFAULT, M_SIZE_MODE, M_USER_DEFINED); MclassControl(PrpDataCtx, M_DEFAULT, M_SIZE_X, SizeX); MclassControl(PrpDataCtx, M_DEFAULT, M_SIZE_Y, SizeY); #ifdef RESIZE_IMAGES MclassControl(PrpDataCtx, M_DEFAULT, M_RESIZE_SCALE_FACTOR, M_FILL_DESTINATION_BILINEAR); #endif MclassControl(PrpDataCtx, M_DEFAULT, M_SEED_MODE, M_USER_DEFINED); MclassControl(PrpDataCtx, M_DEFAULT, M_SEED_VALUE, 42); MclassControl(PrpDataCtx, M_DEFAULT, M_AUGMENT_NUMBER_MODE, M_DISABLE); // From run to run, we are deleting the preparations from previous runs; // by default they are not deleted. MIL_STRING PrepareDataFolder = MIL_TEXT(\"PreparedData\"); CreateDir(PrepareDataFolder); MclassControl(PrpDataCtx, M_DEFAULT, M_PREPARED_DATA_FOLDER, PrepareDataFolder); // The M_PREPARE_ENTRY_PRE hook is being used to allow us to select unique center x/y // coordinates for each image in the dataset. // This is done using MmodFind to find the ring shape of the bottle and allow us to center // our cropping around it. #ifndef SKIP_MOD_FIND SPrepareEntryPreHookData PrepareEntryPre(MilSystem); MclassHookFunction(PrpDataCtx, M_PREPARE_ENTRY_PRE, HookPrepareEntryPreFunc, &amp;PrepareEntryPre); #endif // The M_PREPARE_ENTRY_POST is used to keep track of the the data preparation and // notify us if any entries failed to be augmented. MclassHookFunction(PrpDataCtx, M_PREPARE_ENTRY_POST, HookNumPreparedEntriesFunc, M_NULL); MclassPreprocess(PrpDataCtx, M_DEFAULT); if(!SkipTrain) { // Resize and crop all datasets. MosPrintf(MIL_TEXT(\"Preparing the train dataset...\\n\")); MclassPrepareData(PrpDataCtx, TrainDataset, PreparedTrainDataset, M_NULL, M_DEFAULT); MosPrintf(MIL_TEXT(\"Preparing the dev dataset...\\n\")); MclassPrepareData(PrpDataCtx, DevDataset, PreparedDevDataset, M_NULL, M_DEFAULT); } MosPrintf(MIL_TEXT(\"Preparing the test dataset...\\n\")); MclassPrepareData(PrpDataCtx, TestDataset, PreparedTestDataset, M_NULL, M_DEFAULT); if(!SkipTrain) { MosPrintf(MIL_TEXT(\"Press &lt;v&gt; to view the prepared training dataset.\\n\")); MosPrintf(MIL_TEXT(\"Press any other key to continue...\\n\")); char KeyVal = (char)MosGetch(); if ((KeyVal == 'v' || KeyVal == 'V')) { MosPrintf(MIL_TEXT(\"\\n\\n*******************************************************\\n\")); MosPrintf(MIL_TEXT(\"VIEWING THE PREPARED TRAINING DATASET...\\n\")); MosPrintf(MIL_TEXT(\"*******************************************************\")); CDatasetViewer DatasetViewer(MilSystem, PreparedTrainDataset, true); DatasetViewer.ViewDataset(); } } } //============================================================================== void PrintConfusionMatrix(MIL_ID StatRes) { std::vector&lt;MIL_INT&gt; ConfusionMatrix; MclassGetResultStat(StatRes, M_DEFAULT, M_DEFAULT, M_DEFAULT, M_CONFUSION_MATRIX, ConfusionMatrix); MosPrintf(MIL_TEXT(\"\\nConfusion Matrix:\\n\")); MosPrintf(MIL_TEXT(\"GT\\\\Prediction| Anomalous | Non-Anomalous\\n\")); MosPrintf(MIL_TEXT(\"-------------+-----------+--------------\\n\")); MosPrintf(MIL_TEXT(\"Anomalous |%11d|%11d\\n\"), ConfusionMatrix[0], ConfusionMatrix[1]); MosPrintf(MIL_TEXT(\"Non-Anomalous|%11d|%11d\\n\"), ConfusionMatrix[2], ConfusionMatrix[3]); } //============================================================================== void PrintOverallMacroWeightedMetrics(MIL_ID StatRes, bool IsImageLevel) { MIL_DOUBLE AccOverall = 0; MclassGetResultStat(StatRes, M_DEFAULT, M_DEFAULT, M_DEFAULT, M_ACCURACY_OVERALL, &amp;AccOverall); MIL_DOUBLE AccMacro = 0; MclassGetResultStat(StatRes, M_DEFAULT, M_DEFAULT, M_DEFAULT, M_ACCURACY_MACRO, &amp;AccMacro); MIL_DOUBLE AccWeighted = 0; MclassGetResultStat(StatRes, M_DEFAULT, M_DEFAULT, M_DEFAULT, M_ACCURACY_WEIGHTED, &amp;AccWeighted); MIL_DOUBLE ErrOverall = 0; MclassGetResultStat(StatRes, M_DEFAULT, M_DEFAULT, M_DEFAULT, M_ERROR_RATE_OVERALL, &amp;ErrOverall); MIL_DOUBLE ErrMacro = 0; MclassGetResultStat(StatRes, M_DEFAULT, M_DEFAULT, M_DEFAULT, M_ERROR_RATE_MACRO, &amp;ErrMacro); MIL_DOUBLE ErrWeighted = 0; MclassGetResultStat(StatRes, M_DEFAULT, M_DEFAULT, M_DEFAULT, M_ERROR_RATE_WEIGHTED, &amp;ErrWeighted); MIL_DOUBLE TNRMicro = 0; MclassGetResultStat(StatRes, M_DEFAULT, M_DEFAULT, M_DEFAULT, M_TNR_MICRO, &amp;TNRMicro); MIL_DOUBLE TNRMacro = 0; MclassGetResultStat(StatRes, M_DEFAULT, M_DEFAULT, M_DEFAULT, M_TNR_MACRO, &amp;TNRMacro); MIL_DOUBLE TNRWeighted = 0; MclassGetResultStat(StatRes, M_DEFAULT, M_DEFAULT, M_DEFAULT, M_TNR_WEIGHTED, &amp;TNRWeighted); MIL_DOUBLE FPRMicro = 0; MclassGetResultStat(StatRes, M_DEFAULT, M_DEFAULT, M_DEFAULT, M_FPR_MICRO, &amp;FPRMicro); MIL_DOUBLE FPRMacro = 0; MclassGetResultStat(StatRes, M_DEFAULT, M_DEFAULT, M_DEFAULT, M_FPR_MACRO, &amp;FPRMacro); MIL_DOUBLE FPRWeighted = 0; MclassGetResultStat(StatRes, M_DEFAULT, M_DEFAULT, M_DEFAULT, M_FPR_WEIGHTED, &amp;FPRWeighted); MIL_DOUBLE RecallMicro = 0; MclassGetResultStat(StatRes, M_DEFAULT, M_DEFAULT, M_DEFAULT, M_RECALL_MICRO, &amp;RecallMicro); MIL_DOUBLE RecallMacro = 0; MclassGetResultStat(StatRes, M_DEFAULT, M_DEFAULT, M_DEFAULT, M_RECALL_MACRO, &amp;RecallMacro); MIL_DOUBLE RecallWeighted = 0; MclassGetResultStat(StatRes, M_DEFAULT, M_DEFAULT, M_DEFAULT, M_RECALL_WEIGHTED, &amp;RecallWeighted); MIL_DOUBLE FNRMicro = 0; MclassGetResultStat(StatRes, M_DEFAULT, M_DEFAULT, M_DEFAULT, M_FNR_MICRO, &amp;FNRMicro); MIL_DOUBLE FNRMacro = 0; MclassGetResultStat(StatRes, M_DEFAULT, M_DEFAULT, M_DEFAULT, M_FNR_MACRO, &amp;FNRMacro); MIL_DOUBLE FNRWeighted = 0; MclassGetResultStat(StatRes, M_DEFAULT, M_DEFAULT, M_DEFAULT, M_FNR_WEIGHTED, &amp;FNRWeighted); MIL_DOUBLE PrecisionMicro = 0; MclassGetResultStat(StatRes, M_DEFAULT, M_DEFAULT, M_DEFAULT, M_PRECISION_MICRO, &amp;PrecisionMicro); MIL_DOUBLE PrecisionMacro = 0; MclassGetResultStat(StatRes, M_DEFAULT, M_DEFAULT, M_DEFAULT, M_PRECISION_MACRO, &amp;PrecisionMacro); MIL_DOUBLE PrecisionWeighted = 0; MclassGetResultStat(StatRes, M_DEFAULT, M_DEFAULT, M_DEFAULT, M_PRECISION_WEIGHTED, &amp;PrecisionWeighted); MIL_DOUBLE FDRMicro = 0; MclassGetResultStat(StatRes, M_DEFAULT, M_DEFAULT, M_DEFAULT, M_FDR_MICRO, &amp;FDRMicro); MIL_DOUBLE FDRMacro = 0; MclassGetResultStat(StatRes, M_DEFAULT, M_DEFAULT, M_DEFAULT, M_FDR_MACRO, &amp;FDRMacro); MIL_DOUBLE FDRWeighted = 0; MclassGetResultStat(StatRes, M_DEFAULT, M_DEFAULT, M_DEFAULT, M_FDR_WEIGHTED, &amp;FDRWeighted); MIL_DOUBLE F1ScoreMicro = 0; MclassGetResultStat(StatRes, M_DEFAULT, M_DEFAULT, M_DEFAULT, M_F1SCORE_MICRO, &amp;F1ScoreMicro); MIL_DOUBLE F1ScoreMacro = 0; MclassGetResultStat(StatRes, M_DEFAULT, M_DEFAULT, M_DEFAULT, M_F1SCORE_MACRO, &amp;F1ScoreMacro); MIL_DOUBLE F1ScoreWeighted = 0; MclassGetResultStat(StatRes, M_DEFAULT, M_DEFAULT, M_DEFAULT, M_F1SCORE_WEIGHTED, &amp;F1ScoreWeighted); MIL_DOUBLE IOUMicro = 0, IOUMacro = 0, IOUWeighted = 0; if(!IsImageLevel) { MclassGetResultStat(StatRes, M_DEFAULT, M_DEFAULT, M_DEFAULT, M_IOU_MICRO, &amp;IOUMicro); MclassGetResultStat(StatRes, M_DEFAULT, M_DEFAULT, M_DEFAULT, M_IOU_MACRO, &amp;IOUMacro); MclassGetResultStat(StatRes, M_DEFAULT, M_DEFAULT, M_DEFAULT, M_IOU_WEIGHTED, &amp;IOUWeighted); } MIL_DOUBLE AveragePrecisionMacro = 0; MclassGetResultStat(StatRes, M_DEFAULT, M_DEFAULT, M_DEFAULT, M_AVERAGE_PRECISION_MACRO, &amp;AveragePrecisionMacro); MIL_DOUBLE AveragePrecisionWeighted = 0; MclassGetResultStat(StatRes, M_DEFAULT, M_DEFAULT, M_DEFAULT, M_AVERAGE_PRECISION_WEIGHTED, &amp;AveragePrecisionWeighted); MIL_DOUBLE AUROCMacro = 0; MclassGetResultStat(StatRes, M_DEFAULT, M_DEFAULT, M_DEFAULT, M_AUC_ROC_MACRO, &amp;AUROCMacro); MIL_DOUBLE AUROCWeighted = 0; MclassGetResultStat(StatRes, M_DEFAULT, M_DEFAULT, M_DEFAULT, M_AUC_ROC_WEIGHTED, &amp;AUROCWeighted); MosPrintf(MIL_TEXT(\"\\nMetric | Micro | Macro | Weighted\\n\")); MosPrintf(MIL_TEXT(\"----------+---------+---------+---------\\n\")); MosPrintf(MIL_TEXT(\"Accuracy |%9.2f|%9.2f|%9.2f\\n\"), AccOverall, AccMacro, AccWeighted); MosPrintf(MIL_TEXT(\"Error Rate|%9.2f|%9.2f|%9.2f\\n\"), ErrOverall, ErrMacro, ErrWeighted); MosPrintf(MIL_TEXT(\"TNR |%9.2f|%9.2f|%9.2f\\n\"), TNRMicro, TNRMacro, TNRWeighted); MosPrintf(MIL_TEXT(\"FPR |%9.2f|%9.2f|%9.2f\\n\"), FPRMicro, FPRMacro, FPRWeighted); MosPrintf(MIL_TEXT(\"Recall |%9.2f|%9.2f|%9.2f\\n\"), RecallMicro, RecallMacro, RecallWeighted); MosPrintf(MIL_TEXT(\"FNR |%9.2f|%9.2f|%9.2f\\n\"), FNRMicro, FNRMacro, FNRWeighted); MosPrintf(MIL_TEXT(\"Precision |%9.2f|%9.2f|%9.2f\\n\"), PrecisionMicro, PrecisionMacro, PrecisionWeighted); MosPrintf(MIL_TEXT(\"FDR |%9.2f|%9.2f|%9.2f\\n\"), FDRMicro, FDRMacro, FDRWeighted); MosPrintf(MIL_TEXT(\"F1 Score |%9.2f|%9.2f|%9.2f\\n\"), F1ScoreMicro, F1ScoreMacro, F1ScoreWeighted); if(!IsImageLevel) { MosPrintf(MIL_TEXT(\"IOU |%9.2f|%9.2f|%9.2f\\n\"), IOUMicro, IOUMacro, IOUWeighted); } MosPrintf(MIL_TEXT(\"AP | N/A |%9.2f|%9.2f\\n\"), AveragePrecisionMacro, AveragePrecisionWeighted); MosPrintf(MIL_TEXT(\"AUROC | N/A |%9.2f|%9.2f\\n\"), AUROCMacro, AUROCWeighted); } //============================================================================== void PrintAnomalousNonAnomalousPositiveClassMetrics(MIL_ID StatRes, bool IsImageLevel) { MIL_DOUBLE AccAno = 0; MclassGetResultStat(StatRes, M_ANOMALOUS, M_DEFAULT, M_DEFAULT, M_ACCURACY, &amp;AccAno); MIL_DOUBLE AccNoAno = 0; MclassGetResultStat(StatRes, M_NON_ANOMALOUS, M_DEFAULT, M_DEFAULT, M_ACCURACY, &amp;AccNoAno); MIL_DOUBLE ErrAno = 0; MclassGetResultStat(StatRes, M_ANOMALOUS, M_DEFAULT, M_DEFAULT, M_ERROR_RATE, &amp;ErrAno); MIL_DOUBLE ErrNoAno = 0; MclassGetResultStat(StatRes, M_NON_ANOMALOUS, M_DEFAULT, M_DEFAULT, M_ERROR_RATE, &amp;ErrNoAno); MIL_DOUBLE TNRAno = 0; MclassGetResultStat(StatRes, M_ANOMALOUS, M_DEFAULT, M_DEFAULT, M_TNR, &amp;TNRAno); MIL_DOUBLE TNRNoAno = 0; MclassGetResultStat(StatRes, M_NON_ANOMALOUS, M_DEFAULT, M_DEFAULT, M_TNR, &amp;TNRNoAno); MIL_DOUBLE FPRAno = 0; MclassGetResultStat(StatRes, M_ANOMALOUS, M_DEFAULT, M_DEFAULT, M_FPR, &amp;FPRAno); MIL_DOUBLE FPRNoAno = 0; MclassGetResultStat(StatRes, M_NON_ANOMALOUS, M_DEFAULT, M_DEFAULT, M_FPR, &amp;FPRNoAno); MIL_DOUBLE RecallAno = 0; MclassGetResultStat(StatRes, M_ANOMALOUS, M_DEFAULT, M_DEFAULT, M_RECALL, &amp;RecallAno); MIL_DOUBLE RecallNoAno = 0; MclassGetResultStat(StatRes, M_NON_ANOMALOUS, M_DEFAULT, M_DEFAULT, M_RECALL, &amp;RecallNoAno); MIL_DOUBLE FNRAno = 0; MclassGetResultStat(StatRes, M_ANOMALOUS, M_DEFAULT, M_DEFAULT, M_FNR, &amp;FNRAno); MIL_DOUBLE FNRNoAno = 0; MclassGetResultStat(StatRes, M_NON_ANOMALOUS, M_DEFAULT, M_DEFAULT, M_FNR, &amp;FNRNoAno); MIL_DOUBLE PrecisionAno = 0; MclassGetResultStat(StatRes, M_ANOMALOUS, M_DEFAULT, M_DEFAULT, M_PRECISION, &amp;PrecisionAno); MIL_DOUBLE PrecisionNoAno = 0; MclassGetResultStat(StatRes, M_NON_ANOMALOUS, M_DEFAULT, M_DEFAULT, M_PRECISION, &amp;PrecisionNoAno); MIL_DOUBLE FDRAno = 0; MclassGetResultStat(StatRes, M_ANOMALOUS, M_DEFAULT, M_DEFAULT, M_FDR, &amp;FDRAno); MIL_DOUBLE FDRNoAno = 0; MclassGetResultStat(StatRes, M_NON_ANOMALOUS, M_DEFAULT, M_DEFAULT, M_FDR, &amp;FDRNoAno); MIL_DOUBLE F1ScoreAno = 0; MclassGetResultStat(StatRes, M_ANOMALOUS, M_DEFAULT, M_DEFAULT, M_F1SCORE, &amp;F1ScoreAno); MIL_DOUBLE F1ScoreNoAno = 0; MclassGetResultStat(StatRes, M_NON_ANOMALOUS, M_DEFAULT, M_DEFAULT, M_F1SCORE, &amp;F1ScoreNoAno); MIL_DOUBLE IOUAno = 0, IOUNoAno = 0; if(!IsImageLevel) { MclassGetResultStat(StatRes, M_ANOMALOUS, M_DEFAULT, M_DEFAULT, M_IOU, &amp;IOUAno); MclassGetResultStat(StatRes, M_NON_ANOMALOUS, M_DEFAULT, M_DEFAULT, M_IOU, &amp;IOUNoAno); } MIL_DOUBLE AveragePrecisionAno = 0; MclassGetResultStat(StatRes, M_ANOMALOUS, M_DEFAULT, M_DEFAULT, M_AVERAGE_PRECISION, &amp;AveragePrecisionAno); MIL_DOUBLE AveragePrecisionNoAno = 0; MclassGetResultStat(StatRes, M_NON_ANOMALOUS, M_DEFAULT, M_DEFAULT, M_AVERAGE_PRECISION, &amp;AveragePrecisionNoAno); MIL_DOUBLE AUROCAno = 0; MclassGetResultStat(StatRes, M_ANOMALOUS, M_DEFAULT, M_DEFAULT, M_AUC_ROC, &amp;AUROCAno); MIL_DOUBLE AUROCNoAno = 0; MclassGetResultStat(StatRes, M_NON_ANOMALOUS, M_DEFAULT, M_DEFAULT, M_AUC_ROC, &amp;AUROCNoAno); MosPrintf(MIL_TEXT(\"\\nMetric |Anomalous| Non-Anomalous\\n\")); MosPrintf(MIL_TEXT(\"----------+---------+--------------\\n\")); MosPrintf(MIL_TEXT(\"Accuracy |%9.2f|%9.2f\\n\"), AccAno, AccNoAno); MosPrintf(MIL_TEXT(\"Error Rate|%9.2f|%9.2f\\n\"), ErrAno, ErrNoAno); MosPrintf(MIL_TEXT(\"TNR |%9.2f|%9.2f\\n\"), TNRAno, TNRNoAno); MosPrintf(MIL_TEXT(\"FPR |%9.2f|%9.2f\\n\"), FPRAno, FPRNoAno); MosPrintf(MIL_TEXT(\"Recall |%9.2f|%9.2f\\n\"), RecallAno, RecallNoAno); MosPrintf(MIL_TEXT(\"FNR |%9.2f|%9.2f\\n\"), FNRAno, FNRNoAno); MosPrintf(MIL_TEXT(\"Precision |%9.2f|%9.2f\\n\"), PrecisionAno, PrecisionNoAno); MosPrintf(MIL_TEXT(\"FDR |%9.2f|%9.2f\\n\"), FDRAno, FDRNoAno); MosPrintf(MIL_TEXT(\"F1 Score |%9.2f|%9.2f\\n\"), F1ScoreAno, F1ScoreNoAno); if(!IsImageLevel) { MosPrintf(MIL_TEXT(\"IOU |%9.2f|%9.2f\\n\"), IOUAno, IOUNoAno); } MosPrintf(MIL_TEXT(\"AP |%9.2f|%9.2f\\n\"), AveragePrecisionAno, AveragePrecisionNoAno); MosPrintf(MIL_TEXT(\"AUROC |%9.2f|%9.2f\\n\"), AUROCAno, AUROCNoAno); } //============================================================================== MIL_INT ComputeStats( MIL_ID MilSystem, MIL_ID StatCtx, MIL_ID StatRes, MIL_ID Dataset, bool IsImageLevel) { // Set the score threshold step value. // Larger values will speed up MclassStatCalculate at the cost of numerical precision. MclassControl(StatCtx, M_DEFAULT, M_SCORE_THRESHOLD_STEP, 0.01); if(IsImageLevel) { MosPrintf(MIL_TEXT(\"IMAGE-LEVEL STATS:\\n\")); MclassControl(StatCtx, M_DEFAULT, M_MODE, M_IMAGE_LEVEL); } else { MosPrintf(MIL_TEXT(\"\\nPIXEL-LEVEL STATS:\\n\")); MclassControl(StatCtx, M_DEFAULT, M_MODE, M_PIXEL_LEVEL); } MclassPreprocess(StatCtx, M_DEFAULT); MclassStatCalculate(StatCtx, Dataset, M_DEFAULT, M_DEFAULT_KEY, StatRes, M_DEFAULT); MIL_INT Status = M_NULL; MclassGetResultStat(StatRes, M_DEFAULT, M_DEFAULT, M_DEFAULT, M_STATUS + M_TYPE_MIL_INT, &amp;Status); MIL_DOUBLE ReturnThreshold = 0.0; if(Status == M_COMPLETE) { PrintConfusionMatrix(StatRes); PrintOverallMacroWeightedMetrics(StatRes, IsImageLevel); PrintAnomalousNonAnomalousPositiveClassMetrics(StatRes, IsImageLevel); std::vector&lt;MIL_DOUBLE&gt; Thresholds; MclassGetResultStat(StatRes, M_DEFAULT, M_DEFAULT, M_DEFAULT, M_SCORE_THRESHOLDS, Thresholds); std::vector&lt;MIL_DOUBLE&gt; FPRs; MclassGetResultStat(StatRes, M_ANOMALOUS, M_DEFAULT, M_ALL, M_FPR, FPRs); const MIL_INT ThresholdIndex = std::distance(FPRs.cbegin(), std::min_element(FPRs.cbegin(), FPRs.cend())); ReturnThreshold = Thresholds[ThresholdIndex]; } else { MosPrintf(MIL_TEXT(\"!!! FAILED TO COMPUTE STATS ON THE TESTSET !!!\\n\")); PrintStatCalculateStatusMessage(Status); MosPrintf(MIL_TEXT(\"Continuing example using default threshold only...\\n\")); ReturnThreshold = 50.0; } return Status; } //============================================================================== // The lower threshold will be selected as the threshold that would result in // no image-level false positives on the test dataset. MIL_DOUBLE ComputeLowerThreshold(MIL_INT Status, MIL_ID StatRes) { MIL_DOUBLE LowerThreshold = 0.0; if(Status == M_COMPLETE) { std::vector&lt;MIL_DOUBLE&gt; Thresholds; MclassGetResultStat(StatRes, M_DEFAULT, M_DEFAULT, M_DEFAULT, M_SCORE_THRESHOLDS, Thresholds); std::vector&lt;MIL_DOUBLE&gt; FPRs; MclassGetResultStat(StatRes, M_ANOMALOUS, M_DEFAULT, M_ALL, M_FPR, FPRs); const MIL_INT ThresholdIndex = std::distance(FPRs.cbegin(), std::min_element(FPRs.cbegin(), FPRs.cend())); LowerThreshold = Thresholds[ThresholdIndex]; } else { LowerThreshold = 50.0; } return LowerThreshold; } //============================================================================== std::vector&lt;MIL_UUID&gt; GetIncorrectPredictions(MIL_ID StatRes) { std::vector&lt;MIL_UUID&gt; FPs; MclassGetResultStat(StatRes, M_ANOMALOUS, M_NON_ANOMALOUS, M_DEFAULT, M_CONFUSION_MATRIX_USED_ENTRIES_ELEMENT, FPs); std::vector&lt;MIL_UUID&gt; FNs; MclassGetResultStat(StatRes, M_NON_ANOMALOUS, M_ANOMALOUS, M_DEFAULT, M_CONFUSION_MATRIX_USED_ENTRIES_ELEMENT, FNs); FPs.insert(FPs.end(), FNs.begin(), FNs.end()); return FPs; } //============================================================================== void CreateDir(MIL_STRING DirectoryPath) { // If the directory exists from a previous run of the example, remove it to start again. MIL_INT DirectoryExists = M_NO; MappFileOperation(M_DEFAULT, DirectoryPath, M_NULL, M_NULL, M_FILE_EXISTS, M_DEFAULT, &amp;DirectoryExists); if(DirectoryExists == M_YES) { MappFileOperation(M_DEFAULT, DirectoryPath, M_NULL, M_NULL, M_FILE_DELETE_DIR, M_RECURSIVE, M_NULL); } MappFileOperation(M_DEFAULT, DirectoryPath, M_NULL, M_NULL, M_FILE_MAKE_DIR, M_DEFAULT, M_NULL); } //============================================================================== MIL_STRING GetExampleCurrentDirectory() { DWORD CurDirStrSize = GetCurrentDirectory(0, NULL) + 1; std::vector&lt;MIL_TEXT_CHAR&gt; vCurDir(CurDirStrSize, 0); GetCurrentDirectory(CurDirStrSize, (LPTSTR)&amp;vCurDir[0]); MIL_STRING sRet = &amp;vCurDir[0]; return sRet + MIL_TEXT(\"/\"); } //============================================================================== void GenerateGroundTruthImageLut(MIL_ID LutBufId) { std::vector&lt;MIL_UINT8&gt; LutValues(256 * 3, 0); // We map 1 (anomalous) to red. LutValues[256 * 0 + 1] = M_RGB888_R(M_COLOR_RED); LutValues[256 * 1 + 1] = M_RGB888_G(M_COLOR_RED); LutValues[256 * 2 + 1] = M_RGB888_B(M_COLOR_RED); // We map 255 (don't care) to white. LutValues[256 * 0 + 255] = M_RGB888_R(M_COLOR_WHITE); LutValues[256 * 1 + 255] = M_RGB888_G(M_COLOR_WHITE); LutValues[256 * 2 + 255] = M_RGB888_B(M_COLOR_WHITE); MbufPut1d(LutBufId, 0, 256, LutValues); } //============================================================================== void PredictUsingTrainedContext( MIL_ID MilSystem, MIL_ID MilDisplay, MIL_ID TrainedCtx, MIL_ID TestDataset) { MIL_INT NbEntries {0}; MclassInquire(TestDataset, M_DEFAULT, M_NUMBER_OF_ENTRIES + M_TYPE_MIL_INT, &amp;NbEntries); SPredictedEntryData PredictedEntryData(NbEntries); MclassHookFunction(TrainedCtx, M_PREDICT_ENTRY, HookPredictedEntryFunc, &amp;PredictedEntryData); MclassPreprocess(TrainedCtx, M_DEFAULT); CreateDir(EXAMPLE_ANOMALY_DETECTION_FOLDER_PATH); MclassControl(TestDataset, M_DEFAULT, M_ANOMALY_DETECTION_FOLDER, GetExampleCurrentDirectory() + EXAMPLE_ANOMALY_DETECTION_FOLDER_PATH); MosPrintf(MIL_TEXT(\"\\nPredictions will be performed on the test dataset as a final check\\nof the trained anomaly detection classifier.\\n\")); MclassPredict(TrainedCtx, TestDataset, TestDataset, M_DEFAULT); } //============================================================================== void PrintTrainStatusMessage(MIL_INT Status) { switch(Status) { case M_INTERNAL_ERROR: MosPrintf(MIL_TEXT(\"An unexpected internal error has occurred!\\n\")); break; case M_NON_FINITE_VALUE_DETECTED: MosPrintf(MIL_TEXT(\"Training terminated because a non-finite value was detected!\\n\")); break; case M_NOT_ENOUGH_GPU_MEMORY: MosPrintf(MIL_TEXT(\"Ran out of GPU memory, try reducing the batch size!\\n\")); break; case M_NOT_ENOUGH_MEMORY: MosPrintf(MIL_TEXT(\"Ran out of memory, try reducing the batch size!\\n\")); break; case M_TIMEOUT_REACHED: MosPrintf(MIL_TEXT(\"Timeout reached, try increasing the timeout!\\n\")); break; default: MosPrintf(MIL_TEXT(\"Unexpected status code received!\\n\")); break; } } //============================================================================== void PrintStatCalculateStatusMessage(MIL_INT Status) { switch(Status) { case M_INTERNAL_ERROR: MosPrintf(MIL_TEXT(\"An unexpected internal error has occurred!\\n\")); break; case M_ZERO_USED_ENTRIES: MosPrintf(MIL_TEXT(\"Stat calculate failed because there were no valid entries!\\n\")); break; // These are valid statuses, but should never occur as a result of // the way that the example has been written. case M_TIMEOUT_REACHED: case M_COMPLETE: case M_CALCULATE_NOT_PERFORMED: case M_CURRENTLY_CALCULATING: case M_STOPPED_BY_REQUEST: default: MosPrintf(MIL_TEXT(\"Unexpected status code received!\\n\")); break; } } //============================================================================== MIL_STRING ConvertPrepareDataStatusToStr(MIL_INT Status) { switch(Status) { case M_COMPLETE: return MIL_TEXT(\"M_COMPLETE\"); case M_INVALID_AUG_OP_FOR_1_BAND_BUFFER: return MIL_TEXT(\"M_INVALID_AUG_OP_FOR_1_BAND_BUFFER\"); case M_INVALID_AUG_OP_FOR_1_BIT_BUFFER: return MIL_TEXT(\"M_INVALID_AUG_OP_FOR_1_BIT_BUFFER\"); case M_SOURCE_TOO_SMALL_FOR_DERICHE_OP: return MIL_TEXT(\"M_SOURCE_TOO_SMALL_FOR_DERICHE_OP\"); case M_FLOAT_IMAGE_NOT_NORMALIZED: return MIL_TEXT(\"M_FLOAT_IMAGE_NOT_NORMALIZED\"); case M_FAILED_TO_SAVE_IMAGE: return MIL_TEXT(\"M_FAILED_TO_SAVE_IMAGE\"); case M_IMAGE_FILE_NOT_FOUND: return MIL_TEXT(\"M_IMAGE_FILE_NOT_FOUND\"); case M_IMAGE_FILE_INVALID: return MIL_TEXT(\"M_IMAGE_FILE_INVALID\"); case M_INVALID_BUFFER_SIGN_FOR_AUG: return MIL_TEXT(\"M_INVALID_BUFFER_SIGN_FOR_AUG\"); case M_INVALID_CENTER: return MIL_TEXT(\"M_INVALID_CENTER\"); case M_MASK_FILE_NOT_FOUND: return MIL_TEXT(\"M_MASK_FILE_NOT_FOUND\"); case M_RESIZED_IMAGE_TOO_SMALL: return MIL_TEXT(\"M_RESIZED_IMAGE_TOO_SMALL\"); case M_INTERNAL_ERROR: return MIL_TEXT(\"M_INTERNAL_ERROR\"); default: return MIL_TEXT(\"Unhandled prepare data status!\"); } } //============================================================================== MIL_STRING ConvertPredictEntryStatusToStr(MIL_INT Status) { switch(Status) { case M_COMPLETE: return MIL_TEXT(\"M_COMPLETE\"); case M_IMAGE_FILE_NOT_FOUND: return MIL_TEXT(\"M_IMAGE_FILE_NOT_FOUND\"); case M_INTERNAL_ERROR: return MIL_TEXT(\"M_INTERNAL_ERROR\"); default: return MIL_TEXT(\"Unhandled predict entry status!\"); } } //============================================================================== void SetTrainControls(MIL_ID TrainCtx) { MclassControl(TrainCtx, M_DEFAULT, M_SAMPLES_FIXED_SIZE, SAMPLES_FIXED_SIZE); MclassControl(TrainCtx, M_DEFAULT, M_TRAIN_MODE, SAMPLING_MODE); MclassControl(TrainCtx, M_DEFAULT, M_MINI_BATCHES_PER_SAMPLING, MINI_BATCHES_PER_SAMPLING); } //============================================================================== MIL_UNIQUE_CLASS_ID TrainTheModel( MIL_ID MilSystem, MIL_ID MilDisplay, MIL_ID PreparedTrainDataset, MIL_ID PreparedDevDataset) { MIL_UNIQUE_CLASS_ID TrainCtx = MclassAlloc(MilSystem, M_TRAIN_ANO, M_DEFAULT, M_UNIQUE_ID); MIL_UNIQUE_CLASS_ID TrainRslt = MclassAllocResult(MilSystem, M_TRAIN_ANO_RESULT, M_DEFAULT, M_UNIQUE_ID); SetTrainControls(TrainCtx); MclassPreprocess(TrainCtx, M_DEFAULT); MIL_INT SamplesPerSampling = 0; MclassInquire(TrainCtx, M_DEFAULT, M_SAMPLES_FIXED_SIZE + M_TYPE_MIL_INT, &amp;SamplesPerSampling); if(SamplesPerSampling == M_DEFAULT) { MclassInquire(TrainCtx, M_DEFAULT, M_SAMPLES_FIXED_SIZE + M_TYPE_MIL_INT + M_DEFAULT, &amp;SamplesPerSampling); } MIL_INT TrainEngineUsed { M_NULL }; MclassInquire(TrainCtx, M_DEFAULT, M_TRAIN_ENGINE_USED + M_TYPE_MIL_INT, &amp;TrainEngineUsed); if(TrainEngineUsed == M_GPU) { MIL_INT GpuTrainEngineStatus { M_NULL }; MclassInquire(TrainCtx, M_CONTEXT, M_GPU_TRAIN_ENGINE_LOAD_STATUS + M_TYPE_MIL_INT, &amp;GpuTrainEngineStatus); if(GpuTrainEngineStatus == M_JIT_COMPILATION_REQUIRED) { MosPrintf(MIL_TEXT(\"\\nWarning :: The training might not be optimal for the current system.\\n\")); MosPrintf(MIL_TEXT(\"Use the CNN Train Engine Test under Classification in MILConfig for more information.\\n\")); MosPrintf(MIL_TEXT(\"It may take some time before displaying the first results...\\n\")); } } else if(TrainEngineUsed == M_CPU) { MosPrintf(MIL_TEXT(\"\\nWarning :: The training is being done on the CPU. The training can take significantly more time on CPU.\\n\")); MosPrintf(MIL_TEXT(\"If a training on GPU was expected, use the CNN Train Engine Test under Classification in MILConfig for more information.\\n\")); } MIL_STRING TrainEngineDescription {}; MclassInquire(TrainCtx, M_DEFAULT, M_TRAIN_ENGINE_USED_DESCRIPTION, TrainEngineDescription); MIL_INT NbTrainImages = 0; MclassInquire(PreparedTrainDataset, M_DEFAULT, M_NUMBER_OF_ENTRIES + M_TYPE_MIL_INT, &amp;NbTrainImages); CTrainEvolutionDashboard TheTrainEvolutionDashboard( MilSystem, TrainCtx, NbTrainImages, SIZE_X, SIZE_Y, TrainEngineUsed, TrainEngineDescription); SSampleAddedHookData SampleAddedHookData(SamplesPerSampling, &amp;TheTrainEvolutionDashboard); MclassHookFunction(TrainCtx, M_SAMPLE_ADDED, HookSampleAddedTrainingFunc, &amp;SampleAddedHookData); MclassPreprocess(TrainCtx, M_DEFAULT); MdispSelect(MilDisplay, TheTrainEvolutionDashboard.GetDashboardBufId()); MclassTrain(TrainCtx, M_NULL, PreparedTrainDataset, PreparedDevDataset, TrainRslt, M_DEFAULT); MIL_UNIQUE_CLASS_ID TrainedCtx {}; MIL_INT Status {-1}; MclassGetResult(TrainRslt, M_DEFAULT, M_STATUS + M_TYPE_MIL_INT, &amp;Status); if(Status == M_COMPLETE) { MosPrintf(MIL_TEXT(\"\\nTraining completed successfully!\\n\")); TrainedCtx = MclassAlloc(MilSystem, M_CLASSIFIER_ANO_PREDEFINED, M_DEFAULT, M_UNIQUE_ID); MclassCopyResult(TrainRslt, M_DEFAULT, TrainedCtx, M_DEFAULT, M_TRAINED_CLASSIFIER, M_DEFAULT); MclassSave(EXAMPLE_TRAINED_CONTEXT_FILENAME, TrainedCtx, M_DEFAULT); MosPrintf(MIL_TEXT(\"\\nThe trained context was saved: \\\"%s\\\".\\n\"), EXAMPLE_TRAINED_CONTEXT_FILENAME); MosPrintf(MIL_TEXT(\"\\nPress any key to continue...\\n\")); MosGetch(); } else if(Status == M_STOPPED_BY_REQUEST) { MosPrintf(MIL_TEXT(\"\\nThe training was stopped so we have restored a pre-trained context to predict with.\\n\")); TrainedCtx = MclassRestore(EXAMPLE_PRETRAINED_PATH, MilSystem, M_DEFAULT, M_UNIQUE_ID); MosPrintf(MIL_TEXT(\"\\nPress any key to continue...\\n\")); MosGetch(); } else { PrintTrainStatusMessage(Status); } return TrainedCtx; } //============================================================================== MIL_INT MFTYPE HookPrepareEntryPreFunc(MIL_INT /*HookType*/, MIL_ID EventId, void* pUserData) { SPrepareEntryPreHookData* pPreHookData = reinterpret_cast&lt;SPrepareEntryPreHookData*&gt;(pUserData); MIL_ID ImageId = M_NULL; MclassGetHookInfo(EventId, M_IMAGE_ID + M_TYPE_MIL_ID, &amp;ImageId); MmodFind(pPreHookData-&gt;m_ModCtx, ImageId, pPreHookData-&gt;m_ModRes); MIL_INT NbOccurrences = 0; MmodGetResult(pPreHookData-&gt;m_ModRes, M_DEFAULT, M_NUMBER + M_TYPE_MIL_INT, &amp;NbOccurrences); if(NbOccurrences != 1) { MosPrintf(MIL_TEXT(\"Failed to find the top of the bottle for centering, this should not happen!\\n\")); return M_NULL; } MIL_DOUBLE CenterX = 0; MIL_DOUBLE CenterY = 0; MmodGetResult(pPreHookData-&gt;m_ModRes, 0, M_POSITION_X, &amp;CenterX); MmodGetResult(pPreHookData-&gt;m_ModRes, 0, M_POSITION_Y, &amp;CenterY); MclassSetHookInfo(EventId, M_CENTER_X, CenterX); MclassSetHookInfo(EventId, M_CENTER_Y, CenterY); return M_NULL; } //============================================================================== MIL_INT MFTYPE HookNumPreparedEntriesFunc(MIL_INT /*HookType*/, MIL_ID EventId, void* /*pUserData*/) { MIL_ID SrcDataset {M_NULL}; MclassGetHookInfo(EventId, M_SRC_DATASET_ID + M_TYPE_MIL_ID, &amp;SrcDataset); MIL_INT NumPrpEntries {0}; MclassGetHookInfo(EventId, M_NUMBER_OF_PREPARED_SRC_ENTRIES + M_TYPE_MIL_INT, &amp;NumPrpEntries); const MIL_INT NumEntries = MclassInquire(SrcDataset, M_DEFAULT, M_NUMBER_OF_ENTRIES, M_NULL); MIL_INT Status {-1}; MclassGetHookInfo(EventId, M_STATUS + M_TYPE_MIL_INT, &amp;Status); const MIL_STRING StatusStr = ConvertPrepareDataStatusToStr(Status); MIL_TEXT_CHAR EndOfLine = '\\r'; if(Status != M_COMPLETE) { EndOfLine = '\\n'; } MosPrintf(MIL_TEXT(\"Entry %d of %d completed with status: %s.%c\"), NumPrpEntries, NumEntries, StatusStr.c_str(), EndOfLine); if(NumPrpEntries == NumEntries) { EndOfLine == '\\r' ? MosPrintf(MIL_TEXT(\"\\n\\n\")) : MosPrintf(MIL_TEXT(\"\\n\")); } return M_NULL; } //============================================================================== MIL_INT MFTYPE HookSampleAddedTrainingFunc(MIL_INT /*HookType*/, MIL_ID EventId, void* pUserData) { SSampleAddedHookData* pSSampleAddedHookData = reinterpret_cast&lt;SSampleAddedHookData*&gt;(pUserData); if(pSSampleAddedHookData-&gt;m_NumberOfIterations == 0) { MclassGetHookInfo(EventId, M_NUMBER_OF_ITERATIONS + M_TYPE_MIL_INT, &amp;pSSampleAddedHookData-&gt;m_NumberOfIterations); } MIL_INT CurrentIterationIdx {}; MclassGetHookInfo(EventId, M_ITERATION_INDEX + M_TYPE_MIL_INT, &amp;CurrentIterationIdx); MIL_INT CurrentSampleIdx {}; MclassGetHookInfo(EventId, M_CURRENT_SAMPLE_INDEX + M_TYPE_MIL_INT, &amp;CurrentSampleIdx); if(CurrentSampleIdx == 0) { MappTimer(M_DEFAULT, M_TIMER_READ, &amp;pSSampleAddedHookData-&gt;m_IterationTime); MappTimer(M_DEFAULT, M_TIMER_RESET, M_NULL); } MIL_DOUBLE CurrentSampleLoss {}; MclassGetHookInfo(EventId, M_CURRENT_SAMPLE_LOSS, &amp;CurrentSampleLoss); MosPrintf(MIL_TEXT(\"\\rSample %d of %d learned in iteration %d of %d. Sampling loss: %f\"), CurrentSampleIdx + 1, pSSampleAddedHookData-&gt;m_SamplesPerIteration, CurrentIterationIdx + 1, pSSampleAddedHookData-&gt;m_NumberOfIterations, CurrentSampleLoss); pSSampleAddedHookData-&gt;m_pTrainDashboard-&gt;AddSampleData( CurrentSampleLoss, CurrentSampleIdx, CurrentIterationIdx, pSSampleAddedHookData-&gt;m_SamplesPerIteration, pSSampleAddedHookData-&gt;m_IterationTime); return M_NULL; } //============================================================================== MIL_INT MFTYPE HookPredictedEntryFunc(MIL_INT /*HookType*/, MIL_ID EventId, void* pUserData) { SPredictedEntryData* pPredictedEntryData = reinterpret_cast&lt;SPredictedEntryData*&gt;(pUserData); MIL_INT CurrentEntryIdx {}; MclassGetHookInfo(EventId, M_NUMBER_OF_PREDICTED_ENTRIES + M_TYPE_MIL_INT, &amp;CurrentEntryIdx); MIL_INT Status { -1 }; MclassGetHookInfo(EventId, M_STATUS + M_TYPE_MIL_INT, &amp;Status); const MIL_STRING StatusStr = ConvertPredictEntryStatusToStr(Status); MIL_TEXT_CHAR EndOfLine = '\\r'; if(Status != M_COMPLETE) { EndOfLine = '\\n'; } MosPrintf(MIL_TEXT(\"Predicted entry %d of %d completed with status: %s.%c\"), CurrentEntryIdx, pPredictedEntryData-&gt;m_NbEntries, StatusStr.c_str(), EndOfLine); if(CurrentEntryIdx == pPredictedEntryData-&gt;m_NbEntries) { EndOfLine == '\\r' ? MosPrintf(MIL_TEXT(\"\\n\\n\")) : MosPrintf(MIL_TEXT(\"\\n\")); } return M_NULL; } ",
      "wordCount": 6454
    }
  ]
}]
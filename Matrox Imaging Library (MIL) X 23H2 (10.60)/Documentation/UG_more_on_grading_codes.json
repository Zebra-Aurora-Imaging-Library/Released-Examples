[{
  "id": "UG_more_on_grading_codes",
  "version": "2024020714",
  "title": "More on grading codes",
  "subTitles": null,
  "location": "MIL UG P03: 2D processing and analysis",
  "pageURL": "content\\UserGuide\\more_on_grading_codes\\ChapterInformation.htm",
  "text": " Chapter 18: More on grading codes This chapter describes how to grade various symbols (codes). Code grade operation overview Steps to perform a grading operation Supported grading standard Settings for a code grade operation Control types that are commonly set Specifying the search region Setting the aperture Relative aperture setting Absolute aperture setting Attributes that can be graded Understanding fixed pattern damage Understanding modulation versus reflectance margin with 2D codes Understanding decodability with codes Grading using the ISO/IEC 15415 and ISO/IEC 15416 standards Grading using the ISO/IEC 29158 standard (for DPM) Grading using the SEMI T10 standard Approximating calibration settings (if necessary) Code grading examples ",
  "wordCount": 107,
  "subEntries": [
    {
      "id": "UG_more_on_grading_codes_Code_grade_operation_overview",
      "version": null,
      "title": "Code grade operation overview",
      "subTitles": null,
      "location": "MIL UG P03: 2D processing and analysis",
      "pageURL": "content\\UserGuide\\more_on_grading_codes\\Code_grade_operation_overview.htm",
      "text": " Code grade operation overview Some applications require that you evaluate the quality of a printed or marked code. Due to the possibility for codes on a product to degrade through the production process, it is often important that codes meet certain standards before leaving the marking stations. This ensures that the code is readable by most types of scanners or imagers that support your code type. For this purpose, the industry has created a set of standard print and DPM quality specifications (grading standards). These standards can be used in two distinct phases: one to prepare the physical environment in which to best validate your code so that you test the printed code and not the setup in which it is read (such as lighting, code angle, quality of the code reader), and the other to validate the code that is being read. You can use McodeGrade() for both phases. McodeGrade() can grade codes according to the ISO/IEC 15416, ISO/IEC 15415, ISO/IEC 29158, and SEMI T10 grading standards. There are many code attributes that can be graded, all of which contribute to a code's readability. Depending on the code type and the attribute being tested, most tests are graded from 0.0 to 4.0 (F to A), or given a pass or fail mark. Note that McodeGrade() does not support grading 4-state, Pharmacode, Postnet, and Planet 1D code types. You can grade a single code occurrence or multiple code occurrences with each call to McodeGrade(), depending upon your requirements. In addition, by default, McodeGrade() internally performs a read operation before performing the grading operation. However, you can perform the read operation using McodeRead() and pass the code read result buffer to McodeGrade(). This is done if you do not want to grade the result of every image that you need to read. This chapter will guide you through the steps in using the MIL Code module to prepare your code setup for verification, as well as provide additional details for understanding the grading results from the MIL Code module. For details on detecting the code type, training the code grade context, or setting up a code grade context to read your code, see Chapter 17: Codes. Code grade operation overview ",
      "wordCount": 371,
      "subEntries": []
    },
    {
      "id": "UG_more_on_grading_codes_Steps_to_perform_a_grading_operation",
      "version": null,
      "title": "Steps to perform a grading operation",
      "subTitles": null,
      "location": "MIL UG P03: 2D processing and analysis",
      "pageURL": "content\\UserGuide\\more_on_grading_codes\\Steps_to_perform_a_grading_operation.htm",
      "text": " Steps to perform a grading operation The following steps provide the basic methodology for grading a code using the MIL Code module: Allocate a code context (McodeAlloc()), optionally detect the type of codes to grade (McodeDetect()), add one or more code models of the appropriate type to the code grade context (McodeModel()), and train and change the control type settings so that your code(s) to grade can be read (McodeTrain()). For information on all these steps, see the Steps to reading, grading, or writing a code in an image section of Chapter 17: Codes. A code context can contain multiple code models of 1D code types; for other code types, a code context can contain at most one code model. Note that McodeGrade() does not support grading 4-state, Pharmacode, Postnet, and Planet 1D code types. If necessary, specify the number of occurrences to grade for 1D, DotCode, or Data Matrix code models, using McodeControl() with M_NUMBER. For code models of other types, this control type must be set to 1 (M_DEFAULT) because you can only read/grade one occurrence of these types of code models. Configure your physical setup according to the specifications of your grading standard. For more details, see the section on your grading standard later in this chapter. Allocate a result buffer to hold the code grade results, using McodeAllocResult() with M_CODE_GRADE_RESULT. Grab or load an image that contains the code. If the image is large, and contains information that might be misinterpreted as a code, create a child buffer to isolate the code from the rest of the image. Alternatively, use a 2D graphics list to define a rectangular region of interest (ROI) using MbufSetRegion(). If your image contains other important information besides the code, the presearch feature can help MIL locate a 2D code (except DotCode); enable the feature using McodeControl() with M_USE_PRESEARCH. Optionally, you can perform an McodeRead() operation. The results of this read operation can be graded. This is done if you do not want to grade the results of every image you need to read. Before performing this McodeRead() operation, make sure the context is configured for the McodeGrade() operation. Note, if you do not perform an McodeRead() operation, it will be done internally as part of the McodeGrade() operation. Use McodeGrade() to perform a grade operation. Retrieve grading results, using McodeGetResult(). If necessary, save your code context, using McodeSave() or McodeStream(). If necessary, save a report containing most of the results from a grade operation as a text file, using McodeStream(). Free all your allocated objects, using McodeFree(), unless M_UNIQUE_ID was specified during allocation. Steps to perform a grading operation ",
      "wordCount": 440,
      "subEntries": []
    },
    {
      "id": "UG_more_on_grading_codes_Supported_grading_standard",
      "version": null,
      "title": "Supported grading standard",
      "subTitles": null,
      "location": "MIL UG P03: 2D processing and analysis",
      "pageURL": "content\\UserGuide\\more_on_grading_codes\\Supported_grading_standard.htm",
      "text": " Supported grading standard McodeGrade() supports grading using the grading standards listed below. The selected grading standard affects the implementation of some control types, and can cause different results when grading the same code. ISO/IEC 15415. Used for printed 2D codes (for example, QR, MicroQR, DotCode, and Atzec). For details, see the Grading using the ISO/IEC 15415 and ISO/IEC 15416 standards section later in this chapter. ISO/IEC 15416. Used for printed 1D codes (for example, BC-412, Codabar, and Code 39). For details, see the Grading using the ISO/IEC 15415 and ISO/IEC 15416 standards section later in this chapter. ISO/IEC 29158. Used for DPM (direct part marking) 2D codes (for example, Aztec, Data Matrix and QR). For details, see the Grading using the ISO/IEC 29158 standard (for DPM) section later in this chapter. SEMI T10. Used for DPM (direct part marking) Data Matrix codes on semiconductor parts. DPM is the process of etching or printing codes directly into or on to parts. For details, see the Grading using the SEMI T10 standard section later in this chapter. To use these grading standards, first, set the grading standard using McodeControl() with M_GRADING_STANDARD. By default, the latest supported edition of these standards is used. To specify a specific edition, use McodeControl() with M_GRADING_STANDARD_EDITION. Supported grading standard ",
      "wordCount": 214,
      "subEntries": []
    },
    {
      "id": "UG_more_on_grading_codes_Settings_for_a_code_grade_operation",
      "version": null,
      "title": "Settings for a code grade operation",
      "subTitles": [
        "Control types that are commonly set",
        "Specifying the search region",
        "Setting the aperture",
        "Relative aperture setting",
        "Absolute aperture setting"
      ],
      "location": "MIL UG P03: 2D processing and analysis",
      "pageURL": "content\\UserGuide\\more_on_grading_codes\\Settings_for_a_code_grade_operation.htm",
      "text": " Settings for a code grade operation This section contains settings you might have to change before performing a McodeGrade() operation. Control types that are commonly set The following is a list of control types in McodeControl() that you should typically set (if their default settings don't apply to your code occurrences) before grading a code occurrence: Control type Notes M_FOREGROUND_VALUE Specifies the foreground color of the code occurrence. This control type must be set if the foreground color is not black; the code occurrence will not be graded if the foreground value is not correctly set. M_ENCODING Specifies the type of encoding scheme for the code occurrence. This control type must be set if the default encoding scheme for the code type differs from the one used by the code occurrence or if M_ANY is not supported. M_ERROR_CORRECTION Specifies the type of error correction scheme for the code occurrence. This control type must be set if the default error correction scheme for the code type differs from the one used by the code occurrence or if M_ANY is not supported. M_STRING_SIZE.... Specifies the maximum and minimum size of the string (number of characters) encoded in each code occurrence. These control types must be set if M_STRING_SIZE_MIN and/or M_STRING_SIZE_MAX cannot be set to M_ANY. M_SEARCH_ANGLE.... Specifies the nominal search angle and angular search range. These control types must be set if the code occurrence is at an angle greater or less than 0.0 ±5 degrees. For more information on these settings, see the Supported encoding schemes, sub-types, and error correction schemes by code type section of Chapter 17: Codes and the Customizing read and grade operation settings section of Chapter 17: Codes. Specifying the search region When specifying the search region, it is important to include the quiet zone of the code. The quiet zone is an area around the code with no markings in it. For 1D codes, the quiet zone immediately precedes the start character and follows the stop character. For 2D codes, the quiet zone must be present on all four sides of the code. The quiet zone must be large enough to meet the code type specifications. For example, the Data Matrix code type requires that the quiet zone be at least one cell wide. The DotCode code type requires a quiet zone of three cells wide. 1D code types require a quiet zone of 2 to 10 times the width of the thinnest bar, depending on the type. Setting the aperture The aperture is the diameter of the circular smoothing filter used by the code grade operation to avoid minor defects that might influence the grading of a code occurrence. Ideally, the aperture size is set large enough so that the smoothing effect eliminates insignificant defects and is set small enough so that the contrast between the foreground and the background remains strong. If the aperture is not set correctly, the grading results will not be accurate. In most cases, the M_DEFAULT setting is suitable. However, you have several options depending on how you set the aperture mode (M_APERTURE_MODE). Relative aperture setting. To have MIL calculate the aperture size as a multiplicative factor of the cell size, use M_APERTURE_MODE set to M_RELATIVE (same as M_DEFAULT). Absolute aperture setting. To set your aperture size as a fixed value, use M_APERTURE_MODE set to M_ABSOLUTE. The aperture size can be set for all code types. Relative aperture setting To set the aperture size to a relative value, use M_APERTURE_MODE set to M_RELATIVE. To convert the value you have entered in M_RELATIVE_APERTURE_FACTOR to real-world units, specify the scale value with M_PIXEL_SIZE_IN_MM. Note that specifying the aperture factor with a pixel size in millimeters is typically used when configuring your aperture to be calculated according to the exact guideline from the ISO industry-standardized print-quality specification. The table below shows the calculation used based on how M_RELATIVE_APERTURE_FACTOR and M_PIXEL_SIZE_IN_MM are set. Data to use Set M_RELATIVE_APERTURE_FACTOR Set M_PIXEL_SIZE_IN_MM Calculation used Use standardized factors without specifying pixel size. M_AUTO M_UNKNOWN Aperture Factor x M_CELL_SIZE , where Aperture Factor is a range from 0.15 to 0.8, depending on the code type and applicable standard. Use standardized factors and specify the pixel size. M_AUTO Pixel size in mm For EAN/UPC code types, 0.15 / M_PIXEL_SIZE_IN_MM . For all other codes, Reference number/ M_PIXEL_SIZE_IN_MM , where Reference number is a range from 0.075 to 0.5, and is based on the cell size in millimeters (M_CELL_SIZE x M_PIXEL_SIZE_IN_MM) and the ISO/IEC 15416 specification. Note that, if the cell size in millimeters is less than 0.1 millimeters, the following formula is used: 0.5 x M_CELL_SIZE for 1D codes, and the aperture size is 0.8 x M_CELL_SIZE for matrix codes. Use the specified aperture factor and the pixel size. Aperture factor Pixel size in mm M_RELATIVE_APERTURE_FACTOR x M_CELL_SIZE Note that the cell size should be the smallest cell size among all of the code occurrences of the model in your images. To assist MIL in calculating your aperture setting, specify the pixel size of your code in millimeters. To determine the pixel size of your code in millimeters (M_PIXEL_SIZE_IN_MM), perform the following: Physically measure the entire code with a ruler. Note that this result must be in millimeters. Read the code from a typical image of the code, using McodeRead(). Determine the length of the code in pixels. This can be done in three different ways: For Data Matrix, DotCode, and QR codes, multiply the cell size (McodeGetResult() with M_CELL_SIZE) by the number of cells across the code, as defined by the specification for your code type. For 1D codes, use McodeGetResult() with M_SIZE_X, making sure that M_RESULT_OUTPUT_UNITS is set to M_PIXEL if the image was calibrated. Use the MIL Measurement module to set two point markers to identify the start and end of your code, using MmeasSetMarker() with M_POSITION. Then, calculate the distance between two markers using MmeasCalculate(). Use an interactive tool, such as the MIL Code Reader Interactive Utility. Divide the measurement in millimeters by the length of the code in pixels. Set M_PIXEL_SIZE_IN_MM to this result. Note that if the setup for acquiring the image of the code is significantly changed (making the acquired code either significantly larger or smaller than the code used to perform the pixels in millimeters calculation), the calculation should be performed again and M_PIXEL_SIZE_IN_MM set to the new value. Absolute aperture setting To set the aperture size to a fixed value (so that it will not change regardless of the cell size of your code occurrence), first set the aperture mode to absolute, using M_APERTURE_MODE set to M_ABSOLUTE. Then, set the absolute aperture size to a fixed value, using M_ABSOLUTE_APERTURE_SIZE. The aperture size is set in units specified by M_ABSOLUTE_APERTURE_SIZE_INPUT_UNITS. Settings for a code grade operation Control types that are commonly set Specifying the search region Setting the aperture Relative aperture setting Absolute aperture setting ",
      "wordCount": 1146,
      "subEntries": []
    },
    {
      "id": "UG_more_on_grading_codes_Attributes_that_can_be_graded",
      "version": null,
      "title": "Attributes that can be graded",
      "subTitles": [
        "Understanding fixed pattern damage",
        "Understanding modulation versus reflectance margin with 2D codes",
        "Understanding decodability with codes"
      ],
      "location": "MIL UG P03: 2D processing and analysis",
      "pageURL": "content\\UserGuide\\more_on_grading_codes\\Attributes_that_can_be_graded.htm",
      "text": " Attributes that can be graded To grade a code, McodeGrade() scans the code multiple times along different paths (also referred to as scanlines). To grade a 1D code, McodeGrade() performs scans at regular intervals along the Y-axis of the code; the set of grayscale values along a scanline (in the area of the code and its quiet zones) is called a scan reflectance profile. Note that to read 1D codes, McodeRead() also scans the code at regular intervals along the Y-axis, but it only performs as many scans as needed to successfully read the code; these scans are referred to as decoded scanlines. The image below shows in red example paths along which McodeGrade() extracts scans reflectance profiles and shows in blue the example paths along which McodeRead() decodes scans. For 2D codes, the entire code is analyzed in both operations. For composite codes, the 1D portion is graded with multiple scanlines and the entire 2D portion is analyzed. The following table lists the common code attributes that can be graded using MIL, including the attributes of the scan reflectance profiles. Attribute Notes Available results Axial nonuniformity This attribute is a measure of how spacing between sampling points differs between the X- and Y-axis (width to height). M_AXIAL_NONUNIFORMITY_GRADE Contrast This attribute is a measure of the contrast in the cells of the code occurrence or in the entire code occurrence. The higher the contrast, the better it is for scanning purposes and the better the grade. M_SYMBOL_CONTRAST_GRADE Decode This attribute is a measure of the success or failure of the decoding algorithm and is used to determine if the code is readable. M_DECODE_GRADE M_SCAN_DECODE_GRADE Defects This attribute is a measure of the defects, or local deviations, in the scan reflectance profiles of the code. M_SCAN_DEFECTS_GRADE Fixed-pattern damage This attribute is used to grade the damage relating to the finder pattern and/or clock pattern of Aztec, Data Matrix, QR, and MicroQR codes. This attribute is also used to grade the damage relating to the dot positions not available for printing of a DotCode code. See the Understanding fixed pattern damage subsection of this section Grid non-uniformity This attribute is calculated as the amount of deviation of the code occurrence's actual grid from an ideal grid. M_GRID_NONUNIFORMITY_GRADE Minimum edge contrast This attribute is calculated as the contrast between two adjacent regions (for example, a bar and an adjacent space). M_SCAN_EDGE_CONTRAST_MINIMUM_GRADE Print growth This attribute is a measure of the extent in which the boundaries of the black and white markings of the code occurrence are within their cell's boundaries. M_PRINT_GROWTH_GRADE Start/stop pattern This attribute is used to grade the quality of the pattern that marks the end points of the code occurrence. M_START_STOP_PATTERN_GRADE Unused Error Correction This is a measure of the extent in which regional or spot damage in the code occurrence has eroded the reading safety margin that error correction provides. M_UNUSED_ERROR_CORRECTION_GRADE Note that an overall symbol grade can also be returned, using McodeGetResult() with M_OVERALL_SYMBOL_GRADE. For 2D codes, this is a measure of the worst grade for the results of a specific code occurrence. For 1D codes, it is a measure of the average grade for the results of a specific code occurrence. Other code attributes can also be evaluated with the grading operation, but they return a value as opposed to a grade. Understanding fixed pattern damage The fixed pattern (also known as the fixed orientation pattern and the finder pattern) of a printed code (symbol) enables scanning equipment to identify and locate the code. Damage in the finder pattern of a code can make it unreadable. McodeGrade() can establish a grade for multiple aspects of the fixed pattern of a code occurrence in an image. Code type (and encoding scheme if applicable) Fixed pattern Available results M_AZTEC code type with M_ENC_AZTEC_COMPACT or M_ENC_AZTEC_RUNE Has a 2-ring bull's eye (A segment), whereby each corner of the center bull's eye uses a different, fixed orientation pattern for determining symbol orientation. M_FIXED_PATTERN_DAMAGE_A_GRADE M_AZTEC code type with M_ENC_AZTEC_FULL_RANGE Has a 3-ring bull's eye (A segment), whereby each corner of the center bull's eye uses a different, fixed orientation pattern for determining symbol orientation. In addition, it has a fixed reference grid along every 16th row and column (B segments) to help map the data layers. M_FIXED_PATTERN_DAMAGE_A_GRADE M_FIXED_PATTERN_DAMAGE_B_GRADE M_DATAMATRIX code type Has L1, L2, QZL1, and QZL2 segments. In addition, it has clock track and solid (clock pattern and adjacent solid area) segments. M_FIXED_PATTERN_DAMAGE_AVERAGE_GRADE M_FIXED_PATTERN_DAMAGE_L1_GRADE M_FIXED_PATTERN_DAMAGE_L2_GRADE M_FIXED_PATTERN_DAMAGE_QZL1_GRADE M_FIXED_PATTERN_DAMAGE_QZL2_GRADE M_FIXED_PATTERN_DAMAGE_CLOCKTRACK_SOLID_GRADE M_DOTCODE code type There are no fixed patterns within the data dots of a DotCode code type. Instead, the fixed patterns are those dot positions not made available for printing: the interstitial dot positions and the 3-dot wide quiet zone on all 4 sides. M_FIXED_PATTERN_DAMAGE_INTERSTITIAL_DOTS_GRADE M_FIXED_PATTERN_DAMAGE_QUIET_ZONES_GRADE M_QRCODE code type Has A1, A2, A3, B1, B2, and C segments. M_FIXED_PATTERN_DAMAGE_A1_GRADE M_FIXED_PATTERN_DAMAGE_A2_GRADE M_FIXED_PATTERN_DAMAGE_A3_GRADE M_FIXED_PATTERN_DAMAGE_B1_GRADE M_FIXED_PATTERN_DAMAGE_B2_GRADE M_FIXED_PATTERN_DAMAGE_C_GRADE M_MICROQRCODE code type Has A1, B1, and B2 segments. M_FIXED_PATTERN_DAMAGE_A1_GRADE M_FIXED_PATTERN_DAMAGE_B1_GRADE M_FIXED_PATTERN_DAMAGE_B2_GRADE Understanding modulation versus reflectance margin with 2D codes To analyze whether a given cell is considered part of the foreground or the background, you can grade its modulation and/or reflectance margin. Both modulation and reflectance margin rely on your code occurrence's threshold. The difference is that the modulation is computed without regard to whether the cell should be light or dark; whereas, the reflectance margin takes the expected state of any cell (that is, whether it is supposed to be light or dark) into account. When reading a 2D code occurrence, if the grayscale value of a cell (also called its reflectance value) is above the threshold value, it is considered light. Values close to the threshold are considered ambiguous, while values further away are considered unambiguous. For example, consider a given 2D matrix code occurrence that has a symbol contrast of 255 and a computed threshold of 128. In this case, if a cell has a grayscale value of 255, it is a light cell. This is considered unambiguous since 255 is very far from 128. If a cell's grayscale value is 132, however, the cell is still considered light (since it is over the computed threshold), but the difference between the grayscale value of the cell and the threshold is low enough that the result is considered ambiguous by most grading specifications. In the following image, the circled cells are examples within the code occurrence that are considered ambiguous because those cells are closer to the threshold value than an unambiguous dark cell. The modulation of a code occurrence is based on the difference between the computed threshold and the grayscale value of each cell (its reflectance), divided by the symbol contrast. A greater difference results in a greater modulation. The modulation can be calculated for each cell in the code occurrence and uses the following calculation: The modulation is computed without regards to whether any cell should be light or dark. Instead, the modulation relies on the difference between the grayscale value of each cell and the code occurrence's threshold value. The greater this difference, the greater the modulation, and by association, the unambiguous claim that a cell should be either light or dark, respectively. The following is a list of the different parts of a code occurrence for which you can retrieve the modulation grade: To retrieve the modulation of the code occurrence, as a grade calculated using the ISO standard, use M_MODULATION_GRADE. To retrieve the modulation of the code occurrence calculated using the ISO/IEC 29158 standard, use M_CELL_MODULATION_GRADE. To retrieve the modulation of each codeword as a grade, use M_CODEWORD_MODULATION_GRADE. To retrieve the modulation of the start/stop patterns of 2D cross-row and composite code types, as a grade, use M_SCAN_MODULATION_GRADE. The reflectance margin is similar to the modulation in that it is calculated using the threshold value and the grayscale value of the cell. The difference is that when any cell is supposed to be light and its grayscale value is below the threshold value, its reflectance margin is 0. The following is a list of the different parts of a code occurrence for which you can retrieve the cell's grayscale value (its reflectance) and its reflectance margin grade: To retrieve the reflectance margin grade of a code occurrence, use M_REFLECTANCE_MARGIN_GRADE. To retrieve the minimum reflectance (grayscale value of the cell in the code occurrence), use M_MINIMUM_REFLECTANCE_GRADE. To retrieve the reflectance margin of each codeword, use M_CODEWORD_REFLECTANCE_MARGIN_GRADE. Note that, the reflectance of other code attributes can also be evaluated with the grading operation, but they return a value as opposed to a grade. Understanding decodability with codes For 1D, 2D cross-row, and composite code types, you can retrieve a measure of decodability using M_DECODABILITY_GRADE or M_SCAN_DECODABILITY_GRADE (depending on code type). Decodability is a measure of how well the MIL Code module can read the code occurrence. By contrast, the decode grade is a grade denoting the success or failure of the decoding operation (A or F). You can retrieve the decode grade using M_SCAN_DECODE_GRADE. The range of decodability can sometimes result in a relatively low decodability that still results in a passing decode grade, or the opposite (a relatively high decodability that results in a failing decode grade). For example, with Code 93 code types, each letter is represented by a specific number of bars and spaces, each of a predetermined width. If the code occurrence has a very low decodability grade, this should result in a failing decode grade (although a string might be decoded or partially decoded, depending on the success or failure of the related error checks). However, sometimes a passing decode grade is obtained while the decodability is relatively low. In such cases, the decodability of other parts of the code occurrence should be examined (such as the decodabiliy of the scan profile or codewords). The following is a list of the different parts of a code occurrence for which you can retrieve the decodability grade: To retrieve the decodability grade of the entire code occurrence, use M_DECODABILITY_GRADE. To retrieve the decodability grade of the scan reflectance profile, use M_SCAN_DECODABILITY_GRADE. To retrieve the decodability grade for each codeword, use M_CODEWORD_DECODABILITY_GRADE. To retrieve the decodability grade of the start/stop patterns of the code occurrence, use M_SCAN_DECODABILITY_GRADE. Note that McodeGrade() uses a decoding algorithm specified by the selected standard. This algorithm is less flexible than the Matrox algorithms that are used by McodeRead(). For poor quality codes, it is possible that McodeRead() succeeds (McodeGetResult() with M_STATUS), but McodeGrade() returns an F for the decode grade (McodeGetResult() with M_DECODE_GRADE). Attributes that can be graded Understanding fixed pattern damage Understanding modulation versus reflectance margin with 2D codes Understanding decodability with codes ",
      "wordCount": 1771,
      "subEntries": []
    },
    {
      "id": "UG_more_on_grading_codes_Grading_using_the_ISO_IEC_15416_and_15415_standard",
      "version": null,
      "title": "Grading using the ISO/IEC 15415 and ISO/IEC 15416 standards",
      "subTitles": null,
      "location": "MIL UG P03: 2D processing and analysis",
      "pageURL": "content\\UserGuide\\more_on_grading_codes\\Grading_using_the_ISO_IEC_15416_and_15415_standard.htm",
      "text": " Grading using the ISO/IEC 15415 and ISO/IEC 15416 standards To grade printed codes, MIL supports ISO/IEC 15415 and ISO/IEC 15416. For 1D codes, use ISO/IEC 15416. For 2D codes, use ISO/IEC 15415. For 2D cross-row and composite code types, use ISO/IEC 15416 and ISO/IEC 15415. Note that McodeGrade() is not supported for 4-state, Pharmacode, Postnet, and Planet 1D code types. Before you can validate the print quality of a code, you must configure (calibrate) your setup so that you are analyzing the printed code and not how well the code can be read in the current environment. When calibrating for the ISO/IEC 15415 and ISO/IEC 15416 standards, you adjust the environment and establish exact values for the following McodeGrade() grading settings: M_MINIMUM_CALIBRATED_REFLECTANCE: This is the minimum calibrated reflectance (Rmin). It specifies the expected minimum possible grayscale value in the target image. M_MAXIMUM_CALIBRATED_REFLECTANCE: This is the maximum calibrated reflectance (Rmax). It specifies the expected maximum possible grayscale value in the target image. The general ISO standards ISO/IEC 15416 and ISO/IEC 15415 provide only general guidelines for configuring your setup for code verification. The following procedure is designed to assist in modifying your setup until ideal conditions are obtained. A grabbed image of a near-perfect code is used since you know the grade of a perfect code should be 4.0 (sometimes A), as long as the setup is not influencing the grade. Note that if rigorous calibration is not possible (for example, because you don't have a standard test card or you have workflow constraints), you can approximate the grading setting. See the Approximating calibration settings (if necessary) section later in this chapter. Set the grading standard to ISO/IEC 15416 and ISO/IEC 15415 using McodeControl() with M_GRADING_STANDARD set to M_ISO_GRADING. In the environment in which you will eventually be grading your codes, grab an image of a perfectly printed sample code using MdigGrab() (for example, an image of a code conformance test card for your code type, such as the GS1 Data Matrix calibrated conformance standard test card or the NIST-traceable EAN/UPC calibrated conformance test card). If grading a 2D code, you can calibrate using 1D or 2D test cards. For a 1D code type, a 1D code test card is required. Set the aperture of the code model to the recommended aperture for the code. Typically, you set McodeControl() with M_APERTURE_MODE to M_RELATIVE and M_RELATIVE_APERTURE_FACTOR to M_AUTO; see the Setting the aperture subsection of the Settings for a code grade operation section earlier in this chapter for more information on setting the aperture. Call McodeGrade(). Then, retrieve the overall grade using McodeGetResult() with M_OVERALL_SYMBOL_GRADE. If the resulting grade is not a 4.0 (perfect grade), then as necessary, adjust the image setup to: Maximize the contrast and minimize noise in the image. Avoid pixel saturation. Have a cell size of at least 3. A smaller cell size results in a less robust result. Have a uniform foreground and background grayscale level (that is, there should be no glare or dark spots present in the image). Repeat steps 1-4 until the resulting grade is an \"A\" (or the best possible grade given the surface on which the code is printed). For 1D code types, get the recommended aperture size, using McodeGetResult() with M_RECOMMENDED_APERTURE_SIZE. Smooth the image using multiple calls to MimConvolve() with M_SMOOTH. MimConvolve() should be called at least once and at most a number of times equal to the following: (Recommended Aperture size + 0.5)/2 Find the minimum and maximum pixel values in the smoothed image using MimFindExtreme() with M_MIN_VALUE + M_MAX_VALUE. These values will be used as the minimum calibrated reflectance and the maximum calibrated reflectance, respectively. For 2D code types, get the minimum and maximum reflectance (grayscale) values, using McodeGetResult() with M_R_MIN and M_R_MAX, respectively. These values will be used as the minimum calibrated reflectance and the maximum calibrated reflectance, respectively. Set the minimum and maximum calibrated reflectance to the values previously determined in step 6 or 7, using McodeControl() with M_MINIMUM_CALIBRATED_REFLECTANCE and M_MAXIMUM_CALIBRATED_REFLECTANCE, respectively. If the sample code and target code are of different code types, remove your sample code model from your code context and add a new code model for your target code type. Grade your target codes. It is important not to modify the setup for the remainder of the grading process. Note that for better accuracy, after adjusting your setup using a perfect grade code, you can also grab and test images of non-perfect codes with known grades, if present on your code conformance test card. For these codes, instead of retrieving the overall grade in step 3, retrieve the grade obtained for the code attribute that is not perfect using McodeGetResult() with M_..._GRADE to see if the returned grade matches the known grade. Grading using the ISO/IEC 15415 and ISO/IEC 15416 standards ",
      "wordCount": 800,
      "subEntries": []
    },
    {
      "id": "UG_more_on_grading_codes_Grading_using_the_ISO_IEC_29158_standard",
      "version": null,
      "title": "Grading using the ISO/IEC 29158 standard (for DPM)",
      "subTitles": null,
      "location": "MIL UG P03: 2D processing and analysis",
      "pageURL": "content\\UserGuide\\more_on_grading_codes\\Grading_using_the_ISO_IEC_29158_standard.htm",
      "text": " Grading using the ISO/IEC 29158 standard (for DPM) Direct part marking (DPM) codes are codes that are etched directly on to the parts instead of labels. To grade 2D DPM (direct part marking) codes, use ISO/IEC 29158. The ISO/IEC 29158 standard is an extension of the ISO/IEC 15415 standard and is intended for codes that are marked directly on a surface. The light and dark elements of these codes are determined from the physically altered surface conditions (for example, etched and not etched). When you calibrate for the ISO/IEC 29158 standard, you adjust the environment and establish exact values for the following McodeControl() grading settings: M_REFLECTANCE_CALIBRATION. This is the expected reflectance value (Rcal). This corresponds to the maximum possible intensity of the centers of the white elements. M_MEAN_LIGHT_CALIBRATION. This is the expected mean light value (Mcal). This corresponds to the expected mean intensity of the centers of the white elements of the code occurrence. Ideally, all factors affecting the intensity of grabbed images (that is, lights, exposure and gain settings, and surface characteristics) during calibration and production are identical. This is strongly advised. Otherwise, you can establish and set M_SYSTEM_RESPONSE_CALIBRATION and M_SYSTEM_RESPONSE_TARGET; their ratio tells the code grade algorithm how much brighter or darker a perfect marked code would appear within the target setup, when compared to the calibration setup. If the difference in these settings can be expressed as a constant that is proportional to the change in the intensity (for example, exposure), then providing the calibration and target values of the constant might provide more accurate grades. The ISO/IEC 29158 standard is implemented in two phases: the reflectance calibration phase and the target grading phase. Each phase establishes the settings of the environmental factors that result in an acceptable image of a perfect reference code (printed) and target code (direct part marked), respectively. The second phase is only necessary if you need to set M_SYSTEM_RESPONSE_CALIBRATION and M_SYSTEM_RESPONSE_TARGET; otherwise these control types can be left to their default value of 1. The values of each phase are used to produce the grades associated with the target code. Note that if rigorous calibration is not possible (for example, because you don't have a standard test card or you have workflow constraints), you can approximate the grading setting. See the Approximating calibration settings (if necessary) section later in this chapter. To perform the reflectance calibration phase: Place an A-grade code, printed on a code conformance test card, in the field of view (for example, the GS1 Data Matrix calibrated conformance standard test card or the NIST-traceable EAN/UPC calibrated conformance test card); the code is used as the reference code. The reference code can be of any code type (even 1D code types). Adjust the lighting according to the ISO/IEC 29158 standard. Allocate a code context (using McodeAlloc()) and add a code model that has the same type as the reference code. For this phase, set M_GRADING_STANDARD to M_ISO_GRADING. Set the aperture of the code model to the recommended aperture for the reference code. Typically, you set McodeControl() with M_APERTURE_MODE to M_RELATIVE and M_RELATIVE_APERTURE_FACTOR to M_AUTO; see the Setting the aperture subsection of the Settings for a code grade operation section earlier in this chapter. Grab an image of the reference code, using MdigGrab(). Call McodeGrade(). Calculate the mean light ratio: ((McodeGetResult() with M_MEAN_LIGHT_CALIBRATION) / MbufControl() with M_MAXIMUM_CALIBRATED_REFLECTANCE). By default, MbufControl() with M_MAXIMUM_CALIBRATED_REFLECTANCE is set to the maximum possible grayscale value of the buffer. If the image does not use the full range of possible grayscale values, set M_MAXIMUM_CALIBRATED_REFLECTANCE to the expected maximum value, prior to calling McodeGrade(). If the mean light ratio is not within 70% and 86%, adjust your environment factors (the location, camera, and/or lighting setup) and repeat steps e to g until the mean light ratio is within this range. Take note of McodeGetResult() with M_REFLECTANCE_CALIBRATION and M_MEAN_LIGHT_CALIBRATION. To perform the target grading phase: Calculate the System Response value (SRcal) for the reflectance calibration environment. To do so, use a user-defined aggregate of the environment factors that you used to create the conditions for an acceptable reference code during the reflectance calibration phase. For example, you could set the System Response value to be (Exposure time * Gain factor). If the reference code (printed) and target code (DPM) are of different code types, allocate another code context and add a code model that has the same type as the target code. Set the grading standard to ISO/IEC 29158 using McodeControl() with M_GRADING_STANDARD set to M_ISO_DPM_GRADING. Load the reflectance and mean light values from the reflectance calibration phase into the code context of the target code. To do so with one call, use McodeControl() with M_DPM_CALIBRATION_RESULTS and the result buffer from the reflectance calibration phase. Alternatively, retrieve the reflectance and mean light values separately from this result buffer, and set the values into the code context of the target code using McodeControl() with M_REFLECTANCE_CALIBRATION and M_MEAN_LIGHT_CALIBRATION, respectively. Set the System Response value derived from the reflectance calibration phase (SRcal) using McodeControl() with M_SYSTEM_RESPONSE_CALIBRATION. Acquire an image of the target (DPM) code. All environmental factors must be the same as those used in the reflectance calibration phase, except those factors used to calculate the System Response value (SRcal). Set the System Response value for the target grading environment (the current environment) using McodeControl() with M_SYSTEM_RESPONSE_TARGET. Use the same formula as the one used to calculate it for the reflectance calibration. For example, if you set the System Response value for the reflectance calibration phase to (Exposure time * Gain factor), set M_SYSTEM_RESPONSE_TARGET to (Exposure time * Gain factor) for the current environment. Call McodeGrade(). Calculate the mean light ratio: ((McodeGetResult() with M_MEAN_LIGHT_TARGET) / McodeInquire() with M_MAXIMUM_CALIBRATED_REFLECTANCE). If the mean light ratio is not within 70% and 86%, adjust your environment factors (the location, camera, and/or lighting setup) and repeat steps f to i until the mean light ratio is within this range. Grade your target codes. If you skipped step 2, make sure to change the code model in your context using McodeModel(); also, using the reflectance and mean light values retrieved from the result buffer during the reflectance calibration phase, set McodeControl() with M_REFLECTANCE_CALIBRATION and M_MEAN_LIGHT_CALIBRATION, respectively. It is important not to modify the setup for the remainder of the grading process. Note that if the image of the target code has its mean light ratio within the above mentioned range under the same environmental conditions as the reference code, you can leave M_SYSTEM_RESPONSE_CALIBRATION and M_SYSTEM_RESPONSE_TARGET to their default values of 1. For more information, especially regarding the guidelines for lighting environments and reflectance calibration configurations, refer to the ISO/IEC 29158 specification. For an example, see the Code grading examples section later in this chapter. Grading using the ISO/IEC 29158 standard (for DPM) ",
      "wordCount": 1126,
      "subEntries": []
    },
    {
      "id": "UG_more_on_grading_codes_Grading_using_the_semi_t10_standard",
      "version": null,
      "title": "Grading using the SEMI T10 standard",
      "subTitles": null,
      "location": "MIL UG P03: 2D processing and analysis",
      "pageURL": "content\\UserGuide\\more_on_grading_codes\\Grading_using_the_semi_t10_standard.htm",
      "text": " Grading using the SEMI T10 standard To grade a Data Matrix code direct part marked (DPM) on a semiconductor part, you can use the SEMI T10 grading standard. For information on grading DPM codes under other circumstances, see the Grading using the ISO/IEC 29158 standard (for DPM) section earlier in this chapter. Before you can grade your target codes, you need to configure (calibrate) your setup. The SEMI T10 standard only provides general guidelines. The following procedure is designed to assist in modifying your setup until ideal conditions are obtained. Set the grading standard using McodeControl() with M_GRADING_STANDARD set to M_SEMI_T10_GRADING. Set M_APERTURE_MODE, M_MAXIMUM_CALIBRATED_REFLECTANCE, and M_MINIMUM_CALIBRATED_REFLECTANCE to M_DEFAULT. In the environment in which you will eventually be grading your codes, grab an image of a DataMatrix code perfectly marked on a sample part, using MdigGrab(). Call McodeGrade(). Then, retrieve measures, such as the horizontal/vertical mark growth and misplacement, and the symbol contrast, using McodeGetResult() with M_..._MARK_GROWTH, M_..._MARK_MISPLACEMENT, and M_SYMBOL_CONTRAST. If the measures are not ideal (for example, M_..._MARK_GROWTH is far from 50%, M_..._MARK_MISPLACEMENT is far from 0%, or M_SYMBOL_CONTRAST is far from 80%), then as necessary, adjust the image setup to: Maximize the contrast and minimize noise in the image. To do so, you can adjust your camera's settings (for example, the optical focus, image exposure, gain, and white balance). Avoid pixel saturation. Have a cell size of at least 3. A smaller cell size results in a less robust result. To do so, you can adjust the distance between the camera and the code. Have a uniform foreground and background grayscale level (that is, there should be no glare or dark spots present in the image). To do so, adjust the illumination in your setup. Repeat steps 3 through 5 until you retrieve close to perfect measures. Grade your target codes using McodeGrade(). It is important not to modify the setup for the remainder of the grading process. Grading using the SEMI T10 standard ",
      "wordCount": 327,
      "subEntries": []
    },
    {
      "id": "UG_more_on_grading_codes_Approximating_calibration_settings",
      "version": null,
      "title": "Approximating calibration settings (if necessary)",
      "subTitles": null,
      "location": "MIL UG P03: 2D processing and analysis",
      "pageURL": "content\\UserGuide\\more_on_grading_codes\\Approximating_calibration_settings.htm",
      "text": " Approximating calibration settings (if necessary) Ideally, the setup and the configuration for grading should be done following the calibration procedures described in the related sections earlier in this chapter, using a standard test card. If you are unable to configure your setup according to the calibration specifications mentioned in the related section earlier in this chapter, you can use approximate values. These should give you good results, but will not be as accurate as a full calibration. Adjust the image setup to: Maximize the contrast and minimize noise in the image. Avoid pixel saturation. Have a cell size of at least 3. A smaller cell size results in a less robust result. Have a uniform foreground and background grayscale level (that is, there should be no glare or dark spots present in the image). Set McodeControl() with M_MINIMUM_CALIBRATED_REFLECTANCE and M_MAXIMUM_CALIBRATED_REFLECTANCE to the expected minimum and maximum possible grayscale values in the target image. For example, if the minimum and maximum possible values are 10 and 230, respectively, given your lighting conditions, specify these values. Approximating calibration settings (if necessary) ",
      "wordCount": 181,
      "subEntries": []
    },
    {
      "id": "UG_more_on_grading_codes_Code_grading_examples",
      "version": null,
      "title": "Code grading examples",
      "subTitles": null,
      "location": "MIL UG P03: 2D processing and analysis",
      "pageURL": "content\\UserGuide\\more_on_grading_codes\\Code_grading_examples.htm",
      "text": " Code grading examples The following grading example, CodeGrading.cpp, shows a code grading operation run on several types of linear, composite, and cross-row codes. codegrading.cpp The following grading example, ISODPMGrading.cpp, illustrates how to grade a target image containing a DPM Data Matrix code type. The example's grading operation and results are based on ISO/IEC 29158 quality guidelines. isodpmgrading.cpp To run these examples, use the Matrox Example Launcher in the MIL Control Center. Code grading examples ",
      "wordCount": 76,
      "subEntries": []
    }
  ]
}]
[{
  "id": "UG_data-buffers",
  "version": "2024020714",
  "title": "Data buffers",
  "subTitles": null,
  "location": "MIL UG P04: 2D related information",
  "pageURL": "content\\UserGuide\\data-buffers\\ChapterInformation.htm",
  "text": " Chapter 23: Data buffers This chapter discusses data buffers in detail. It shows you how to allocate and manage data buffers, and how to restrict an operation to a portion of a data buffer using child buffers and regions of interest. It shows you how YUV buffers are stored, how to create a user-defined buffer, and how MIL defines the pixel reference position. It shows you how to grab images with a Bayer camera and restore the color information. Data buffers overview Target system Specifying the dimensions of a data buffer Specifying the dimensions of a multi-frame image buffer Data type and depth Attribute Memory locations Using on-board memory Using mappable buffers Using child buffers, ROIs, or a copy to manipulate specific data areas Child buffers Specifying a region of interest Processing a non-rectangular area when an ROI is not supported Copying specific buffer areas Managing data buffers Copying data from one buffer to another Cloning a data buffer Transferring data between an array and a buffer Loading a data buffer Generating data into a data buffer Saving a data buffer Performing operations on a sequence of image buffers Controlling how color image buffers are stored RGB buffers RGB data formats Binary buffers YUV buffers YUV16 Packed YUV9 Planar YUV12 Planar YUV16 Planar YUV24 Planar Child YUV buffers Accessing a MIL buffer directly Mapping a data buffer to user-allocated memory Pixel conventions and subpixel accuracy Dealing with subpixel accuracy Angle convention in MIL Using images acquired with a Bayer color filter Using MIL to convert the image How the Bayer image gets converted Bilinear interpolation algorithm Adaptive algorithm Average algorithm Performing color correction Performing gamma correction White balancing your Bayer images Buffer overscan region Advanced memory management MIL non-paged memory management driver Large non-paged MIL buffers On-Demand Mode ",
  "wordCount": 300,
  "subEntries": [
    {
      "id": "UG_data-buffers_Data_buffers_overview",
      "version": null,
      "title": "Data buffers overview",
      "subTitles": null,
      "location": "MIL UG P04: 2D related information",
      "pageURL": "content\\UserGuide\\data-buffers\\Data_buffers_overview.htm",
      "text": " Data buffers overview In this Help file, the term data buffer is used loosely to refer to the most general type of data buffer (storage area) that is allocated by the MIL package and operated on by most MIL functions. For example, a data buffer can be a buffer for image data or one for lookup table (LUT) data. Besides data buffers, there are also other buffers (for example, result buffers), which are specific to a particular group of functions. These types of buffers are discussed in the chapters describing their related functions. All data buffers must be allocated before a function can access them. You can allocate a monochrome buffer using MbufAlloc1d(), MbufAlloc2d(), or MbufAllocColor(). You allocate a color buffer using MbufAllocColor(). When allocating a data buffer, you must specify its: Target MIL system. Dimensions. Data type and depth. Attribute. You can manipulate or control specific parts of data buffers by allocating and using child buffers. A child buffer is a subset of a parent buffer (a specific area of the parent buffer). Although any change made to the child buffer data affects the parent buffer, the buffer is considered a data buffer in its own right; wherever the parent buffer can be used, you can use the child buffer instead to affect only a part of the buffer. All results are returned relative to the child buffer coordinates rather than the parent buffer. Another way to specify a part of an image buffer is to use a region of interest (ROI). The ROI identifies specific areas of the buffer for further processing or analysis. The ROI of a buffer can be any shape and can encompass non-contiguous areas; it can be defined using a 2D graphics list or an image mask. In addition, when defined using a 2D graphics list whose elements have been defined in world units, the region of interest will move according to the position of the relative coordinate system. Unlike a child buffer, which can be created for any type of buffer, an ROI can only be created for an image buffer. Furthermore, an ROI is not a buffer in its own right; it does not have its own MIL identifier. When you call a function, you pass the identifier of the buffer in which the ROI is defined. If a processing or analysis function respects the ROI of an image buffer, the function will only operate on the areas dictated by the ROI; whether a function respects the ROI will be stated in the function's description. In addition, all results are returned relative to the buffer in which it is defined. Data buffers overview ",
      "wordCount": 443,
      "subEntries": []
    },
    {
      "id": "UG_data-buffers_Target_system",
      "version": null,
      "title": "Target system",
      "subTitles": null,
      "location": "MIL UG P04: 2D related information",
      "pageURL": "content\\UserGuide\\data-buffers\\Target_system.htm",
      "text": " Target system A data buffer is allocated on the specified system. If the M_DEFAULT_HOST system is specified, the default Host system of the current MIL application will be used. In addition, any operation involving one or more buffers will be performed by the most appropriate system that is associated with one of the buffers. By default, if none of these systems is more appropriate than the Host, the Host is used to perform the operation. Target system ",
      "wordCount": 79,
      "subEntries": []
    },
    {
      "id": "UG_data-buffers_Specifying_the_dimensions_of_a_data_buffer",
      "version": null,
      "title": "Specifying the dimensions of a data buffer",
      "subTitles": [
        "Specifying the dimensions of a multi-frame image buffer"
      ],
      "location": "MIL UG P04: 2D related information",
      "pageURL": "content\\UserGuide\\data-buffers\\Specifying_the_dimensions_of_a_data_buffer.htm",
      "text": " Specifying the dimensions of a data buffer Data buffers can have up to three dimensions: an X, Y, and color band dimension. Most data buffers have an X dimension (for example, LUT buffers) or an X and Y dimension (for example, monochrome image buffers). The color-band dimension has been provided to allow you to store data for each color component used to represent an image; when allocating color buffers, each band will be of the same data depth and type. Once you finish using a data buffer, you should release its memory space, using MbufFree(). Certain MIL functions support manipulating multi-band image buffers. For details on handling color image buffers, see the Dealing with color section of Chapter 2: Building an application. Specifying the dimensions of a multi-frame image buffer A multi-frame image buffer is one in which you plan on storing multiple sequential frames in vertically adjacent locations in the buffer. Multi-frame image buffers are used when grabbing images with a digitizer that supports frame burst technology. To work with a multi-frame image buffer, allocate the image buffer with a height that is the product of the Y-size of each individual frame and the number of frames that will be grabbed into the buffer on each grab command. Before calling the grab command (MdigGrab() or one grab of MdigProcess()) you must also set the number of sequential frames to grab into your multi-frame image buffer using MdigControl() with M_GRAB_FRAME_BURST_SIZE. The set value defines the number of frames that will be stored continguously in the same buffer. Note that the end-of-grab event only occurs once the entire group of frames has been grabbed, reducing the number of events that need to be handled. Specifying the dimensions of a data buffer Specifying the dimensions of a multi-frame image buffer ",
      "wordCount": 300,
      "subEntries": []
    },
    {
      "id": "UG_data-buffers_Data_type_and_depth",
      "version": null,
      "title": "Data type and depth",
      "subTitles": null,
      "location": "MIL UG P04: 2D related information",
      "pageURL": "content\\UserGuide\\data-buffers\\Data_type_and_depth.htm",
      "text": " Data type and depth The data depth of a buffer indicates the number of bits per band in the buffer (1, 8, 16, 32). The data type of a buffer indicates how its data is internally represented (that is, whether the data is considered signed, unsigned, or floating-point). Supported combinations are: 1-bit packed binary; 8-, 16-, and 32-bit integer (signed and unsigned); and 32-bit floating-point. If a function can only operate on data buffers of certain depths, this is explicitly stated in the function's description, otherwise the function can be used with any combination of data buffers. The packed binary data format represents each pixel by a single bit, in a state of 0 or 1. Therefore, 8 pixels can be packed in a single byte (known as an 8-bit data unit); that is, in a format eight times smaller than an 8-bit image. Processing done directly on a packed binary buffer is very fast and efficient. Many MIL functions support accelerated processing using packed binary buffers. General processing functions which do not support packed binary buffers directly, automatically convert the data into a suitable data type buffer, perform the operation, and re-convert the resulting buffer to packed binary. For efficiency, when possible, you should store binary data in packed binary buffers (rather than, for example, 8-bit integer buffers with only the values 0 and 0xFF). General processing functions that are optimized for packed binary buffers are noted as such in the MIL Reference. In general, the fewer bits per pixel in a buffer, the faster an operation can be performed on the buffer. Packed binary buffers are the fastest to process. When you need to use integer buffers, use 8 bits per pixel when possible, 16 bits if necessary, and 32 bits as a last resort. When you need non-integer values, extra precision, or a greater dynamic range, you can use floating-point data buffers. Data type and depth ",
      "wordCount": 321,
      "subEntries": []
    },
    {
      "id": "UG_data-buffers_Attribute",
      "version": null,
      "title": "Attribute",
      "subTitles": [
        "Memory locations",
        "Using on-board memory",
        "Using mappable buffers"
      ],
      "location": "MIL UG P04: 2D related information",
      "pageURL": "content\\UserGuide\\data-buffers\\Attribute.htm",
      "text": " Attribute The data buffer attribute indicates the buffer type and its intended usage. MIL uses this information to determine the most appropriate location in physical memory in which to allocate the buffer, and how to handle the buffer. A data buffer can be one of the following types: M_IMAGE. Image buffers are used to store grabbed images. M_LUT. Lookup table buffers are used to store lookup table data. M_KERNEL. Kernel buffers define the filters used by convolution functions. M_STRUCT_ELEMENT. Structuring element buffers are used to store the structuring element data for morphology functions. M_ARRAY. Array buffers store array type data. When allocating an image buffer (M_IMAGE), you must give more information about its intended usage. An image buffer can be any combination of the following: A buffer that can be displayed (M_DISP). A buffer that can be processed (M_PROC). A buffer in which data can be grabbed (M_GRAB). A buffer in which data is stored in a compressed format (M_COMPRESS). For example, to allocate an image buffer that can be displayed and used for processing, its attribute should be given as: M_IMAGE + M_DISP + M_PROC + M_GRAB. The M_KERNEL and M_STRUCT_ELEMENT attributes are not required to work under MIL-Lite. When a displayable image buffer is allocated and selected for display (MbufAlloc...() with M_DISP, and then MdispSelect()), multiple buffers are maintained: one in Host memory for processing purposes, and other internal buffers in display or non-paged memory (maintained directly or using the normal Windows mechanisms) for display purposes (not necessarily the same size). When the Host buffer is modified, its associated internal buffers in display/non-paged memory are automatically updated. When displaying an image buffer, both the buffer and the display should be allocated on the same system. Image buffers with the M_GRAB attribute are allocated in MIL non-paged (DMA) memory, which is physically contiguous. An advantage of non-paged memory is that a bus mastering device can write to it without the help of the Host CPU. If a system does not support grab buffers (for example, M_SYSTEM_HOST), you could still allocate a buffer on such a system in physically contiguous and non-paged memory by giving it an M_NON_PAGED attribute instead. When grabbing a single frame into a displayable image buffer, MIL grabs into the Host memory version of the buffer and then updates the display of the buffer. When grabbing continuously, the grab will typically bypass the specified buffer, and grab into an intermediate temporary display buffer (in display or Host non-paged memory) to minimize CPU usage and improve performance. Only the last frame grabbed is written into the selected buffer. It is possible to force the internal representation of a data buffer using internal storage format specifiers, such as M_PACKED or M_PLANAR, which force the data buffer to be in a packed or planar format, respectively. Refer to MbufAllocColor() for a complete list of internal format specifiers. If you try to use a data buffer in a situation that is not appropriate for its allocated attributes, an error message is generated and the operation is not performed. For example, if you try to display an image buffer without an M_DISP attribute with MdispSelect(), an error message will be generated. Memory locations By default, all Matrox Imaging boards allocate buffers in shared Host memory instead of on-board memory. On these boards, on-board memory is typically limited in size and Host memory can be accessed much faster than on-board memory. Changing the default location for your buffer's allocation is typically done only when dealing with large buffers or limited amounts of memory. In most cases using the default memory storage locations will produce the best results. The following memory storage locations are available: M_HOST_MEMORY. Stores the buffer in Host memory. Note that in all cases, M_HOST_MEMORY is the same as M_OFF_BOARD. M_ON_BOARD. Stores the buffer in memory located on your Matrox Imaging board. M_OFF_BOARD. Stores the buffer in memory located off your Matrox Imaging board. M_MAPPABLE. Stores the buffer in non-paged memory that is not mapped to Host memory. The Host memory mapping can be controlled using MbufControl() with M_MAP. Using on-board memory Using on-board memory can improve performance when all buffers are allocated and processed on-board. This is beneficial when using boards with fast-processing memory. There are three types of on-board memory available for some Matrox Imaging boards: M_FAST_MEMORY. Available only on a limited number of boards. In the case of Matrox Radient, M_FAST_MEMORY forces the buffer in the QDR-II SRAM fast-processing memory. M_SHARED. Available in all boards with an FPGA, this forces the buffer in memory that is mapped on the PCI bus. Note that shared memory is only available on-board. Unshared memory. This is the default memory location for all boards with a FPGA. The buffer is stored in unmapped memory. Using mappable buffers When dealing with many very large buffers that cannot all be mapped in Host memory at the same time, allocate the buffers as M_MAPPABLE so that they can be mapped and unmapped as needed. A mappable buffer is allocated in non-paged Host memory. By default the buffer will have a physical address, but not a Host address. Use MbufControl() with M_MAP to enable or disable the mapping. There are two types of memory locations available to all Matrox Imaging boards: M_PAGED. Forces the buffer into paged memory. Note that this value cannot be used with M_MAPPABLE. M_NON_PAGED. Forces the buffer into non-paged memory. Paging memory at allocation divides the available computer memory into small portions where the page is the smallest building block. Paging memory helps reduce the amount of external fragmentation and thus little memory is wasted. Use the MILConfig utility to set the amount of Non-paged memory available to your system. The rest of the memory is available for paging memory. Whenever possible, use the default settings for paged and non-paged memory. If there is insufficient memory of the appropriate type to allocate a buffer with the specified attributes, the function generates an error and does not allocate the buffer. Attribute Memory locations Using on-board memory Using mappable buffers ",
      "wordCount": 1009,
      "subEntries": []
    },
    {
      "id": "UG_data-buffers_Using_child_buffers_ROIs_or_a_copy_to_manipulate_specific_data_areas",
      "version": null,
      "title": "Using child buffers, ROIs, or a copy to manipulate specific data areas",
      "subTitles": [
        "Child buffers",
        "Specifying a region of interest",
        "Processing a non-rectangular area when an ROI is not supported",
        "Copying specific buffer areas"
      ],
      "location": "MIL UG P04: 2D related information",
      "pageURL": "content\\UserGuide\\data-buffers\\Using_child_buffers_ROIs_or_a_copy_to_manipulate_specific_data_areas.htm",
      "text": " Using child buffers, ROIs, or a copy to manipulate specific data areas You can manipulate or control specific parts of a data buffer by creating a child buffer within it, by specifying a region of interest, or by copying specific parts of it to another buffer. Child buffers A child buffer is a specified subset of a given data buffer (known as the parent buffer), associated with a MIL identifier. Child buffers occupy a specific rectangular area of the parent buffer. Since this area is part of the same physical memory space as the parent buffer, changes made to the data of the child buffer affect the data of the parent buffer and vice versa. Since a child buffer has a MIL identifier, it is considered a data buffer, and it can be used in the same context as its parent buffer; for example, it can be selected to a MIL 2D display and be the only data that is displayed. A child buffer takes on the same attributes and type as the parent buffer. However, any pixel coordinates specified or returned when using a child buffer are relative to the child buffer's top-left corner. One major benefit of the child buffer is being able to handle several buffers simultaneously, in contexts where normally only one buffer can be handled. For example, a MIL 2D display can only display one image buffer at a time. However, you might want to display the source and destination buffer of an operation in the same window. You can get around this situation by allocating a displayable image buffer as large as the 2D display and then allocating two child buffers from this buffer. You can then use one as the source data buffer and one as the destination. When the parent buffer is selected on the 2D display (MdispSelect()), both the source and the destination child buffers can be seen. When the parent buffer is multi-band, the child buffer can occupy one or all bands. The following example shows some child buffers that can be created from a multi-band image parent buffer. Just as its parent buffer, a child buffer must be allocated so that it can be associated with an identifier and recognized as an entity by MIL. You can use one of the MIL functions from the table below to allocate the child buffer. MIL function Monochrome parent buffer Multi-band parent buffer MbufChild1d() 1D region of first row of band. 1D region of first row of all bands. MbufChild2d() 2D region of band. 2D region of all bands. MbufChildColor() - Entire area of band chosen. MbufChildColor2d() - 2D region of band chosen or 2D region of all bands. Allocate a child buffer by specifying its size and offset with respect to each of the parent buffer dimensions. Note that, as a subset of the parent buffer, a child buffer cannot exceed the bounds of its parent in any dimension. For example, a color child buffer cannot be created from a monochrome parent buffer. Once you have finished using a child buffer, you must free it using MbufFree(), before freeing the parent buffer. Specifying a region of interest A region of interest (ROI) is similar to a child buffer in that it identifies a subset of data in an image buffer. The ROI of an image buffer can be of any shape and can be composed of several non-contiguous areas. When dealing with processing operations that respect the ROI, all pixels outside the ROI are ignored. You can have the ROI move within the image buffer according to the relative coordinate system if the image is calibrated. Note that, unlike a child buffer, an ROI does not have its own MIL identifier and cannot have results returned with respect to it. Use MbufSetRegion() to create an ROI from an image mask, the graphics in a 2D graphics list, or the valid pixels in a depth map. When defined from an image mask, the region of interest consists of the pixels corresponding to the non-zero pixels in the image mask. When defined from the graphics contained in a 2D graphics list, only areas corresponding to the graphics are processed. If the graphics defining the ROI are not filled, the ROI will consist of only the graphics' outline (MgraControlList() with M_LINE_THICKNESS). However, if the combination constant M_FILL_REGION is specified when calling MbufSetRegion(), the ROI is created such that non-filled graphics are considered filled. This is useful if you want to display the 2D graphics list defining the region of interest, or modify it interactively, without obstructing the target image. You can also specify the combination constant M_USE_LINE_THICKNESS_1 when calling MbufSetRegion() to ignore the M_LINE_THICKNESS setting of the graphics in the 2D graphics list and use the default value of one pixel. This is useful when interactively creating a region of interest from graphics in a 2D graphics list that have line thickness greater than one pixel for visual clarity. To ignore invalid pixels in a depth map image buffer, associate the image with an ROI that identifies the valid pixels. To do so, use MbufSetRegion() with M_RASTERIZE_DEPTH_MAP_VALID_PIXELS. You can also specify an image mask to further limit the ROI to pixels that are non-zero in the image mask buffer. The depth map must be fully corrected. For more information, see Generating fully corrected depth and intensity maps. When defining the ROI with an image mask, this raster (bitmap) information is stored in the image buffer, creating an M_RASTER ROI. When defining the ROI with a 2D graphics list, this vectorial information and/or its corresponding raster (bitmap) version is stored in the image buffer, creating an M_VECTOR ROI, an M_RASTER ROI, or an M_VECTOR_AND_RASTER ROI, depending on how you set the Operation parameter of MbufSetRegion(). Some functions (for example, MblobCalculate()) expect an M_RASTER ROI, while other functions (for example, McodeRead()) expect an M_VECTOR ROI; creating an M_VECTOR_AND_RASTER ROI allows more MIL modules to use the ROI in the source image. To inquire an ROI's type, use MbufInquire() with M_REGION_TYPE. When an ROI is defined, the information from the specified 2D graphics list or image mask is copied to the source image buffer. Any subsequent changes to the original 2D graphics list or image mask will not affect the ROI. To update the ROI using a new or modified 2D graphics list or image mask, call MbufSetRegion() again with the new information. The old ROI information is replaced with the new ROI information. An M_VECTOR ROI or an M_VECTOR_AND_RASTER ROI can be associated with the same camera calibration information as the image. This ensures that whenever the relative coordinate system moves (using McalRelativeOrigin(), McalSetCoordinateSystem(), or McalFixture()), the ROI moves accordingly. To associate an ROI with camera calibration information, you must define the ROI with a 2D graphics list. All graphics in the 2D graphics list that were created in world units (using MgraControl() with M_INPUT_UNITS set to M_WORLD), will be associated with the same camera calibration information as the image; all other graphics in the 2D graphics list, as well as any generated raster information, will not be calibrated. If the camera calibration information associated with the image buffer changes, the raster information of an M_VECTOR_AND_RASTER ROI will be discarded, causing the ROI to become an M_VECTOR ROI. Calling MbufSetRegion() with the Operation parameter set to M_RASTERIZE and the ImageOrGraphicListId parameter set to M_NULL transforms the ROI back to an M_VECTOR_AND_RASTER ROI, such that the raster data is synchronized with the vector information. By default, the ROI of a child buffer is dynamically linked with that of its parent. You can define different ROIs for a parent buffer and its child buffer, or relink the ROIs using MbufSetRegion() with the Operation parameter set to M_LINK_TO_PARENT. Note that a child buffer's ROI is not accessible from its parent buffer. To remove the ROI from a source image buffer, call MbufSetRegion() with the Operation parameter set to M_DELETE. Alternatively, to ignore the ROI associated with a source image buffer without removing it, call MbufControl() with M_REGION_USE. The following table gives a broad overview of the modules that support the raster and vector-based ROIs. This table is meant as a general guideline and every module will have exceptions. For example, in most modules which do support ROIs, the M...Draw() function will not support any type of ROI. For functions that take an image buffer, the MIL Reference indicates if the function does not support an ROI or if there are ROI limitations. If the function takes an image buffer but does not specify whether it does or does not support an ROI, it is safe to assume it does support an ROI without any restrictions. Module ROI ROI in world units M_RASTER 2 M_VECTOR 2 M3dMap N N N Magm N N N Mbead N N N Mblob Y N N Mcode N Y Y Mcol (in general) N N N McolDefine() Y N N Mdmr N Y Y Medge N N N Mgra N N N Mim (in general) N N N MimStatCalculate() (for stats) Y 1 N 1 N MimArith...() Y N N MimLutMap() Y N N Mmeas N Y Y Mmet N N N Mmod N N N Mocr N Y Y Mpat N Y Y Mreg N N N Mstr N Y Y 1 Note that not all statistics operations support ROIs; for a list of those that do, see MimControl(). 2 These types of ROI will also support M_VECTOR_AND_RASTER ROIs. Processing a non-rectangular area when an ROI is not supported To process a non-rectangular area when an ROI is not supported, you can apply a mask to the source image. For example: Allocate an image buffer, using MbufAlloc...(). The buffer should be at least the same size as the area in the source image to process. This buffer will be used as a mask buffer. Draw a filled shape in the mask buffer corresponding to the pixels to be modified, using the graphics functions (Mgra...()) or the drawing functions (M...Draw()). You can also annotate the image with Windows GDI annotations. For more information, see the Using GDI annotations subsection of the Annotating the displayed image non-destructively section of Chapter 25: Displaying an image. Allocate a temporary destination buffer, using MbufAlloc...(). The temporary destination buffer should be at least the same size as the area to process. Perform the required operation from the source buffer to the temporary destination buffer. Copy the temporary destination buffer to the required destination buffer, using MbufCopyCond(), with the mask buffer as the condition buffer. Copying specific buffer areas As an alternative to using a child buffer or an ROI, you can restrict operations to specific areas or bits of a buffer (child or parent) by copying the required portions to another buffer. For information about the functions allowing you to copy specific buffer areas, see Managing data buffers. Using child buffers, ROIs, or a copy to manipulate specific data areas Child buffers Specifying a region of interest Processing a non-rectangular area when an ROI is not supported Copying specific buffer areas ",
      "wordCount": 1844,
      "subEntries": []
    },
    {
      "id": "UG_data-buffers_Managing_data_buffers",
      "version": null,
      "title": "Managing data buffers",
      "subTitles": [
        "Copying data from one buffer to another",
        "Cloning a data buffer",
        "Transferring data between an array and a buffer",
        "Loading a data buffer",
        "Generating data into a data buffer",
        "Saving a data buffer",
        "Performing operations on a sequence of image buffers"
      ],
      "location": "MIL UG P04: 2D related information",
      "pageURL": "content\\UserGuide\\data-buffers\\Managing_data_buffers.htm",
      "text": " Managing data buffers MIL provides several data buffer management functions. These allow you to copy data from one buffer to another, clone a buffer, transfer data between an array and a buffer, load data into a buffer, generate ramp data into a buffer, save a buffer to disk, and perform operations on sequences of image buffers. Copying data from one buffer to another You can copy different required portions of one buffer to another as follows: Copy an entire image buffer to another buffer, using MbufCopy() or using MbufClone() with M_COPY_SOURCE_DATA. While MbufCopy() requires you to allocate a destination buffer before calling the function, MbufClone() will automatically allocate one similar to the original. Copy an image buffer to another buffer at the specified offset, using MbufCopyClip(). Data that falls outside of the destination buffer will be automatically clipped. Copy specific non-sequential areas to another buffer based on a condition buffer, using MbufCopyCond(). Source buffer data is copied to the destination buffer if corresponding data in the specified condition buffer satisfies the copy condition. Other data in the destination buffer is left unaffected. Copy specific non-consecutive bits to another buffer based on a mask, using MbufCopyMask(). Only destination bits that correspond to non-zero bits in the mask are modified with source bits. Copy a single band of a multi-color band buffer to or from a single-band buffer, using MbufCopyColor() or MbufCopyColor2d(). This allows you to operate on a single color band of a buffer. Note that only MbufCopy() and MbufClone() copy the entire buffer into another buffer; the other functions copy only portions of a buffer. If the source and destination buffers have different depth and size, MIL converts data according to the following general rules: Case Result Source depth &gt; destination depth The most significant bits are truncated when the data is copied into the destination. Destination depth &gt; source depth The source data is zero or sign-extended (depending on the type of the source) when copied into the destination. Destination size &gt; source size Exceeding areas of the destination buffer are unaffected. If the source and destination buffers have the same number of band(s), all band(s) will be copied correspondingly. Otherwise, the following rules apply: When copying from Result 3-band to 1-band Only the first band of the three is copied (for example, the Y band of a YUV buffer and the R band of an RGB buffer). 1-band to 3-band All the three bands of the destination buffer are filled with the same data. Note that if the source buffer is associated with a LUT buffer, it will be first mapped through the LUT. MIL automatically handles data type and data format conversions. When copying from a floating-point buffer to an integer buffer, the values are truncated. When converting an M_RGB15 buffer into an M_BGR24 buffer, the least-significant bits of each band are set to 0. Note that when copying from a non-binary buffer to a binary buffer, all non-zero pixels in the source buffer are represented as ones (1) in the binary buffer. When copying a binary buffer to a buffer of a different depth, each single-bit pixel is copied into the least-significant bit of its corresponding destination pixel. The remaining bits of the destination pixel are set to 0; to propagate the bit value to all bits, use MimBinarize(). MIL also automatically handles source and destination buffers with different compression types. When copying from Result M_COMPRESS to uncompressed The data will be automatically decompressed. Uncompressed to M_COMPRESS The data will be automatically compressed. M_COMPRESS to M_COMPRESS (with different compression types) The data will be re-compressed according to the settings in the destination buffer. Cloning a data buffer You can clone a data buffer using MbufClone(). This function takes a specified source buffer and allocates a new buffer with similar characteristics (a clone). The degree of similarity between the two buffers is determined by the settings that you pass to MbufClone(). By default, MbufClone() allocates a clone on the same system as the original, and the two buffers have the same size, data type, and attributes. However, when calling MbufClone(), you can specify, for example, for the clone to have a different size than the source. You can also specify whether or not to copy the source buffer's data to the clone. The buffer's data is not copied by default. Note that regardless of the specified settings, MbufClone() does not clone the source buffer's region of interest. Transferring data between an array and a buffer You can put data from an array into a data buffer, using MbufPut(), MbufPut1d(), MbufPut2d(), MbufPutColor(), or MbufPutColor2d(). MbufPut() puts data in the entire buffer, while MbufPutColor() or MbufPutColor2d() put data into one or all color bands of a multi-band buffer. The other two functions allow you to put data in a selected area of a monochrome buffer, respectively. In addition, you can retrieve data from a data buffer and place it into an array, using MbufGet(), MbufGet1d(), MbufGet2d(), MbufGetColor(), or MbufGetColor2d(). MbufGet() gets data from the entire buffer, while MbufGetColor() or MbufGetColor2d() get data from one or all bands of a multi-band buffer. The other two functions, like their \"put in buffer\" counterparts, allow you to get data from a selected area of a monochrome, respectively. Note that you can also access the contents of a MIL buffer from an array using MbufInquire(). Inquire the Host address of the buffer, and then using a pointer access the buffer as an array. This is discussed in more detail later. Loading a data buffer You can load data into a MIL data buffer, using one of two methods: Load data into an automatically allocated MIL data buffer, using MbufImport() with M_RESTORE, or using MbufRestore(). Load data into a previously allocated MIL data buffer, using MbufImport() with M_LOAD or using MbufLoad(). These functions internally handle the opening and closing of the file. With MbufImport(), you can specify the file's format. MbufLoad() and MbufRestore() will read the data in the file to determine the format; therefore, they might take more time to return a result. Generating data into a data buffer 2D ramp data is data that linearly increases or decreases in both X and Y. You can generate 2D ramp data into a buffer, using MgenRamp(). Generating 2D ramp data into a buffer can be useful, for example, to simulate non-uniform lighting in an image; non-uniform lighting is generally approximated by an intensity ramp that is added to the image. You can also generate 2D ramp data into a buffer, for example, to retrieve the index of any pixel in the buffer. To do so, call MgenRamp() and set ScaleX to 1, ScaleY to M_PITCH, and Offset to 0. MgenRamp() generates the ramp data using the following formula: BufId [x,y] = ScaleX * x + ScaleY * y + Offset. You can specify to generate data into any MIL buffer, such as a MIL array, image, kernel, LUT, or structuring element buffer. The following code snippets provide two examples of valid calls to MgenRamp() to generate 2D ramp data into a buffer. MgenRamp(ImageId, 25.0, 25.0, 50.0, M_DEFAULT); MgenRamp(ImageId, 1.0, M_PITCH, 0, M_DEFAULT); The following images depict the 2D ramp data generated by the previous snippets, and their resulting buffers. Saving a data buffer You can save a data buffer to disk, using MbufExport() or MbufSave(). MbufExport() is the most general of these functions and can save data in any MIL-supported file format. MbufSave() can only save a buffer in an M_MIL_TIFF file format. These functions internally handle opening and closing the file. If the given file name already exists, the file will be overwritten. You can use the M_MIL_NATIVE format to store any data buffer, including its settings, ROI, and calibration information. You can use the M_MIL_TIFF format to save an image buffer with its ROI and calibration information in a file that can be viewed by any software that supports the TIFF 6.0 specification. Performing operations on a sequence of image buffers You can perform operations on a sequence of image buffers. You can import a sequence of images from a file using MbufImportSequence(). You can export a sequence of image buffers to a file using MbufExportSequence(). You can also use the MIL Sequences module to perform operations such as H.264 compression and decompression on sequences. For more information about using the Sequences module, see the MIL Sequences module overview section of Chapter 31: Sequences. Managing data buffers Copying data from one buffer to another Cloning a data buffer Transferring data between an array and a buffer Loading a data buffer Generating data into a data buffer Saving a data buffer Performing operations on a sequence of image buffers ",
      "wordCount": 1448,
      "subEntries": []
    },
    {
      "id": "UG_data-buffers_Controlling_how_color_image_buffers_are_stored",
      "version": null,
      "title": "Controlling how color image buffers are stored",
      "subTitles": null,
      "location": "MIL UG P04: 2D related information",
      "pageURL": "content\\UserGuide\\data-buffers\\Controlling_how_color_image_buffers_are_stored.htm",
      "text": " Controlling how color image buffers are stored A color image buffer's internal representation can be either in a planar or packed format. When allocating the buffer, if you specify an M_PLANAR attribute, the pixels are stored in planes (for example, RRR GGG BBB); if you specifiy an M_PACKED attribute, each pixel is stored as one unit containing all its components (for example, RGB RGB RGB). MIL automatically selects the most appropriate format, according to the specified intended purpose attribute. If an image buffer is allocated in one format, and a general processing function requiring another format is called, the function will automatically convert the data to the required format and re-convert it back to its original format upon completion. To change a buffer's default internal storage format, explicitly specify the required internal storage format when calling MbufAllocColor(). Note that it might be slower to process buffers with M_PACKED attributes. In general, packed formats are mostly used for display purposes; when setting a buffer's attribute to M_DISP, the default internal representation is usually packed. This configuration allows for faster transfers to display sections. Planar formats are generally preferred for processing. Processing is done on each of the component planes separately. When allocating an image buffer with more than one attribute, for example, M_DISP and M_PROC, the buffer's internal storage requirements for the display will take precedence over other attributes. See MbufAllocColor() in the MIL Reference to determine which formats are supported for your MIL system. Controlling how color image buffers are stored ",
      "wordCount": 253,
      "subEntries": []
    },
    {
      "id": "UG_data-buffers_RGB_buffers",
      "version": null,
      "title": "RGB buffers",
      "subTitles": [
        "RGB data formats"
      ],
      "location": "MIL UG P04: 2D related information",
      "pageURL": "content\\UserGuide\\data-buffers\\RGB_buffers.htm",
      "text": " RGB buffers By default, MIL allocates color image buffers in an RGB color format. The pixels are internally stored in little-endian order, that is, they are stored in memory from their least-significant to the most significant bytes. The definitions of the RGB formats that are available are shown here. The corresponding MIL constant is shown in brackets beside the common format name. RGB data formats BGR24 packed (M_PACKED + M_BGR24) and RGB24 packed (M_PACKED + M_RGB24) are formats whereby each pixel is internally stored as three consecutive bytes. In BGR24 packed format, the blue band is stored in the first byte of the sequence; in RGB24 packed, the red byte is stored in the first byte of the sequence. BGR32 packed (M_PACKED + M_BGR32) is a format whereby each pixel is internally stored as four consecutive bytes. The first byte of the sequence stores the blue band of the image, and the last byte is a \"don't care\" byte, as shown below: RGB15 packed (M_PACKED + M_RGB15) is a format whereby each pixel is internally stored as a 16-bit word with a 5-bit blue value (least significant), a 5-bit green value, a 5-bit red value, and a \"don't care\" bit (most significant), in little-endian order, as shown below. Note that when accessing an M_PACKED + M_RGB15 buffer as a 3-band 8-bit buffer, the least significant bits of each band are set to 0. RGB16 packed (M_PACKED + M_RGB16) is a format whereby each pixel is internally stored as a 16-bit word with a 5-bit blue value (least significant), a 6-bit green value, and a 5-bit red value (most significant), in little-endian order, as shown below. Note that when accessing an M_PACKED + M_RGB16 buffer as a 3-band 8-bit buffer, the least significant bits of each band are set to 0. RGB planar are formats whereby the color components of all the pixels are stored contiguously: (RRR...., BBB..., GGG...). RGB buffers RGB data formats ",
      "wordCount": 325,
      "subEntries": []
    },
    {
      "id": "UG_data-buffers_Binary_buffers",
      "version": null,
      "title": "Binary buffers",
      "subTitles": null,
      "location": "MIL UG P04: 2D related information",
      "pageURL": "content\\UserGuide\\data-buffers\\Binary_buffers.htm",
      "text": " Binary buffers Binary buffers have a different internal storage format than other types of buffers: eight pixels are stored in one byte. The left-most pixel of an image is the least significant bit that is stored in memory. Binary buffers ",
      "wordCount": 42,
      "subEntries": []
    },
    {
      "id": "UG_data-buffers_YUV_buffers",
      "version": null,
      "title": "YUV buffers",
      "subTitles": [
        "YUV16 Packed",
        "YUV9 Planar",
        "YUV12 Planar",
        "YUV16 Planar",
        "YUV24 Planar",
        "Child YUV buffers"
      ],
      "location": "MIL UG P04: 2D related information",
      "pageURL": "content\\UserGuide\\data-buffers\\YUV_buffers.htm",
      "text": " YUV buffers YUV is a format in which Y is the grayscale component (luminance) and U and V are the color components. MIL supports grabbing, loading, or saving images in a YUV color format. Although some general processing operations can be performed on YUV buffers, allocating YUV buffers for processing purposes is not recommended because these operations can only process color data that is in RGB format. However, MIL will automatically convert YUV buffer data to RGB for these operations (including conversion for display), and re-convert it to YUV upon completion. All YUV formats are supported even on the Host system. However, only some systems support grabbing into YUV buffers. See MbufAllocColor() in the MIL Reference to determine if grabbing into YUV buffers is supported on your system. YUV buffers must be allocated as 3-band 8-bit buffers, however, the actual number of bits per pixel will differ depending on the YUV format selected. The supported YUV formats are: YUV16 Packed. YUV9 Planar. YUV12 Planar. YUV16 Planar. YUV24 Planar. YUV16 Packed YUV16 Packed or YUV 4:2:2 (M_YUV16 + M_PACKED) is an interleaved data format. Although each pixel has a corresponding one byte Y (luminance component), each pair of pixels share the same one byte U (chrominance U) and the same one byte V (chrominance V). Since a pair (two pixels) is represented by 4 bytes, each pixel has an average of 16 bits per pixel. The YUV16 packed data format has two available formats: YUYV and UYVY. The only difference between these two YUV formats is the ordering of data in the buffer. Certain digitizer boards grab data in exclusively YUYV or UYVY packed data format. Note that, for display, certain operations are optimized to handle the YUYV format; for example, displaying a decompressed buffer. When you allocate an M_YUV16 + M_PACKED buffer, MIL allocates the buffer in the format that is most suitable for the selected system and the specified buffer attributes. You can, however, force a format using the M_YUV16_YUYV or M_YUV16_UYVY control types. When the buffer has an M_GRAB attribute, forcing an inappropriate format generates an error. When the buffer has an M_DISP attribute, if you force the buffer in the other YUV format, then CPU intervention is required to perform the automatic conversion. See the MbufAllocColor() reference for supported data formats. The following image is an example of a YUYV buffer: The following image is an example of a UYVY buffer: YUV9 Planar YUV9 Planar (M_YUV9 + M_PLANAR) is a planar format whose components have a depth of one byte but are not of the same size. Although each pixel has a corresponding 1 byte Y (luminance) component, each block of 16 pixels share the same one byte of U (chrominance U) and the same one byte of V (chrominance V). Since the 16 pixels are represented by 18 bytes, each pixel has an average 9 bits. For example, a block of 16 pixels has the following: 16 bytes Y and 1 byte each of U and V. YUV12 Planar YUV12 Planar (M_YUV12 + M_PLANAR) is a planar format whose components have a depth of one byte but are not of the same size. Although each pixel has a corresponding 1 byte Y (luminance) component, each block of 4 pixels share the same one byte of U (chrominance U) and the same one byte of V (chrominance V). Since the 16 pixels are represented by 24 bytes, each pixel has an average of 12 bits. For example, a block of 16 pixels has the following: 16 bytes Y and 4 bytes each of U and V. YUV16 Planar YUV16 Planar (M_YUV16 + M_PLANAR) is a planar format whose components have a depth of one byte but are not of the same size. Although each pixel has a corresponding 1 byte Y (luminance) component, each block of 2 pixels share the same 1 byte of U (chrominance U) and the same 1 byte of V (chrominance V). Since the 16 pixels are represented by 32 bytes, each pixel has an average 16 bits. For example, a block of 16 pixels has the following: 16 bytes Y and 8 bytes each of U and V. YUV24 Planar YUV24 Planar (M_YUV24 + M_PLANAR) is an uncompressed planar format whose components have a depth of one byte and are of equal size. Each pixel has a corresponding 1 byte Y (luminance) component, 1 byte U component (chrominance U), and 1 byte V component (chrominance V). Since the 16 pixels are represented by 48 bytes, each pixel has an average 24 bits. For example, a block of 16 pixels has the following: 16 bytes Y and 16 bytes each of U and V. Child YUV buffers You can create child buffers from YUV buffers in the same way as RGB child buffers. When creating YUV child buffers, MIL will keep the proportions of the U and V bands with respect to the Y band. For example, if your YUV9 Planar Y band is a size of 256x256 pixels, the U and V bands will be 1/4 the size of the Y band in each dimension (width and height): 64x64 pixels, which is 1/16 the size of the Y band. If a child buffer is 16x16 pixels, then the U and V bands will be 4x4 pixels. In other words, the 4x4 U and V bands (16 pixels) is 1/16 the size of the Y band (256 pixels). YUV buffers YUV16 Packed YUV9 Planar YUV12 Planar YUV16 Planar YUV24 Planar Child YUV buffers ",
      "wordCount": 922,
      "subEntries": []
    },
    {
      "id": "UG_data-buffers_Accessing_a_MIL_buffer_directly",
      "version": null,
      "title": "Accessing a MIL buffer directly",
      "subTitles": null,
      "location": "MIL UG P04: 2D related information",
      "pageURL": "content\\UserGuide\\data-buffers\\Accessing_a_MIL_buffer_directly.htm",
      "text": " Accessing a MIL buffer directly If needed, a MIL buffer's contents can be accessed directly. For instance, if you want to calculate the average value of the pixels in your image, you could create a custom algorithm. The algorithm could be applied directly to the buffer without having to copy the contents of the MIL buffer into a user-allocated array using MbufGet(). This would be more efficient and might improve the performance of the custom algorithm. To access the MIL buffer directly, you need to know the buffer's address, pitch, depth, size, and format. When dealing with image buffers, the format includes whether the image buffer is packed or planar, as well as its color format. The pitch is the number of pixels between the beginning of any two adjacent lines of the buffer data. The pitch can differ from the width of the buffer, especially when dealing with child buffers, where the pitch of the child is the pitch of the parent buffer. For this reason, we recommend you always inquire the pitch (using MbufInquire() with M_PITCH). To inquire the pitch in bytes, use M_PITCH_BYTE. You can inquire the address of a parent or child buffer using MbufInquire() with M_HOST_ADDRESS or M_PHYSICAL_ADDRESS. For an image buffer, the returned address will be the address of the top left-most pixel in the parent or child image buffer, respectively. The following example shows how to inquire and use the Host address when accessing a monochrome buffer, a color packed buffer, and a color planar buffer. mbufpointeraccess.cpp Accessing a MIL buffer directly ",
      "wordCount": 261,
      "subEntries": []
    },
    {
      "id": "UG_data-buffers_Mapping_a_data_buffer_to_userallocated_memory",
      "version": null,
      "title": "Mapping a data buffer to user-allocated memory",
      "subTitles": null,
      "location": "MIL UG P04: 2D related information",
      "pageURL": "content\\UserGuide\\data-buffers\\Mapping_a_data_buffer_to_userallocated_memory.htm",
      "text": " Mapping a data buffer to user-allocated memory Instead of allocating new memory to a buffer using MbufAlloc...(), you can create a buffer from the memory at a specified location, using MbufCreate2d() to create a monochrome data buffer and MbufCreateColor() to create a color data buffer. In these cases, MIL does not allocate any memory; it uses the memory that you provide. When creating a buffer with MbufCreateColor(), you can pass an array of data pointers. For packed color buffers, you can pass an array of one pointer; for planar buffers, you can pass an array with the same number of pointers as the number of bands in the buffer. When creating a buffer with MbufCreate2d(), you can pass the address of the data. The address(es) can be either logical or physical. If you want to use the buffer for grabbing, the address(es) must be physical (grab buffers must be allocated in physically contiguous and always present memory, that is, non-paged). The MbufCreate...() functions must be used with caution because, when using physical addresses, these functions provide direct access to any of your computer's memory mapped devices; when using logical addresses, memory protection errors could result. You can use MbufInquire() with the M_HOST_ADDRESS or M_PHYSICAL_ADDRESS inquire type to determine the Host's logical address or the physical address of a buffer's data, respectively. Note that the physical address is not necessarily an address in Host memory. It could be an address in on-board memory. If an on-board buffer is mapped to the Host, you can use the MbufInquire() function with the M_HOST_ADDRESS inquire type to determine the Host address to which it is mapped. Both MbufCreate2d() and MbufCreateColor() can also be used to create a buffer that maps to an already existing buffer. When mapping to an existing buffer, pass the MIL identifier of the buffer to MbufCreate2d() or to MbufCreateColor(). Note that on some Matrox frame grabbers, on-board buffers are allocated in unshared memory by default. In this case, MbufCreate2d() and MbufCreateColor() are not supported, unless creating the buffer on the same system. There are several instances when memory mapping is useful. A particularly useful instance is when processing and displaying an interlaced grab in a time critical application. In this case, you could use a displayable image buffer to store and display the grabbed data. Then, to process each field as it is grabbed, you could use a buffer that is mapped to the odd field of the displayable image buffer (Buffer 1) and a buffer that is mapped to the even field (Buffer 2). Create Buffers 1 and 2 as follows: Buffer 1 (Odd field): Size = 640x240 (that is, half height). Pitch = 1280 (that is, to skip to the next field). Address = Address A (that is, first pixel of the first row). Buffer 2 (Even field): Size = 640x240 (that is, half height). Pitch = 1280 (that is, to skip to the next field). Address = Address B (that is, first pixel of the second row). In general, MIL automatically issues a display update after a displayed buffer has been modified. However, if a buffer selected on the display is modified using a mapped buffer, its display is not updated until you notify it of the change using the M_MODIFIED setting in MbufControl(). For another instance where creating buffers is useful, see the Multiple systems section of Chapter 2: Building an application. Mapping a data buffer to user-allocated memory ",
      "wordCount": 575,
      "subEntries": []
    },
    {
      "id": "UG_data-buffers_Pixel_conventions",
      "version": null,
      "title": "Pixel conventions and subpixel accuracy",
      "subTitles": [
        "Dealing with subpixel accuracy",
        "Angle convention in MIL"
      ],
      "location": "MIL UG P04: 2D related information",
      "pageURL": "content\\UserGuide\\data-buffers\\Pixel_conventions.htm",
      "text": " Pixel conventions and subpixel accuracy When working in pixel units, you are using the pixel coordinate system, where the center of the top-left pixel corresponds to (0,0), the X-axis follows the first row of pixels, and the Y-axis follows the first column of pixels. Knowing what is considered the origin of the pixel coordinate system is important for all MIL functions. Understanding MIL's angle convention is also important for functions that can perform or deal with rotations. Dealing with subpixel accuracy For MIL functions that calculate with subpixel accuracy, it is important to keep in mind that since the center of the pixel is used as its reference position, the top-left corner of the first pixel is considered (-0.5, -0,5) and the bottom-right corner of the last pixel is considered (ImageSizeX - 0.5, ImageSizeY -0.5). The following image shows the pixel coordinate system; the dots indicate the center of the pixels. With this in mind, the coordinates of the center of an image can always be found using the following formula: For example, the following image contains 4 pixels. If the formula is applied, the center of the image is found at (1.5, 0.0). When a function works with subpixel accuracy, you must be especially careful when specifying end points and bounds. For example, to draw a rectangle around the border of an image of width SizeX and height SizeY, using MgraRect(), you must take into account the 0.5 distance from the center of the pixel to its edges. The following images show how a vector based rectangle will be drawn using MgraRect() with and without the correction for subpixel accuracy. The following code snippet shows the correct positions to specify when drawing a box that completly encloses an image. /* Specify the size of the buffer. */ MIL_INT SizeX = 5; MIL_INT SizeY = 4; MbufAlloc2d(MilSystem, SizeX, SizeY, 8, M_IMAGE + M_DISP +M_PROC, &amp;DstImageBufId); /* ... */ /* The start positions of the drawn rectangle corrected for subpixel accuracy. */ MIL_DOUBLE XStart = -0.5; MIL_DOUBLE YStart = -0.5; /* The end positions of the drawn rectangle corrected for subpixel accuracy. */ MIL_DOUBLE XEnd = SizeX - 0.5; MIL_DOUBLE YEnd = SizeY - 0.5; /* Draw a rectangle that encloses the entire buffer. */ MgraRect(ContextGraId, DstImageBufId, XStart, YStart, XEnd, YEnd); Note that when drawing with MgraRect() directly in an image, the annotations are scaled to the size of a pixel since they are drawn in a rasterized, destructive, way. Angle convention in MIL When working in pixel units, you define angles (in degrees) with respect to the pixel coordinate system. In this case, positive angles are always interpreted to be counterclockwise with respect to the positive X-axis. Therefore, when rotating a point (x, y) around the origin, the 2D rotation matrix that MIL uses is always: Note that the direction of rotation is inversed from the typical mathematical convention since the Y-axis is oriented downwards. To determine the angle that follows the typical mathematical convention, subtract the angle from 360 (that is, 360 - angle). If you don't convert the angle, the sign of the sine function is inversed from the typical mathematical convention. Pixel conventions and subpixel accuracy Dealing with subpixel accuracy Angle convention in MIL ",
      "wordCount": 539,
      "subEntries": []
    },
    {
      "id": "UG_data-buffers_Using_buffers_with_the_Bayer_color_filter",
      "version": null,
      "title": "Using images acquired with a Bayer color filter",
      "subTitles": [
        "Using MIL to convert the image",
        "How the Bayer image gets converted",
        "Bilinear interpolation algorithm",
        "Adaptive algorithm",
        "Average algorithm",
        "Performing color correction",
        "Performing gamma correction",
        "White balancing your Bayer images"
      ],
      "location": "MIL UG P04: 2D related information",
      "pageURL": "content\\UserGuide\\data-buffers\\Using_buffers_with_the_Bayer_color_filter.htm",
      "text": " Using images acquired with a Bayer color filter Cameras that feature a Bayer color filter can be used with MIL to provide a cost-effective method for grabbing color images: the camera grabs a single-band color-encoded image, and then you can convert it to a multi-band color image, using the MbufBayer() function. This conversion is called demosaicing. Bayer images are distinct from standard single-band images because of the color information contained in their pixels, which is extracted by the MbufBayer() function. When grabbing from these cameras, each pixel quantifies only one of the color components of the image in the camera's field of view at the corresponding location. Within a group of 2x2 pixels, there are two pixels containing color information for the green component, and one pixel for each the red and blue components; Bayer images contain more green pixels because the human eye is more sensitive to this color. The pixels are arranged in the following pattern: green pixels are always diagonal to each other, as are the red and blue pixels. The MbufBayer() function can also perform gamma correction and white balancing on the Bayer image before the demosaicing process, and color correction after the demosaicing process. Gamma correction changes the overall brightness and color saturation of an image so that the midtones appear more realistic on your display device; gamma correction effectively adjusts an image to compensate for the non-linear relationship between a pixel's value and its displayed intensity on your display device. White balancing adjusts an image for color variations that were introduced by the lighting conditions when the image was grabbed; MbufBayer() converts pixels that represent white so they appear as close to white as possible, and adjusts other pixels accordingly. Color correction adjusts an image for color artifacts that are introduced during the demosaicing operation and that appear on the transition edges of the image. Gamma correction, white balancing, and color correction are discussed in greater detail later in this section. Note that if the scale of the image is changed (using MdigControl() with M_GRAB_SCALE...) to a value other than 1 prior to grabbing a Bayer image, the Bayer image will not be converted properly; some of the Bayer pattern is lost during the scaling process, rendering color recovery impossible. Using MIL to convert the image The steps below describe, in general, how to convert a Bayer image using MIL: Determine the gamma correction exponents (optional). For information on how to calculate the exponents, see the Performing gamma correction subsection of this section. Determine the white balancing coefficients (optional). For information on how to calculate the coefficients, see the White balancing your Bayer images subsection of this section. Grab or load a Bayer image into your source buffer. Apply the MIL Bayer filter on the image using MbufBayer(), including the white balancing coefficients and/or gamma correction exponents, if they are being used. To use the adaptive demosaicing algorithm, you must also add M_ADAPTIVE to the ControlFlag parameter. Below is an example of how to grab a Bayer image and convert it to a 3-band color image. This example also shows how to correct the white balance, which will be discussed later in this section. interactivebayer.cpp How the Bayer image gets converted Bayer images are arranged in groups of 2x2 pixels. Each group contains one blue pixel, one red pixel, and two green pixels; the values of which are used in calculating the corresponding bands of the destination pixels. Your camera will grab an image with one of the following four patterns: You must specify the pattern that is used by your camera when calling MbufBayer(). Since the green pixels are always diagonal to each other, specifying the starting two pixels of the pattern defines the pattern uniquely. Consult your camera's documentation or contact the manufacturer if you are unsure; the Bayer image will not be converted properly if you specify the wrong pattern. If you cannot obtain information regarding the pattern of your camera, try all of the MbufBayer() function's supported patterns to find the correct one. Once you have specified the Bayer pattern of your camera, you must consider which demosaicing algorithm to use to convert a single-band Bayer color-encoded image to a multi-band color image. There are currently two from which you can choose from: the bilinear interpolation demosaicing algorithm and the adaptive demosaicing algorithm. Bilinear interpolation algorithm When using the bilinear interpolation algorithm, the value of a source pixel is used in the corresponding band of its destination pixel. The two remaining color bands use the average value of the source pixel's corresponding neighbors. If the source pixel is green, then the average value for the remaining two components (red and blue) is based on two neighboring pixels. If the source pixel is either red or blue, the average value for the remaining two components is based on four neighboring pixels. Note that if the source pixel is on an edge of the image, MIL will use as many neighbors as possible when determining the average pixel value for the remaining components. Regardless of the destination buffer format, MIL converts the Bayer image first to RGB, and then to the format of the destination buffer. This is the default demosaicing algorithm used by MbufBayer(). Adaptive algorithm The bilinear demosaicing algorithm is simple, fast, and does an effective job of demosaicing the Bayer images. However, since it uses only the neighborhood averages to determine the pixel values, details are sometimes lost and sporadic artifacts are introduced. To minimize image artifacts, such as the zipper effect and false colors, you can use the adaptive demosaicing algorithm to convert your images. The adaptive demosaicing algorithm analyzes the surrounding neighborhood of the source pixel and assigns weights to its neighbors. MIL then uses these weights in the calculation of the destination pixel value, depending on the neighbor's relevancy to the source pixel. To use the adaptive demosaicing algorithm, add M_ADAPTIVE to the ControlFlag parameter. Average algorithm The average algorithm is the fastest demosaicing algorithm. The average algorithm uses a 2x2 neighborhood kernel to perform the demosaicing. When using this algorithm the zipper effect is minimal, but the image is shifted by half a pixel to the left and by half a pixel upwards and some false colors can be introduced. To use the average demosaicing algorithm, add M_AVERAGE_2X2 to the ControlFlag parameter. Performing color correction Sometimes grabbed images appear with a color fringe on transition edges. To minimize these color artifacts on the edges, you can perform a color correction on the image during the Bayer conversion. Color correction can only be used in conjunction with the adaptive demosaicing algorithm and is designed to produce very good looking vertical and horizontal edges. For best visual results, you should combine M_ADAPTIVE and M_COLOR_CORRECTION together. The following compares the results of the two demosaicing algorithms and the effect of color correction. Performing gamma correction For typical machine vision processing applications, an image should not be gamma corrected; however, it can be useful to perform gamma correction for display purposes. There is typically a non-linear relationship between a pixel's value and its displayed intensity on your display device. Therefore, images can look either bleached out or too dark. You can compensate for the non-linear output of your display device by performing gamma correction. You should pass positive exponents in the range of 0.0 to 1.0 (most commonly, 0.45) for the red, green, and blue band in the fourth, fifth, and sixth elements of the MIL array buffer, respectively. MbufBayer() performs gamma correction on the raw RGB values of your image before performing white balancing and demosaicing. White balancing your Bayer images Sometimes grabbed images appear with \"the wrong colors\". This is due primarily to color distortions introduced by the light source or lighting conditions. You can correct such distortions by performing white balancing on the image. MbufBayer() uses the gray world assumption algorithm to perform white balancing. The steps below show how to white balance Bayer images using the MbufBayer() function: Grab an image that is a uniform shade of gray. To do so, hold a flat, smooth, non-reflective object that is a uniform shade of gray in front of the camera so that the object occupies the camera's entire field of view. The shade of gray should not be too close to white (too saturated); otherwise, one or more of the color bands might be clipped during the grab to maximum saturation, and the imbalance between the bands cannot be properly observed. Ensure that the image is grabbed under the same lighting conditions as subsequent source images. Note that it is unlikely that you will be able to grab an image whose pixels have the same red, green, and blue value. Allocate a 3x1 (or 6x1 if gamma is used) MIL array of type M_FLOAT using MbufAlloc1d() or MbufAlloc2d(). Call MbufBayer(), using the gray image as the source image, and adding M_WHITE_BALANCE_CALCULATE to the ControlFlag parameter. This call calculates the three coefficients required to white balance the specified source image and writes them to the array. Alternatively, you could fill an array with custom values, and then load these values (in the order described below) into the MIL array using MbufPut1d() or MbufPut2d(). Grab the image required for the Bayer conversion. Call MbufBayer(), using the new source image and the MIL array with the white balance coefficients. When MbufBayer() calculates the coefficients, the three white balancing coefficients, a, b, and c, are calculated and written to the array as the first, second, and third values, respectively. These coefficients are for a given lighting condition, and calculated such that given an image of a flat gray surface in that lighting: where R, G, and B with macrons () are the average values of the red, green, and blue color components, respectively. When source images are converted, the color components of each pixel are multiplied by their corresponding coefficient. Regardless of the destination buffer format, white balancing is performed on the gamma corrected RGB values (if gamma correction is performed at all). Using images acquired with a Bayer color filter Using MIL to convert the image How the Bayer image gets converted Bilinear interpolation algorithm Adaptive algorithm Average algorithm Performing color correction Performing gamma correction White balancing your Bayer images ",
      "wordCount": 1713,
      "subEntries": []
    },
    {
      "id": "UG_data-buffers_Buffer_overscan",
      "version": null,
      "title": "Buffer overscan region",
      "subTitles": null,
      "location": "MIL UG P04: 2D related information",
      "pageURL": "content\\UserGuide\\data-buffers\\Buffer_overscan.htm",
      "text": " Buffer overscan region Buffer overscan pixels are pixels added around an image. MIL neighborhood operations, such as MimConvolve(), use these pixels to process the border pixels of an image since these pixels don't have a complete neighborhood. For example, in the image above, if MimConvolve() is called with the M_HORIZONTAL_EDGE_PREWITT FIR filter (which operates on 3 by 3 neighborhoods), the neighborhoods of the image border pixels would be incomplete. In such cases, overscan pixels might be used. Note that MIL recursive neighborhood operations ignore the values of overscan pixels. To set the values of overscan pixels, use MbufControl() with M_OVERSCAN. However, some MIL neighborhood operations with predefined kernels or structuring elements do not require that you set the values of overscan pixels. For example, if you call MimErode(), the overscan pixels are automatically set to the highest possible buffer value, which will produce the most accurate possible results for the image border pixels. Set the number of overscan pixels that should be added to an image buffer during allocation, using MsysControl() with M_ALLOCATION_OVERSCAN_SIZE. By default, the size of the overscan is 8 pixels. The specified size represents the number of rows/columns added to each side of the image buffer. For example, in the image above, the size of the overscan is 2. Each buffer allocated on a particular system will have the same overscan size. You can inquire the size of the overscan using either the MbufInquire() or MsysInquire() function. In cases where the overscan is not sufficient for the size of the kernel, two separate buffers are used to handle the overscans (one for left/right and one for top/bottom). Note that if the buffers are too small to use Intel's single-instruction, multiple-data (SIMD) technologies, the results of the neighborhood operation will not be saturated, unless the operation forces saturation. Allocating two buffers for a neighborhood operation is slow, so it is recommended that you instead increase the size of the overscan to suit the kernel. Note that increasing the overscan size increases the pitch of the buffer, which might slightly degrade the performance of the neighborhood operation. When the results of operations performed on image border pixels are not important, and you want to speed up your application, you can use the MbufControl() function to disable the use of overscan pixels. In addition, several functions allow you to disable the use of overscan pixels for neighborhood operations. Buffer overscan region ",
      "wordCount": 403,
      "subEntries": []
    },
    {
      "id": "UG_data-buffers_Advanced_memory_management",
      "version": null,
      "title": "Advanced memory management",
      "subTitles": [
        "MIL non-paged memory management driver",
        "Large non-paged MIL buffers",
        "On-Demand Mode"
      ],
      "location": "MIL UG P04: 2D related information",
      "pageURL": "content\\UserGuide\\data-buffers\\Advanced_memory_management.htm",
      "text": " Advanced memory management When installing MIL, the default setup asks the operating system to reserve a portion of RAM from the non-paged memory pool for MIL. By default, this reserved portion of non-paged memory is a single contiguous block that MIL typically uses for grab buffers. The default is usually sufficient and no further action is required on your part. On occasion, it might be necessary to alter how MIL manages this memory. This can occur when you need large buffers and/or a large number of buffers for your application, as well as when you are changing the amount of RAM or the number of PCI devices, such as boards, in your computer. To make adjustments to MIL's non-paged memory setup, especially the non-paged memory size reserved for MIL, use the MILConfig utility under the Non-paged memory item. MIL non-paged memory management driver The MIL non-paged memory management driver uses the operating system's mechanism to reserve the total amount of non-paged memory required for MIL. The mechanism allocates non-paged memory into non-adjacent chunks of contiguous memory. The chunk size depends upon the total RAM installed in your computer, but the size is only relevant if the total non-paged memory requested for MIL is greater than the size of a single chunk. If you request 1 Gbyte of non-paged memory and, based on the amount of RAM in your computer, the chunk size is 256 Mbytes, you will have 4 non-adjacent 256-Mbyte chunks of contiguous memory. In this example, if you allocate two 100 Mbyte grab buffers, they could both exist in a single chunk, but if you allocate two 150 Mbyte grab buffers, they would each occupy a separate chunk, since a single buffer cannot occupy two separate chunks. MIL will not allow you to allocate a buffer larger than the chunk size, by default. To allow very large buffers, you must enable large non-paged MIL buffers using the MILConfig utility. Note that you might have installed MIL without installing the MIL non-paged memory management driver; this can happen if no boards were selected during MIL installation. If this is the case, there will be no MILConfig utility option to adjust non-paged memory, since there is no driver able to reserve non-paged memory for MIL; consequently, there will be no non-paged memory available for your application. To install the MIL non-paged memory manager driver, you must uninstall and re-install MIL. Large non-paged MIL buffers If your application needs individual buffers that are larger than the chunk size, such as for line-scan cameras, you can explicitly allow the MIL non-paged memory management driver to re-allocate memory such that chunk sizes are ignored when allocating buffers. However, if afterwards, you change either the PCI devices in your computer, or the total amount of RAM, the original re-allocation of memory that allowed large non-paged MIL buffers can lead to the problem of memory conflicts and/or an unusable block of memory. To resolve these problems, you should use a tool in the MILConfig utility that respects both the amount of non-paged memory you reserved for MIL and the new hardware setup. This two button tool is found in the Error Detection sub-item under the Non-paged memory item. Any user can click on the Check Errors button to assess if a hardware change created conflicts or waste, but only an administrator can click on the Repair Errors button to repair the issue. This tool can also be setup to run automatically immediately after logging in. To do so, select the Check errors at each reboot and each time the MILConfig utility starts option and/or the Fix problems when found option. If an error is found while the tool is running, an error message will appear prompting you for further action to repair the issue. If the Fix problems when found option was selected and you logged in as an administrator, the problem will be fixed and a message box will appear prompting a reboot. You must allow the tool to reboot twice for the fix to take effect. Note that if a conflict occurs that crashes your computer and prevents a normal boot, press and hold F8 while your computer is booting to enter safe mode. Once in safe mode, open the MILConfig utility and click on the Check Errors button followed by the Repair Errors button. When Windows is running in safe mode, the MILConfig utility's On-Demand mode is enabled by default, and there is no non-paged memory reserved. On-Demand Mode If your MIL application sporadically needs more non-paged memory than what was reserved, or the maximum usage is unknown and you want to minimize non-paged reservation, increasing the amount of non-paged memory reserved for MIL might be counterproductive. To accommodate this type of application, enable On-demand mode using the MILConfig utility; the option can be found through the Non-paged memory item. This mode allows MIL to use RAM outside of the non-paged memory reserved for MIL. This mode should be used with caution because the memory outside of the non-paged memory reserved for MIL is taken from the operating system's non-paged memory pool. If the pool is ever exhausted, this might lead to a system crash because of a failed memory allocation by another application or driver. Advanced memory management MIL non-paged memory management driver Large non-paged MIL buffers On-Demand Mode ",
      "wordCount": 890,
      "subEntries": []
    }
  ]
}]
[{
  "id": "BSN_iris-gtx",
  "version": "2024020714",
  "title": "Matrox Iris GTX",
  "subTitles": null,
  "location": "MIL Hardware-specific Notes",
  "pageURL": "content\\BoardSpecificNotes\\iris-gtx\\ChapterInformation.htm",
  "text": " Matrox Iris GTX This section discusses features of MIL that are particular to the Matrox Iris GTX family of smart cameras and ways that optimize their performance. Matrox Iris GTX information regarding specific functions is integrated into the functions' reference topics. Refer to the Matrox Iris GTX release notes for any additions/modifications to the MIL Hardware-specific Notes in this chapter or in the MIL Reference. Matrox Iris GTX overview Summary of Matrox Iris GTX features Using Matrox Iris GTX with MIL Using the Advanced I/O Engine with Matrox Iris GTX Using EtherNet/IP, Modbus, CC-Link, or PROFINET Using the analog intensity control signal with Matrox Iris GTX Performing Bayer color conversion in hardware Matrox Iris GTX exposure mode Controlling your lighting device indirectly Using either a grab trigger or a continuous grab to start your lighting device Controlling your lighting controller and/or the LED lighting device Automatically scheduling an output upon the occurrence of an event Auto-focusing the Varioptic lens Matrox Iris GTX connectors and signal names Board connectors Signal names and their matching MIL constants ",
  "wordCount": 177,
  "subEntries": [
    {
      "id": "BSN_iris-gtx_Iris_GTX_specific_features",
      "version": null,
      "title": "Matrox Iris GTX overview",
      "subTitles": [
        "Summary of Matrox Iris GTX features"
      ],
      "location": "MIL Hardware-specific Notes",
      "pageURL": "content\\BoardSpecificNotes\\iris-gtx\\Iris_GTX_specific_features.htm",
      "text": " Matrox Iris GTX overview Matrox Iris GTX is a family of smart cameras that combine image acquisition, embedded processing, and display. Matrox Iris GTX includes an Ethernet port (100/1000 BaseT), which provides connection for supported industrial protocols, including: PROFINET, EtherNet/IP, CC-Link, and Modbus. For PROFINET support, Matrox Iris GTX includes a Matrox PROFINET Engine; on Matrox Iris GTX, the PROFINET service comes preinstalled (but not enabled). Matrox Iris GTX also features an Advanced I/O Engine, which provides use of auxiliary I/O signals, an analog intensity control signal, general timers, an exposure timer, a strobe timer, a quadrature decoder, and an I/O command list (with 2 reference latches). Matrox Iris GTX uses a CMOS image sensor, which supports an asynchronous externally triggered global shutter. The primary difference between the members of the Matrox Iris GTX family are: the sensor chip size, the effective resolution, color, and frame rate. Matrox Iris GTX family members Sensor chip size 1 Effective resolution Color/monochrome Frame rate GTX2000 1/2.2\"-type 1920 x 1200 pixels Monochrome Up to 70.7 fps GTX2000C 1/2.2\"-type 1920 x 1200 pixels Color Up to 17.6 fps GTX5000 2/3\"-type 2592 x 2048 pixels Monochrome Up to 41.7 fps GTX5000C 2/3\"-type 2592 x 2048 pixels Color Up to 10.4 fps GTX8000 1/1.1\"-type 4096 x 2160 pixels Monochrome Up to 39.6 fps GTX8000C 1/1.1\"-type 4096 x 2160 pixels Color Up to 9.9 fps GTX12000 1\"-type 4096 x 3072 pixels Monochrome Up to 28 fps GTX12000C 1\"-type 4096 x 3072 pixels Color Up to 7.0 fps GTX16000 1.1\"-type 4000 x 4000 pixels Monochrome Up to 21.6 fps GTX16000C 1.1\"-type 4000 x 4000 pixels Color Up to 5.4 fps 1 Sensor chips are always measured on the diagonal. Summary of Matrox Iris GTX features The following table outlines the features currently available on each member of the Matrox Iris GTX family. Features Matrox Iris GTX Can access GenICam camera features using MdigControlFeature() / MdigInquireFeature() No On-board memory 4 Gbytes LPDDR4x SDRAM Number of auxiliary signals 7 (4 in, 3 out) Matrox PROFINET Engine Yes Number of general timers 8 Number of strobe timers 1 Number of exposure timers 1 Number of quadrature decoders for input from linear or rotary encoders 1 Number of I/O command lists 1 Number of reference latches per I/O command list 2 Digitizer LUT Yes Asynchronous reset mode support Yes Matrox Iris GTX overview Summary of Matrox Iris GTX features ",
      "wordCount": 398,
      "subEntries": []
    },
    {
      "id": "BSN_iris-gtx_Using_Iris_GTX",
      "version": null,
      "title": "Using Matrox Iris GTX with MIL",
      "subTitles": [
        "Using the Advanced I/O Engine with Matrox Iris GTX",
        "Using EtherNet/IP, Modbus, CC-Link, or PROFINET",
        "Using the analog intensity control signal with Matrox Iris GTX",
        "Performing Bayer color conversion in hardware",
        "Matrox Iris GTX exposure mode"
      ],
      "location": "MIL Hardware-specific Notes",
      "pageURL": "content\\BoardSpecificNotes\\iris-gtx\\Using_Iris_GTX.htm",
      "text": " Using Matrox Iris GTX with MIL To use Matrox Iris GTX, you must allocate it as a MIL Iris GTX system (M_SYSTEM_IRIS_GTX), using MsysAlloc(). This allocation opens communication with Matrox Iris GTX and allows MIL to use its resources. To grab images from your Matrox Iris GTX, you must allocate a single digitizer, using MdigAlloc() with M_DEV0. You can allocate a MIL Iris GTX system for your smart camera in multiple processes (executables). However, only one digitizer can be allocated at a time for your Matrox Iris GTX's image sensor (across all processes). To set up grabbing with triggers, use MdigControl() with M_GRAB_TRIGGER.... Refer to the Matrox Iris GTX release notes for any additions/modifications to the MIL Hardware-specific Notes in this chapter and in the MIL Reference. Using the Advanced I/O Engine with Matrox Iris GTX Matrox Iris GTX has an Advanced I/O Engine that controls the auxiliary I/O interface. The Advanced I/O Engine includes 7 auxiliary signals (4 inputs and 3 outputs), 1 analog intensity control signal, 8 general timers, 1 exposure timer, 1 strobe timer, 1 quadrature decoder, and 1 I/O command list (with 2 reference latches). For more information on some of these features, refer to Chapter 56: I/O signals and communicating with external devices. Note, to program the exposure timer, use MdigControl() with M_EXPOSURE...; whereas, to control the strobe timer, use MdigControl() with M_TIMER... + M_TIMER_STROBE. Using EtherNet/IP, Modbus, CC-Link, or PROFINET You can use the Gigabit Ethernet port for communication with external devices using the EtherNet/IP, Modbus (over TCP/IP), CC-Link, or PROFINET industrial protocol. For PROFINET communication, the port has access to the Matrox PROFINET Engine; the interface of this engine is recognized as a second network device with its own IP and MAC settings (when the PROFINET service is enabled) even though it shares the same LAN connection. By default, PROFINET is disabled. To enable it, open the MILConfig utility, expand the Communication tab, select the PROFINET page, and add a PROFINET protocol instance; note that instance names are case sensitive. Once the protocol instance is added, the status of the protocol instance should be Ready. If the status is Waiting NIC, there is no cable connected to the Ethernet port. For more information, see the Steps to perform industrial communication section of Chapter 57: Industrial communication. Using the analog intensity control signal with Matrox Iris GTX Matrox Iris GTX has an analog intensity control signal that provides a slow changing analog intensity (dimming) control signal from 0-10 VDC. This control signal can be used to set the intensity for a light controller (such as, an Advanced Illumination inline control system, a Smart Vision Lights brick light, or similar device). This signal should not be used to draw any current or drive power; it should only be used as a reference voltage for dimming control. To set the intensity of the light controller, connect the lighting controller's intensity pin directly to the analog intensity control pin and use MdigControl() with M_LIGHTING_BRIGHT_FIELD. To see an example of how to connect your light controller to the analog intensity control signal, refer to the Matrox Iris GTX Hardware and Installation manual. Performing Bayer color conversion in hardware Matrox Iris GTX color smart cameras use a sensor with a Bayer color filter (as specified by the DCF); when grabbing, the cameras perform Bayer color conversion in hardware before saving the images. If the images require white balancing, Matrox Iris GTX can perform this automatically in hardware if white balancing is enabled using MdigControl() with M_WHITE_BALANCE set to M_ENABLE. If performing white balancing, you can use the default white balance coefficients, automatically have them calculated (using MdigControl() with M_WHITE_BALANCE set to M_CALCULATE), or set explicit coefficients (M_BAYER_COEFFICIENTS_ID). For information on Bayer color conversion, refer to the Using images acquired with a Bayer color filter section of Chapter 23: Data buffers. If you don't want to perform Bayer color conversion in hardware, disable it using MdigControl() with M_BAYER_CONVERSION set to M_ENABLE. The M_BAYER... control types can only be used when grabbing from a color version of Matrox Iris GTX; otherwise, an error will be generated. Matrox Iris GTX exposure mode On Matrox Iris GTX, you can specify that the exposure duration is set with a timer or the width of the trigger signal, using MdigControl() with M_EXPOSURE_MODE set to M_TIMED or M_TRIGGER_WIDTH, respectively. When set to M_TIMED, the exposure duration will last as long as the time specified with M_EXPOSURE_TIME. M_TRIGGER_WIDTH can only be used when M_GRAB_TRIGGER_ACTIVATION is set to M_LEVEL_HIGH or M_LEVEL_LOW. When set to M_LEVEL_HIGH, the exposure will be triggered upon the rising edge of the trigger signal, and will remain active while the trigger signal is high. When set to M_LEVEL_LOW, the exposure will be triggered upon the falling edge of the trigger signal, and will remain active while the trigger signal is low. Using Matrox Iris GTX with MIL Using the Advanced I/O Engine with Matrox Iris GTX Using EtherNet/IP, Modbus, CC-Link, or PROFINET Using the analog intensity control signal with Matrox Iris GTX Performing Bayer color conversion in hardware Matrox Iris GTX exposure mode ",
      "wordCount": 851,
      "subEntries": []
    },
    {
      "id": "BSN_iris-gtx_Using_Iris_GTX_strobe",
      "version": null,
      "title": "Controlling your lighting device indirectly",
      "subTitles": [
        "Using either a grab trigger or a continuous grab to start your lighting device",
        "Controlling your lighting controller and/or the LED lighting device"
      ],
      "location": "MIL Hardware-specific Notes",
      "pageURL": "content\\BoardSpecificNotes\\iris-gtx\\Using_Iris_GTX_strobe.htm",
      "text": " Controlling your lighting device indirectly The auxiliary output signals of your Matrox Iris GTX can be linked to the exposure signal to control a lighting device that illuminates an object when the camera takes a picture. To indirectly control a lighting device with the strobe timer signal, perform the following: Connect a lighting controller to an auxiliary output signal. Set the source of the auxiliary output signal to the strobe timer, using MsysControl() with M_IO_SOURCE set to M_TIMER_STROBE. To control the strobe timer, use MdigControl() with M_TIMER... + M_TIMER_STROBE. For more information about setting up a strobe timer, refer to the Timers and coordinating events section of Chapter 56: I/O signals and communicating with external devices. Using either a grab trigger or a continuous grab to start your lighting device Whenever using a lighting device, it will always start cold (that is, completely discharged) and take a certain amount of time to reach the specified intensity. How you account for this cold period when setting up the strobe timer, depends on how you are grabbing: Continuous (or almost continuous) grabs. If you are grabbing a sequence of images with a negligible amount of delay between one image and the next, you only have to deal with the lighting device being cold at the very beginning of the grab sequence. In this case, you can trigger the strobe timer when the camera starts exposing its sensor (using M_TIMER_TRIGGER_SOURCE set to M_EXPOSURE_START). Triggered grabs. If you are grabbing images based on a trigger that might arrive after a non-negligible delay, you will have to account for the lighting device recharging before reaching the specified intensity for each grab. In this case, you should trigger the strobe timer upon the grab trigger signal (using M_TIMER_TRIGGER_SOURCE set to M_GRAB_TRIGGER). Typically, the lighting device should be illuminated for the duration of the camera's exposure time. Unlike with other products, when using the grab trigger signal to trigger the strobe timer, the specified duration of the strobe timer's output signal (set using M_TIMER_DURATION + M_TIMER_STROBE) specifies how long the timer should remain active during the exposure period (and therefore how long the lighting device should remain active during the exposure period). The active period of the strobe timer's output will actually start after the specified delay, but the count for how long it should remain active only starts when the camera starts exposing its image sensor. Once counting begins, the signal will typically be active for the specified duration. If the duration of the strobe timer is greater than the exposure time, the strobe timer's output signal will end when the exposure time ends (set using M_EXPOSURE_TIME). This allows for hardware-specific variances to occur between when the grab trigger signal arrives and when the exposure of the camera's sensor actually starts. The maximum amount of time it takes for your lighting device to arrive at the required intensity must be probed. This is because the amount of time is hardware-specific, and can vary greatly based on the type of lighting device, the period of the lighting device's reduced activity (caused by significant delays between grab triggers, or long processing delays during MdigProcess()) or inactivity (such as, between individual grabs with MdigGrab()). When the exposure ends and the strobe timer's stops outputting an active signal, the lighting device begins to discharge and grow cold. Controlling your lighting controller and/or the LED lighting device The following is an example of how to configure a grab using the camera's exposure and the strobe timer. MIL_ID MilApplication, /* Application identifier. */ MilSystem, /* System identifier. */ MilDisplay, /* Display identifier. */ MilDigitizer, /* Digitizer identifier. */ MilImage; /* Image buffer identifier. */ MIL_DOUBLE ExposureTime = 9000 * 1000; MIL_DOUBLE ExposureTimeDelay = ExposureTime / 3; MIL_DOUBLE StrobeLength = ExposureTime + ExposureTimeDelay; MIL_DOUBLE StrobeTimeDelay = 0; MIL_DOUBLE StrobeLevel = 128; //Allocate defaults. MappAllocDefault(M_DEFAULT, &amp;MilApplication, &amp;MilSystem, &amp;MilDisplay, &amp;MilDigitizer, &amp;MilImage); //Set the grab trigger source to be an external signal. MdigControl(MilDigitizer, M_GRAB_TRIGGER_SOURCE, M_AUX_IO8); //Specify to trigger the grab on the falling edge of the grab trigger signal. //Note that this could be set to the default, which is the same as M_EDGE_RISING. MdigControl(MilDigitizer, M_GRAB_TRIGGER_ACTIVATION, M_EDGE_FALLING); //Setup the exposure settings (in nanoseconds) MdigControl(MilDigitizer, M_EXPOSURE_TIME, ExposureTime); MdigControl(MilDigitizer, M_EXPOSURE_DELAY, ExposureTimeDelay); //Invert the timer output. MdigControl(MilDigitizer, M_TIMER_OUTPUT_INVERTER+M_TIMER_STROBE, M_ENABLE); //Sets the grab trigger source signal as the trigger source. MdigControl(MilDigitizer, M_TIMER_TRIGGER_SOURCE+M_TIMER_STROBE, M_GRAB_TRIGGER); //Sets a delay before the active portion of the stobe (in nanoseconds). MdigControl(MilDigitizer, M_TIMER_DELAY+M_TIMER_STROBE, StrobeTimeDelay); //Sets the duration of the active portion of the strobe (in nanoseconds) during the exposure period. //If set to M_INFINITE, the signal will always be ON. MdigControl(MilDigitizer, M_TIMER_DURATION+M_TIMER_STROBE, StrobeLength); //Enable timer 2 to output a pulse-train strobe signal and CCS output. MdigControl(MilDigitizer, M_TIMER_STATE+M_TIMER_STROBE, M_ENABLE); //Enable the strobe signal on M_AUX_IO4. MsysControl(MilSystem, M_IO_SOURCE + M_AUX_IO4, M_TIMER_STROBE); //Enable the grab trigger. MdigControl(MilDigitizer, M_GRAB_TRIGGER_STATE, M_ENABLE); //Grab continuously. MdigGrabContinuous(MilDigitizer, MilImage); //Wait. MosGetch(); //Stop continuous grab. MdigHalt(MilDigitizer); //Disable the timer. MdigControl(MilDigitizer, M_TIMER_STATE+M_TIMER_STROBE, M_DISABLE); //Disable the grab trigger. MdigControl(MilDigitizer, M_GRAB_TRIGGER_STATE, M_DISABLE); //Free the defaults. MappFreeDefault(MilApplication, MilSystem, MilDisplay, MilDigitizer, MilImage); Controlling your lighting device indirectly Using either a grab trigger or a continuous grab to start your lighting device Controlling your lighting controller and/or the LED lighting device ",
      "wordCount": 861,
      "subEntries": []
    },
    {
      "id": "BSN_iris-gtx_Iris_GTX_auto_register",
      "version": null,
      "title": "Automatically scheduling an output upon the occurrence of an event",
      "subTitles": null,
      "location": "MIL Hardware-specific Notes",
      "pageURL": "content\\BoardSpecificNotes\\iris-gtx\\Iris_GTX_auto_register.htm",
      "text": " Automatically scheduling an output upon the occurrence of an event Matrox Iris GTX supports I/O command lists. An I/O command list is an internal container for MIL I/O commands. For information on I/O command lists, refer to the Using I/O command lists section of Chapter 56: I/O signals and communicating with external devices. Besides supporting scheduling I/O commands on an individual basis, Matrox Iris GTX supports automatically registering an I/O command every time a specified latch is triggered, and using that latch's value as a reference. To do so, use MsysIoCommandRegister() with an operation, M_AUTO_REGISTER, and M_LATCHn. In this example, parts are moving along a conveyor belt, but are fixed in their position on the conveyor belt. The parts are always taking 100 rotary steps forward before reaching a camera, which will always acquire an image of the parts. For simplicity, the conveyor belt can only move forward and the camera is an areascan camera. An I/O command list is used to schedule the acquisition of the image. The rotary decoder output is used as the counter source of the I/O command list so that each time the rotary decoder counts 100 steps (distance that the part travels) after the sensor detects a part, an image is acquired. // M_AUX_IO14: Receives rotary encoder bit 0 // M_AUX_IO15: Receives rotary encoder bit 1 // M_AUX_IO8 (input): Object detector // M_AUX_IO0 (output): trigger to the camera, 100 positions after object detector #define CAMERA_TRIGGER_OFFSET 100 // in rotary encoder steps MIL_INT MFTYPE ProcessingFunction(MIL_INT HookType, MIL_ID HookId, void* HookDataPtr); typedef struct _HOOK_PARAM { MIL_ID MilSystem; MIL_ID CmdListId; } HOOK_PARAM, *PHOOK_PARAM; // Setup triggered grab. MdigControl(MilDigitizer, M_GRAB_TRIGGER_SOURCE, M_AUX_IO0); MdigControl(MilDigitizer, M_GRAB_TRIGGER_ACTIVATION, M_EDGE_RISING); MdigControl(MilDigitizer, M_GRAB_TRIGGER_STATE, M_ENABLE); // Setup the rorary decoder; for simplicty, we assume the conveyor cannot move backwards. MsysControl(SysId, M_ROTARY_ENCODER_BIT0_SOURCE + M_ROTARY_ENCODER1, M_AUX_IO14); MsysControl(SysId, M_ROTARY_ENCODER_BIT1_SOURCE + M_ROTARY_ENCODER1, M_AUX_IO15); MsysControl(SysId, M_ROTARY_ENCODER_OUTPUT_MODE + M_ROTARY_ENCODER1, M_STEP_FORWARD); MsysControl(SysId, M_ROTARY_ENCODER_STATE + M_ROTARY_ENCODER1, M_ENABLE); // Link the grab trigger to an I/O command register bit. MsysControl(SysId, M_IO_SOURCE + M_AUX_IO0, M_IO_COMMAND_LIST1 + M_IO_COMMAND_BIT0); // Allocate an I/O command list where I/O commands are scheduled based on rotary decoder 1's output signal. CmdListId = MsysIoAlloc(SysId, M_IO_COMMAND_LIST1, M_IO_COMMAND_LIST, M_ROTARY_ENCODER1, M_NULL); if (CmdListId!= M_NULL) { // Latch the counter upon detection of the object MsysIoControl(CmdListId, M_REFERENCE_LATCH_TRIGGER_SOURCE+M_LATCH1, M_AUX_IO8); MsysIoControl(CmdListId, M_REFERENCE_LATCH_ACTIVATION+M_LATCH1, M_EDGE_RISING); MsysIoControl(CmdListId, M_REFERENCE_LATCH_STATE+M_LATCH1, M_ENABLE); // Every one hundred decoder steps after latch 1 is triggered, two I/O commands // are automatically added to the I/O command list to change register bit 0, // such that M_AUX_IO0 outputs an active high pulse. // Since M_AUX_IO0 is the grab trigger source, a frame will always be grabbed 100 // decoder steps after latch 1 is triggered. MsysIoCommandRegister(CmdListId, M_PULSE_HIGH+M_AUTO_REGISTER, M_LATCH1, CAMERA_TRIGGER_OFFSET, 1, M_IO_COMMAND_BIT0, M_NULL); // Start the grabbing and processing. // The processing function is called each time a frame is grabbed. MdigProcess(MilDigitizer, MilGrabBufferList, MilGrabBufferListSize, M_START, M_DEFAULT, ProcessingFunction, &amp;HookParam); // Print a message and wait for a key press before stopping the processing. MosPrintf(MIL_TEXT(\"Press &lt;Enter&gt; to stop. \\n\\n\")); MosGetch(); HookParam.MilSystem = SysId; HookParam.CmdListId = CmdListId; // Stop the grabbing and processing. MdigProcess(MilDigitizer, MilGrabBufferList, MilGrabBufferListSize, M_STOP, M_DEFAULT, ProcessingFunction, &amp;HookParam); // Release the auto-register, so that, if latch 1 is triggered, it will not cause // an I/O command to be added. MsysIoCommandRegister(CmdListId, M_PULSE_HIGH + M_AUTO_REGISTER_CANCEL, M_LATCH1, CAMERA_TRIGGER_OFFSET, 1, M_IO_COMMAND_BIT0, M_NULL); } // Free the I/O command list. MsysIoFree(CmdListId); // Defines the processing function, called by MdigProcess() MIL_INT MFTYPE ProcessingFunction(MIL_INT HookType, MIL_ID HookId, void* HookDataPtr) { PHOOK_PARAM pHookParam = (PHOOK_PARAM)HookDataPtr; MIL_ID ModifiedBufferId; /* Retrieve the MIL_ID of the grabbed buffer. */ MdigGetHookInfo(HookId, M_MODIFIED_BUFFER+M_BUFFER_ID, &amp;ModifiedBufferId); /* Execute the processing */ // ... PUT YOUR PROCESSING FUNCTION HERE return 0; } Automatically scheduling an output upon the occurrence of an event ",
      "wordCount": 610,
      "subEntries": []
    },
    {
      "id": "BSN_iris-gtx_Using_the_Varioptic_lens",
      "version": null,
      "title": "Auto-focusing the Varioptic lens",
      "subTitles": null,
      "location": "MIL Hardware-specific Notes",
      "pageURL": "content\\BoardSpecificNotes\\iris-gtx\\Using_the_Varioptic_lens.htm",
      "text": " Auto-focusing the Varioptic lens Matrox Iris GTX supports using the Varioptic Caspian C-39NO-160-I2C or C-39N0-250-I2C lens. This lens can be auto-focused using MdigFocus(). Note that this function is only available in the full version of MIL. The Varioptic Caspian C-39NO-160-I2C lens can also be controlled using MdigControl() with M_FOCUS + M_WAIT to wait a predetermined amount of time for the camera to focus before calling the user-defined function associated with MdigFocus(). The Varioptic Caspian C-39NO-160-I2C lens has a range of 1024 lens motor positions. When using this or any other type of auto-focusing lens, to determine the minimum and maximum number of lens motor positions, use MdigInquire() with M_FOCUS + M_MIN_VALUE, or M_FOCUS + M_MAX_VALUE, respectively. Auto-focusing the Varioptic lens ",
      "wordCount": 122,
      "subEntries": []
    },
    {
      "id": "BSN_iris-gtx_Iris_GTX_connectors_and_signal_names",
      "version": null,
      "title": "Matrox Iris GTX connectors and signal names",
      "subTitles": [
        "Board connectors",
        "Signal names and their matching MIL constants"
      ],
      "location": "MIL Hardware-specific Notes",
      "pageURL": "content\\BoardSpecificNotes\\iris-gtx\\Iris_GTX_connectors_and_signal_names.htm",
      "text": " Matrox Iris GTX connectors and signal names This section serves as a reference to match Matrox Iris GTX's connectors and auxiliary signals with MIL information, such as MIL auxiliary signal numbers. Auxiliary I/O signals can have one or more functionalities (for example, trigger input, user input or user output, depending on the signal). Their possible functionalities are listed in their description in the pinout table below. Only those auxiliary signals that have matching MIL information are included in this section. To set/inquire the routing, or state of an auxiliary signal, use MsysControl() / MsysInquire() with M_IO_... control/inquire types, respectively. Whereas, the MIL function that you should use to act upon an input signal or setup the source of an output signal depends on the functionality. For example, you can use MsysControl() with M_USER_BIT_... control types, MdigControl() with M_GRAB_TRIGGER_... control types, and you can use their corresponding MsysInquire() and MdigInquire() inquire types to inquire them. To control a timer associated with the strobe signal, use MdigControl() with M_TIMER_... + M_TIMER_STROBE control types. To control the exposure timer, use MdigControl() with M_EXPOSURE.... To control the 8 general system timers available, use MsysControl() with M_TIMER_... + M_TIMERn, where n is a number from 1 to 8. For a comprehensive list of all available input and output signals, refer to the board's installation and hardware reference manual. Board connectors Only the following connector has auxiliary I/O signals with matching MIL information. Connector Name Connector Abbreviation Image Description Digital I/O and power connector M12-12P This connector is an M12 12-pin female connector. It is used to transmit and receive digital auxiliary I/O signals and provide power to your Matrox Iris GTX. Signal names and their matching MIL constants The table below lists the auxiliary I/O signals and the dedicated trigger signal with their associated MIL information. Sort by: MIL I/O information Connector and pin Hardware manual signal name Filter by: Show all Direction: input Direction: output Direction: input/output Timers Triggers Tables: Expanded Collapsed System Description MIL I/O # Pin information Direction User-bit information Trigger information Timer information Hardware manual signal name System Indicates the following. MIL I/O #: M_AUX_IO0 Opto-isloated auxiliary signal 0 (output), which supports: user output, timer output, strobe timer output, and outputting the state of an I/O command register bit. Pin information Connector: M12-12P&nbsp;Pin: 10+ Direction Output User-bit information MIL user-bit #: M_USER_BIT0; Hardware manual signal name AUX_OPTOIND_OUT0 MIL I/O #: M_AUX_IO1 Opto-isloated auxiliary signal 1 (output), which supports: user output, timer output, strobe timer output, and outputting the state of an I/O command register bit. Pin information Connector: M12-12P&nbsp;Pin: 12+ Direction Output User-bit information MIL user-bit #: M_USER_BIT1; Hardware manual signal name AUX_OPTOIND_OUT1 MIL I/O #: M_AUX_IO2 Opto-isloated auxiliary signal 2 (output), which supports: user output, timer output, strobe timer output, and outputting the state of an I/O command register bit. Pin information Connector: M12-12P&nbsp;Pin: 3+ Direction Output User-bit information MIL user-bit #: M_USER_BIT2; Hardware manual signal name AUX_OPTOIND_OUT2 MIL I/O #: M_AUX_IO3 Opto-isolated auxiliary signal 3 (input), which supports: User-defined signal 0 (input 1 of 4), acquisition trigger, timer trigger source, and rotary encoder bit source. Pin information Connector: M12-12P&nbsp;Pin: 5+ Direction Input Hardware manual signal name AUX(TRIG)_OPTOIND_IN3 MIL I/O #: M_AUX_IO4 Opto-isolated auxiliary signal 4 (input), which supports: User-defined signal 1 (input 2 of 4), acquisition trigger, timer trigger source, and rotary encoder bit source. Pin information Connector: M12-12P&nbsp;Pin: 9+ Direction Input Hardware manual signal name AUX_OPTOIND_IN4 MIL I/O #: M_AUX_IO5 Opto-isolated auxiliary signal 5 (input), which supports: User-defined signal 2 (input 3 of 4), acquisition trigger, timer trigger source, and rotary encoder bit source. Pin information Connector: M12-12P&nbsp;Pin: 7+ Direction Input Hardware manual signal name AUX_OPTOIND_IN5 MIL I/O #: M_AUX_IO6 Opto-isolated auxiliary signal 6 (input), which supports: User-defined signal 3 (input 4 of 4), acquisition trigger, timer trigger source, and rotary encoder bit source. Pin information Connector: M12-12P&nbsp;Pin: 8+ Direction Input Hardware manual signal name AUX_OPTOIND_IN6 expandTable(\"mil_io_information_show_all\"); Matrox Iris GTX connectors and signal names Board connectors Signal names and their matching MIL constants ",
      "wordCount": 667,
      "subEntries": []
    }
  ]
}]
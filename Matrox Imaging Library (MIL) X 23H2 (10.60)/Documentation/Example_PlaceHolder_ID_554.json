[{
  "id": "Example_PlaceHolder_ID",
  "version": "2024020714",
  "title": "Example_PlaceHolder_Title",
  "wordCount": 0,
  "subEntries": [
    {
      "id": "Examples_Processing_Preprocessing_FlatFieldCorrection_CPP_flatfieldcorrection_cpp",
      "version": "2024020714",
      "title": "flatfieldcorrection.cpp",
      "location": "Sample Code from MIL Examples",
      "text": " Top //***************************************************************************************/ // // File name: FlatFieldCorrection.cpp // Location: See Matrox Example Launcher in the MIL Control Center // // // Synopsis: This program illustrates how to setup and apply flat field correction. // See the PrintHeader() function below for detailed description. // // Copyright (C) Matrox Electronic Systems Ltd., 1992-2024. // All Rights Reserved #include &lt;mil.h&gt; #include &lt;math.h&gt; #include \"HistogramDisplay.h\" //***************************************************************************** // Example description. //***************************************************************************** void PrintHeader() { MosPrintf(MIL_TEXT(\"[EXAMPLE NAME]\\n\") MIL_TEXT(\"FlatFieldCorrection\\n\\n\") MIL_TEXT(\"[SYNOPSIS]\\n\") MIL_TEXT(\"This program illustrates how to set up a flat field correction\\n\") MIL_TEXT(\"context. The flat field correction is then applied to a sequence\\n\") MIL_TEXT(\"or live images. Two typical flat field correction scenarios will\\n\") MIL_TEXT(\"be presented:\\n\\n\") MIL_TEXT(\" - Case 1: Flat field correction for sensor anomalies and non-uniform lighting.\\n\") MIL_TEXT(\" - Case 2: Flat field correction for sensor anomalies only.\\n\\n\") MIL_TEXT(\"[MODULES USED]\\n\") MIL_TEXT(\"Modules used: application, system, display, buffer,\\n\") MIL_TEXT(\"graphic, image processing.\\n\\n\")); MosPrintf(MIL_TEXT(\"Press any key to continue.\\n\\n\")); MosGetch(); } //***************************************************************************** // Constants. //***************************************************************************** // The path of the avi. #define EXAMPLE_IMAGE_PATH M_IMAGE_PATH MIL_TEXT(\"FlatFieldCorrection/\") // The path of the intro images. static MIL_CONST_TEXT_PTR INTRO_NON_UNIFORM_IMAGE = EXAMPLE_IMAGE_PATH MIL_TEXT(\"NonUniformIntro.mim\"); static MIL_CONST_TEXT_PTR INTRO_VIGNETTING_IMAGE = EXAMPLE_IMAGE_PATH MIL_TEXT(\"VignettingIntro.mim\"); static MIL_CONST_TEXT_PTR INTRO_OFFSET_IMAGE = EXAMPLE_IMAGE_PATH MIL_TEXT(\"OffsetIntro.mim\"); // The messages for grabbing each image of the flat field correction. #define NB_LIGHT_STEP 3 static MIL_CONST_TEXT_PTR LIGHT_MESSAGE[NB_LIGHT_STEP] = { // FLAT_MESSAGE MIL_TEXT(\"The camera is grabbing continuously with normal exposure time.\\n\") MIL_TEXT(\"To set up a Flat image, grab a uniform light gray area (such as grabbing an\\n\") MIL_TEXT(\"image of a blank piece of paper).\\n\"), // DARK_MESSAGE MIL_TEXT(\"The camera is grabbing continuously with normal exposure time.\\n\") MIL_TEXT(\"To set up a Dark image, grab a uniform dark area (such as grabbing with the \\n\") MIL_TEXT(\"camera's lens cap firmly in place).\\n\"), }; static MIL_CONST_TEXT_PTR LIGHT_CORRECTION_MESSAGE = MIL_TEXT(\"The offset correction is visible in the histogram. The darkest pixel is now 0.\\n\") MIL_TEXT(\"The non-uniform lighting correction is visible in the image and histogram. \\n\") MIL_TEXT(\"The top-right and bottom-left white square are now even. The histogram\\n\") MIL_TEXT(\"distribution of the white areas is much less dispersed.\\n\"); static MIL_CONST_TEXT_PTR LIGHT_AVI[NB_LIGHT_STEP] = { EXAMPLE_IMAGE_PATH MIL_TEXT(\"FlatLightImage.avi\"), EXAMPLE_IMAGE_PATH MIL_TEXT(\"DarkImage.avi\"), EXAMPLE_IMAGE_PATH MIL_TEXT(\"TargetLightImage.avi\") }; #define NB_SENSOR_STEP 4 static MIL_CONST_TEXT_PTR SENSOR_MESSAGE[NB_SENSOR_STEP] = { // FLAT_MESSAGE MIL_TEXT(\"The camera is grabbing continuously with short exposure time.\\n\") MIL_TEXT(\"To set up a Flat image, grab a uniform light gray area (such as grabbing an\\n\") MIL_TEXT(\"image of a blank piece of paper). Adjust your lighting intensity to\\n\") MIL_TEXT(\"maximize the dynamic range of the image (avoid white saturation).\\n\"), // DARK_MESSAGE MIL_TEXT(\"The camera is grabbing continuously with normal exposure time.\\n\") MIL_TEXT(\"To set up a Dark image, grab a uniform dark area (such as grabbing with the \\n\") MIL_TEXT(\"camera's lens cap firmly in place).\\n\"), M_NULL, // OFFSET_MESSAGE MIL_TEXT(\"The camera is grabbing continuously with short exposure time.\\n\") MIL_TEXT(\"To set up an Offset image, grab a uniform dark area (such as grabbing with the \\n\") MIL_TEXT(\"camera's lens cap firmly in place).\\n\") }; static MIL_CONST_TEXT_PTR SENSOR_CORRECTION_MESSAGE = MIL_TEXT(\"The lens vignetting correction is visible in the image and histogram.\\n\") MIL_TEXT(\"The corners of the image are now as bright as the center. The histogram\\n\") MIL_TEXT(\"distribution of the white areas is much less dispersed.\\n\"); static MIL_CONST_TEXT_PTR SENSOR_AVI[NB_SENSOR_STEP] = { EXAMPLE_IMAGE_PATH MIL_TEXT(\"FlatSensorImage.avi\"), EXAMPLE_IMAGE_PATH MIL_TEXT(\"DarkSensorImage.avi\"), EXAMPLE_IMAGE_PATH MIL_TEXT(\"TargetSensorImage.avi\"), EXAMPLE_IMAGE_PATH MIL_TEXT(\"OffsetSensorImage.avi\") }; // The enum that describe the step. enum FlatFieldStepEnum { enFlat = 0, enDark, enTarget, enOffset, enTotalStep, }; // The number of images to average the frames. static const MIL_INT NB_ACCUMULATE_FRAMES = 16; // The short exposure time ratio. static const MIL_DOUBLE SHORT_EXPOSURE_TIME_MULTIPLIER = 8; // Offsets of the windows. static const MIL_INT WINDOWS_OFFSET_X = 15; static const MIL_INT WINDOWS_OFFSET_Y = 38; // Useful defines. static const MIL_DOUBLE PI = 3.14159265358979323846; //***************************************************************************** // Callback structures. //***************************************************************************** struct SStatCumulativeData { MIL_ID MilStatResult[3]; MIL_ID MilStatContext; MIL_ID MilSrcImage; MIL_ID MilDispImage; }; struct SUserData { MIL_ID MilDispImage; MIL_ID MilSrcImage; MIL_ID MilCorrectedImage; MIL_ID MilFlatFieldContext; MIL_ID MilDisplay; MIL_ID MilCorrectedDisplay; CHistogramDisplay* pSrcHistDisplay; CHistogramDisplay* pDstHistDisplay; }; //***************************************************************************** // Function prototypes. //***************************************************************************** MIL_INT MFTYPE CalImageAccumulationFunc(MIL_INT HookType, MIL_ID EventId, void* pHookData); MIL_INT MFTYPE FlatFieldCorrectionFunc(MIL_INT HookType, MIL_ID EventId, void* pHookData); bool AskForInteractive(); void DrawArrow(MIL_ID MilGraContext, MIL_ID MilDest, MIL_DOUBLE ArrowCenterX, MIL_DOUBLE ArrowCenterY, MIL_DOUBLE ArrowLength, MIL_DOUBLE ArrowTickness, MIL_DOUBLE ArrowAngle); void GrabAndSetImageInContext(MIL_ID MilDigitizer, MIL_ID MilDisplay, MIL_ID MilDispImage, MIL_ID MilSrcImage, MIL_ID* pMilGrabImages, MIL_INT NbGrabImages, MIL_ID MilDestImage, MIL_ID MilFlatFieldContext, MIL_ID MilStatCumulativeContext, MIL_INT ControlFlag, MIL_CONST_TEXT_PTR ImageTypeTag, MIL_CONST_TEXT_PTR Message); void SensorOnlyFlatFieldExample(MIL_ID MilSystem, MIL_ID MilDisplay, MIL_ID MilGralist, MIL_ID MilCorrectedDisplay, MIL_ID MilCorrectedGraList, bool IsInteractive); void LightingAndSensorFlatFieldExample(MIL_ID MilSystem, MIL_ID MilDisplay, MIL_ID MilGralist, MIL_ID MilCorrectedDisplay, MIL_ID MilCorrectedGraList, bool IsInteractive); void FlatFieldExample(MIL_ID MilSystem, MIL_ID MilDisplay, MIL_ID MilGraList, MIL_ID MilCorrectedDisplay, MIL_ID MilCorrectedGraList, MIL_INT NbSteps, MIL_CONST_TEXT_PTR* StepMessages, MIL_CONST_TEXT_PTR* StepAvi, MIL_CONST_TEXT_PTR CorrectionMessage, bool IsInteractive); void IntroNonUniform(MIL_ID MilSystem, MIL_ID MilDisplay, MIL_ID MilGraList, MIL_ID MilIntroImage); void IntroVignetting(MIL_ID MilSystem, MIL_ID MilDisplay, MIL_ID MilGraList, MIL_ID MilIntroImage); void IntroDust(MIL_ID MilSystem, MIL_ID MilDisplay, MIL_ID MilGraList, MIL_ID MilIntroImage, MIL_ID MilEqualizeDisplay, MIL_ID MilEqualizeGraList, MIL_INT NbDust, const MIL_DOUBLE* pDustX, const MIL_DOUBLE* pDustY, const MIL_DOUBLE* pDustRadius); void IntroOffset(MIL_ID MilSystem, MIL_ID MilDisplay, MIL_ID MilGraList, MIL_ID MilIntroImage); void GetScreenSize(MIL_INT* pMaxSizeX, MIL_INT* pMaxSizeY); //***************************************************************************** // Main. //***************************************************************************** int MosMain(void) { // Print Header. PrintHeader(); // Ask whether to run the example interactively. bool IsInteractive = AskForInteractive(); // Allocate the MIL objects. MIL_ID MilApplication = MappAlloc(M_NULL, M_DEFAULT, M_NULL); MIL_CONST_TEXT_PTR SystemDescriptor = IsInteractive ? M_SYSTEM_DEFAULT : M_SYSTEM_HOST; MIL_ID MilSystem = MsysAlloc(M_DEFAULT, SystemDescriptor, M_DEFAULT, M_DEFAULT, M_NULL); // Check if the example can run in interactive mode. MIL_INT SystemType = MsysInquire(MilSystem, M_SYSTEM_TYPE, M_NULL); if (IsInteractive &amp;&amp; SystemType == M_SYSTEM_HOST_TYPE) { IsInteractive = false; MosPrintf(MIL_TEXT(\"This example requires a real digitizer to run properly in interactive mode.\\n\") MIL_TEXT(\"The current default configuration (system, digitizer, ...) needs to be changed.\\n\\n\") MIL_TEXT(\"Press any key to continue in standalone mode.\\n\\n\")); MosGetch(); } // Allocate the displays. MIL_ID MilDisplay = MdispAlloc(MilSystem, M_DEFAULT, MIL_TEXT(\"M_DEFAULT\"), M_WINDOWED, M_NULL); MdispControl(MilDisplay, M_WINDOW_INITIAL_POSITION_X, 0); MdispControl(MilDisplay, M_WINDOW_INITIAL_POSITION_Y, 0); MdispControl(MilDisplay, M_TITLE, MIL_TEXT(\"Source image\")); MIL_ID MilCorrectedDisplay = MdispAlloc(MilSystem, M_DEFAULT, MIL_TEXT(\"M_DEFAULT\"), M_WINDOWED, M_NULL); // Allocate a graphic lists for the displays. MIL_ID MilGralist = MgraAllocList(MilSystem, M_DEFAULT, M_NULL); MdispControl(MilDisplay, M_ASSOCIATED_GRAPHIC_LIST_ID, MilGralist); MIL_ID MilCorrectedGralist = MgraAllocList(MilSystem, M_DEFAULT, M_NULL); MdispControl(MilCorrectedDisplay, M_ASSOCIATED_GRAPHIC_LIST_ID, MilCorrectedGralist); if(IsInteractive) { // Ask the user to choose the example. bool ValidChoice = true; do { MosPrintf(MIL_TEXT(\"Please choose the type of flat field correction to perform.\\n\") MIL_TEXT(\" a. Lighting and Sensor correction.\\n\") MIL_TEXT(\" b. Sensor only correction.\\n\\n\") MIL_TEXT(\"Your choice: \")); switch(MosGetch()) { case MIL_TEXT('a'): case MIL_TEXT('A'): MosPrintf(MIL_TEXT(\" a. Lighting and Sensor correction.\\n\\n\")); LightingAndSensorFlatFieldExample(MilSystem, MilDisplay, MilGralist, MilCorrectedDisplay, MilCorrectedGralist, true); ValidChoice = true; break; case MIL_TEXT('b'): case MIL_TEXT('B'): MosPrintf(MIL_TEXT(\" b. Sensor only correction.\\n\\n\")); SensorOnlyFlatFieldExample(MilSystem, MilDisplay, MilGralist, MilCorrectedDisplay, MilCorrectedGralist, true); ValidChoice = true; break; default: ValidChoice = false; } } while (!ValidChoice); } else { // Show the lighting correction example. LightingAndSensorFlatFieldExample(MilSystem, MilDisplay, MilGralist, MilCorrectedDisplay, MilCorrectedGralist, false); // Show the Sensor correction example. SensorOnlyFlatFieldExample(MilSystem, MilDisplay, MilGralist, MilCorrectedDisplay, MilCorrectedGralist, false); } // Free the graphic lists. MgraFree(MilCorrectedGralist); MgraFree(MilGralist); // Free the displays. MdispFree(MilCorrectedDisplay); MdispFree(MilDisplay); // Free allocated objects. MsysFree(MilSystem); MappFree(MilApplication); return 0; } //***************************************************************************** // Non-Uniform lighting introduction functions. //***************************************************************************** static const MIL_DOUBLE PROFILE_DISPLAY_SIZE_Y = 75; static const MIL_DOUBLE PROFILE_CENTER_X = 320; static const MIL_DOUBLE PROFILE_CENTER_Y = 240; static const MIL_INT PROFILE_HEIGHT = 25; static const MIL_INT PROFILE_LENGTH = 720; static const MIL_DOUBLE PROFILE_ANGLE = 36.87; void IntroNonUniform(MIL_ID MilSystem, MIL_ID MilDisplay, MIL_ID MilGraList, MIL_ID MilIntroImage) { // Clear the graphic list. MgraClear(M_DEFAULT, MilGraList); // Get the size Y of the image. MIL_INT ImageSizeY = MbufInquire(MilIntroImage, M_SIZE_Y, M_NULL); // Allocate a profile image. MIL_ID MilProfileImage = MbufAlloc2d(MilSystem, PROFILE_LENGTH, PROFILE_HEIGHT, 8+M_UNSIGNED, M_IMAGE+M_PROC+M_DISP, M_NULL); // Allocate the profile data. MIL_ID MilProfileResult = MimAllocResult(MilSystem, PROFILE_LENGTH, M_PROJ_LIST, M_NULL); MIL_DOUBLE ProfileData[PROFILE_LENGTH]; MIL_DOUBLE ProfileIndex[PROFILE_LENGTH]; // Allocate a profile display. MIL_ID MilProfileDisplay = MdispAlloc(MilSystem, M_DEFAULT, MIL_TEXT(\"M_DEFAULT\"), M_WINDOWED, M_NULL); MIL_ID MilProfileGraList = MgraAllocList(MilSystem, M_DEFAULT, M_NULL); MdispControl(MilProfileDisplay, M_ASSOCIATED_GRAPHIC_LIST_ID, MilProfileGraList); MdispControl(MilProfileDisplay, M_WINDOW_INITIAL_POSITION_Y, ImageSizeY + WINDOWS_OFFSET_Y); MdispControl(MilProfileDisplay, M_TITLE, MIL_TEXT(\"Profile display\")); // Draw the profile region in the graphic list. MgraControl(M_DEFAULT, M_COLOR, M_COLOR_RED); MgraRectAngle(M_DEFAULT, MilGraList, PROFILE_CENTER_X, PROFILE_CENTER_Y, PROFILE_LENGTH, PROFILE_HEIGHT, PROFILE_ANGLE, M_CENTER_AND_DIMENSION + M_FILLED); MgraRectAngle(M_DEFAULT, MilProfileGraList, 0, 0, PROFILE_LENGTH-1, PROFILE_HEIGHT-1, 0, M_DEFAULT); DrawArrow(M_DEFAULT, MilGraList, PROFILE_CENTER_X, PROFILE_CENTER_Y, (MIL_DOUBLE)PROFILE_LENGTH, (MIL_DOUBLE)PROFILE_HEIGHT, PROFILE_ANGLE); // Get the profile image. MimRotate(MilIntroImage, MilProfileImage, -PROFILE_ANGLE, PROFILE_CENTER_X, PROFILE_CENTER_Y, M_DEFAULT, M_DEFAULT, M_BILINEAR + M_OVERSCAN_CLEAR); // Get the profile data. MimProjection(MilProfileImage, MilProfileResult, M_0_DEGREE, M_DEFAULT, M_NULL); MimGetResult(MilProfileResult, M_TYPE_MIL_DOUBLE, ProfileData); // Rescale the data. for(MIL_INT ValIdx = 0; ValIdx &lt; PROFILE_LENGTH; ValIdx++) { ProfileData[ValIdx] = (PROFILE_HEIGHT - ProfileData[ValIdx] / 255); ProfileIndex[ValIdx] = (MIL_DOUBLE)ValIdx; } // Draw the profile. MgraLines(M_DEFAULT, MilProfileGraList, PROFILE_LENGTH, ProfileIndex, ProfileData, M_NULL, M_NULL, M_POLYLINE); // Display the profile. Rescale the display to fit the desired size. MdispZoom(MilProfileDisplay, 1, (MIL_DOUBLE)PROFILE_DISPLAY_SIZE_Y / PROFILE_HEIGHT); MdispSelect(MilProfileDisplay, MilProfileImage); // Print message about non-uniform lighting. MosPrintf(MIL_TEXT(\"(a) Non-uniform lighting.\\n\") MIL_TEXT(\"The displayed flat image exhibits non-uniform lighting, which is\\n\") MIL_TEXT(\"illustrated by the intensity profile along the diagonal.\\n\\n\") MIL_TEXT(\"Press any key to continue.\\n\\n\")); MosGetch(); // Free the profile display. MgraFree(MilProfileGraList); MdispFree(MilProfileDisplay); // Free the profile result. MimFree(MilProfileResult); // Free the profile image. MbufFree(MilProfileImage); } //***************************************************************************** // Vignetting introduction functions. //***************************************************************************** static const MIL_DOUBLE ARROW_RADIUS = 270; static const MIL_DOUBLE ARROW_LENGTH = 40; static const MIL_DOUBLE ARROW_THICKNESS = 10; static const MIL_DOUBLE ARROW_ANGLE = 36.87; static const MIL_DOUBLE ARROW_CENTER_DIST_X = (ARROW_RADIUS) * cos(ARROW_ANGLE * PI / 180); static const MIL_DOUBLE ARROW_CENTER_DIST_Y = (ARROW_RADIUS) * sin(ARROW_ANGLE * PI / 180); void IntroVignetting(MIL_ID MilSystem, MIL_ID MilDisplay, MIL_ID MilGraList, MIL_ID MilIntroImage) { // Clear the graphic list. MgraClear(M_DEFAULT, MilGraList); // Get the size of the image; MIL_INT ImageSizeX = MbufInquire(MilIntroImage, M_SIZE_X, M_NULL); MIL_INT ImageSizeY = MbufInquire(MilIntroImage, M_SIZE_Y, M_NULL); MIL_DOUBLE ImageCenterX = (MIL_DOUBLE)ImageSizeX / 2; MIL_DOUBLE ImageCenterY = (MIL_DOUBLE)ImageSizeY / 2; // Draw the 4 arrows. MgraControl(M_DEFAULT, M_COLOR, M_COLOR_RED); DrawArrow(M_DEFAULT, MilGraList, ImageCenterX - ARROW_CENTER_DIST_X, ImageCenterY - ARROW_CENTER_DIST_Y, ARROW_LENGTH, ARROW_THICKNESS, 180 - ARROW_ANGLE); DrawArrow(M_DEFAULT, MilGraList, ImageCenterX + ARROW_CENTER_DIST_X, ImageCenterY - ARROW_CENTER_DIST_Y, ARROW_LENGTH, ARROW_THICKNESS, ARROW_ANGLE); DrawArrow(M_DEFAULT, MilGraList, ImageCenterX + ARROW_CENTER_DIST_X, ImageCenterY + ARROW_CENTER_DIST_Y, ARROW_LENGTH, ARROW_THICKNESS, - ARROW_ANGLE); DrawArrow(M_DEFAULT, MilGraList, ImageCenterX - ARROW_CENTER_DIST_X, ImageCenterY + ARROW_CENTER_DIST_Y, ARROW_LENGTH, ARROW_THICKNESS, 180 + ARROW_ANGLE); // Print message about vignetting. MosPrintf(MIL_TEXT(\"(a) Lens vignetting\\n\") MIL_TEXT(\"The displayed flat image exhibits lens vignetting which is visible in\\n\") MIL_TEXT(\"its corners.\\n\\n\") MIL_TEXT(\"Press any key to continue.\\n\\n\")); MosGetch(); } //***************************************************************************** // Dust introduction functions. //***************************************************************************** void IntroDust(MIL_ID MilSystem, MIL_ID MilDisplay, MIL_ID MilGraList, MIL_ID MilIntroImage, MIL_ID MilEqualizeDisplay, MIL_ID MilEqualizeGraList, MIL_INT NbDust, const MIL_DOUBLE* pDustX, const MIL_DOUBLE* pDustY, const MIL_DOUBLE* pDustRadius) { MIL_INT ImageSizeX = MbufInquire(MilIntroImage, M_SIZE_X, M_NULL); // Setup the displays. MgraControl(M_DEFAULT, M_COLOR, M_COLOR_RED); MgraText(M_DEFAULT, MilGraList, 0, 0, MIL_TEXT(\"Source image\")); MdispControl(MilEqualizeDisplay, M_WINDOW_INITIAL_POSITION_X, ImageSizeX + WINDOWS_OFFSET_X); MdispControl(MilEqualizeDisplay, M_WINDOW_INITIAL_POSITION_Y, 0); MdispControl(MilEqualizeDisplay, M_TITLE, MIL_TEXT(\"Equalized image\")); MgraControl(M_DEFAULT, M_COLOR, M_COLOR_CYAN); MgraText(M_DEFAULT, MilEqualizeGraList, 0, 0, MIL_TEXT(\"Equalized image\")); // Clear the graphic lists. MgraClear(M_DEFAULT, MilGraList); MgraClear(M_DEFAULT, MilEqualizeGraList); // Create the equalized image. MIL_ID MilEqualizeIntroImage = MbufClone(MilIntroImage, M_DEFAULT, M_DEFAULT, M_DEFAULT, M_DEFAULT, M_DEFAULT, M_DEFAULT, M_NULL); MIL_ID MilHistogramEqualizeAdaptiveContext = MimAlloc(MilSystem, M_HISTOGRAM_EQUALIZE_ADAPTIVE_CONTEXT, M_DEFAULT, M_NULL); MimHistogramEqualizeAdaptive(MilHistogramEqualizeAdaptiveContext, MilIntroImage, MilEqualizeIntroImage, M_DEFAULT); MimFree(MilHistogramEqualizeAdaptiveContext); // Select it on the equalized display. MdispSelect(MilEqualizeDisplay, MilEqualizeIntroImage); // Draw circles around the dust. MgraControl(M_DEFAULT, M_COLOR, M_COLOR_BLUE); for(MIL_INT DustIdx = 0; DustIdx &lt; NbDust; DustIdx++) { MgraArc(M_DEFAULT, MilGraList, pDustX[DustIdx], pDustY[DustIdx], pDustRadius[DustIdx], pDustRadius[DustIdx], 0, 360); MgraArc(M_DEFAULT, MilEqualizeGraList, pDustX[DustIdx], pDustY[DustIdx], pDustRadius[DustIdx], pDustRadius[DustIdx], 0, 360); } // Print message about dust. MosPrintf(MIL_TEXT(\"(b) Sensor and lens anomalies.\\n\") MIL_TEXT(\"Dust, scratches and defects are examples of sensor and lens anomalies that can\\n\") MIL_TEXT(\"affect an image's quality. Sensor sensitivity variations can also introduce\\n\") MIL_TEXT(\"unwanted artifacts. The displayed flat image exhibits several dust problems\\n\") MIL_TEXT(\"which are circled in blue. The image is equalized to enhance the visualization\\n\") MIL_TEXT(\"of the anomalies.\\n\\n\") MIL_TEXT(\"Press any key to continue.\\n\\n\")); MosGetch(); // Deselect the image. MdispSelect(MilEqualizeDisplay, M_NULL); // Free the equalize image. MbufFree(MilEqualizeIntroImage); } //***************************************************************************** // Offset introduction functions. //***************************************************************************** void IntroOffset(MIL_ID MilSystem, MIL_ID MilDisplay, MIL_ID MilGraList, MIL_ID MilIntroImage) { // Clear the graphic list. MgraClear(M_DEFAULT, MilGraList); // Get the size Y. MIL_INT ImageSizeY = MbufInquire(MilIntroImage, M_SIZE_Y, M_NULL); // Allocate a histogram display. CHistogramDisplay* pIntroHistogram = new CHistogramDisplay(MilSystem); pIntroHistogram-&gt;SetWindowInitialPosition(0, ImageSizeY + WINDOWS_OFFSET_Y); pIntroHistogram-&gt;Update(MilIntroImage, M_NULL); pIntroHistogram-&gt;Show(); // Print message about offset. MosPrintf(MIL_TEXT(\"(c) Black offset.\\n\") MIL_TEXT(\"The displayed image exhibits a black offset that can be observed\\n\") MIL_TEXT(\"in its histogram.\\n\\n\") MIL_TEXT(\"Press any key to continue.\\n\\n\")); MosGetch(); // Delete the histogram display. delete pIntroHistogram; } //***************************************************************************** // Flat field example function //***************************************************************************** static const MIL_INT LIGHTING_NB_DUST = 3; static const MIL_DOUBLE LIGHTING_DUST_POS_X[LIGHTING_NB_DUST] = {325, 132, 402}; static const MIL_DOUBLE LIGHTING_DUST_POS_Y[LIGHTING_NB_DUST] = {378, 338, 373}; static const MIL_DOUBLE LIGHTING_DUST_RADIUS[LIGHTING_NB_DUST] = { 9, 85, 38}; void LightingAndSensorFlatFieldExample(MIL_ID MilSystem, MIL_ID MilDisplay, MIL_ID MilGralist, MIL_ID MilCorrectedDisplay, MIL_ID MilCorrectedGraList, bool IsInteractive) { // Print the example title. MosPrintf(MIL_TEXT(\"CASE 1: LIGHTING AND SENSOR CORRECTION\\n\") MIL_TEXT(\"--------------------------------------\\n\\n\") MIL_TEXT(\"This flat-field case shows you how to correct:\\n\") MIL_TEXT(\" (a) Non-uniform lighting.\\n\") MIL_TEXT(\" (b) Sensor and lens anomalies.\\n\") MIL_TEXT(\" (c) Black offset.\\n\\n\") MIL_TEXT(\"Press any key to continue.\\n\\n\")); MosGetch(); // Restore the non-uniform lighting introduction image. MIL_ID MilIntroImage = MbufRestore(INTRO_NON_UNIFORM_IMAGE, MilSystem, M_NULL); MdispSelect(MilDisplay, MilIntroImage); // Non-uniform lighting introduction. IntroNonUniform(MilSystem, MilDisplay, MilGralist, MilIntroImage); // Dust introduction. IntroDust(MilSystem, MilDisplay, MilGralist, MilIntroImage, MilCorrectedDisplay, MilCorrectedGraList, LIGHTING_NB_DUST, LIGHTING_DUST_POS_X, LIGHTING_DUST_POS_Y, LIGHTING_DUST_RADIUS); // Free the intro image. MbufFree(MilIntroImage); // Restore the offset introduction image. MbufRestore(INTRO_OFFSET_IMAGE, MilSystem, &amp;MilIntroImage); MdispSelect(MilDisplay, MilIntroImage); // Offset introduction. IntroOffset(MilSystem, MilDisplay, MilGralist, MilIntroImage); // Free the intro image. MbufFree(MilIntroImage); // Print a summary of the flat field setup. MosPrintf(MIL_TEXT(\"SETUP PROCEDURE FOR LIGHTING AND SENSOR CORRECTION:\\n\") MIL_TEXT(\"For this type of correction, you need to set up:\\n\") MIL_TEXT(\" - a Flat image: gray image under the application's lighting (NORMAL exposure).\\n\") MIL_TEXT(\" - a Dark image: black image with the lens cap in place (NORMAL exposure).\\n\\n\") MIL_TEXT(\"Press any key to start.\\n\\n\")); MosGetch(); // Run the example. FlatFieldExample(MilSystem, MilDisplay, MilGralist, MilCorrectedDisplay, MilCorrectedGraList, NB_LIGHT_STEP, LIGHT_MESSAGE, LIGHT_AVI, LIGHT_CORRECTION_MESSAGE, IsInteractive); } static const MIL_INT VIGNETTING_NB_DUST = 1; static const MIL_DOUBLE VIGNETTING_DUST_POS_X[VIGNETTING_NB_DUST] = {315}; static const MIL_DOUBLE VIGNETTING_DUST_POS_Y[VIGNETTING_NB_DUST] = {196}; static const MIL_DOUBLE VIGNETTING_DUST_RADIUS[VIGNETTING_NB_DUST] = { 48}; void SensorOnlyFlatFieldExample(MIL_ID MilSystem, MIL_ID MilDisplay, MIL_ID MilGralist, MIL_ID MilCorrectedDisplay, MIL_ID MilCorrectedGraList, bool IsInteractive) { // Print the example title. MosPrintf(MIL_TEXT(\"CASE 2: SENSOR ONLY CORRECTION\\n\") MIL_TEXT(\"------------------------------\\n\\n\") MIL_TEXT(\"This flat-field case shows you how to correct:\\n\") MIL_TEXT(\" (a) Lens vignetting.\\n\") MIL_TEXT(\" (b) Sensor and lens anomalies.\\n\") MIL_TEXT(\" (c) Black offset.\\n\\n\") MIL_TEXT(\"Press any key to continue.\\n\\n\")); MosGetch(); // Restore the vignetting introduction image. MIL_ID MilIntroImage = MbufRestore(INTRO_VIGNETTING_IMAGE, MilSystem, M_NULL); MdispSelect(MilDisplay, MilIntroImage); // Non-uniform lighting introduction. IntroVignetting(MilSystem, MilDisplay, MilGralist, MilIntroImage); // Dust introduction. IntroDust(MilSystem, MilDisplay, MilGralist, MilIntroImage, MilCorrectedDisplay, MilCorrectedGraList, VIGNETTING_NB_DUST, VIGNETTING_DUST_POS_X, VIGNETTING_DUST_POS_Y, VIGNETTING_DUST_RADIUS); // Free the intro image. MbufFree(MilIntroImage); // Restore the offset introduction image. MbufRestore(INTRO_OFFSET_IMAGE, MilSystem, &amp;MilIntroImage); MdispSelect(MilDisplay, MilIntroImage); // Offset introduction. IntroOffset(MilSystem, MilDisplay, MilGralist, MilIntroImage); // Free the intro image. MbufFree(MilIntroImage); // Print a summary of the flat field setup. MosPrintf(MIL_TEXT(\"SETUP PROCEDURE FOR SENSOR ONLY CORRECTION:\\n\") MIL_TEXT(\"For this type of correction, you need to set up:\\n\") MIL_TEXT(\" - an Offset image: black image with the lens cap in place (SHORT exposure).\\n\") MIL_TEXT(\" - a Flat image: gray image with uniform lighting (SHORT exposure).\\n\") MIL_TEXT(\" - a Dark image: black image with the lens cap in place (NORMAL exposure).\\n\\n\") MIL_TEXT(\"Press any key to start.\\n\\n\")); MosGetch(); FlatFieldExample(MilSystem, MilDisplay, MilGralist, MilCorrectedDisplay, MilCorrectedGraList, NB_SENSOR_STEP, SENSOR_MESSAGE, SENSOR_AVI, SENSOR_CORRECTION_MESSAGE, IsInteractive); } void FlatFieldExample(MIL_ID MilSystem, MIL_ID MilDisplay, MIL_ID MilGraList, MIL_ID MilCorrectedDisplay, MIL_ID MilCorrectedGraList, MIL_INT NbSteps, MIL_CONST_TEXT_PTR* StepMessages, MIL_CONST_TEXT_PTR* StepAvi, MIL_CONST_TEXT_PTR CorrectionMessage, bool IsInteractive) { // Allocate the digitizer. MIL_ID MilDigitizers[enTotalStep]; if(!IsInteractive) { for(MIL_INT StepIdx = 0; StepIdx &lt; NbSteps; StepIdx++) MdigAlloc(MilSystem, M_DEFAULT, StepAvi[StepIdx], M_DEFAULT, &amp;MilDigitizers[StepIdx]); } else { MdigAlloc(MilSystem, M_DEFAULT, MIL_TEXT(\"M_DEFAULT\"), M_DEFAULT, &amp;MilDigitizers[0]); for(MIL_INT StepIdx = 1; StepIdx &lt; NbSteps; StepIdx++) MilDigitizers[StepIdx] = MilDigitizers[0]; } // Get the parameters of the digitizer. MIL_INT Type = MdigInquire(MilDigitizers[0], M_TYPE, M_NULL); MIL_INT SizeX = MdigInquire(MilDigitizers[0], M_SIZE_X, M_NULL); MIL_INT SizeY = MdigInquire(MilDigitizers[0], M_SIZE_Y, M_NULL); MIL_INT SizeBand = MdigInquire(MilDigitizers[0], M_SIZE_BAND, M_NULL); MIL_INT SizeBit = MdigInquire(MilDigitizers[0], M_SIZE_BIT, M_NULL); if (SizeBit != 8) { MdispControl(MilDisplay, M_VIEW_MODE, M_AUTO_SCALE); } // Allocate the images. const MIL_INT NB_GRABIMAGES = 3; MIL_ID MilGrabImages[NB_GRABIMAGES]; for (MIL_INT i = 0; i &lt; NB_GRABIMAGES; i++) { MilGrabImages[i] = MbufAllocColor(MilSystem, SizeBand, SizeX, SizeY, Type, M_IMAGE + M_PROC + M_GRAB, M_NULL); } MIL_ID MilOffsetImage = MbufAllocColor(MilSystem, SizeBand, SizeX, SizeY, Type, M_IMAGE + M_PROC + M_DISP, M_NULL); MIL_ID MilFlatImage = MbufAllocColor(MilSystem, SizeBand, SizeX, SizeY, Type, M_IMAGE + M_PROC + M_DISP, M_NULL); MIL_ID MilDarkImage = MbufAllocColor(MilSystem, SizeBand, SizeX, SizeY, Type, M_IMAGE + M_PROC + M_DISP, M_NULL); MIL_ID MilSrcImage = MbufAllocColor(MilSystem, SizeBand, SizeX, SizeY, Type, M_IMAGE + M_PROC + M_DISP, M_NULL); MIL_ID MilCorrectedImage = MbufAllocColor(MilSystem, SizeBand, SizeX, SizeY, Type, M_IMAGE + M_PROC + M_DISP, M_NULL); MIL_ID MilDispImage = MbufAllocColor(MilSystem, SizeBand, SizeX, SizeY, Type, M_IMAGE + M_PROC + M_DISP + M_GRAB, M_NULL); // Allocate and setup the histogram displays. CHistogramDisplay* pSrcHistDisplay = new CHistogramDisplay(MilSystem, MIL_TEXT(\"Source histogram\"), M_COLOR_RED); CHistogramDisplay* pDstHistDisplay = new CHistogramDisplay(MilSystem, MIL_TEXT(\"Corrected histogram\"), M_COLOR_CYAN); pSrcHistDisplay-&gt;Preprocess(MilGrabImages[0]); pDstHistDisplay-&gt;Preprocess(MilGrabImages[0]); // Get the maximum size of the display. MIL_INT MaxSizeX; MIL_INT MaxSizeY; GetScreenSize(&amp;MaxSizeX, &amp;MaxSizeY); // Get the zoom factor of the image. MIL_DOUBLE ZoomX = (MIL_DOUBLE)(MaxSizeX - 2 * WINDOWS_OFFSET_X) / (SizeX * 2); MIL_DOUBLE ZoomY = (MIL_DOUBLE)(MaxSizeY - pSrcHistDisplay-&gt;GetHistImageSizeY() - 2 * WINDOWS_OFFSET_Y) / SizeY; MIL_DOUBLE Zoom = (ZoomX &lt; ZoomY) ? ZoomX : ZoomY; if (Zoom &lt; 1.0) { MdispZoom(MilDisplay, Zoom, Zoom); MdispZoom(MilCorrectedDisplay, Zoom, Zoom); } else Zoom = 1.0; // Set the position of the histograms. pSrcHistDisplay-&gt;SetWindowInitialPosition(0, (MIL_INT)((MIL_DOUBLE)SizeY * Zoom + WINDOWS_OFFSET_Y)); pDstHistDisplay-&gt;SetWindowInitialPosition((MIL_INT)((MIL_DOUBLE)SizeX * Zoom + WINDOWS_OFFSET_X), (MIL_INT)((MIL_DOUBLE)SizeY * Zoom + WINDOWS_OFFSET_Y)); // Allocate the flat field context. MIL_ID MilFlatFieldContext = MimAlloc(MilSystem, M_FLAT_FIELD_CONTEXT, M_DEFAULT, M_NULL); // Allocate the stat Cumulative context and preprocess it. MIL_ID MilStatCumulativeContext = MimAlloc(MilSystem, M_STATISTICS_CUMULATIVE_CONTEXT, M_DEFAULT, M_NULL); MimControl(MilStatCumulativeContext, M_STAT_MEAN, M_ENABLE); // Clear the graphic lists. MgraClear(M_DEFAULT, MilGraList); MgraClear(M_DEFAULT, MilCorrectedGraList); // If all the steps are performed, grab the offset image first and reduce the exposure time. MIL_DOUBLE CurExposureTime; MIL_INT ExposureTimeControlError = M_NULL_ERROR; if(NbSteps == enTotalStep) { if(IsInteractive) { // Reduce the exposure time if supported. MIL_DOUBLE MinExposureTime; // Disable the error printing. MappControl(M_ERROR, M_PRINT_DISABLE); // Get the current exposure time MdigInquire(MilDigitizers[0], M_EXPOSURE_TIME , &amp;CurExposureTime); MappGetError(M_CURRENT, &amp;ExposureTimeControlError); if (ExposureTimeControlError == M_NULL_ERROR) { MdigInquire(MilDigitizers[0], M_EXPOSURE_TIME + M_MIN_VALUE, &amp;MinExposureTime); MappGetError(M_CURRENT, &amp;ExposureTimeControlError); if (ExposureTimeControlError == M_NULL_ERROR) { // Set the short exposure time. MIL_DOUBLE ShortExposureTime = MinExposureTime * SHORT_EXPOSURE_TIME_MULTIPLIER; ShortExposureTime = (ShortExposureTime &gt; CurExposureTime) ? CurExposureTime : ShortExposureTime; MdigControl(MilDigitizers[0], M_EXPOSURE_TIME, ShortExposureTime); MappGetError(M_CURRENT, &amp;ExposureTimeControlError); } } // If an error occurred while setting the exposure time if (ExposureTimeControlError != M_NULL_ERROR) { MosPrintf(MIL_TEXT(\"LIMITATION DETECTED:\\n\") MIL_TEXT(\"This digitizer does not allow dynamic control of the exposure time.\\n\") MIL_TEXT(\"The example will continue using the normal exposure time instead of\\n\") MIL_TEXT(\"a short exposure time. Sensor only correction might not work as expected.\\n\\n\") MIL_TEXT(\"Press any key to continue.\\n\\n\")); MosGetch(); } // Enable the error printing. MappControl(M_ERROR, M_PRINT_ENABLE); } // Grab and set the offset image. GrabAndSetImageInContext(MilDigitizers[enOffset], MilDisplay, MilDispImage, MilSrcImage, MilGrabImages, NB_GRABIMAGES, MilOffsetImage, MilFlatFieldContext, MilStatCumulativeContext, M_OFFSET_IMAGE, MIL_TEXT(\"Offset\"), StepMessages[enOffset]); } // Grab and set the flat image. GrabAndSetImageInContext(MilDigitizers[enFlat], MilDisplay, MilDispImage, MilSrcImage, MilGrabImages, NB_GRABIMAGES, MilFlatImage, MilFlatFieldContext, MilStatCumulativeContext, M_FLAT_IMAGE, MIL_TEXT(\"Flat\"), StepMessages[enFlat]); // Put the exposure time back to the dcf value. if(IsInteractive &amp;&amp; (NbSteps == enTotalStep) &amp;&amp; (ExposureTimeControlError == M_NULL_ERROR)) MdigControl(MilDigitizers[0], M_EXPOSURE_TIME, CurExposureTime); // Grab and set the dark image. GrabAndSetImageInContext(MilDigitizers[enDark], MilDisplay, MilDispImage, MilSrcImage, MilGrabImages, NB_GRABIMAGES, MilDarkImage, MilFlatFieldContext, MilStatCumulativeContext, M_DARK_IMAGE, MIL_TEXT(\"Dark\"), StepMessages[enDark]); // If the offset image wasn't grabbed set the dark image as the offset image. The flat image // needed to be grabbed with normal exposure time. if(NbSteps != enTotalStep) MimControl(MilFlatFieldContext, M_OFFSET_IMAGE, MilDarkImage); // Use the automatic gain. MimControl(MilFlatFieldContext, M_GAIN_CONST, M_AUTOMATIC); // Preprocess the flat field context. MimFlatField(MilFlatFieldContext, MilDispImage, MilCorrectedImage, M_PREPROCESS); // Deselect the image on the display. MdispSelect(MilDisplay, M_NULL); // Print message. MosPrintf(MIL_TEXT(\"The flat field context is now preprocessed.\\n\\n\") MIL_TEXT(\"Press any key to continue.\\n\\n\")); MosGetch(); // Setup the displays. MdispControl(MilDisplay, M_WINDOW_INITIAL_POSITION_X, 0); MdispControl(MilDisplay, M_WINDOW_INITIAL_POSITION_Y, 0); MdispControl(MilDisplay, M_TITLE, MIL_TEXT(\"Source image\")); MgraControl(M_DEFAULT, M_COLOR, M_COLOR_RED); MgraText(M_DEFAULT, MilGraList, 0, 0, MIL_TEXT(\"Source image\")); MdispControl(MilCorrectedDisplay, M_WINDOW_INITIAL_POSITION_X, SizeX * Zoom + WINDOWS_OFFSET_X); MdispControl(MilCorrectedDisplay, M_WINDOW_INITIAL_POSITION_Y, 0); MdispControl(MilCorrectedDisplay, M_TITLE, MIL_TEXT(\"Corrected image\")); MgraControl(M_DEFAULT, M_COLOR, M_COLOR_CYAN); MgraText(M_DEFAULT, MilCorrectedGraList, 0, 0, MIL_TEXT(\"Corrected image\")); MdispSelect(MilDisplay, M_NULL); MdispSelect(MilDisplay, MilDispImage); MdispSelect(MilCorrectedDisplay, MilCorrectedImage); // Fill the user data structure. SUserData UserData; UserData.MilDispImage = MilDispImage; UserData.MilSrcImage = MilSrcImage; UserData.MilCorrectedImage = MilCorrectedImage; UserData.MilFlatFieldContext = MilFlatFieldContext; UserData.MilDisplay = MilDisplay; UserData.MilCorrectedDisplay = MilCorrectedDisplay; UserData.pSrcHistDisplay = pSrcHistDisplay; UserData.pDstHistDisplay = pDstHistDisplay; // Show the histogram display. pSrcHistDisplay-&gt;Show(); pDstHistDisplay-&gt;Show(); // Start grabbing and wait for the user input to stop. MdigProcess(MilDigitizers[enTarget], MilGrabImages, NB_GRABIMAGES, M_START, M_DEFAULT, FlatFieldCorrectionFunc, &amp;UserData); MosPrintf(MIL_TEXT(\"The images of a continuous grab are now flat field corrected.\\n\") MIL_TEXT(\"%s\\n\") MIL_TEXT(\"Press any key to end.\\n\\n\"), IsInteractive ? MIL_TEXT(\"\") : CorrectionMessage); MosGetch(); // Stop grabbing. MdigProcess(MilDigitizers[enTarget], MilGrabImages, NB_GRABIMAGES, M_STOP, M_DEFAULT, FlatFieldCorrectionFunc, &amp;UserData); // Free the histogram displays. delete pDstHistDisplay; delete pSrcHistDisplay; // Free the stat cumulative context. MimFree(MilStatCumulativeContext); // Free the flat field context. MimFree(MilFlatFieldContext); // Free the images. MbufFree(MilCorrectedImage); MbufFree(MilSrcImage); MbufFree(MilDarkImage); MbufFree(MilFlatImage); MbufFree(MilOffsetImage); MbufFree(MilDispImage); for (MIL_INT i = 0; i &lt; NB_GRABIMAGES; i++) { MbufFree(MilGrabImages[i]); } if (Zoom &lt; 1.0) { MdispZoom(MilDisplay, 1.0, 1.0); MdispZoom(MilCorrectedDisplay, 1.0, 1.0); } // Free the digitizer. if(!IsInteractive) { for(MIL_INT StepIdx = 1; StepIdx &lt; NbSteps; StepIdx++) MdigFree(MilDigitizers[StepIdx]); } MdigFree(MilDigitizers[0]); } //***************************************************************************** // Mean image processing function callback. //***************************************************************************** MIL_INT MFTYPE CalImageAccumulationFunc(MIL_INT HookType, MIL_ID EventId, void* pHookData) { SStatCumulativeData* pStatCumulativeData = (SStatCumulativeData*)pHookData; // Get the modified buffer id. MIL_ID MilModifiedBuffer; MdigGetHookInfo(EventId, M_MODIFIED_BUFFER + M_BUFFER_ID, &amp;MilModifiedBuffer); MIL_INT SizeBand = MbufInquire(MilModifiedBuffer, M_SIZE_BAND, M_NULL); // Copy the image in the src image, in case the format of the image is not planar. MbufCopy(MilModifiedBuffer, pStatCumulativeData-&gt;MilSrcImage); // Add the grab buffer to the stat cumulative result. for (MIL_INT ResultIdx = 0; ResultIdx &lt; SizeBand; ResultIdx++) { MIL_ID MilBand = MbufChildColor(pStatCumulativeData-&gt;MilSrcImage, ResultIdx, M_NULL); MimStatCalculate(pStatCumulativeData-&gt;MilStatContext, MilBand, pStatCumulativeData-&gt;MilStatResult[ResultIdx], M_DEFAULT); MbufFree(MilBand); } // Copy the modified buffer in the displayed image. MbufCopy(MilModifiedBuffer, pStatCumulativeData-&gt;MilDispImage); return 0; } //***************************************************************************** // Flat field processing function callback. //***************************************************************************** MIL_INT MFTYPE FlatFieldCorrectionFunc(MIL_INT HookType, MIL_ID EventId, void* pHookData) { SUserData* pUserData = (SUserData*)pHookData; // Get the modified buffer id. MIL_ID MilModifiedBuffer; MdigGetHookInfo(EventId, M_MODIFIED_BUFFER + M_BUFFER_ID, &amp;MilModifiedBuffer); // Disable display updates. MdispControl(pUserData-&gt;MilDisplay, M_UPDATE, M_DISABLE); MdispControl(pUserData-&gt;MilCorrectedDisplay, M_UPDATE, M_DISABLE); // Copy the image in the src image, in case the format of the image is not planar. MbufCopy(MilModifiedBuffer, pUserData-&gt;MilSrcImage); // Perform the flat field correction. MimFlatField(pUserData-&gt;MilFlatFieldContext, pUserData-&gt;MilSrcImage, pUserData-&gt;MilCorrectedImage, M_DEFAULT); // Update the histograms. MIL_DOUBLE MaxVal = pUserData-&gt;pSrcHistDisplay-&gt;Update(pUserData-&gt;MilDispImage, M_NULL); pUserData-&gt;pDstHistDisplay-&gt;Update(pUserData-&gt;MilCorrectedImage, MaxVal); // Copy the modified buffer in the displayed image. MbufCopy(MilModifiedBuffer, pUserData-&gt;MilDispImage); // Enable display updates. MdispControl(pUserData-&gt;MilCorrectedDisplay, M_UPDATE, M_ENABLE); MdispControl(pUserData-&gt;MilDisplay, M_UPDATE, M_ENABLE); return 0; } //***************************************************************************** // Function that grabs and sets the grabbed image in the flat field context. //***************************************************************************** void GrabAndSetImageInContext(MIL_ID MilDigitizer, MIL_ID MilDisplay, MIL_ID MilDispImage, MIL_ID MilSrcImage, MIL_ID* pMilGrabImages, MIL_INT NbGrabImages, MIL_ID MilDestImage, MIL_ID MilFlatFieldContext, MIL_ID MilStatCumulativeContext, MIL_INT ControlFlag, MIL_CONST_TEXT_PTR ImageTypeTag, MIL_CONST_TEXT_PTR Message) { // Allocate a stat cumulative result and preprocess it. MIL_ID MilSystem = MbufInquire(pMilGrabImages[0], M_OWNER_SYSTEM, M_NULL); MIL_INT SizeBand = MbufInquire(pMilGrabImages[0], M_SIZE_BAND, M_NULL); SStatCumulativeData StatCumulativeData; StatCumulativeData.MilStatContext = MilStatCumulativeContext; for (MIL_INT ResultIdx = 0; ResultIdx &lt; SizeBand; ResultIdx++) { MIL_ID MilBand = MbufChildColor(MilSrcImage, ResultIdx, M_NULL); MimAllocResult(MilSystem, M_DEFAULT, M_STATISTICS_RESULT, &amp;StatCumulativeData.MilStatResult[ResultIdx]); MimStatCalculate(MilStatCumulativeContext, MilBand, StatCumulativeData.MilStatResult[ResultIdx], M_PREPROCESS); MbufFree(MilBand); } StatCumulativeData.MilDispImage = MilDispImage; StatCumulativeData.MilSrcImage = MilSrcImage; // Select the image on the display. MbufClear(MilDispImage, 0); MdispSelect(MilDisplay, MilDispImage); // Start grabbing the flat field image. MdigGrabContinuous(MilDigitizer, MilDispImage); MosPrintf(MIL_TEXT(\"%s\\nPress any key to grab and set the %s image.\\n\\n\"), Message, ImageTypeTag); MosGetch(); // Stop the grab. MdigHalt(MilDigitizer); // Grab a sequence of images. MdigProcess(MilDigitizer, pMilGrabImages, NbGrabImages, M_SEQUENCE + M_COUNT(NB_ACCUMULATE_FRAMES), M_SYNCHRONOUS, CalImageAccumulationFunc, &amp;StatCumulativeData); for (MIL_INT ResultIdx = 0; ResultIdx &lt; SizeBand; ResultIdx++) { MIL_ID MilBand = MbufChildColor(MilDestImage, ResultIdx, M_NULL); // Get the mean grabbed image band. MimDraw(M_DEFAULT, StatCumulativeData.MilStatResult[ResultIdx], M_NULL, MilBand, M_DRAW_STAT_RESULT, M_STAT_MEAN, M_NULL, M_DEFAULT); // Free the stat Cumulative result. MimFree(StatCumulativeData.MilStatResult[ResultIdx]); MbufFree(MilBand); } // Set the mean grabbed image in the flat field context. MimControl(MilFlatFieldContext, ControlFlag, MilDestImage); } //***************************************************************************** // Draws a thick arrow. //***************************************************************************** void DrawArrow(MIL_ID MilGraContext, MIL_ID MilDest, MIL_DOUBLE ArrowCenterX, MIL_DOUBLE ArrowCenterY, MIL_DOUBLE ArrowLength, MIL_DOUBLE ArrowTickness, MIL_DOUBLE ArrowAngle) { MIL_DOUBLE ArrowEndX[3] = {ArrowLength/2 + ArrowTickness, ArrowLength/2, ArrowLength/2}; MIL_DOUBLE ArrowEndY[3] = {0, -ArrowTickness, ArrowTickness}; MIL_DOUBLE RotatedArrowEndX[3]; MIL_DOUBLE RotatedArrowEndY[3]; MIL_DOUBLE Vx = cos(-ArrowAngle * PI / 180); MIL_DOUBLE Vy = sin(-ArrowAngle * PI / 180); for(MIL_INT PointIdx = 0; PointIdx &lt; 3; PointIdx++) { RotatedArrowEndX[PointIdx] = ArrowCenterX + Vx * ArrowEndX[PointIdx] - Vy * ArrowEndY[PointIdx]; RotatedArrowEndY[PointIdx] = ArrowCenterY + Vy * ArrowEndX[PointIdx] + Vx * ArrowEndY[PointIdx]; } MgraRectAngle(MilGraContext, MilDest, ArrowCenterX, ArrowCenterY, ArrowLength, ArrowTickness, ArrowAngle, M_CENTER_AND_DIMENSION + M_FILLED); MgraLines(MilGraContext, MilDest, 3, RotatedArrowEndX, RotatedArrowEndY, M_NULL, M_NULL, M_POLYGON + M_FILLED); } //***************************************************************************** // Ask the user for interactive method choice. //***************************************************************************** bool AskForInteractive() { // Ask the user if he wants to run the example in interactive mode. MosPrintf(MIL_TEXT(\"Do you want to run the example in interactive mode ? (Y or N)\\n\\n\")); do { switch(MosGetch()) { case 'y': case 'Y': return true; case 'n': case 'N': return false; } } while(1); return true; } //***************************************************************************** //Get the size of the screen. //***************************************************************************** void GetScreenSize(MIL_INT* pMaxSizeX, MIL_INT* pMaxSizeY) { MIL_ID MilExclusiveDisp = MdispAlloc(M_DEFAULT_HOST, M_DEFAULT, MIL_TEXT(\"M_DEFAULT\"), M_EXCLUSIVE, M_NULL); MdispInquire(MilExclusiveDisp, M_SIZE_X, pMaxSizeX); MdispInquire(MilExclusiveDisp, M_SIZE_Y, pMaxSizeY); MdispFree(MilExclusiveDisp); } ",
      "wordCount": 3927
    },
    {
      "id": "Examples_Processing_Preprocessing_FlatFieldCorrection_CPP_histogramdisplay_cpp",
      "version": "2024020714",
      "title": "histogramdisplay.cpp",
      "location": "Sample Code from MIL Examples",
      "text": " Top //***************************************************************************************/ // // File name: HistogramDisplay.cpp // Location: See Matrox Example Launcher in the MIL Control Center // // // Synopsis: Implementation of the CHistogramDisplay class that displays the histogram of // an image. // // Copyright (C) Matrox Electronic Systems Ltd., 1992-2024. // All Rights Reserved #include \"mil.h\" #include \"HistogramDisplay.h\" //***************************************************************************** // Constants. //***************************************************************************** static const MIL_INT MAX_LEGEND_DIGIT = 4; static const MIL_INT HIST_BORDER_X = (MAX_LEGEND_DIGIT + 6) * 8 + 1; static const MIL_INT HIST_BORDER_Y = 32; static const MIL_INT DEFAULT_HIST_SIZE_X = 256; static const MIL_INT DEFAULT_HIST_SIZE_Y = 196; //***************************************************************************** // Constructor. //***************************************************************************** CHistogramDisplay::CHistogramDisplay(MIL_ID MilSystem, MIL_CONST_TEXT_PTR Title /* = NULL */, MIL_INT TitleColor /* = M_COLOR_WHITE */) : m_MilSystem(MilSystem), m_MilHistResult(M_NULL), m_MilDisplay(M_NULL), m_MilBackImage(M_NULL), m_MilGraList(M_NULL), m_MilGraContext(M_NULL), m_NbEntries(0), m_pHistIndexes(NULL), m_TitleColor(TitleColor), m_Title(NULL), m_HistSizeX(DEFAULT_HIST_SIZE_X), m_HistSizeY(DEFAULT_HIST_SIZE_Y) { m_pHistValues[0] = NULL; m_pHistValues[1] = NULL; m_pHistValues[2] = NULL; // Allocate the display. MdispAlloc(MilSystem, M_DEFAULT, MIL_TEXT(\"M_DEFAULT\"), M_WINDOWED, &amp;m_MilDisplay); // Allocate the graphic list and associate it with the display. MgraAllocList(MilSystem, M_DEFAULT, &amp;m_MilGraList); MdispControl(m_MilDisplay, M_ASSOCIATED_GRAPHIC_LIST_ID, m_MilGraList); // Allocate a graphic context and set the text alignment. MgraAlloc(m_MilSystem, &amp;m_MilGraContext); // Save the display title. if(Title) { MdispControl(m_MilDisplay, M_TITLE, Title); MIL_INT TitleSize = MosStrlen(Title)+1; m_Title = new MIL_TEXT_CHAR[TitleSize]; MosStrcpy(m_Title, TitleSize, Title); } } //***************************************************************************** // Destructor. //***************************************************************************** CHistogramDisplay::~CHistogramDisplay() { // Free the Mil objects. FreeHistObjects(); // Free the graphic context. MgraFree(m_MilGraContext); // Free the graphic list. MgraFree(m_MilGraList); // Free the display. MdispFree(m_MilDisplay); // delete the title. if(m_Title) delete [] m_Title; } //***************************************************************************** // Function that allocates the Mil objects. //***************************************************************************** void CHistogramDisplay::AllocateHistObjects() { // Free the Mil Objects. FreeHistObjects(); // Allocate the histograms index array. The last 2 values are used to fill the polygon. m_pHistIndexes = new MIL_DOUBLE[m_NbEntries + 2]; // Set the index array. MIL_DOUBLE InvPixelSizeX = (MIL_DOUBLE)m_HistSizeX / m_NbEntries; for(MIL_UINT HistIdx = 0; HistIdx &lt; m_NbEntries; HistIdx++) m_pHistIndexes[HistIdx] = HistIdx * InvPixelSizeX; m_pHistIndexes[m_NbEntries] = (m_NbEntries-1) * InvPixelSizeX; m_pHistIndexes[m_NbEntries+1] = 0; // Allocate the histograms values arrays. for (MIL_INT BandIdx = 0; BandIdx &lt; 3; BandIdx++) { m_pHistValues[BandIdx] = new MIL_DOUBLE[m_NbEntries + 2]; m_pHistValues[BandIdx][m_NbEntries] = 0; m_pHistValues[BandIdx][m_NbEntries + 1] = 0; } // Allocate the histogram result. MimAllocResult(m_MilSystem, m_NbEntries, M_HIST_LIST, &amp;m_MilHistResult); // Allocate the background image. m_HistImageSizeX = m_HistSizeX + 2 * HIST_BORDER_X; m_HistImageSizeY = m_HistSizeY + (MIL_INT)(1.5 * HIST_BORDER_Y); MbufAlloc2d(m_MilSystem, m_HistImageSizeX, m_HistImageSizeY, 8+M_UNSIGNED, M_IMAGE+M_DISP, &amp;m_MilBackImage); MbufClear(m_MilBackImage, 0); } //***************************************************************************** // Function that frees the Mil objects. //***************************************************************************** void CHistogramDisplay::FreeHistObjects() { // Delete the histogram arrays. delete [] m_pHistIndexes; delete [] m_pHistValues[0]; delete [] m_pHistValues[1]; delete [] m_pHistValues[2]; // Free the histogram result. if(m_MilHistResult) { MimFree(m_MilHistResult); m_MilHistResult = M_NULL; } // Free the background image. if(m_MilBackImage) { MbufFree(m_MilBackImage); m_MilBackImage = M_NULL; } } //***************************************************************************** // Preprocessing function. //***************************************************************************** void CHistogramDisplay::Preprocess(MIL_ID MilTypicalImage) { // Get the image information. MIL_INT ImageSizeBit = MbufInquire(MilTypicalImage, M_SIZE_BIT, M_NULL); if(m_NbEntries == 0 || m_NbEntries != (1 &lt;&lt; ImageSizeBit)) { // Set the number of entries. m_NbEntries = 1 &lt;&lt; ImageSizeBit; // Reallocate the histogram objects. AllocateHistObjects(); // Draw the title of the display. DrawDisplayTitle(); } } //***************************************************************************** // Show and hide functions. //***************************************************************************** void CHistogramDisplay::Show() { // Select the image on the display MdispSelect(m_MilDisplay, m_MilBackImage); } void CHistogramDisplay::Hide() { // Deselect the image on the display MdispSelect(m_MilDisplay, M_NULL); } //***************************************************************************** // Function that sets the window initial position. //***************************************************************************** void CHistogramDisplay::SetWindowInitialPosition(MIL_INT WindowPosX, MIL_INT WindowPosY) { MdispControl(m_MilDisplay, M_WINDOW_INITIAL_POSITION_X, WindowPosX); MdispControl(m_MilDisplay, M_WINDOW_INITIAL_POSITION_Y, WindowPosY); } //***************************************************************************** // Function that draws the display title. //***************************************************************************** void CHistogramDisplay::DrawDisplayTitle() { if(m_Title) { MgraControl(m_MilGraContext, M_INPUT_UNITS, M_DISPLAY); MgraControl(m_MilGraContext, M_TEXT_ALIGN_HORIZONTAL, M_LEFT); MgraControl(m_MilGraContext, M_TEXT_ALIGN_VERTICAL, M_TOP); MgraControl(m_MilGraContext, M_COLOR, (MIL_DOUBLE)m_TitleColor); MgraText(m_MilGraContext, m_MilGraList, 0, 0, m_Title); MgraControl(m_MilGraContext, M_INPUT_UNITS, M_PIXEL); } } //***************************************************************************** // Function that updates the histogram with the image. //***************************************************************************** MIL_DOUBLE CHistogramDisplay::Update(MIL_ID MilImage, MIL_DOUBLE MaxVal) { // Disable the display updates MdispControl(m_MilDisplay, M_UPDATE, M_DISABLE); // Preprocess the display if necessary. Preprocess(MilImage); // Clear the graphic list. MgraClear(M_DEFAULT, m_MilGraList); // Get the number of bands of the image. MIL_INT SizeBand = MbufInquire(MilImage, M_SIZE_BAND, M_NULL); MIL_DOUBLE MaxValToUse = MaxVal; for (MIL_INT BandIdx = 0; BandIdx &lt; SizeBand; BandIdx++) { // Get the current band. MIL_ID MilBand = MbufChildColor(MilImage, BandIdx, M_NULL); // Calculate the histogram. MimHistogram(MilBand, m_MilHistResult); // Get the histogram values. MimGetResult(m_MilHistResult, M_VALUE + M_TYPE_MIL_DOUBLE, m_pHistValues[BandIdx]); // Get the maximum histogram value if required. if (MaxVal == M_NULL) { for (MIL_UINT ValIdx = 0; ValIdx &lt; m_NbEntries; ValIdx++) { MaxValToUse = (MaxValToUse &lt; m_pHistValues[BandIdx][ValIdx]) ? m_pHistValues[BandIdx][ValIdx] : MaxValToUse; } } // Free the band. MbufFree(MilBand); } for (MIL_INT BandIdx = 0; BandIdx &lt; SizeBand; BandIdx++) { // Calculate the histogram value to draw. MIL_DOUBLE InvPixelSizeY = (MIL_DOUBLE)m_HistSizeY / MaxValToUse; for (MIL_UINT ValIdx = 0; ValIdx &lt; m_NbEntries; ValIdx++) m_pHistValues[BandIdx][ValIdx] = -m_pHistValues[BandIdx][ValIdx] * InvPixelSizeY; // Draw the legend. MgraControl(m_MilGraContext, M_COLOR, M_COLOR_MAGENTA); MgraControl(m_MilGraContext, M_TEXT_ALIGN_HORIZONTAL, M_RIGHT); MgraControl(m_MilGraContext, M_TEXT_ALIGN_VERTICAL, M_CENTER); MIL_TEXT_CHAR Legend[MAX_LEGEND_DIGIT + 10]; MosSprintf(Legend, MAX_LEGEND_DIGIT + 10, MIL_TEXT(\"%.*g\"), MAX_LEGEND_DIGIT, (MIL_DOUBLE)MaxValToUse); MgraText(m_MilGraContext, m_MilGraList, HIST_BORDER_X - 1, HIST_BORDER_Y, Legend); // Draw the polygon. const MIL_DOUBLE PolygonColors[3] = { M_COLOR_RED, M_COLOR_GREEN, M_COLOR_BLUE }; MgraControl(m_MilGraContext, M_DRAW_OFFSET_X, -HIST_BORDER_X); MgraControl(m_MilGraContext, M_DRAW_OFFSET_Y, -(HIST_BORDER_Y + m_HistSizeY)); MgraControl(m_MilGraContext, M_COLOR, PolygonColors[BandIdx]); MIL_INT ControlFlag = M_POLYLINE; MIL_INT NbEntriesToUse = m_NbEntries; if (SizeBand == 1) { ControlFlag = M_POLYGON + M_FILLED; NbEntriesToUse = m_NbEntries + 2; } MgraLines(m_MilGraContext, m_MilGraList, NbEntriesToUse, m_pHistIndexes, m_pHistValues[BandIdx], M_NULL, M_NULL, ControlFlag); MgraControl(m_MilGraContext, M_DRAW_OFFSET_X, 0); MgraControl(m_MilGraContext, M_DRAW_OFFSET_Y, 0); // Draw the axis. MgraControl(m_MilGraContext, M_COLOR, M_COLOR_YELLOW); MgraLine(m_MilGraContext, m_MilGraList, HIST_BORDER_X, HIST_BORDER_Y, HIST_BORDER_X, HIST_BORDER_Y + m_HistSizeY); MgraLine(m_MilGraContext, m_MilGraList, HIST_BORDER_X, HIST_BORDER_Y + m_HistSizeY, HIST_BORDER_X + m_HistSizeX, HIST_BORDER_Y + m_HistSizeY); } // Draw the title. DrawDisplayTitle(); // Enable the display updates MdispControl(m_MilDisplay, M_UPDATE, M_ENABLE); return MaxValToUse; } ",
      "wordCount": 886
    }
  ]
}]
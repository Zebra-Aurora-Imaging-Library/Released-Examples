[{
  "id": "Example_PlaceHolder_ID",
  "version": "2024020714",
  "title": "Example_PlaceHolder_Title",
  "wordCount": 0,
  "subEntries": [
    {
      "id": "Examples_General_MdispMFC_CPP_childfrm_cpp",
      "version": "2024020714",
      "title": "childfrm.cpp",
      "location": "Sample Code from MIL Examples",
      "text": " Top /* * File name: ChildFrm.cpp * Location: See Matrox Example Launcher in the MIL Control Center * */ // ChildFrm.cpp : implementation of the CChildFrame class // // Copyright (C) Matrox Electronic Systems Ltd., 1992-2024. // All Rights Reserved #include \"stdafx.h\" #include \"MdispMFC.h\" #include \"ChildFrm.h\" #ifdef _DEBUG #define new DEBUG_NEW #undef THIS_FILE static char THIS_FILE[] = __FILE__; #endif static UINT indicators[] = { ID_INDICATOR_FRAMERATE, ID_INDICATOR_SCALE, ID_INDICATOR_MOUSE, }; ///////////////////////////////////////////////////////////////////////////// // CChildFrame IMPLEMENT_DYNCREATE(CChildFrame, CMDIChildWnd) BEGIN_MESSAGE_MAP(CChildFrame, CMDIChildWnd) //{{AFX_MSG_MAP(CChildFrame) ON_WM_CREATE() //}}AFX_MSG_MAP END_MESSAGE_MAP() ///////////////////////////////////////////////////////////////////////////// // CChildFrame construction/destruction CChildFrame::CChildFrame() { // TODO: add member initialization code here } CChildFrame::~CChildFrame() { } BOOL CChildFrame::PreCreateWindow(CREATESTRUCT&amp; cs) { // TODO: Modify the Window class or styles here by modifying // the CREATESTRUCT cs return CMDIChildWnd::PreCreateWindow(cs); } ///////////////////////////////////////////////////////////////////////////// // CChildFrame diagnostics #ifdef _DEBUG void CChildFrame::AssertValid() const { CMDIChildWnd::AssertValid(); } void CChildFrame::Dump(CDumpContext&amp; dc) const { CMDIChildWnd::Dump(dc); } #endif //_DEBUG ///////////////////////////////////////////////////////////////////////////// // CChildFrame message handlers int CChildFrame::OnCreate(LPCREATESTRUCT lpCreateStruct) { if (CMDIChildWnd::OnCreate(lpCreateStruct) == -1) return -1; if (!m_wndStatusBar.Create(this) || !m_wndStatusBar.SetIndicators(indicators, sizeof(indicators)/sizeof(UINT))) { TRACE0(\"Failed to create status bar\\n\"); return -1; // fail to create } /////// // MIL document status bar // //Section for frame rate m_wndStatusBar.SetPaneInfo(0, ID_INDICATOR_FRAMERATE, SBPS_NORMAL, 140); //Section for scale m_wndStatusBar.SetPaneInfo(1, ID_INDICATOR_SCALE, SBPS_NORMAL, 100); //Section for Mouse m_wndStatusBar.SetPaneInfo(2, ID_INDICATOR_MOUSE, SBPS_NORMAL, 180); return 0; } //////////////////////////////////////////////////////////////////////// // MIL: Used to update status bar with frame rate //////////////////////////////////////////////////////////////////////// void CChildFrame::UpdateStatusBarWithFrameRate(MIL_DOUBLE CurrentRate) { CString strCurrentRate; if(CurrentRate == M_INVALID) { strCurrentRate.Format(MIL_TEXT(\"Display Updates: Not Available\")); } else { strCurrentRate.Format(MIL_TEXT(\"Display Updates: %.2f fps\"),CurrentRate); } m_wndStatusBar.SetPaneText(0,strCurrentRate); } //////////////////////////////////////////////////////////////////////// // MIL: Used to update status bar with zoom factor //////////////////////////////////////////////////////////////////////// void CChildFrame::UpdateStatusBarWithScale(MIL_DOUBLE CurrentScaleX, MIL_DOUBLE CurrentScaleY) { CString strCurrentScale; strCurrentScale.Format(MIL_TEXT(\"%.4f, %.4f\"),CurrentScaleX, CurrentScaleY); m_wndStatusBar.SetPaneText(1,strCurrentScale); } void CChildFrame::UpdateStatusBarWithMouse(MIL_INT DispPositionX, MIL_INT DispPositionY, MIL_DOUBLE BufPositionX, MIL_DOUBLE BufPositionY) { CString strMouse; strMouse.Format(MIL_TEXT(\"M:(%d,%d)-&gt;(%.2f,%.2f)\"),(MIL_INT)DispPositionX, (MIL_INT)DispPositionY, BufPositionX, BufPositionY); m_wndStatusBar.SetPaneText(2,strMouse); } //////////////////////////////////////////////////////////////////////// // MIL: Used to retrieve size of the status bar //////////////////////////////////////////////////////////////////////// CSize CChildFrame::GetStatusBarSize() { RECT statusBarRECT; m_wndStatusBar.GetStatusBarCtrl().GetClientRect(&amp;statusBarRECT); //construct a csize object to receive size of the status bar CSize statusBarSize(statusBarRECT.right - statusBarRECT.left, statusBarRECT.bottom - statusBarRECT.top); return statusBarSize; } ",
      "wordCount": 324
    },
    {
      "id": "Examples_General_MdispMFC_CPP_mainfrm_cpp",
      "version": "2024020714",
      "title": "mainfrm.cpp",
      "location": "Sample Code from MIL Examples",
      "text": " Top /* * File name: MainFrm.cpp * Location: See Matrox Example Launcher in the MIL Control Center * */ // MainFrm.cpp : implementation of the CMainFrame class // // Copyright (C) Matrox Electronic Systems Ltd., 1992-2024. // All Rights Reserved #include \"stdafx.h\" #include \"MdispMFC.h\" #include &lt;algorithm&gt; #include \"MainFrm.h\" #ifdef _DEBUG #define new DEBUG_NEW #undef THIS_FILE static char THIS_FILE[] = __FILE__; #endif ///////////////////////////////////////////////////////////////////////////// // CMainFrame IMPLEMENT_DYNAMIC(CMainFrame, CMDIFrameWnd) BEGIN_MESSAGE_MAP(CMainFrame, CMDIFrameWnd) //{{AFX_MSG_MAP(CMainFrame) ON_WM_CREATE() //}}AFX_MSG_MAP END_MESSAGE_MAP() static UINT indicators[] = { ID_SEPARATOR, // status line indicator ID_INDICATOR_CAPS, ID_INDICATOR_NUM, ID_INDICATOR_SCRL, }; ///////////////////////////////////////////////////////////////////////////// // CMainFrame construction/destruction CMainFrame::CMainFrame() { } CMainFrame::~CMainFrame() { } int CMainFrame::OnCreate(LPCREATESTRUCT lpCreateStruct) { if(CMDIFrameWnd::OnCreate(lpCreateStruct) == -1) return -1; DWORD dwToolbarStyle = WS_CHILD | WS_VISIBLE | CBRS_TOP | CCS_ADJUSTABLE | CBRS_TOOLTIPS | CBRS_FLYBY | CBRS_SIZE_DYNAMIC; if(!m_wndToolBar.Create(this, dwToolbarStyle) || !m_wndToolBar.LoadToolBar(IDR_MAINFRAME)) { TRACE0(\"Failed to create toolbar\\n\"); return -1; // fail to create } if(!m_wndStatusBar.Create(this) || !m_wndStatusBar.SetIndicators(indicators, sizeof(indicators)/sizeof(UINT))) { TRACE0(\"Failed to create status bar\\n\"); return -1; // fail to create } //Set toolbar titles m_wndToolBar.SetWindowText(MIL_TEXT(\"Standard\")); //Add view Mode combo box into display toolbar /////////////////////////////////////////////////////// CRect rectComboViewMode; //Associate combo boxes identifiers to an empty space in toolbar m_wndToolBar.SetButtonInfo(13, IDC_CB_VIEW_MODE, TBBS_SEPARATOR, 140); //Retrieve position of the empty items m_wndToolBar.GetItemRect(13,&amp;rectComboViewMode); //Offset the rect to center in bar rectComboViewMode.OffsetRect(5,7); //Allow drop-down rectComboViewMode.bottom = rectComboViewMode.top + 900; m_viewModeCombo.Create(WS_TABSTOP|CBS_AUTOHSCROLL|WS_VISIBLE|WS_VSCROLL|CBS_DROPDOWNLIST, rectComboViewMode,&amp;m_wndToolBar,IDC_CB_VIEW_MODE); //Fill combo box with available view modes m_viewModeCombo.AddString(MIL_TEXT(\"M_DEFAULT\")); m_viewModeCombo.AddString(MIL_TEXT(\"M_TRANSPARENT\")); m_viewModeCombo.AddString(MIL_TEXT(\"M_AUTO_SCALE\")); m_viewModeCombo.AddString(MIL_TEXT(\"M_MULTI_BYTES\")); m_viewModeCombo.AddString(MIL_TEXT(\"M_BIT_SHIFT:2\")); m_viewModeCombo.AddString(MIL_TEXT(\"M_BIT_SHIFT:4\")); m_viewModeCombo.AddString(MIL_TEXT(\"M_BIT_SHIFT:8\")); // Set the combo boxes font properly CFont fontComboBox; fontComboBox.Attach(GetStockObject(DEFAULT_GUI_FONT)); m_viewModeCombo.SetFont(&amp;fontComboBox); //Initial selection of the view mode m_viewModeCombo.SelectString(0,MIL_TEXT(\"M_TRANSPARENT\")); // TODO: Delete these lines if you don't want the toolbars to // be dockable m_wndToolBar.EnableDocking(CBRS_ALIGN_TOP); EnableDocking(CBRS_ALIGN_ANY); DockControlBar(&amp;m_wndToolBar,AFX_IDW_DOCKBAR_TOP); // To make sure mainframe is at least the size of the toolbar, tweak the size. RECT rectWindow; GetWindowRect(&amp;rectWindow); int SizeX = max(1280, rectWindow.right - rectWindow.left); int SizeY = max(960, rectWindow.bottom - rectWindow.top); SetWindowPos(0,0,SizeX,SizeY,rectWindow.bottom - rectWindow.top,SWP_NOMOVE|SWP_NOZORDER); return 0; } BOOL CMainFrame::PreCreateWindow(CREATESTRUCT&amp; cs) { // TODO: Modify the Window class or styles here by modifying // the CREATESTRUCT cs return CMDIFrameWnd::PreCreateWindow(cs); } ///////////////////////////////////////////////////////////////////////////// // CMainFrame diagnostics #ifdef _DEBUG void CMainFrame::AssertValid() const { CMDIFrameWnd::AssertValid(); } void CMainFrame::Dump(CDumpContext&amp; dc) const { CMDIFrameWnd::Dump(dc); } #endif //_DEBUG ///////////////////////////////////////////////////////////////////////////// // CMainFrame message handlers ",
      "wordCount": 346
    },
    {
      "id": "Examples_General_MdispMFC_CPP_mdispmfc_cpp",
      "version": "2024020714",
      "title": "mdispmfc.cpp",
      "location": "Sample Code from MIL Examples",
      "text": " Top /* * File name: MdispMFC.cpp * Location: See Matrox Example Launcher in the MIL Control Center * */ // MdispMFC.cpp : Defines the class behaviors for the application. // // Copyright (C) Matrox Electronic Systems Ltd., 1992-2024. // All Rights Reserved #include \"stdafx.h\" #include \"MdispMFC.h\" #include \"MainFrm.h\" #include \"ChildFrm.h\" #include \"MdispMFCDoc.h\" #include \"MdispMFCView.h\" #ifdef _DEBUG #define new DEBUG_NEW #undef THIS_FILE static char THIS_FILE[] = __FILE__; #endif ///////////////////////////////////////////////////////////////////////////// // CMdispMFCApp BEGIN_MESSAGE_MAP(CMdispMFCApp, CWinApp) //{{AFX_MSG_MAP(CMdispMFCApp) ON_COMMAND(ID_APP_ABOUT, OnAppAbout) // NOTE - the ClassWizard will add and remove mapping macros here. // DO NOT EDIT what you see in these blocks of generated code! //}}AFX_MSG_MAP // Standard file-based document commands ON_COMMAND(ID_FILE_NEW, CWinApp::OnFileNew) ON_COMMAND(ID_FILE_OPEN, CWinApp::OnFileOpen) // Standard print setup command ON_COMMAND(ID_FILE_PRINT_SETUP, CWinApp::OnFilePrintSetup) END_MESSAGE_MAP() ///////////////////////////////////////////////////////////////////////////// // CMdispMFCApp construction CMdispMFCApp::CMdispMFCApp() { // TODO: add construction code here m_isCurrentlyHookedOnErrors = false; // Place all significant initialization in InitInstance } ///////////////////////////////////////////////////////////////////////////// // The one and only CMdispMFCApp object CMdispMFCApp theApp; ///////////////////////////////////////////////////////////////////////////// // CMdispMFCApp initialization BOOL CMdispMFCApp::InitInstance() { LoadStdProfileSettings(); // Load standard INI file options (including MRU) ///////////////////////////////////////////////////////////////////////// // MIL: Write your one-time initialization code here ///////////////////////////////////////////////////////////////////////// // Allocate an application and a system [CALL TO MIL] MappAllocDefault(M_DEFAULT,&amp;m_MilApplication, &amp;m_MilSystem, M_NULL, M_NULL, M_NULL); // Hook MIL error on function DisplayError() [CALL TO MIL] MappHookFunction(M_DEFAULT, M_ERROR_CURRENT,DisplayErrorExt,this); m_isCurrentlyHookedOnErrors = true; // Disable the typical MIL error message display [CALL TO MIL] MappControl(M_DEFAULT, M_ERROR,M_PRINT_DISABLE); // Inquire the number of digitizers available on the system [CALL TO MIL] MsysInquire(m_MilSystem,M_DIGITIZER_NUM,&amp;m_numberOfDigitizer); // Digitizer is available if (m_numberOfDigitizer) { // Allocate a digitizer [CALL TO MIL] MdigAlloc(m_MilSystem,M_DEFAULT,MIL_TEXT(\"M_DEFAULT\"),M_DEFAULT,&amp;m_MilDigitizer); // Inquire digitizer information [CALL TO MIL] MdigInquire(m_MilDigitizer,M_SIZE_X,&amp;m_digitizerSizeX); MdigInquire(m_MilDigitizer,M_SIZE_Y,&amp;m_digitizerSizeY); MdigInquire(m_MilDigitizer,M_SIZE_BAND,&amp;m_digitizerNbBands); } // Initialize the state of the grab m_isGrabStarted = FALSE; ///////////////////////////////////////////////////////////////////////// // MIL: Write your one-time initialization code here ///////////////////////////////////////////////////////////////////////// // Register the application's document templates. Document templates // serve as the connection between documents, frame windows and views. CMultiDocTemplate* pDocTemplate; pDocTemplate = new CMultiDocTemplate( IDR_MDISPTYPE, RUNTIME_CLASS(CMdispMFCDoc), RUNTIME_CLASS(CChildFrame), // custom MDI child frame RUNTIME_CLASS(CMdispMFCView)); AddDocTemplate(pDocTemplate); // Create main MDI Frame window CMainFrame* pMainFrame = new CMainFrame; if (!pMainFrame-&gt;LoadFrame(IDR_MAINFRAME)) return FALSE; m_pMainWnd = pMainFrame; // Parse command line for standard shell commands, DDE, file open CCommandLineInfo cmdInfo; ParseCommandLine(cmdInfo); // Dispatch commands specified on the command line if (!ProcessShellCommand(cmdInfo)) return FALSE; // Show and update the initialized main window. pMainFrame-&gt;ShowWindow(m_nCmdShow); pMainFrame-&gt;UpdateWindow(); return TRUE; } ///////////////////////////////////////////////////////////////////////////// // CAboutDlg dialog used for App About class CAboutDlg : public CDialog { public: CAboutDlg(); // Dialog Data //{{AFX_DATA(CAboutDlg) enum { IDD = IDD_ABOUTBOX }; //}}AFX_DATA // ClassWizard generated virtual function overrides //{{AFX_VIRTUAL(CAboutDlg) protected: virtual void DoDataExchange(CDataExchange* pDX); // DDX/DDV support //}}AFX_VIRTUAL // Implementation protected: HICON m_hIcon; //{{AFX_MSG(CAboutDlg) virtual BOOL OnInitDialog(); //}}AFX_MSG DECLARE_MESSAGE_MAP() }; CAboutDlg::CAboutDlg() : CDialog(CAboutDlg::IDD) { //{{AFX_DATA_INIT(CAboutDlg) //}}AFX_DATA_INIT m_hIcon = AfxGetApp()-&gt;LoadIcon(IDI_IMAGING); } void CAboutDlg::DoDataExchange(CDataExchange* pDX) { CDialog::DoDataExchange(pDX); //{{AFX_DATA_MAP(CAboutDlg) //}}AFX_DATA_MAP } BEGIN_MESSAGE_MAP(CAboutDlg, CDialog) //{{AFX_MSG_MAP(CAboutDlg) //}}AFX_MSG_MAP END_MESSAGE_MAP() BOOL CAboutDlg::OnInitDialog() { CDialog::OnInitDialog(); SetIcon(m_hIcon, TRUE); // Set big icon SetIcon(m_hIcon, FALSE); // Set small icon return TRUE; // return TRUE unless you set the focus to a control // EXCEPTION: OCX Property Pages should return FALSE } // App command to run the dialog void CMdispMFCApp::OnAppAbout() { CAboutDlg aboutDlg; aboutDlg.DoModal(); } ///////////////////////////////////////////////////////////////////////////// // CMdispMFCApp commands int CMdispMFCApp::ExitInstance() { ///////////////////////////////////////////////////////////////////////// // MIL: Write your code that will be executed on application exit ///////////////////////////////////////////////////////////////////////// //Free the digitizer [CALL TO MIL] if(m_MilDigitizer) MdigFree (m_MilDigitizer); //Free the system [CALL TO MIL] if(m_MilSystem) MsysFree (m_MilSystem); if(m_MilApplication) { // Enable the typical MIL error message display[CALL TO MIL] MappControl(M_DEFAULT, M_ERROR,M_PRINT_ENABLE); // Unhook MIL error on function DisplayError() [CALL TO MIL] if(m_isCurrentlyHookedOnErrors) { MappHookFunction(M_DEFAULT, M_ERROR_CURRENT+M_UNHOOK,DisplayErrorExt,this); m_isCurrentlyHookedOnErrors = false; } // Free the application [CALL TO MIL] MappFree(m_MilApplication); } ///////////////////////////////////////////////////////////////////////// // MIL: Write your code that will be executed on application exit ///////////////////////////////////////////////////////////////////////// return CWinApp::ExitInstance(); } ///////////////////////////////////////////////////////////////////////// // MIL: Hook-handler function: DisplayError() ///////////////////////////////////////////////////////////////////////// MIL_INT MFTYPE DisplayErrorExt(MIL_INT HookType, MIL_ID EventId, void* UserDataPtr) { //If user clicks NO on error message, unhook to errors. if(((CMdispMFCApp*) AfxGetApp())-&gt;DisplayError(HookType, EventId, (CWinApp*) UserDataPtr) == M_NO) { MappHookFunction(M_DEFAULT, M_ERROR_CURRENT+M_UNHOOK,DisplayErrorExt,UserDataPtr); ((CMdispMFCApp*) AfxGetApp())-&gt;HookedOnErrors(false); } return M_NULL; } long MFTYPE CMdispMFCApp::DisplayError(MIL_INT HookType, MIL_ID EventId, void* UserDataPtr) { MIL_STRING ErrorMessageFunction; MIL_STRING ErrorMessage; MIL_STRING ErrorSubMessage1; MIL_STRING ErrorSubMessage2; MIL_STRING ErrorSubMessage3; MIL_INT NbSubCode; CString CErrorMessage; //Retrieve error message [CALL TO MIL] MappGetHookInfo(M_DEFAULT, EventId,M_MESSAGE+M_CURRENT_OPCODE,ErrorMessageFunction); MappGetHookInfo(M_DEFAULT, EventId,M_MESSAGE+M_CURRENT,ErrorMessage); MappGetHookInfo(M_DEFAULT, EventId,M_CURRENT_SUB_NB,&amp;NbSubCode); if (NbSubCode &gt; 2) MappGetHookInfo(M_DEFAULT, EventId,M_MESSAGE+M_CURRENT_SUB_3,ErrorSubMessage3); if (NbSubCode &gt; 1) MappGetHookInfo(M_DEFAULT, EventId,M_MESSAGE+M_CURRENT_SUB_2,ErrorSubMessage2); if (NbSubCode &gt; 0) MappGetHookInfo(M_DEFAULT, EventId,M_MESSAGE+M_CURRENT_SUB_1,ErrorSubMessage1); CErrorMessage = ErrorMessageFunction.c_str(); CErrorMessage = CErrorMessage + \"\\n\"; CErrorMessage = CErrorMessage + ErrorMessage.c_str(); if(NbSubCode &gt; 0) { CErrorMessage = CErrorMessage + \"\\n\"; CErrorMessage = CErrorMessage + ErrorSubMessage1.c_str(); } if(NbSubCode &gt; 1) { CErrorMessage = CErrorMessage + \"\\n\"; CErrorMessage = CErrorMessage + ErrorSubMessage2.c_str(); } if(NbSubCode &gt; 2) { CErrorMessage = CErrorMessage + \"\\n\"; CErrorMessage = CErrorMessage + ErrorSubMessage3.c_str(); } CErrorMessage = CErrorMessage + \"\\n\\n\"; CErrorMessage = CErrorMessage + \"Do you want to continue error print?\"; return (AfxMessageBox(CErrorMessage,MB_YESNO,0) == IDYES)?M_YES:M_NO; } ///////////////////////////////////////////////////////////////////////// // MIL: Hook-handler function: DisplayError() ///////////////////////////////////////////////////////////////////////// ",
      "wordCount": 782
    },
    {
      "id": "Examples_General_MdispMFC_CPP_mdispmfcdoc_cpp",
      "version": "2024020714",
      "title": "mdispmfcdoc.cpp",
      "location": "Sample Code from MIL Examples",
      "text": " Top /* * File name: MdispMFCDoc.cpp * Location: See Matrox Example Launcher in the MIL Control Center * */ // MdispMFCDoc.cpp : implementation of the CMdispMFCDoc class // // Copyright (C) Matrox Electronic Systems Ltd., 1992-2024. // All Rights Reserved #include \"stdafx.h\" #include \"MdispMFC.h\" #include \"MdispMFCDoc.h\" #include \"MdispMFCView.h\" #ifdef _DEBUG #define new DEBUG_NEW #undef THIS_FILE static char THIS_FILE[] = __FILE__; #endif #define IMAGE_FILE M_IMAGE_PATH MIL_TEXT(\"BaboonRGB.mim\") ///////////////////////////////////////////////////////////////////////////// // CMdispMFCDoc IMPLEMENT_DYNCREATE(CMdispMFCDoc, CDocument) BEGIN_MESSAGE_MAP(CMdispMFCDoc, CDocument) //{{AFX_MSG_MAP(CMdispMFCDoc) // NOTE - the ClassWizard will add and remove mapping macros here. // DO NOT EDIT what you see in these blocks of generated code! //}}AFX_MSG_MAP END_MESSAGE_MAP() ///////////////////////////////////////////////////////////////////////////// // CMdispMFCDoc construction/destruction CMdispMFCDoc::CMdispMFCDoc() { // TODO: add one-time construction code here } CMdispMFCDoc::~CMdispMFCDoc() { } BOOL CMdispMFCDoc::OnNewDocument() { // TODO: add re-initialization code here // (SDI documents will reuse this document) ///////////////////////////////////////////////////////////////////////// // MIL: Write code that will be executed when a new document is created ///////////////////////////////////////////////////////////////////////// // Set buffer settings if(((CMdispMFCApp*)AfxGetApp())-&gt;m_numberOfDigitizer) { m_bufferAttributes=M_IMAGE+M_DISP+M_GRAB+M_PROC; m_imageSizeX = ((CMdispMFCApp*)AfxGetApp())-&gt;m_digitizerSizeX; m_imageSizeY = ((CMdispMFCApp*)AfxGetApp())-&gt;m_digitizerSizeY; m_NbBands = ((CMdispMFCApp*)AfxGetApp())-&gt;m_digitizerNbBands; // Allocate a buffer [CALL TO MIL] MbufAllocColor(((CMdispMFCApp*)AfxGetApp())-&gt;m_MilSystem, m_NbBands, m_imageSizeX, m_imageSizeY, 8+M_UNSIGNED, m_bufferAttributes, &amp;m_MilImage); // Clear the buffer [CALL TO MIL] MbufClear(m_MilImage,M_COLOR_BLACK); } else { //Import image in buffer [CALL TO MIL] MbufImport(IMAGE_FILE,M_DEFAULT,M_RESTORE,((CMdispMFCApp*)AfxGetApp())-&gt;m_MilSystem,&amp;m_MilImage); // Set SizeX and SizeY variable to the size of the buffer [CALL TO MIL] if (m_MilImage) { m_imageSizeX = MbufInquire(m_MilImage, M_SIZE_X, M_NULL); m_imageSizeY = MbufInquire(m_MilImage, M_SIZE_Y, M_NULL); m_NbBands = MbufInquire(m_MilImage, M_SIZE_BAND, M_NULL); } } // If not able to allocate a buffer, do not create a new document if(!m_MilImage) return FALSE; ///////////////////////////////////////////////////////////////////////// // MIL: Write code that will be executed when a new document is created ///////////////////////////////////////////////////////////////////////// return CDocument::OnNewDocument(); } ///////////////////////////////////////////////////////////////////////////// // CMdispMFCDoc serialization void CMdispMFCDoc::Serialize(CArchive&amp; ar) { if (ar.IsStoring()) { // TODO: add storing code here } else { // TODO: add loading code here } } ///////////////////////////////////////////////////////////////////////////// // CMdispMFCDoc diagnostics #ifdef _DEBUG void CMdispMFCDoc::AssertValid() const { CDocument::AssertValid(); } void CMdispMFCDoc::Dump(CDumpContext&amp; dc) const { CDocument::Dump(dc); } #endif //_DEBUG ///////////////////////////////////////////////////////////////////////////// // CMdispMFCDoc commands void CMdispMFCDoc::OnCloseDocument() { // TODO: Add your specialized code here and/or call the base class ///////////////////////////////////////////////////////////////////////// // MIL: Write code that will be executed when a document is closed ///////////////////////////////////////////////////////////////////////// // Halt the grab, deselected the display, free the display and the image buffer // only if MbufAlloc was successful if (m_MilImage) { CMdispMFCView *CurView; POSITION CurPos; // Make sure all views displays are deselected and grab is halt CurPos = GetFirstViewPosition(); while(CurView = (CMdispMFCView *)GetNextView(CurPos)) { CurView-&gt;KillTimer(TIMER_FRAMERATE); CurView-&gt;RemoveFromDisplay(); } // Free image buffer [CALL TO MIL] MbufFree(m_MilImage); } ///////////////////////////////////////////////////////////////////////// // MIL: Write code that will be executed when a document is closed ///////////////////////////////////////////////////////////////////////// CDocument::OnCloseDocument(); } BOOL CMdispMFCDoc::OnOpenDocument(LPCTSTR lpszPathName) { if (!CDocument::OnOpenDocument(lpszPathName)) return FALSE; // TODO: Add your specialized creation code here ///////////////////////////////////////////////////////////////////////// // MIL: Write code that will be executed when a document is opened ///////////////////////////////////////////////////////////////////////// //Import image in buffer [CALL TO MIL] MbufImport((MIL_TEXT_CHAR *)lpszPathName,M_DEFAULT,M_RESTORE,((CMdispMFCApp*)AfxGetApp())-&gt;m_MilSystem,&amp;m_MilImage); // Set SizeX and SizeY variable to the size of the buffer [CALL TO MIL] if (m_MilImage) { m_imageSizeX = MbufInquire(m_MilImage,M_SIZE_X,M_NULL); m_imageSizeY = MbufInquire(m_MilImage,M_SIZE_Y,M_NULL); return TRUE; } else return FALSE; ///////////////////////////////////////////////////////////////////////// // MIL: Write code that will be executed when a document is opened ///////////////////////////////////////////////////////////////////////// } BOOL CMdispMFCDoc::OnSaveDocument(LPCTSTR lpszPathName) { // TODO: Add your specialized code here and/or call the base class ///////////////////////////////////////////////////////////////////////// // MIL: Write code that will be executed when a document is saved ///////////////////////////////////////////////////////////////////////// BOOL SaveStatus; CString TempPath; long FileFormat ; // Get extension for file format determination TempPath = lpszPathName; TempPath.MakeUpper(); //Set the file format to M_MIL_TIFF when the file path extension is \".MIM\" if (TempPath.Find(MIL_TEXT(\".MIM\")) != -1) FileFormat = M_MIL_TIFF; //Set the file format to M_TIFF when the file path extension is \".TIF\" if (TempPath.Find(MIL_TEXT(\".TIF\")) != -1) FileFormat = M_TIFF; //Set the file format to M_BMP when the file path extension is \".BMP\" if (TempPath.Find(MIL_TEXT(\".BMP\")) != -1) FileFormat = M_BMP; //Set the file format to M_JPEG_LOSSY when the file path extension is \".JPG\" if (TempPath.Find(MIL_TEXT(\".JPG\")) != -1) FileFormat = M_JPEG_LOSSY; //Set the file format to M_JPEG2000_LOSSLESS when the file path extension is \".JP2\" if (TempPath.Find(MIL_TEXT(\".JP2\")) != -1) FileFormat = M_JPEG2000_LOSSLESS; //Set the file format to M_RAW when the file path extension is \".RAW\" if (TempPath.Find(MIL_TEXT(\".RAW\")) != -1) FileFormat = M_RAW; //Set the file format to M_PNG when the file path extension is \".PNG\" if (TempPath.Find(MIL_TEXT(\".PNG\")) != -1) FileFormat = M_PNG; // To get the first view in the list of views: POSITION pos = GetFirstViewPosition(); CView* pFirstView = GetNextView( pos ); // Halt the grab if the current view has it [CALL TO MIL] if((((CMdispMFCApp*)AfxGetApp())-&gt;m_pGrabView == pFirstView) &amp;&amp; (((CMdispMFCApp*)AfxGetApp())-&gt;m_isGrabStarted == TRUE)) MdigHalt(((CMdispMFCApp*)AfxGetApp())-&gt;m_MilDigitizer); // Save the current buffer [CALL TO MIL] MbufExport((MIL_TEXT_CHAR *)lpszPathName, FileFormat,m_MilImage); // Verify if save operation was successful [CALL TO MIL] SaveStatus = (MappGetError(M_DEFAULT, M_CURRENT,M_NULL) == M_NULL_ERROR); // Document has been saved if (!((((CMdispMFCApp*)AfxGetApp())-&gt;m_pGrabView == pFirstView) &amp;&amp; (((CMdispMFCApp*)AfxGetApp())-&gt;m_isGrabStarted == TRUE))) SetModifiedFlag(FALSE); // Restart the grab if the current view had it [CALL TO MIL] if((((CMdispMFCApp*)AfxGetApp())-&gt;m_pGrabView == pFirstView) &amp;&amp; (((CMdispMFCApp*)AfxGetApp())-&gt;m_isGrabStarted == TRUE)) MdigGrabContinuous(((CMdispMFCApp*)AfxGetApp())-&gt;m_MilDigitizer, m_MilImage); return SaveStatus; } ",
      "wordCount": 813
    },
    {
      "id": "Examples_General_MdispMFC_CPP_mdispmfcview_cpp",
      "version": "2024020714",
      "title": "mdispmfcview.cpp",
      "location": "Sample Code from MIL Examples",
      "text": " Top /* * File name: MdispMFCView.cpp * Location: See Matrox Example Launcher in the MIL Control Center * */ // MdispMFCView.cpp : implementation of the CMdispMFCView class // // Copyright (C) Matrox Electronic Systems Ltd., 1992-2024. // All Rights Reserved #include \"stdafx.h\" #include \"MdispMFC.h\" #include \"MdispMFCDoc.h\" #include \"MdispMFCView.h\" #include \"MainFrm.h\" #include \"ChildFrm.h\" #include &lt;algorithm&gt; #ifdef _DEBUG #define new DEBUG_NEW #undef THIS_FILE static char THIS_FILE[] = __FILE__; #endif // Static data member initialization const MIL_INT CMdispMFCView::s_CompressionType[] = {M_NULL, M_JPEG_LOSSY, M_JPEG_LOSSLESS}; const MIL_INT CMdispMFCView::s_AsynchronousMaxUpdateRate[] = {M_DISABLE, 1, 5, 10, 15, 30, M_INFINITE}; const MIL_INT CMdispMFCView::s_QFactor[] = {60, 70, 75, 80, 82, 85, 87, 90, 92, 95, 99}; const MIL_INT CMdispMFCView::s_Opacity[] = {M_DEFAULT, M_DISABLE, 0, 20, 40, 60, 80, 100}; const UINT CMdispMFCView::s_FirstCompressionTypeControlInRange = ID_COMPRESSION_NONE; const UINT CMdispMFCView::s_FirstAsynchronousMaxUpdateRateControlInRange = ID_ASYNCHRONOUSMODE_DISABLED; const UINT CMdispMFCView::s_FirstQFactorControlInRange = ID_QFACTOR_60; const UINT CMdispMFCView::s_FirstOverlayOpacityControlInRange = ID_OVERLAY_OPACITY_DEFAULT; const UINT CMdispMFCView::s_FirstGraOpacityControlInRange = ID_GRA_OPACITY_DEFAULT; MIL_INT MFTYPE MouseFct(MIL_INT HookType, MIL_ID EventID, void* UserDataPtr) { CMdispMFCView* pCurrentView = (CMdispMFCView*)UserDataPtr; if(pCurrentView) { MOUSEPOSITION MousePosition; MdispGetHookInfo(EventID, M_MOUSE_POSITION_X, &amp;MousePosition.m_DisplayPositionX); MdispGetHookInfo(EventID, M_MOUSE_POSITION_Y, &amp;MousePosition.m_DisplayPositionY); MdispGetHookInfo(EventID, M_MOUSE_POSITION_BUFFER_X, &amp;MousePosition.m_BufferPositionX); MdispGetHookInfo(EventID, M_MOUSE_POSITION_BUFFER_Y, &amp;MousePosition.m_BufferPositionY); pCurrentView-&gt;SetMousePosition(MousePosition); pCurrentView-&gt;SendMessage(WM_COMMAND, ID_MOUSE_UPDATE_TEXT); } return 0; } MIL_INT MFTYPE GraphicListModifiedHookFct(MIL_INT HookType, MIL_ID EventID, void* UserDataPtr) { CMdispMFCView* pCurrentView = (CMdispMFCView*)UserDataPtr; if(pCurrentView) { MIL_INT State = M_NULL; MgraGetHookInfo(EventID, M_INTERACTIVE_GRAPHIC_STATE, &amp;State); if((State != M_STATE_WAITING_FOR_CREATION) &amp;&amp; (State != M_STATE_BEING_CREATED)) { pCurrentView-&gt;ResetPrimitiveCreation(); } } return 0; } ///////////////////////////////////////////////////////////////////////////// // CMdispMFCView IMPLEMENT_DYNCREATE(CMdispMFCView, CView) BEGIN_MESSAGE_MAP(CMdispMFCView, CView) //{{AFX_MSG_MAP(CMdispMFCView) ON_COMMAND(ID_GRAB_START, OnGrabStart) ON_UPDATE_COMMAND_UI(ID_GRAB_START, OnUpdateGrabStart) ON_UPDATE_COMMAND_UI(ID_FILE_SAVE, OnUpdateSave) ON_UPDATE_COMMAND_UI(ID_FILE_SAVE_AS, OnUpdateSaveAs) ON_COMMAND(ID_GRAB_STOP, OnGrabStop) ON_COMMAND(ID_MOUSE_UPDATE_TEXT, OnMouseUpdateText) ON_UPDATE_COMMAND_UI(ID_GRAB_STOP, OnUpdateGrabStop) ON_WM_DESTROY() ON_COMMAND(ID_OVERLAY_SHOW, OnOverlay) ON_UPDATE_COMMAND_UI(ID_OVERLAY_SHOW, OnUpdateOverlay) ON_WM_SIZE() ON_WM_TIMER() ON_COMMAND(ID_ZOOMIN, OnZoomin) ON_UPDATE_COMMAND_UI(ID_ZOOMIN, OnUpdateZoomin) ON_COMMAND(ID_ZOOMOUT, OnZoomout) ON_UPDATE_COMMAND_UI(ID_ZOOMOUT, OnUpdateZoomout) ON_COMMAND(ID_NOZOOM, OnNoZoom) ON_UPDATE_COMMAND_UI(ID_NOZOOM, OnUpdateNoZoom) ON_COMMAND(ID_SCALEDISPLAY, OnScaleDisplay) ON_UPDATE_COMMAND_UI(ID_SCALEDISPLAY, OnUpdateScaleDisplay) ON_COMMAND(ID_GDIANNOTATIONS, OnGDIAnnotations) ON_UPDATE_COMMAND_UI(ID_GDIANNOTATIONS, OnUpdateGDIAnnotations) ON_CONTROL(CBN_SELCHANGE, IDC_CB_VIEW_MODE, OnViewModeChange) // Standard printing commands ON_COMMAND(ID_FILE_PRINT, CView::OnFilePrint) ON_COMMAND(ID_FILE_PRINT_DIRECT, CView::OnFilePrint) ON_COMMAND(ID_FILE_PRINT_PREVIEW, CView::OnFilePrintPreview) ON_WM_SIZING() ON_COMMAND_RANGE(ID_COMPRESSION_NONE, ID_COMPRESSION_LOSSLESS, &amp;CMdispMFCView::OnCompression) ON_UPDATE_COMMAND_UI_RANGE(ID_COMPRESSION_NONE, ID_COMPRESSION_LOSSLESS, &amp;CMdispMFCView::OnUpdateCompression) ON_COMMAND_RANGE(ID_ASYNCHRONOUSMODE_DISABLED, ID_ASYNCHRONOUSMODE_MAXIMUMRATE, &amp;CMdispMFCView::OnAsynchronousMode) ON_UPDATE_COMMAND_UI_RANGE(ID_ASYNCHRONOUSMODE_DISABLED, ID_ASYNCHRONOUSMODE_MAXIMUMRATE, &amp;CMdispMFCView::OnUpdateAsynchronousMode) ON_COMMAND_RANGE(ID_QFACTOR_DEFAULT, ID_QFACTOR_99, &amp;CMdispMFCView::OnQFactor) ON_UPDATE_COMMAND_UI_RANGE(ID_QFACTOR_DEFAULT, ID_QFACTOR_99, &amp;CMdispMFCView::OnUpdateQFactor) ON_COMMAND(ID_RESTRICTCURSOR, &amp;CMdispMFCView::OnRestrictCursor) ON_UPDATE_COMMAND_UI(ID_RESTRICTCURSOR, &amp;CMdispMFCView::OnUpdateRestrictCursor) ON_COMMAND(ID_DISPLAY_GRAPHICSANNOTATIONS, &amp;CMdispMFCView::OnGraphicsAnnotations) ON_UPDATE_COMMAND_UI(ID_DISPLAY_GRAPHICSANNOTATIONS, &amp;CMdispMFCView::OnUpdateGraphicsAnnotations) ON_COMMAND(ID_GRA_RECTANGLE, &amp;CMdispMFCView::OnGraRectangle) ON_UPDATE_COMMAND_UI(ID_GRA_RECTANGLE, &amp;CMdispMFCView::OnUpdateGraRectangle) ON_COMMAND(ID_GRA_CIRCLE, &amp;CMdispMFCView::OnGraCircle) ON_UPDATE_COMMAND_UI(ID_GRA_CIRCLE, &amp;CMdispMFCView::OnUpdateGraCircle) ON_COMMAND(ID_GRA_POLYGON, &amp;CMdispMFCView::OnGraPolygon) ON_UPDATE_COMMAND_UI(ID_GRA_POLYGON, &amp;CMdispMFCView::OnUpdateGraPolygon) ON_COMMAND(ID_GRA_COLOR, &amp;CMdispMFCView::OnGraChooseColor) ON_UPDATE_COMMAND_UI(ID_GRA_COLOR, &amp;CMdispMFCView::OnUpdateGraChooseColor) ON_COMMAND(ID_GRA_FILL, &amp;CMdispMFCView::OnGraFill) ON_UPDATE_COMMAND_UI(ID_GRA_FILL, &amp;CMdispMFCView::OnUpdateGraFill) ON_COMMAND(ID_GRA_DRAW_DIRECTION, &amp;CMdispMFCView::OnGraDrawDirCycle) ON_UPDATE_COMMAND_UI(ID_GRA_DRAW_DIRECTION, &amp;CMdispMFCView::OnUpdateGraDrawDirCycle) ON_COMMAND(ID_GRA_ORIENTED_RECT, &amp;CMdispMFCView::OnGraDrawOrientedRect) ON_UPDATE_COMMAND_UI(ID_GRA_ORIENTED_RECT, &amp;CMdispMFCView::OnUpdateGraDrawOrientedRect) ON_COMMAND(ID_GRA_ARC_THREE_POINTS, &amp;CMdispMFCView::OnGraDrawThreePointsArc) ON_UPDATE_COMMAND_UI(ID_GRA_ARC_THREE_POINTS, &amp;CMdispMFCView::OnUpdateGraDrawThreePointsArc) ON_COMMAND_RANGE(ID_GRA_OPACITY_DEFAULT, ID_GRA_OPACITY_100, &amp;CMdispMFCView::OnGraOpacity) ON_UPDATE_COMMAND_UI_RANGE(ID_GRA_OPACITY_DEFAULT, ID_GRA_OPACITY_100, &amp;CMdispMFCView::OnUpdateGraOpacity) ON_COMMAND_RANGE(ID_OVERLAY_OPACITY_DEFAULT, ID_OVERLAY_OPACITY_100, &amp;CMdispMFCView::OnOverlayOpacity) ON_UPDATE_COMMAND_UI_RANGE(ID_OVERLAY_OPACITY_DEFAULT, ID_OVERLAY_OPACITY_100, &amp;CMdispMFCView::OnUpdateOverlayOpacity) ON_COMMAND(ID_GRA_LINE_THICKNESS, &amp;CMdispMFCView::OnGraLineThicknessToggle) ON_UPDATE_COMMAND_UI(ID_GRA_LINE_THICKNESS, &amp;CMdispMFCView::OnUpdateGraLineThicknessToggle) //}}AFX_MSG_MAP END_MESSAGE_MAP() ///////////////////////////////////////////////////////////////////////////// // CMdispMFCView construction/destruction CMdispMFCView::CMdispMFCView() { // TODO: add construction code here m_MilOverlayImage = M_NULL; // Overlay image buffer identifier. m_MilDisplay = M_NULL; // Display identifier. m_MilGraphContext = M_NULL; m_MilGraphList = M_NULL; m_isWindowed = true; m_isExclusive = false; m_isOverlayEnabled = false; // Overlay state m_isOverlayInitialized = false; m_isScaleDisplayEnabled = false; m_isGDIAnnotationsEnabled = false; m_currentViewMode = M_TRANSPARENT; m_currentShiftValue = M_NULL; m_isInAsynchronousMode = false; m_currentCompressionType = M_NULL; m_currentAsynchronousFrameRate = M_INFINITE; m_currentQFactor = M_DEFAULT; m_currentOverlayOpacity = M_DEFAULT; m_currentGraOpacity = M_DEFAULT; m_currentRestrictCursor = M_ENABLE; m_bGraphicsAnnotations = false; m_PrimitiveInCreation = M_NULL; } CMdispMFCView::~CMdispMFCView() { } BOOL CMdispMFCView::PreCreateWindow(CREATESTRUCT&amp; cs) { // TODO: Modify the Window class or styles here by modifying // the CREATESTRUCT cs return CView::PreCreateWindow(cs); } ///////////////////////////////////////////////////////////////////////////// // CMdispMFCView diagnostics #ifdef _DEBUG void CMdispMFCView::AssertValid() const { CView::AssertValid(); } void CMdispMFCView::Dump(CDumpContext&amp; dc) const { CView::Dump(dc); } CMdispMFCDoc* CMdispMFCView::GetDocument() // non-debug version is inline { ASSERT(m_pDocument-&gt;IsKindOf(RUNTIME_CLASS(CMdispMFCDoc))); return (CMdispMFCDoc*)m_pDocument; } #endif //_DEBUG ///////////////////////////////////////////////////////////////////////////// // CMdispMFCView message handlers void CMdispMFCView::OnGrabStart() { // TODO: Add your command handler code here ///////////////////////////////////////////////////////////////////////// // MIL: Write code that will be executed on a grab start ///////////////////////////////////////////////////////////////////////// // If there is a grab in a view, halt the grab before starting a new one if(((CMdispMFCApp*)AfxGetApp())-&gt;m_isGrabStarted) ((CMdispMFCApp*)AfxGetApp())-&gt;m_pGrabView-&gt;SendMessage(WM_COMMAND, ID_GRAB_STOP, 0); // Start a continuous grab in this view MdigGrabContinuous(((CMdispMFCApp*)AfxGetApp())-&gt;m_MilDigitizer, ((CMdispMFCDoc*)GetDocument())-&gt;m_MilImage); // Update the variable GrabIsStarted ((CMdispMFCApp*)AfxGetApp())-&gt;m_isGrabStarted = TRUE; // GrabInViewPtr is now a pointer to m_pGrabView view ((CMdispMFCApp*)AfxGetApp())-&gt;m_pGrabView = this; // Document has been modified ((CMdispMFCDoc*)GetDocument())-&gt;SetModifiedFlag(TRUE); ///////////////////////////////////////////////////////////////////////// // MIL: Write code that will be executed on a grab start ///////////////////////////////////////////////////////////////////////// } void CMdispMFCView::OnUpdateGrabStart(CCmdUI* pCmdUI) { // TODO: Add your command update UI handler code here CView *GrabOwnerViewPtr = ((CMdispMFCApp*)AfxGetApp())-&gt;m_pGrabView; // Check if there is a valid frame grabber in the system if( 0 == ((CMdispMFCApp*)AfxGetApp())-&gt;m_numberOfDigitizer ) { // NO FRAME GRABBER: Disable grab feature pCmdUI-&gt;Enable(0); } else { // FRAME GRABBER PRESENT: Enable grab feature pCmdUI-&gt;Enable(!(GrabOwnerViewPtr &amp;&amp; (GetDocument() == GrabOwnerViewPtr-&gt;GetDocument()) &amp;&amp; (((CMdispMFCApp*)AfxGetApp())-&gt;m_isGrabStarted == TRUE) &amp;&amp; ((CMdispMFCApp*)AfxGetApp())-&gt;m_numberOfDigitizer)); } } void CMdispMFCView::OnUpdateSave(CCmdUI* pCmdUI) { pCmdUI-&gt;Enable(((CMdispMFCApp*)AfxGetApp())-&gt;m_isGrabStarted == FALSE); } void CMdispMFCView::OnUpdateSaveAs(CCmdUI* pCmdUI) { pCmdUI-&gt;Enable(((CMdispMFCApp*)AfxGetApp())-&gt;m_isGrabStarted == FALSE); } void CMdispMFCView::OnMouseUpdateText() { ((CChildFrame*)GetParentFrame())-&gt;UpdateStatusBarWithMouse(m_LastMousePosition.m_DisplayPositionX, m_LastMousePosition.m_DisplayPositionY, m_LastMousePosition.m_BufferPositionX, m_LastMousePosition.m_BufferPositionY); // Reset mouse position m_LastMousePosition.Set(M_INVALID, M_INVALID, M_INVALID, M_INVALID); } void CMdispMFCView::OnGrabStop() { // TODO: Add your command handler code here ///////////////////////////////////////////////////////////////////////// // MIL: Write code that will be executed on a grab stop ///////////////////////////////////////////////////////////////////////// // Halt the grab MdigHalt(((CMdispMFCApp*)AfxGetApp())-&gt;m_MilDigitizer); ((CMdispMFCApp*)AfxGetApp())-&gt;m_isGrabStarted = FALSE; ///////////////////////////////////////////////////////////////////////// // MIL: Write code that will be executed on a grab stop ///////////////////////////////////////////////////////////////////////// } void CMdispMFCView::OnUpdateGrabStop(CCmdUI* pCmdUI) { CView *GrabOwnerViewPtr = ((CMdispMFCApp*)AfxGetApp())-&gt;m_pGrabView; pCmdUI-&gt;Enable(GrabOwnerViewPtr &amp;&amp; (GetDocument() == GrabOwnerViewPtr-&gt;GetDocument()) &amp;&amp; (((CMdispMFCApp*)AfxGetApp())-&gt;m_isGrabStarted == TRUE) &amp;&amp; ((CMdispMFCApp*)AfxGetApp())-&gt;m_numberOfDigitizer); } void CMdispMFCView::OnOverlay() { ///////////////////////////////////////////////////////////////////////// // MIL: Write code that will be executed when 'add overlay' is selected ///////////////////////////////////////////////////////////////////////// // Enable overlay if (!m_isOverlayEnabled) { MdispControl(m_MilDisplay, M_OVERLAY, M_ENABLE); //If overlay buffer as not been initialized yet, do it now. if(!m_isOverlayInitialized) InitializeOverlay(); m_isOverlayEnabled = true; } // Disable overlay else { // Disable the overlay display. [CALL TO MIL] MdispControl(m_MilDisplay, M_OVERLAY, M_DISABLE); m_isOverlayInitialized = false; m_isOverlayEnabled = false; } ///////////////////////////////////////////////////////////////////////// // MIL: Write code that will be executed when 'add overlay' is selected ///////////////////////////////////////////////////////////////////////// } void CMdispMFCView::OnUpdateOverlay(CCmdUI* pCmdUI) { pCmdUI-&gt;SetCheck(m_isOverlayEnabled); } void CMdispMFCView::OnInitialUpdate() { //Init timer used for frame rate SetTimer(TIMER_FRAMERATE,500,M_NULL); //Retrieve size of the status bar CSize statusBarSize = ((CChildFrame*)GetParentFrame())-&gt;GetStatusBarSize(); // TODO: Add your specialized code here and/or call the base class ///////////////////////////////////////////////////////////////////////// // MIL: Code that will be executed when a view is first attached to the document ///////////////////////////////////////////////////////////////////////// if (((CMdispMFCDoc*)GetDocument())-&gt;m_MilImage) { // Allocate a display using default display type [CALL TO MIL] MdispAlloc(((CMdispMFCApp*)AfxGetApp())-&gt;m_MilSystem, M_DEFAULT, MIL_TEXT(\"M_DEFAULT\"), M_DEFAULT, &amp;m_MilDisplay); if(m_MilDisplay) { MIL_INT DisplayType = MdispInquire(m_MilDisplay, M_DISPLAY_TYPE, M_NULL); // Check display type [CALL TO MIL] if((DisplayType&amp;(M_WINDOWED|M_EXCLUSIVE)) != M_WINDOWED) m_isWindowed = false; if(DisplayType&amp;(M_EXCLUSIVE)) m_isExclusive = true; // Initially set view mode to default ChangeViewMode(M_DEFAULT); if(IsNetworkedSystem()) { // Check compression type [CALL TO MIL] MdispInquire(m_MilDisplay, M_COMPRESSION_TYPE, &amp;m_currentCompressionType); // Check asynchronous mode [CALL TO MIL] m_isInAsynchronousMode = (MdispInquire(m_MilDisplay, M_ASYNC_UPDATE, M_NULL) == M_ENABLE); // Check asynchronous frame rate [CALL TO MIL] MdispInquire(m_MilDisplay, M_UPDATE_RATE_MAX, &amp;m_currentAsynchronousFrameRate); // Check Q factor [CALL TO MIL] MdispInquire(m_MilDisplay, M_Q_FACTOR, &amp;m_currentQFactor); } if(m_isExclusive) { MdispInquire(m_MilDisplay, M_RESTRICT_CURSOR, &amp;m_currentRestrictCursor); } // Select the buffer from it's display object and given window [CALL TO MIL] MdispSelectWindow(m_MilDisplay, ((CMdispMFCDoc*)GetDocument())-&gt;m_MilImage, m_isWindowed?m_hWnd:0); // Allow panning and zooming with the mouse [CALL TO MIL] MdispControl(m_MilDisplay, M_MOUSE_USE, M_ENABLE); // Allow mouse cursor handling [CALL TO MIL] MdispControl(m_MilDisplay, M_MOUSE_CURSOR_CHANGE, M_ENABLE); } CView::OnInitialUpdate(); //Resize display window if not currently maximized if(!GetParent()-&gt;IsZoomed()&amp;&amp; !m_isExclusive) ResizeDisplayWindow(); // In windowed mode, resize window to image. if(m_isWindowed) { //May need to resize frame GetParentFrame()-&gt;RecalcLayout(); } // Hook a function to mouse-movement event, to update cursor position in status bar. MdispHookFunction(m_MilDisplay, M_MOUSE_MOVE, MouseFct, (void*)this); } ///////////////////////////////////////////////////////////////////////// // MIL: Code that will be executed when a view is first attached to the document ///////////////////////////////////////////////////////////////////////// } void CMdispMFCView::OnDestroy() { //Frame rate timer not needed anymore KillTimer(TIMER_FRAMERATE); ///////////////////////////////////////////////////////////////////////// // MIL: Write code that will be executed when the window is destroyed ///////////////////////////////////////////////////////////////////////// RemoveFromDisplay(); ///////////////////////////////////////////////////////////////////////// // MIL: Write code that will be executed when the window is destroyed ///////////////////////////////////////////////////////////////////////// CView::OnDestroy(); } // Function used to halt the grab, deselect the buffer and free the display void CMdispMFCView::RemoveFromDisplay() { //Halt grab if in process in THIS view if ((((CMdispMFCApp*)AfxGetApp())-&gt;m_pGrabView == this) &amp;&amp; ((CMdispMFCApp*)AfxGetApp())-&gt;m_isGrabStarted) { //Signal to the digitizer to halt the grab [CALL TO MIL] MdigHalt(((CMdispMFCApp*)AfxGetApp())-&gt;m_MilDigitizer); ((CMdispMFCApp*)AfxGetApp())-&gt;m_isGrabStarted = FALSE; } if (((CMdispMFCDoc*)GetDocument())-&gt;m_MilImage &amp;&amp; m_MilDisplay) { //Deselect the buffer from its display object and given window [CALL TO MIL] MdispSelect(m_MilDisplay, M_NULL); // Hook from mouse-movement event. MdispHookFunction(m_MilDisplay, M_MOUSE_MOVE+M_UNHOOK, MouseFct, (void*)this); //Free the display [CALL TO MIL] if(m_MilGraphList) { MgraFree(m_MilGraphList); m_MilGraphList = M_NULL; } if(m_MilGraphContext) { MgraFree(m_MilGraphContext); m_MilGraphContext = M_NULL; } MdispFree(m_MilDisplay); m_MilDisplay = M_NULL; } } void CMdispMFCView::OnDraw(CDC* pDC) { ///////////////////////////////////////////////////////////////////////// // MIL: Write code that will be executed when 'OnDraw' window message is received ///////////////////////////////////////////////////////////////////////// RECT clientRECT; if(!m_MilDisplay) { //Retrieve current client rect of the window GetClientRect(&amp;clientRECT); pDC-&gt;SetBkMode(TRANSPARENT); pDC-&gt;SetTextColor(RGB(255,0,0)); pDC-&gt;DrawText(\"Display Allocation Failed!\", &amp;clientRECT,DT_LEFT); } // If no windowed display involved, no window annotations can be written in display. else if(m_isWindowed) { if(m_isGDIAnnotationsEnabled ) { //Retrieve current client rectangle of the window GetClientRect(&amp;clientRECT); //Signal to the given device context to draw the string pDC-&gt;SetBkMode(TRANSPARENT); pDC-&gt;SetTextColor(RGB(255,0,255)); clientRECT.top += 50; // move down to avoid collision with Interactive Graphic Annotations pDC-&gt;DrawText(\"Window Annotations\", &amp;clientRECT,DT_CENTER); } } // In non-windowed mode, write message in window else { //Retrieve current client rectangle of the window GetClientRect(&amp;clientRECT); //Signal to the given device context to draw the string pDC-&gt;SetBkMode(TRANSPARENT); pDC-&gt;SetTextColor(RGB(0,0,0)); pDC-&gt;DrawText(\"Image displayed on external screen\", &amp;clientRECT,DT_LEFT); } } void CMdispMFCView::OnSize(UINT nType, int cx, int cy) { CView::OnSize(nType, cx, cy); ///////////////////////////////////////////////////////////////////////// // MIL: Write code that will be executed when 'OnSize' window message is received ///////////////////////////////////////////////////////////////////////// //Update status bar with current zoom factor if(m_MilDisplay) { MIL_DOUBLE ZoomX = 1, ZoomY = 1; MdispInquire(m_MilDisplay, M_ZOOM_FACTOR_X, &amp;ZoomX); MdispInquire(m_MilDisplay, M_ZOOM_FACTOR_Y, &amp;ZoomY); ((CChildFrame*)GetParentFrame())-&gt;UpdateStatusBarWithScale(ZoomX, ZoomY); } } void CMdispMFCView::OnTimer(UINT_PTR nIDEvent) { ///////////////////////////////////////////////////////////////////////// // MIL: update status bar with current display update rate ///////////////////////////////////////////////////////////////////////// if (m_MilDisplay &amp;&amp; (nIDEvent == TIMER_FRAMERATE)) { MIL_DOUBLE CurrentFrameRate = M_NULL; MdispInquire(m_MilDisplay, M_UPDATE_RATE, &amp;CurrentFrameRate); ((CChildFrame*)GetParentFrame())-&gt;UpdateStatusBarWithFrameRate(CurrentFrameRate); //Update status bar with current zoom factor MIL_DOUBLE ZoomX =1, ZoomY = 1; MdispInquire(m_MilDisplay, M_ZOOM_FACTOR_X, &amp;ZoomX); MdispInquire(m_MilDisplay, M_ZOOM_FACTOR_Y, &amp;ZoomY); ((CChildFrame*)GetParentFrame())-&gt;UpdateStatusBarWithScale(ZoomX, ZoomY); } CView::OnTimer(nIDEvent); } void CMdispMFCView::OnZoomin() { ///////////////////////////////////////////////////////////////////////// // MIL: Write code that will be executed when 'Zoom In' button or menu is clicked ///////////////////////////////////////////////////////////////////////// if(m_MilDisplay) { //Calculate new zoom factors MIL_DOUBLE ZoomX = 1, ZoomY = 1; MdispInquire(m_MilDisplay, M_ZOOM_FACTOR_X, &amp;ZoomX); MdispInquire(m_MilDisplay, M_ZOOM_FACTOR_Y, &amp;ZoomY); if((ZoomX &lt; 64) &amp;&amp; (ZoomY &lt; 64)) { ZoomX *= 2; ZoomY *= 2; } //Perform zooming with MIL (using MdispZoom) Zoom(ZoomX, ZoomY); } } void CMdispMFCView::OnUpdateZoomin(CCmdUI* pCmdUI) { if(m_isScaleDisplayEnabled) pCmdUI-&gt;Enable(0); else pCmdUI-&gt;Enable(1); } void CMdispMFCView::OnZoomout() { ///////////////////////////////////////////////////////////////////////// // MIL: Write code that will be executed when 'Zoom Out' button or menu is clicked ///////////////////////////////////////////////////////////////////////// if(m_MilDisplay) { //Calculate new zoom factors MIL_DOUBLE ZoomX = 1, ZoomY = 1; MdispInquire(m_MilDisplay, M_ZOOM_FACTOR_X, &amp;ZoomX); MdispInquire(m_MilDisplay, M_ZOOM_FACTOR_Y, &amp;ZoomY); if((ZoomX &gt; 0.015625) &amp;&amp; (ZoomY &gt; 0.015625)) { ZoomX /= 2; ZoomY /= 2; } //Perform zooming with MIL (using MdispZoom) Zoom(ZoomX, ZoomY); } } void CMdispMFCView::OnUpdateZoomout(CCmdUI* pCmdUI) { if(m_isScaleDisplayEnabled) pCmdUI-&gt;Enable(0); else pCmdUI-&gt;Enable(1); } void CMdispMFCView::OnNoZoom() { ///////////////////////////////////////////////////////////////////////// // MIL: Write code that will be executed when 'No Zoom' button or menu is clicked ///////////////////////////////////////////////////////////////////////// if(m_MilDisplay) { //Perform zooming with MIL Zoom(1, 1); MdispPan(m_MilDisplay, M_NULL, M_NULL); } } void CMdispMFCView::OnUpdateNoZoom(CCmdUI* pCmdUI) { if(m_isScaleDisplayEnabled) pCmdUI-&gt;Enable(0); else pCmdUI-&gt;Enable(1); } void CMdispMFCView::OnScaleDisplay() { ///////////////////////////////////////////////////////////////////////// // MIL: Write code that will be executed when 'Scale Display' button or menu is clicked ///////////////////////////////////////////////////////////////////////// if(m_MilDisplay) { //If Scale Display is not currently enabled, enable it if(!m_isScaleDisplayEnabled) { //Using MIL, enable Scale Display Mode [CALL TO MIL] MdispControl(m_MilDisplay, M_SCALE_DISPLAY, M_ENABLE); m_isScaleDisplayEnabled = true; } //If Fill Display is currently enabled, disable it else { //Using MIL, disable Scale Display Mode [CALL TO MIL] MdispControl(m_MilDisplay, M_SCALE_DISPLAY, M_DISABLE); m_isScaleDisplayEnabled = false; } //Queue an update if(m_isWindowed) InvalidateRect(M_NULL); } } void CMdispMFCView::OnUpdateScaleDisplay(CCmdUI* pCmdUI) { // TODO: Add your command update UI handler code here pCmdUI-&gt;SetCheck(m_isScaleDisplayEnabled); pCmdUI-&gt;Enable(1); } void CMdispMFCView::ResizeDisplayWindow() { ///////////////////////////////////////////////////////////////////////// // MIL: Write code that will be executed when window needs to be resized ///////////////////////////////////////////////////////////////////////// //Retrieve parent size CRect parentRECT; GetParent()-&gt;GetParent()-&gt;GetClientRect(&amp;parentRECT); //Retrieve size of the status bar CSize statusBarSize = ((CChildFrame*)GetParentFrame())-&gt;GetStatusBarSize(); // Get active multimedia window rectangle, adding the height of the status bar CRect MMRect; MIL_DOUBLE ZoomX, ZoomY = 0; MdispInquire(m_MilDisplay, M_ZOOM_FACTOR_X, &amp;ZoomX); MdispInquire(m_MilDisplay, M_ZOOM_FACTOR_Y, &amp;ZoomY); int dispX = (int)(GetDocument()-&gt;m_imageSizeX * ZoomX); int dispY = (int)(GetDocument()-&gt;m_imageSizeY * ZoomY); if(!m_isWindowed) { dispX = (int)MdispInquire(m_MilDisplay, M_SIZE_X, M_NULL); dispY = (int)MdispInquire(m_MilDisplay, M_SIZE_Y, M_NULL); } // Dimension must be adjusted long PosOffset = 4; MMRect.SetRect(0, 0, dispX, dispY); // Dimension must be adjusted // Resize frame to the dimensions of the multimedia window GetParent()-&gt;CalcWindowRect(&amp;MMRect, CWnd::adjustBorder); MMRect.OffsetRect(-MMRect.left,-MMRect.top); if(MMRect.Width() &gt; parentRECT.Width()) MMRect.right = parentRECT.right; if(MMRect.Height() &gt; parentRECT.Height()) MMRect.bottom = parentRECT.bottom; else MMRect.bottom = MMRect.bottom + statusBarSize.cy; GetParent()-&gt;SetWindowPos( NULL, 0, 0, MMRect.right + PosOffset, MMRect.bottom + PosOffset, SWP_NOACTIVATE|SWP_NOZORDER); GetParent()-&gt;InvalidateRect(NULL,FALSE); } void CMdispMFCView::OnGDIAnnotations() { ///////////////////////////////////////////////////////////////////////// // MIL: Write code that will be executed when 'GDI Annotations' button or menu is clicked ///////////////////////////////////////////////////////////////////////// if(!m_isGDIAnnotationsEnabled) { MdispControl(m_MilDisplay, M_WINDOW_ANNOTATIONS, M_ENABLE); //Make sure it was supported before setting it's status to enabled [CALL TO MIL] if (MdispInquire(m_MilDisplay,M_WINDOW_ANNOTATIONS,M_NULL) == M_ENABLE) m_isGDIAnnotationsEnabled = true; } else { MdispControl(m_MilDisplay, M_WINDOW_ANNOTATIONS, M_DISABLE); m_isGDIAnnotationsEnabled = false; } //Generate an update to make sure an OnDraw message is sent InvalidateRect(NULL); UpdateWindow(); } void CMdispMFCView::OnUpdateGDIAnnotations(CCmdUI* pCmdUI) { pCmdUI-&gt;Enable(m_isWindowed); pCmdUI-&gt;SetCheck(m_isGDIAnnotationsEnabled); } void CMdispMFCView::OnViewModeChange() { ///////////////////////////////////////////////////////////////////////// // MIL: Write code that will be executed when the active view mode // was changed from the toolbar combo box ///////////////////////////////////////////////////////////////////////// if(m_MilDisplay) { //Retrieve combo box from Application Main Frame CComboBox* pViewModeComboBox = ((CMainFrame*)AfxGetMainWnd())-&gt;GetToolbarViewModeCombo() ; if (pViewModeComboBox) { //Retrieves the index of the currently selected item int index = pViewModeComboBox-&gt;GetCurSel(); if(index!=CB_ERR) { switch(index) { case 0: ChangeViewMode(M_DEFAULT); break; case 1: ChangeViewMode(M_TRANSPARENT); break; case 2: ChangeViewMode(M_AUTO_SCALE); break; case 3: ChangeViewMode(M_MULTI_BYTES); break; case 4: ChangeViewMode(M_BIT_SHIFT,2); break; case 5: ChangeViewMode(M_BIT_SHIFT,4); break; case 6: ChangeViewMode(M_BIT_SHIFT,8); break; default: ChangeViewMode(M_DEFAULT); } } } } } void CMdispMFCView::OnActivateView(BOOL bActivate, CView* pActivateView, CView* pDeactiveView) { UpdateComboBoxWithCurrentViewMode(); CView::OnActivateView(bActivate, pActivateView, pDeactiveView); } void CMdispMFCView::UpdateComboBoxWithCurrentViewMode() { CComboBox *ViewModeComboBox = ((CMainFrame*)AfxGetMainWnd())-&gt;GetToolbarViewModeCombo(); if(ViewModeComboBox) { if(m_currentViewMode == M_DEFAULT) ViewModeComboBox-&gt;SelectString(0,MIL_TEXT(\"M_DEFAULT\")); else if(m_currentViewMode == M_TRANSPARENT) ViewModeComboBox-&gt;SelectString(0,MIL_TEXT(\"M_TRANSPARENT\")); else if(m_currentViewMode==M_AUTO_SCALE) ViewModeComboBox-&gt;SelectString(0,MIL_TEXT(\"M_AUTO_SCALE\")); else if(m_currentViewMode==M_MULTI_BYTES) ViewModeComboBox-&gt;SelectString(0,MIL_TEXT(\"M_MULTI_BYTES\")); else if(m_currentViewMode==M_BIT_SHIFT) { if(m_currentShiftValue == 2) ViewModeComboBox-&gt;SelectString(0,MIL_TEXT(\"M_BIT_SHIFT:2\")); else if(m_currentShiftValue == 4) ViewModeComboBox-&gt;SelectString(0,MIL_TEXT(\"M_BIT_SHIFT:4\")); else if(m_currentShiftValue == 8) ViewModeComboBox-&gt;SelectString(0,MIL_TEXT(\"M_BIT_SHIFT:8\")); } ViewModeComboBox-&gt;UpdateData(FALSE); } } void CMdispMFCView::Zoom(MIL_DOUBLE ZoomFactorToApplyX, MIL_DOUBLE ZoomFactorToApplyY) { ///////////////////////////////////////////////////////////////////////// // MIL: Apply current zoom factor on display ///////////////////////////////////////////////////////////////////////// //Apply zoom [CALL TO MIL] MdispZoom(m_MilDisplay, ZoomFactorToApplyX, ZoomFactorToApplyY); } void CMdispMFCView::ChangeViewMode(MIL_INT ViewMode, MIL_INT ShiftValue) { if(m_MilDisplay) { //Apply view mode on display [CALL TO MIL] MdispControl(m_MilDisplay, M_VIEW_MODE, ViewMode); if(ViewMode == M_BIT_SHIFT) MdispControl(m_MilDisplay, M_VIEW_BIT_SHIFT, ShiftValue); //Check if control worked correctly before considering it as successful [CALL TO MIL] if(MdispInquire(m_MilDisplay, M_VIEW_MODE,M_NULL)==ViewMode) { //Make sure View Mode combo box shows current view mode m_currentViewMode = ViewMode; m_currentShiftValue = ShiftValue; UpdateComboBoxWithCurrentViewMode(); } } } void CMdispMFCView::InitializeOverlay() { // Initialize overlay if not already done if ((!m_isOverlayInitialized) &amp;&amp; (m_MilDisplay)) { //Verify the validity of windowed display [CALL TO MIL] if ((((CMdispMFCDoc*)GetDocument())-&gt;m_MilImage) &amp;&amp; (m_MilDisplay) ) { //////////////////////////// // Prepare overlay buffer // //////////////////////////// // Enable display overlay annotations. MdispControl(m_MilDisplay, M_OVERLAY, M_ENABLE); // Inquire the overlay buffer associated with the display. MdispInquire(m_MilDisplay, M_OVERLAY_ID, &amp;m_MilOverlayImage); // Clear the overlay to transparent. MdispControl(m_MilDisplay, M_OVERLAY_CLEAR, M_DEFAULT); // Disable the overlay display update to accelerate annotations. MdispControl(m_MilDisplay, M_OVERLAY_SHOW, M_DISABLE); // Draw MIL monochrome overlay annotation * //***************************************** // Inquire MilOverlayImage size X and Y [CALL TO MIL] long imageWidth = (long)MbufInquire(m_MilOverlayImage,M_SIZE_X,M_NULL); long imageHeight = (long)MbufInquire(m_MilOverlayImage,M_SIZE_Y,M_NULL); // Set graphic text to transparent background. [CALL TO MIL] MgraControl(M_DEFAULT, M_BACKGROUND_MODE, M_TRANSPARENT); // Set drawing color to white. [CALL TO MIL] MgraControl(M_DEFAULT, M_COLOR, M_COLOR_WHITE); // Print a string in the overlay image buffer. [CALL TO MIL] MgraText(M_DEFAULT, m_MilOverlayImage, (imageWidth/9), (imageHeight/5), MIL_TEXT(\" -------------------- \")); MgraText(M_DEFAULT, m_MilOverlayImage, (imageWidth/9), ((imageHeight/5)+25), MIL_TEXT(\" - MIL Overlay Text - \")); MgraText(M_DEFAULT, m_MilOverlayImage, (imageWidth/9), ((imageHeight/5)+50), MIL_TEXT(\" -------------------- \")); // Print a green string in the green component overlay image buffer. [CALL TO MIL] MgraControl(M_DEFAULT, M_COLOR, M_COLOR_GREEN); MgraText(M_DEFAULT, m_MilOverlayImage, imageWidth*11/18, (imageHeight/5), MIL_TEXT(\" -------------------- \")); MgraText(M_DEFAULT, m_MilOverlayImage, imageWidth*11/18, ((imageHeight/5)+25), MIL_TEXT(\" - MIL Overlay Text - \")); MgraText(M_DEFAULT, m_MilOverlayImage, imageWidth*11/18, ((imageHeight/5)+50), MIL_TEXT(\" -------------------- \")); // Draw GDI color overlay annotation * //************************************ // Disable hook to MIL error because control might not be supported MappControl(M_DEFAULT, M_ERROR_HOOKS, M_DISABLE); // Create a device context to draw in the overlay buffer with GDI. [CALL TO MIL] MbufControl(m_MilOverlayImage, M_DC_ALLOC, M_DEFAULT); // Re-enable hook to MIL error MappControl(M_DEFAULT, M_ERROR_HOOKS, M_ENABLE); // Retrieve the HDC of the overlay [CALL TO MIL] HDC OverlayDC = (HDC)MbufInquire(m_MilOverlayImage, M_DC_HANDLE, M_NULL); if(OverlayDC != M_NULL) { // Attach the device context. CDC NewDC; NewDC.Attach(OverlayDC); NewDC.SetBkMode(TRANSPARENT); // Create a blue pen. m_pen.CreatePen(PS_SOLID, 1, RGB(0, 0, 255)); m_penOld = NewDC.SelectObject(&amp;m_pen); // Draw a cross in the overlay buffer. NewDC.MoveTo(0,(imageHeight/2)); NewDC.LineTo(imageWidth,(imageHeight/2)); NewDC.MoveTo((imageWidth/2),0); NewDC.LineTo((imageWidth/2),imageHeight); // Write text in the overlay buffer. MosStrcpy(m_chText, 80, MIL_TEXT(\"GDI Overlay Text \")); NewDC.SetTextColor(RGB(255, 0, 0)); NewDC.TextOut((imageWidth*3/18),(imageHeight*17/24), m_chText, (MIL_INT32)MosStrlen(m_chText)); NewDC.SetTextColor(RGB(255, 255, 0)); NewDC.TextOut((imageWidth*12/18),(imageHeight*17/24), m_chText, (MIL_INT32)MosStrlen(m_chText)); // Deselect and destroy the blue pen. NewDC.SelectObject(m_penOld); m_pen.DeleteObject(); // Detach the device context. NewDC.Detach(); // Delete created device context. [CALL TO MIL] MbufControl(m_MilOverlayImage, M_DC_FREE, M_DEFAULT); // Signal to MIL that the overlay buffer was modified. [CALL TO MIL] MbufControl(m_MilOverlayImage, M_MODIFIED, M_DEFAULT); } // Now that overlay buffer is correctly prepared, display it [CALL TO MIL] MdispControl(m_MilDisplay, M_OVERLAY_SHOW, M_ENABLE); // Overlay is now initialized m_isOverlayInitialized = true; } } } void CMdispMFCView::OnSizing(UINT fwSide, LPRECT pRect) { ///////////////////////////////////////////////////////////////////////// // MIL: Write code that will be executed when window is resized ///////////////////////////////////////////////////////////////////////// if(m_MilDisplay &amp;&amp; !m_isWindowed) CView::OnSizing(fwSide, pRect); } void CMdispMFCView::OnCompression(UINT nID) { ///////////////////////////////////////////////////////////////////////// // MIL: Write code that will be executed when // 'Distributed MIL / Compression / *' button or menu is clicked ///////////////////////////////////////////////////////////////////////// UINT CompressionTypeIndex = nID - s_FirstCompressionTypeControlInRange; ASSERT(CompressionTypeIndex &lt; (sizeof(s_CompressionType) / sizeof(MIL_INT))); ChangeCompressionType(s_CompressionType[CompressionTypeIndex]); } void CMdispMFCView::OnUpdateCompression(CCmdUI *pCmdUI) { // TODO: Add your command update UI handler code here pCmdUI-&gt;Enable(IsNetworkedSystem()); UINT CompressionTypeIndex = pCmdUI-&gt;m_nID - s_FirstCompressionTypeControlInRange; ASSERT(CompressionTypeIndex &lt; (sizeof(s_CompressionType) / sizeof(MIL_INT))); pCmdUI-&gt;SetRadio(m_currentCompressionType == s_CompressionType[CompressionTypeIndex]); } void CMdispMFCView::OnAsynchronousMode(UINT nID) { ///////////////////////////////////////////////////////////////////////// // MIL: Write code that will be executed when // 'Distributed MIL / Asynchronous Mode / *' button or menu is clicked ///////////////////////////////////////////////////////////////////////// UINT AsynchronousModeIndex = nID - s_FirstAsynchronousMaxUpdateRateControlInRange; ASSERT(AsynchronousModeIndex &lt; (sizeof(s_AsynchronousMaxUpdateRate) / sizeof(MIL_INT))); ChangeAsynchronousMode(s_AsynchronousMaxUpdateRate[AsynchronousModeIndex] != M_DISABLE, s_AsynchronousMaxUpdateRate[AsynchronousModeIndex]); } void CMdispMFCView::OnUpdateAsynchronousMode(CCmdUI *pCmdUI) { // TODO: Add your command update UI handler code here pCmdUI-&gt;Enable(IsNetworkedSystem()); UINT AsynchronousModeIndex = pCmdUI-&gt;m_nID - s_FirstAsynchronousMaxUpdateRateControlInRange; ASSERT(AsynchronousModeIndex &lt; (sizeof(s_AsynchronousMaxUpdateRate) / sizeof(MIL_INT))); bool SetRadio = m_isInAsynchronousMode || (s_AsynchronousMaxUpdateRate[AsynchronousModeIndex] == M_DISABLE); if(m_isInAsynchronousMode) SetRadio = (s_AsynchronousMaxUpdateRate[AsynchronousModeIndex] == m_currentAsynchronousFrameRate); pCmdUI-&gt;SetRadio(SetRadio); } void CMdispMFCView::OnQFactor(UINT nID) { ///////////////////////////////////////////////////////////////////////// // MIL: Write code that will be executed when // 'Distributed MIL / Q factor / *' button or menu is clicked ///////////////////////////////////////////////////////////////////////// UINT QFactorIndex = nID - s_FirstQFactorControlInRange; ASSERT(QFactorIndex &lt; (sizeof(s_QFactor) / sizeof(MIL_INT))); ChangeQFactor(s_QFactor[QFactorIndex]); } void CMdispMFCView::OnUpdateQFactor(CCmdUI *pCmdUI) { // TODO: Add your command update UI handler code here pCmdUI-&gt;Enable(IsNetworkedSystem()); UINT QFactorIndex = pCmdUI-&gt;m_nID - s_FirstQFactorControlInRange; ASSERT(QFactorIndex &lt; (sizeof(s_QFactor) / sizeof(MIL_INT))); pCmdUI-&gt;SetRadio(s_QFactor[QFactorIndex] == m_currentQFactor); } void CMdispMFCView::ChangeCompressionType(MIL_INT CompressionType) { if(m_MilDisplay) { // Apply compression type to display [CALL TO MIL] MdispControl(m_MilDisplay, M_COMPRESSION_TYPE, CompressionType); // Check if control worked correctly before considering it successful [CALL TO MIL] if(MdispInquire(m_MilDisplay, M_COMPRESSION_TYPE, M_NULL) == CompressionType) { m_currentCompressionType = CompressionType; } } } void CMdispMFCView::ChangeAsynchronousMode(bool Enabled, MIL_INT FrameRate) { if(Enabled &amp;&amp; (FrameRate != m_currentAsynchronousFrameRate)) { if(m_MilDisplay) { // Apply asynchronous frame rate to display [CALL TO MIL] MdispControl(m_MilDisplay, M_UPDATE_RATE_MAX, FrameRate); // Check if control worked correctly before considering it successful [CALL TO MIL] if(MdispInquire(m_MilDisplay, M_UPDATE_RATE_MAX, M_NULL) == FrameRate) { m_currentAsynchronousFrameRate = FrameRate; } } } if((Enabled &amp;&amp; !m_isInAsynchronousMode) || (!Enabled &amp;&amp; m_isInAsynchronousMode)) { if(m_MilDisplay) { // Apply asynchronous update to display [CALL TO MIL] MdispControl(m_MilDisplay, M_ASYNC_UPDATE, (Enabled ? M_ENABLE : M_DISABLE)); // Check if control worked correctly before considering it successful [CALL TO MIL] if(MdispInquire(m_MilDisplay, M_ASYNC_UPDATE, M_NULL) == (Enabled ? M_ENABLE : M_DISABLE)) { m_isInAsynchronousMode = Enabled; } } } } void CMdispMFCView::ChangeQFactor(MIL_INT QFactor) { if(m_MilDisplay) { // Apply Q factor to display [CALL TO MIL] MdispControl(m_MilDisplay, M_Q_FACTOR, QFactor); // Check if control worked correctly before considering it successful [CALL TO MIL] if(MdispInquire(m_MilDisplay, M_Q_FACTOR, M_NULL) == QFactor) { m_currentQFactor = QFactor; } } } bool CMdispMFCView::IsNetworkedSystem() { bool NetworkedSystem = false; MIL_ID SystemId = ((CMdispMFCApp*)AfxGetApp())-&gt;m_MilSystem; // Check if system is networked (DistributedMIL) [CALL TO MIL] if(SystemId) NetworkedSystem = (MsysInquire(SystemId, M_LOCATION, M_NULL) == M_REMOTE); return NetworkedSystem; } void CMdispMFCView::OnRestrictCursor() { ///////////////////////////////////////////////////////////////////////// // MIL: Write code that will be executed when 'Restrict Cursor' menu item is clicked ///////////////////////////////////////////////////////////////////////// if(m_MilDisplay) { // Apply mouse restriction to display [CALL TO MIL] if(m_currentRestrictCursor == M_DISABLE) { MdispControl(m_MilDisplay, M_RESTRICT_CURSOR, M_ENABLE); } else { MdispControl(m_MilDisplay, M_RESTRICT_CURSOR, M_DISABLE); } // Check if control worked correctly before considering it successful [CALL TO MIL] MdispInquire(m_MilDisplay, M_RESTRICT_CURSOR, &amp;m_currentRestrictCursor); } } void CMdispMFCView::OnUpdateRestrictCursor(CCmdUI *pCmdUI) { // TODO: Add your command update UI handler code here pCmdUI-&gt;Enable(m_isExclusive); pCmdUI-&gt;SetCheck(m_currentRestrictCursor == M_ENABLE); } void CMdispMFCView::OnGraphicsAnnotations() { m_bGraphicsAnnotations = !m_bGraphicsAnnotations; ///////////////////////////////////////////////////////////////////////// // MIL: Write code that will be executed when 'Graphics Annotations' menu item is clicked ///////////////////////////////////////////////////////////////////////// if(m_MilDisplay) { if(m_bGraphicsAnnotations) { if(!m_MilGraphContext &amp;&amp; !m_MilGraphList) { MIL_INT BufSizeX = 0, BufSizeY = 0; MIL_INT Offset = 15; MgraAlloc(((CMdispMFCApp*)AfxGetApp())-&gt;m_MilSystem, &amp;m_MilGraphContext); MgraAllocList(((CMdispMFCApp*)AfxGetApp())-&gt;m_MilSystem, M_DEFAULT, &amp;m_MilGraphList); MdispControl(m_MilDisplay, M_ASSOCIATED_GRAPHIC_LIST_ID, m_MilGraphList); MdispControl(m_MilDisplay, M_UPDATE_GRAPHIC_LIST, M_DISABLE); MbufInquire(((CMdispMFCDoc*)GetDocument())-&gt;m_MilImage, M_SIZE_X, &amp;BufSizeX); MbufInquire(((CMdispMFCDoc*)GetDocument())-&gt;m_MilImage, M_SIZE_Y, &amp;BufSizeY); MgraClear(m_MilGraphContext, m_MilGraphList); MgraControl(m_MilGraphContext, M_COLOR, M_COLOR_LIGHT_BLUE); MgraRect(m_MilGraphContext, m_MilGraphList, Offset, Offset, BufSizeX - Offset, BufSizeY - Offset); MgraControl(m_MilGraphContext, M_COLOR, M_COLOR_GREEN); MgraControl(m_MilGraphContext, M_BACKGROUND_MODE, M_TRANSPARENT); MgraControl(m_MilGraphContext, M_TEXT_ALIGN_HORIZONTAL, M_CENTER); MgraControl(m_MilGraphContext, M_TEXT_ALIGN_VERTICAL, M_CENTER); MgraControl(m_MilGraphContext, M_FONT_SIZE, 12);// Because of Large Font reduce size from 24 to 12 MgraFont(m_MilGraphContext, M_FONT_DEFAULT_TTF MIL_TEXT(\":Bold\")); MgraText(m_MilGraphContext, m_MilGraphList, BufSizeX/2, Offset, MIL_TEXT(\"Interactive Graphic Annotations\")); //Initialize graphic list MdispControl(m_MilDisplay, M_UPDATE_GRAPHIC_LIST, M_ENABLE); MdispControl(m_MilDisplay, M_GRAPHIC_LIST_INTERACTIVE, M_ENABLE); MgraControlList(m_MilGraphList, M_LIST, M_DEFAULT, M_ACTION_KEYS, M_ENABLE); //Remap rotation to page down/up keys to prevent problems with alt key and mfc while using action keys MgraControlList(m_MilGraphList, M_LIST, M_DEFAULT, M_ACTION_KEY_ROTATE_COUNTER_CLOCKWISE, M_KEY_PAGEUP); MgraControlList(m_MilGraphList, M_LIST, M_DEFAULT, M_ACTION_KEY_ROTATE_CLOCKWISE, M_KEY_PAGEDOWN); //Remap angle snapping on rotation to shift to prevent problems with alt key and mfc while using modifier keys MgraControlList(m_MilGraphList, M_LIST, M_DEFAULT, M_MODE_ROTATE_ALT, M_DISABLE); MgraControlList(m_MilGraphList, M_LIST, M_DEFAULT, M_MODE_ROTATE_SHIFT, M_ANGLE_SNAPPING); //Disable resize with aspect ratio set to 1 to prevent problems with alt key and mfc while using modifier keys MgraControlList(m_MilGraphList, M_LIST, M_DEFAULT, M_MODE_RESIZE_ALT, M_DISABLE); //Map escape and delete keys to control the graphic list MgraControlList(m_MilGraphList, M_LIST, M_DEFAULT, M_ACTION_KEY_CANCEL, M_KEY_ESC); MgraControlList(m_MilGraphList, M_LIST, M_DEFAULT, M_ACTION_KEY_DELETE, M_KEY_DELETE); MgraHookFunction(m_MilGraphList, M_INTERACTIVE_GRAPHIC_STATE_MODIFIED, GraphicListModifiedHookFct, (void*)this); } } else { MgraHookFunction(m_MilGraphList, M_INTERACTIVE_GRAPHIC_STATE_MODIFIED+M_UNHOOK, GraphicListModifiedHookFct, (void*)this); MdispControl(m_MilDisplay, M_ASSOCIATED_GRAPHIC_LIST_ID, M_NULL); if(m_MilGraphList) { MgraFree(m_MilGraphList); m_MilGraphList = M_NULL; } if(m_MilGraphContext) { MgraFree(m_MilGraphContext); m_MilGraphContext = M_NULL; } } } } void CMdispMFCView::OnGraOpacity(UINT nID) { ///////////////////////////////////////////////////////////////////////// // MIL: Write code that will be executed when 'Graphics Annotations-&gt;Opacity' menu item is clicked ///////////////////////////////////////////////////////////////////////// UINT OpacityIndex = nID - s_FirstGraOpacityControlInRange; ASSERT(OpacityIndex &lt; (sizeof(s_Opacity) / sizeof(MIL_INT))); if(m_bGraphicsAnnotations &amp;&amp; m_MilDisplay) { // Apply Opacity to display [CALL TO MIL] MdispControl(m_MilDisplay, M_GRAPHIC_LIST_OPACITY, s_Opacity[OpacityIndex]); // Check if control worked correctly before considering it successful [CALL TO MIL] if((s_Opacity[OpacityIndex] == M_DEFAULT) || (MdispInquire(m_MilDisplay, M_GRAPHIC_LIST_OPACITY, M_NULL) == s_Opacity[OpacityIndex])) { m_currentGraOpacity = s_Opacity[OpacityIndex]; } } } void CMdispMFCView::OnUpdateGraOpacity(CCmdUI *pCmdUI) { pCmdUI-&gt;Enable(m_bGraphicsAnnotations); UINT OpacityIndex = pCmdUI-&gt;m_nID - s_FirstGraOpacityControlInRange; ASSERT(OpacityIndex &lt; (sizeof(s_Opacity) / sizeof(MIL_INT))); pCmdUI-&gt;SetRadio(s_Opacity[OpacityIndex] == m_currentGraOpacity); } void CMdispMFCView::OnOverlayOpacity(UINT nID) { ///////////////////////////////////////////////////////////////////////// // MIL: Write code that will be executed when 'Overlay-&gt;Opacity' menu item is clicked ///////////////////////////////////////////////////////////////////////// if(m_isOverlayEnabled) { UINT OpacityIndex = nID - s_FirstOverlayOpacityControlInRange; ASSERT(OpacityIndex &lt; (sizeof(s_Opacity) / sizeof(MIL_INT))); // Apply Opacity to display [CALL TO MIL] MdispControl(m_MilDisplay, M_OVERLAY_OPACITY, s_Opacity[OpacityIndex]); // Check if control worked correctly before considering it successful [CALL TO MIL] if((s_Opacity[OpacityIndex] == M_DEFAULT) || (MdispInquire(m_MilDisplay, M_OVERLAY_OPACITY, M_NULL) == s_Opacity[OpacityIndex])) { m_currentOverlayOpacity = s_Opacity[OpacityIndex]; } } } void CMdispMFCView::OnUpdateOverlayOpacity(CCmdUI *pCmdUI) { pCmdUI-&gt;Enable(m_isOverlayEnabled); UINT OpacityIndex = pCmdUI-&gt;m_nID - s_FirstOverlayOpacityControlInRange; ASSERT(OpacityIndex &lt; (sizeof(s_Opacity) / sizeof(MIL_INT))); pCmdUI-&gt;SetRadio(s_Opacity[OpacityIndex] == m_currentOverlayOpacity); } void CMdispMFCView::OnUpdateGraphicsAnnotations(CCmdUI *pCmdUI) { pCmdUI-&gt;SetCheck(m_bGraphicsAnnotations); } void CMdispMFCView::OnGraRectangle() { if(m_bGraphicsAnnotations) { MgraControl(m_MilGraphContext, M_COLOR, M_COLOR_WHITE); MgraInteractive(m_MilGraphContext, m_MilGraphList, M_GRAPHIC_TYPE_RECT, M_DEFAULT, M_AXIS_ALIGNED_RECT); m_PrimitiveInCreation = M_AXIS_ALIGNED_RECT; } } void CMdispMFCView::OnGraCircle() { if(m_bGraphicsAnnotations) { MgraControl(m_MilGraphContext, M_COLOR, M_COLOR_YELLOW); MgraInteractive(m_MilGraphContext, m_MilGraphList, M_GRAPHIC_TYPE_ARC, M_DEFAULT, M_CIRCLE); m_PrimitiveInCreation = M_CIRCLE; } } void CMdispMFCView::OnGraPolygon() { if(m_bGraphicsAnnotations) { MgraControl(m_MilGraphContext, M_COLOR, M_COLOR_RED); MgraInteractive(m_MilGraphContext, m_MilGraphList, M_GRAPHIC_TYPE_POLYGON, M_DEFAULT, M_DEFAULT); m_PrimitiveInCreation = M_GRAPHIC_TYPE_POLYGON; } } void CMdispMFCView::OnGraDrawOrientedRect() { if(m_bGraphicsAnnotations) { MgraControl(m_MilGraphContext, M_COLOR, M_COLOR_BLUE); MgraInteractive(m_MilGraphContext, m_MilGraphList, M_GRAPHIC_TYPE_RECT, M_DEFAULT, M_ORIENTED_RECT); m_PrimitiveInCreation = M_ORIENTED_RECT; } } void CMdispMFCView::OnGraDrawThreePointsArc() { if(m_bGraphicsAnnotations) { MgraControl(m_MilGraphContext, M_COLOR, M_COLOR_GREEN); MgraInteractive(m_MilGraphContext, m_MilGraphList, M_GRAPHIC_TYPE_ARC, M_DEFAULT, M_ARC_THREE_POINTS); m_PrimitiveInCreation = M_ARC_THREE_POINTS; } } void CMdispMFCView::OnGraLineThicknessToggle() { MIL_INT NbGrph = 0; MgraInquireList(m_MilGraphList, M_LIST, M_DEFAULT, M_NUMBER_OF_GRAPHICS, &amp;NbGrph); for(MIL_INT g = 0; g &lt; NbGrph; g++) { if(MgraInquireList(m_MilGraphList, M_GRAPHIC_INDEX(g), M_DEFAULT, M_GRAPHIC_SELECTED, M_NULL) == M_TRUE) { MIL_INT CurLineThickness = MgraInquireList(m_MilGraphList, M_GRAPHIC_INDEX(g), M_DEFAULT, M_LINE_THICKNESS, M_NULL); // Toggle thickness if(CurLineThickness &gt; 1) { MgraControlList(m_MilGraphList, M_GRAPHIC_INDEX(g), M_DEFAULT, M_LINE_THICKNESS, 1); } else { MgraControlList(m_MilGraphList, M_GRAPHIC_INDEX(g), M_DEFAULT, M_LINE_THICKNESS, 3); } } } } void CMdispMFCView::OnUpdateGraRectangle(CCmdUI *pCmdUI) { // TODO: Add your command update UI handler code here pCmdUI-&gt;Enable(m_bGraphicsAnnotations); pCmdUI-&gt;SetCheck(m_PrimitiveInCreation == M_AXIS_ALIGNED_RECT); } void CMdispMFCView::OnUpdateGraCircle(CCmdUI *pCmdUI) { // TODO: Add your command update UI handler code here pCmdUI-&gt;Enable(m_bGraphicsAnnotations); pCmdUI-&gt;SetCheck(m_PrimitiveInCreation == M_CIRCLE); } void CMdispMFCView::OnUpdateGraPolygon(CCmdUI *pCmdUI) { // TODO: Add your command update UI handler code here pCmdUI-&gt;Enable(m_bGraphicsAnnotations); pCmdUI-&gt;SetCheck(m_PrimitiveInCreation == M_GRAPHIC_TYPE_POLYGON); } void CMdispMFCView::OnUpdateGraDrawOrientedRect(CCmdUI *pCmdUI) { // TODO: Add your command update UI handler code here pCmdUI-&gt;Enable(m_bGraphicsAnnotations); pCmdUI-&gt;SetCheck(m_PrimitiveInCreation == M_ORIENTED_RECT); } void CMdispMFCView::OnUpdateGraDrawThreePointsArc(CCmdUI *pCmdUI) { // TODO: Add your command update UI handler code here pCmdUI-&gt;Enable(m_bGraphicsAnnotations); pCmdUI-&gt;SetCheck(m_PrimitiveInCreation == M_ARC_THREE_POINTS); } void CMdispMFCView::OnUpdateGraLineThicknessToggle(CCmdUI *pCmdUI) { // TODO: Add your command update UI handler code here pCmdUI-&gt;Enable(m_bGraphicsAnnotations); } void CMdispMFCView::OnGraChooseColor() { COLORREF NewColor = M_NULL; if(ShowColorChooser(NewColor)) { //Convert color into MIL color NewColor = M_RGB888(GetRValue(NewColor), GetGValue(NewColor), GetBValue(NewColor)); MgraControlList(m_MilGraphList, M_ALL_SELECTED, M_DEFAULT, M_COLOR, (MIL_INT)NewColor); MgraControlList(m_MilGraphList, M_ALL, M_DEFAULT, M_GRAPHIC_SELECTED, M_FALSE); } } void CMdispMFCView::OnUpdateGraChooseColor(CCmdUI *pCmdUI) { if(m_bGraphicsAnnotations) { pCmdUI-&gt;Enable(true); } else { pCmdUI-&gt;Enable(false); } } void CMdispMFCView::OnGraFill() { MgraControlList(m_MilGraphList, M_ALL_SELECTED, M_DEFAULT, M_FILLED, M_TRUE); MgraControlList(m_MilGraphList, M_ALL, M_DEFAULT, M_GRAPHIC_SELECTED, M_FALSE); } void CMdispMFCView::OnUpdateGraFill(CCmdUI *pCmdUI) { if(m_bGraphicsAnnotations) { pCmdUI-&gt;Enable(true); } else { pCmdUI-&gt;Enable(false); } } void CMdispMFCView::OnGraDrawDirCycle() { const MIL_INT NbValues = 4; MIL_INT DrawDirValues[NbValues] = { M_NONE, M_PRIMARY_DIRECTION, M_SECONDARY_DIRECTION, M_PRIMARY_DIRECTION + M_SECONDARY_DIRECTION }; MIL_INT NbGrph = 0; MgraInquireList(m_MilGraphList, M_LIST, M_DEFAULT, M_NUMBER_OF_GRAPHICS, &amp;NbGrph); MIL_INT DrawDirCurValueIdx = 0; MIL_INT NbSelectedGrph = 0; for(MIL_INT g = 0; g &lt; NbGrph; g++) // Finds the highest draw direction among selected graphics { if(MgraInquireList(m_MilGraphList, M_GRAPHIC_INDEX(g), M_DEFAULT, M_GRAPHIC_SELECTED, M_NULL) == M_TRUE) { MIL_INT GrphDrawDir = MgraInquireList(m_MilGraphList, M_GRAPHIC_INDEX(g), M_DEFAULT, M_DRAW_DIRECTION, M_NULL); if(GrphDrawDir == M_DEFAULT) { GrphDrawDir = M_NONE; } MIL_INT FoundIdx = std::find(&amp;DrawDirValues[0], &amp;DrawDirValues[NbValues], GrphDrawDir) - &amp;DrawDirValues[0]; if(FoundIdx &lt; NbValues) { DrawDirCurValueIdx = max(DrawDirCurValueIdx, FoundIdx); } ++NbSelectedGrph; } } if(NbSelectedGrph &gt; 0) { // toggle current value DrawDirCurValueIdx = (DrawDirCurValueIdx + 1) % NbValues; MgraControlList(m_MilGraphList, M_ALL_SELECTED, M_DEFAULT, M_DRAW_DIRECTION, DrawDirValues[DrawDirCurValueIdx]); } } void CMdispMFCView::OnUpdateGraDrawDirCycle(CCmdUI *pCmdUI) { if(m_bGraphicsAnnotations) { pCmdUI-&gt;Enable(true); } else { pCmdUI-&gt;Enable(false); } } bool CMdispMFCView::ShowColorChooser(COLORREF&amp; NewColor) { bool Success = false; CColorDialog ColorDlg(NewColor, CC_FULLOPEN); if(ColorDlg.DoModal() == IDOK) { Success = true; NewColor = ColorDlg.GetColor(); } return Success; } ",
      "wordCount": 4180
    },
    {
      "id": "Examples_General_MdispMFC_CPP_stdafx_cpp",
      "version": "2024020714",
      "title": "stdafx.cpp",
      "location": "Sample Code from MIL Examples",
      "text": " Top /* * File name: StdAfx.cpp * Location: See Matrox Example Launcher in the MIL Control Center * */ // stdafx.cpp : source file that includes just the standard includes // MDispMFC.pch will be the pre-compiled header // stdafx.obj will contain the pre-compiled type information #include \"stdafx.h\" ",
      "wordCount": 49
    }
  ]
}]
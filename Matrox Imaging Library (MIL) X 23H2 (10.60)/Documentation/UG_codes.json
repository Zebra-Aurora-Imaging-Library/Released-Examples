[{
  "id": "UG_codes",
  "version": "2024020714",
  "title": "Codes",
  "subTitles": null,
  "location": "MIL UG P03: 2D processing and analysis",
  "pageURL": "content\\UserGuide\\codes\\ChapterInformation.htm",
  "text": " Chapter 17: Codes This chapter describes how to read, grade, train, detect, and write various symbols (codes). MIL code module Steps to reading, grading, or writing a code in an image Basic concepts for the MIL Code module Technical code information Code context initialization modes Supported code types 1D code types 2D code types Composite codes Predefined SEMI code contexts Supported encoding schemes, sub-types, and error correction schemes by code type Supported encoding schemes and sub-types Supported encoding schemes for 1D code types (except GS1 Databar) Supported encoding schemes and sub-types for the GS1 Databar code type Supported encoding schemes for 2D code types Supported encoding scheme for composite codes Supported error correction schemes Extended Channel Interpretation (ECI) encoding Automatically detecting the code type Training read and grade operation settings Activating the control types to train Setting a code context from trained results Training images and verifying the training results An example Customizing read and grade operation settings Reading and grading multiple occurrences Child buffers Regions of interest Presearching Foreground color Setting the search speed Timing out your search Cell size and number Search angular range Dot spacing String size Reading EAN 14 code types Reading GS1-128 code types Distortion and deterioration Aztec, Data Matrix, DotCode, and QR code types PDF417 and TruncatedPDF417 code types Thresholding Determining whether your code type supports GS1 Customizing write operation settings Destination buffer size Special characters Foreground color Cell size, number, and shape Bearer bars Writing EAN 14 code types Writing GS1-128 code types Retrieving results Drawing results A code example ",
  "wordCount": 259,
  "subEntries": [
    {
      "id": "UG_codes_MIL_code_module",
      "version": null,
      "title": "MIL code module",
      "subTitles": null,
      "location": "MIL UG P03: 2D processing and analysis",
      "pageURL": "content\\UserGuide\\codes\\MIL_code_module.htm",
      "text": " MIL code module Many industries label products using symbols from symbologies such as UPC-A bar codes and PDF417 cross-row codes. This is done for identification purposes during different stages of production and distribution. Each symbology, known as a code type in MIL, follows a different set of rules to encode the data into light and dark patterns. MIL can both read symbols from and write symbols to images. To read symbols, MIL searches for specified code types in an image and decodes them. The decoded strings can then be used to identify the object, or objects, in the image. To write a symbol, MIL encodes a string into a symbol using the specified code type and encoding scheme. The resulting image of the symbol can then be rotated, combined with text on a logo, and then printed on a physical medium (such as a labeling sticker, bag, or package). In MIL, symbols are known as codes. MIL also allows you to grade the quality of the printed codes so that you can ensure there were no errors in the print process and the codes are readable by most types of imagers (such as, bar code scanners) that support your code type. To grade a code, MIL computes the quality-grade of the code in the specified source image. MIL supports 1D, 2D, and composite code types: One-dimensional (1D) code types. These are linear bar codes used to represent data with vertical bars and spaces. These code types are typically used to represent short strings (for example, the identification number for a grocery store item, or a stock room part number). Two-dimensional (2D) code types. These are cross-row and matrix codes used to represent data with blocks stacked within a predetermined grid (that is, in or potentially spanning 1 or more rows and/or columns). 2D code types can store more information than 1D code types. These code types are typically used to represent longer strings (for example, postage and paper boarding passes). Composite code types. These are a combination of specific 1D and 2D code types. The 1D code type component encodes the item's primary identification, while the 2D code type component encodes additional data (for example, batch number or expiration date). For examples of supported code types, see the Supported code types section later in this chapter. The MIL Code module can read multiple code occurrences of most 1D code types, the DotCode code type, and the Data Matrix code type from an image. Some code types support several methods of encoding, known as encoding schemes. This means a code type might, for example, support an encoding scheme of alpha characters only, numeric characters only, or both alpha and numeric characters. In addition, some code types can support any number of characters, while others need a fixed number. If the bar code is degraded, codes can still be read if an error correction scheme was used when the code was generated. Error correction is essentially redundant data included in the encoding scheme of some code types. Some error correction schemes are used only for error detection, while others are used for error detection and recovery. For more information, see the Supported code types section later in this chapter. To help setup for reading or grading, the Code module can detect the type of most 1D code occurrences in an image. In addition, the module can automatically optimize the control settings of a read or grade operation by training them using a set of sample images. The MIL Code module only supports 8-bit unsigned 1-band image buffers. Performing a code operation on buffers in other formats will produce an error. Note that MIL supports the reading, grading, or training of codes encoded with Extended Channel Interpretation (ECI). MIL code module ",
      "wordCount": 630,
      "subEntries": []
    },
    {
      "id": "UG_codes_Steps_to_reading_or_writing_a_code_in_an_image",
      "version": null,
      "title": "Steps to reading, grading, or writing a code in an image",
      "subTitles": null,
      "location": "MIL UG P03: 2D processing and analysis",
      "pageURL": "content\\UserGuide\\codes\\Steps_to_reading_or_writing_a_code_in_an_image.htm",
      "text": " Steps to reading, grading, or writing a code in an image The following steps provide a basic methodology for using the MIL Code module: Optionally, detect the code types of 1D code occurrences in your image using McodeDetect(). This returns the position of the code occurrences and their code type and encoding scheme. For information, see the Automatically detecting the code type section later in this chapter. Allocate a code context, using McodeAlloc(). A code context is a MIL object that stores the code models and code operation settings. Optionally, specify the initial configuration of the code context as either M_IMPROVED_RECOGNITION or M_TYPICAL_RECOGNITION, depending on whether robustness or speed is more important, respectively. Add one or more code models to the code context, using McodeModel(), depending on the operation you need to perform. A code model contains control settings to read, grade, train, or write a particular code type. Specify the code type when adding the code model. You can use the combination value M_SUPPORTED to determine whether a code model of the specified code type can be added to the code context, given the code type of the code models that already exist in the context. A code context can contain multiple code models of 1D code types (excluding GS1 databar, Planet, Postnet, and 4-state); for other code types, a code context can contain at most one code model. If necessary, change the control settings of the code context or the code models, using McodeControl() (for example, change the encoding scheme for your code type using McodeControl() with M_ENCODING, or change the error correction scheme for your code type using McodeControl() with M_ERROR_CORRECTION). You can use McodeTrain() to establish the optimal control type settings for a read or grade operation given a sample set of your images. Then, you can configure the code context and its code models with these results using McodeControl() with M_RESET_FROM_TRAINED_RESULTS. For information, see the Training read and grade operation settings section later in this chapter. If necessary, specify the number of occurrences to read or grade for 1D code models (excluding GS1 databar, Planet, Postnet, and 4-state), DotCode code models, or Data Matrix code models, using McodeControl() with M_NUMBER. For code models of other types, this control type must be set to 1 (M_DEFAULT) because you can only read/grade one occurrence of these types of code models. If reading, grading, detecting, training or writing a code, allocate a result buffer to hold the code results, using McodeAllocResult(). If reading or grading a code, grab or load an image that contains the code. If the image is large, and contains information which might be misinterpreted as a code, create a child buffer to isolate the code from the rest of the image. Alternatively, use a 2D graphics list to define a rectangular region of interest (ROI) using MbufSetRegion(). If your image contains other important information besides the code, the presearch feature can help MIL locate a 2D code; enable the feature using McodeControl() with M_USE_PRESEARCH. If writing a code, allocate the image buffer in which to generate the code. To perform a read operation, use McodeRead(). To perform a grade operation, use McodeGrade(). To perform a write operation, use McodeWrite(). Retrieve reading, grading, detecting, training, or writing results, using McodeGetResult(). If necessary, draw the results using McodeDraw(). If necessary, save your code context, using McodeSave() or McodeStream(). If necessary, save a report containing most of the results from a grade operation as a flat text file, using McodeStream(). Free all allocated objects, using McodeFree(), unless M_UNIQUE_ID was specified during allocation. Note that you must take into consideration any particularities of the chosen code type. More detailed and code type-dependent information is described in subsequent sections of this chapter, as well as in the MIL Reference. Once created, a MIL code context can be saved and restored as needed. Restoring this information using McodeRestore() or McodeStream(), rather than creating the MIL code context from scratch saves time, especially if the restored code context requires no further modifications. Steps to reading, grading, or writing a code in an image ",
      "wordCount": 684,
      "subEntries": []
    },
    {
      "id": "UG_codes_Basic_concepts",
      "version": null,
      "title": "Basic concepts for the MIL Code module",
      "subTitles": [
        "Technical code information"
      ],
      "location": "MIL UG P03: 2D processing and analysis",
      "pageURL": "content\\UserGuide\\codes\\Basic_concepts.htm",
      "text": " Basic concepts for the MIL Code module The following are terms commonly used in code operations: One-dimensional (1D) code types. 1D code types are linear bar codes containing vertical bars and spaces that typically span one row; stacked versions of 1D codes span multiple rows. They store data in one dimension. Note that postal code types encode data in the height of the bars rather than in the width of the bars and spaces. The following are examples of 1D code types: Two-dimensional (2D) code types. 2D code types contain blocks that can span multiple rows and columns. They store data both horizontally and vertically. The following are examples of 2D code types: Aperture. A measurement of the diameter of the circular smoothing filter used by the code grade operation to avoid minor defects that might influence the grades. Bearer bars. Bars that run along both the top and bottom of a code, two examples of which are illustrated in the diagram below. Cell. The narrowest (thinnest) dark or white space into which data is encoded. Cells have different shapes, depending on the code type. Cells in 1D code types are the thinnest bars or spaces. Some 2D codes have cells that are approximately-square blocks, while Maxicode cells are hexagonal. In 1D and 2D codes, bars can occupy several contiguous cells, as can spaces. When dealing with 1D code types (except 4-state, Postnet and Planet) and 2D cross-row codes (MicroPDF, PDF417, and Truncated PDF), industry uses the term module to refer to a cell. Cell size. Width of the cell, the code's narrowest unit. It is the size of the cell in X. The cell size of a Maxicode is defined as the distance between the center points of two hexagons in the same row. The industry refers to the cell size as either x-width or module size. Checksum number. Number included as part of a 1D or 2D code, which is calculated based on the other characters in the code; it is a simple form of error detection. Typically during a read operation, the characters that make up the string are put through a checksum calculation whose results are compared against the checksum number. Check digit. A character included in a code for the purpose of performing a mathematical check on the value of the decoded code to ensure its accuracy. Codeword. A specific pattern of dark and light cells (such as lines and spaces) that encodes one or more specific digits, depending on the encoding scheme. Each code contains several types of codewords, and the purpose of the codeword is dependent on its type. For example, a data codeword contains part of the encoded information (typically, multiple data codewords are used to encode information), and error codewords are used in error-detection. Code context. A MIL object that stores all code models. The code context also contains general code operation settings. Code model. A data structure that stores all the control settings to read, grade, train, or write a particular code type. Column. A series of cells along the Y-axis. Columns are only referred to when dealing with codes that have more than one row (such as 2D codes). Composite code. Composite codes combine a 1D code type and a 2D code type into one code. Composite codes are most often used to encode large strings of data. The following is an example of a composite code: Extended Channel Interpretation (ECI). A piece of information embedded in a code that indicates that non-standard characters, such as Arabic or Mandarin characters, are used. Encoding scheme. An encoding scheme is a set of rules governing how a string is encoded. Not all code types support all encoding schemes. Error correction. Error correction schemes prevent read operations from returning incorrect results. During read operations, knowing the error correction scheme allows for error detection and error recovery. Error detection discovers bit errors (when a 1 is read as a 0 or vice versa). Error recovery both detects and corrects bit errors; depending on the error correction scheme used, questionable data can be corrected based on the remaining data. Erasure. An erasure is a missing or unreadable codeword at a known position. All erasures are errors, but not all errors are erasures. Extended area. The extended area is a region of a 2D code 20 times the cell size beyond the code's quiet zone. The extended area should contain no marks and a constant symbol contrast (reflectance). Marks can impede the read operation significantly. Finder pattern and clock pattern. The finder pattern and clock pattern are used for symbol identification, orientation, and cell location. For a Data Matrix code, the finder pattern and clock pattern are on the perimeter of the code. The finder pattern consists of two solid lines that touch at a point and the clock pattern consists of two lines of alternating light and dark cells on the opposite side of the finder pattern. Aztec codes use a finder pattern and a orientation pattern in the center of the code. The finder pattern consists of concentric squares, while the orientation pattern is along the outer-corners of the finder pattern. Note that DotCode codes have no finder pattern; instead the fixed patterns are the interstitial dot positions and the 3-dot wide quiet zone not available for printing. Module. See cell. Quiet zone. Quiet zones are areas with no marks and are used to aid the scanning process. For 1D codes, the quiet zone immediately precedes the start character and immediately follows the stop character. For 2D matrix codes, the quiet zone must be present on all four sides of the code; for 2D cross-row codes, the quiet zone must be present on 2 sides. Even hand-written scribbles in the quiet zone will impede the read operation significantly. The size of the quiet zone is dependent on the code type. Reflectance. The grayscale value of a cell. Scan reflectance profile. A scan reflectance profile of a code is a record of values measured along a line across the width of the code and its quiet zone (scan path). Scanline. A scan path is the region of the scanline that spans the code and its quiet zone. The rest of the image's width is ignored. The scan path can be in any direction, but must be straight. Multiple scan paths are used to grade the code. A single scan path is used when generating a single scan profile as part of the scan reflectance profile. Start and stop characters. Characters which inform the reader or scanner of the beginning and end of a code, analogous to the start and stop bits which are specified when transferring data across a modem. Some code types, such as Code 39, use identical stop and start characters, while others use different stop and start characters. The PDF417 code type refers to these characters as start and stop patterns. Technical code information For detailed information about specific code types, refer to one of the following sources. Code type Source 1D Code types All 1D codes except for Pharamcode, Planet code and Postnet. \"International Organization for Standardization (ISO-IEC) 15416:2000 Automatic identification and data capture techniques — Bar code print quality test specification — Linear symbols . Switzerland: ISO/IEC Information technology, 2000. 42.\" \"International Organization for Standardization (ISO-IEC) 15416:2016 Automatic identification and data capture techniques — Bar code print quality test specification — Linear symbols . Switzerland: ISO/IEC Information technology, 2016. 44.\" BC412 \"SEMI 1993, 2003 Semi T1-95 (Reapproved 0303) Specification for back surface bar code marking of silicon wafers . San Jose, CA, USA: Semiconductor Equipment and Matrerials International (SEMI), 2003. 10.\" Code 128 \"International Organization for Standardization (ISO-IEC) 15417:2007 Automatic identification and data capture techniques - Code 128 bar code symbology specification . Switzerland: ISO/IEC Information technology, 2007. 32.\" Code 39 \"International Organization for Standardization (ISO-IEC) 16388:2007 Automatic identification and data capture techniques - Code 39 bar code symbology specification . Switzerland: ISO/IEC Information technology, 2007. 26.\" EAN 8, EAN 13, UPC-A, UPC-E \"International Organization for Standardization (ISO-IEC) 15420:2000 Automatic identification and data capture techniques - Bar code symbology specification - EAN-UPC . Switzerland: ISO/IEC Information technology, 2000. 44.\" Interleaved 2 of 5 \"International Organization for Standardization (ISO-IEC) 16390:2000 Automatic identification and data capture techniques - Interleaved 2 of 5 bar code symbology specification . Switzerland: ISO/IEC Information technology, 2000. 42.\" GS1 Databar \"International Organization for Standardization (ISO-IEC) 24724:2000 Automatic identification and data capture techniques - Reduced Space Symbology (RSS) bar code symbology specification . Switzerland: ISO/IEC Information technology, 2000. 42.\" Code 93 \"ANSI/AIM-BC5-2000 AIM Uniform symbology specification - Code 93 . U.S.A: American National Standards Institute, Inc, 2000. 17.\" Codabar \"ANSI/AIM-BC3-2000 AIM Uniform symbology specification - Codabar . U.S.A: American National Standards Institute, Inc, 2000. 17.\" Pharmacode For technical information about Pharmacode, see \"Laetus am Sandberg Geratebau GmbH The Pharmacode Guide . Germany: Laetus am Sandberg Geratebau GmbH, 1997. 61.\" by Laetus Planet code This code type is no longer actively supported by the USPS, but you can find the technical information about it using the Wayback Machine (https://web.archive.org/web/20060505214851/https://mailtracking.usps.com/mtr/resources/documents/Guide.pdf) Postnet This code type is no longer actively supported by the USPS, but you can find the technical information about it using the Wayback Machine (https://web.archive.org/web/20100805234724/http://pe.usps.com/cpim/ftp/manuals/dmm300/708.pdf) 2D code types All 2D codes except for MaxiCode. \"International Organization for Standardization (ISO-IEC) 15415:2011(E) Automatic identification and data capture techniques — Bar code print quality test specification — Two-dimensional symbols . Switzerland: ISO/IEC Information technology, 2011. 56.\" Aztec \"International Organization for Standardization (ISO-IEC) 24778:2008(E) Automatic identification and data capture techniques - Aztec Code bar code symbology specification . Switzerland: ISO/IEC Information technology, 2008. 52.\" \"ISO/IEC TR 29158:2011 Direct Part Mark (DPM) Quality Guideline . USA: ISO/IEC Information technology, 2011. 20.\" \"ISO/IEC 29158:2020 Direct Part Mark (DPM) Quality Guideline . USA: ISO/IEC Information technology, 2020. 34.\" Cross-row \"International Organization for Standardization (ISO-IEC) 15438:2006(E) Automatic identification and data capture techniques - PDF417 bar code symbology specification . Switzerland: ISO/IEC Information technology, 2006. 112.\" \"International Organization for Standardization (ISO-IEC) 24728:2006 Automatic identification and data capture techniques\" MicroPDF417 bar code symbology specification . Switzerland: ISO/IEC Information technology, 2006. 56.\" \"International Organization for Standardization (ISO-IEC) 15416:2000 Automatic identification and data capture techniques — Bar code print quality test specification — Linear symbols . Switzerland: ISO/IEC Information technology, 2000. 42.\" \"International Organization for Standardization (ISO-IEC) 15416:2016 Automatic identification and data capture techniques — Bar code print quality test specification — Linear symbols . Switzerland: ISO/IEC Information technology, 2016. 44.\" \"International Organization for Standardization (ISO-IEC) 15415:2004(E) Automatic identification and data capture techniques — Bar code print quality test specification — Two-dimensional symbols . Switzerland: ISO/IEC Information technology, 2004. 56.\" Data matrix \"ANSI/AIM-BC11-1997 AIM Uniform symbology specification - Data matrix . U.S.A: American National Standards Institute, Inc, 2000. 17.\" \"International Organization for Standardization (ISO-IEC) 16022:2007 Automatic identification and data capture techniques - Data Matrix bar code symbology specification . Switzerland: ISO/IEC Information technology, 2006. 142.\" \"ISO/IEC 21471:2020 Automatic identification and data capture techniques - Extended Rectangular Data Matrix (DMRE) bar code symbology specification . Switzerland: ISO/IEC Information technology, 2020. 80.\" \"ISO/IEC TR 29158:2011 Direct Part Mark (DPM) Quality Guideline . USA: ISO/IEC Information technology, 2011. 20.\" \"ISO/IEC 29158:2020 Direct Part Mark (DPM) Quality Guideline . USA: ISO/IEC Information technology, 2020. 34.\" \"SEMI T2-0298E 1993, 2000 Specification for marking of wafers with a two-dimensional matrix code symbol . San Jose, CA, USA: Semiconductor Equipment and Matrerials International (SEMI), 2000. 8.\" \"SEMI T7-0303 1997, 2003 Specification for back surface marking of double-side polished wafers with a two-dimensional matrix code symbol . San Jose, CA, USA: Semiconductor Equipment and Matrerials International (SEMI), 2003. 4.\" DotCode \"Association for Automatic Identification and Mobility (AIM) Information technology - Automatic identification and data capture techniques - Bar code symbology specification - DotCode . USA: American National Standards Institute, Inc, 2019. 50.\" MaxiCode \"ANSI/AIM-BC10 AIM Uniform symbology specification - MaxiCode . U.S.A: American National Standards Institute, Inc, 2000. 17.\" QR and Micro QR \"ISO/IEC FDIS 18004:2006(E) Automatic identification and data capture techniques - QR Code 2005 bar code symbology specification . U.S.A: ISO/IEC Information technology, 2006. 17.\" \"International Organization for Standardization (ISO-IEC) 18004:2006 Automatic identification and data capture techniques - QR Code 2005 bar code symbology specification . Switzerland: ISO/IEC Information technology, 2006. 124.\" \"ISO/IEC TR 29158:2011 Direct Part Mark (DPM) Quality Guideline . USA: ISO/IEC Information technology, 2011. 20.\" \"ISO/IEC 29158:2020 Direct Part Mark (DPM) Quality Guideline . USA: ISO/IEC Information technology, 2020. 34.\" Composite codes General \"International Organization for Standardization (ISO-IEC) 24723:2006(E) Automatic identification and data capture techniques - EAN.UCC Composite bar code symbology specification . Switzerland: ISO/IEC Information technology, 2006. 52.\" \"International Organization for Standardization (ISO-IEC) 15416:2000 Automatic identification and data capture techniques — Bar code print quality test specification — Linear symbols . Switzerland: ISO/IEC Information technology, 2000. 42.\" \"International Organization for Standardization (ISO-IEC) 15416:2016 Automatic identification and data capture techniques — Bar code print quality test specification — Linear symbols . Switzerland: ISO/IEC Information technology, 2016. 44.\" \"International Organization for Standardization (ISO-IEC) 15415:2004(E) Automatic identification and data capture techniques — Bar code print quality test specification — Two-dimensional symbols . Switzerland: ISO/IEC Information technology, 2004. 56.\" \"International Organization for Standardization (ISO-IEC) 15415:2011(E) Automatic identification and data capture techniques — Bar code print quality test specification — Two-dimensional symbols . Switzerland: ISO/IEC Information technology, 2011. 56.\" Basic concepts for the MIL Code module Technical code information ",
      "wordCount": 2224,
      "subEntries": []
    },
    {
      "id": "UG_codes_Code_context_initialization_modes",
      "version": null,
      "title": "Code context initialization modes",
      "subTitles": null,
      "location": "MIL UG P03: 2D processing and analysis",
      "pageURL": "content\\UserGuide\\codes\\Code_context_initialization_modes.htm",
      "text": " Code context initialization modes A code context is a MIL object that stores code models and operation settings. Some of these settings can be initialized to predetermined values that change based on the selected code context initialization mode. When allocating your code context (using McodeAlloc()), you can chose between 2 types of initialization modes: M_TYPICAL_RECOGNITION. This configures the context for a faster but less robust McodeRead() or McodeGrade() operation by making assumptions about the code to read and/or grade (such as, that the foreground color is black). This is the default value. M_IMPROVED_RECOGNITION. This configures the context for a more robust McodeRead(), McodeGrade(), or McodeTrain() operation by not making many assumptions about the code to read and grade (such as, that the foreground color could be black or white). This initialization mode is recommended if your target images lack similarity (for example, some but not all include complex or noisy backgrounds), contain distorted codes, or contain codes that are at an angle or even flipped. It is also recommended when searching for 2D matrix codes that are composed of dots. Note that this initialization mode is not recommended with M_PHARMACODE. Note that when selecting this mode, the default of the affected code context and code model settings might change between MIL releases to improve robustness, given new features or standard recommendations. The initialization mode can be changed after allocation, using McodeControl() with M_INITIALIZATION_MODE. When you change the initialization mode, control types that have already been set to some value (other than default) are not changed. Instead, the initialization mode changes those control types that are set to their default value (M_DEFAULT). Code context initialization modes ",
      "wordCount": 277,
      "subEntries": []
    },
    {
      "id": "UG_codes_Supported_code_types_and_noteworthy_characteristics",
      "version": null,
      "title": "Supported code types",
      "subTitles": [
        "1D code types",
        "2D code types ",
        "Composite codes",
        "Predefined SEMI code contexts"
      ],
      "location": "MIL UG P03: 2D processing and analysis",
      "pageURL": "content\\UserGuide\\codes\\Supported_code_types_and_noteworthy_characteristics.htm",
      "text": " Supported code types Whether you plan on reading, grading, training, or writing codes, you typically need to specify the code type when adding a code model to your code context using McodeModel(). If your operation is not successful, ensure that you have added a code model of the appropriate code type. Alternatively, you can automatically detect the code type of most 1D code occurrences in an image, using McodeDetect(), and then automatically add a code model for each detected code type to your code context, using McodeModel() with M_RESET_FROM_DETECTED_RESULTS. For information, see the Automatically detecting the code type section later in this chapter. A code context can contain multiple code models of 1D code types (excluding GS1 databar, Planet, Postnet, and 4-state); for other code types, a code context can contain at most one code model. Although a code context can contain only one 2D code model, you can specify to perform a read, grade, or train operation on more than one occurrence of a Data Matrix code model (or any 1D code model that is not a GS1 Databar, Planet, Postnet, and 4-state code model), using McodeControl() with M_NUMBER. If setting up a code context for reading codes that meet an ISO-compatible SEMI-specification, you can use a predefined code context, distributed with MIL, using McodeRestore(). This section lists the supported code types, and their MIL predefined constants. It also lists the predefined SEMI code contexts. 1D code types The following is a list of the supported 1D code types. Family of code Code type Sample MIL constant McodeDetect() supported Code 128 family Code 128 M_CODE128 Yes EAN 14 M_EAN14 Yes GS1-128 M_GS1_128 Yes Code 2 of 5 IATA 2 of 5 (International Air Transport Association) M_IATA25 Yes Industrial 2 of 5 (standard 2 of 5) M_INDUSTRIAL25 Yes Interleaved 2 of 5 (ITF-14) M_INTERLEAVED25 Yes Consumer EAN 8 M_EAN8 Yes EAN 13 M_EAN13 Yes UPC-A M_UPC_A Yes UPC-E M_UPC_E Yes Postal 4-state M_4_STATE -- Planet M_PLANET -- Postnet M_POSTNET -- Miscellaneous BC412 M_BC412 Yes Codabar M_CODABAR Yes Code 39 M_CODE39 Yes Code 93 M_CODE93 Yes GS1 Databar 1 M_GS1_DATABAR -- Pharmacode M_PHARMACODE -- 1 There are several different sub-types of the GS1 Databar code type; see the Supported encoding schemes and sub-types for the GS1 Databar code type subsection of the Supported encoding schemes, sub-types, and error correction schemes by code type section later in this chapter. 2D code types The following is a list of the supported 2D code types. Family of code Code type Sample MIL constant Matrix Aztec M_AZTEC Data Matrix M_DATAMATRIX DotCode M_DOTCODE Maxicode M_MAXICODE QR code M_QRCODE Micro QR code M_MICROQRCODE Cross-row PDF417 M_PDF417 MicroPDF417 M_MICROPDF417 Truncated PDF417 M_TRUNCATED_PDF417 Composite codes A composite code combines a 1D and 2D code together in a single image. You specify the 1D and 2D components by specifying their corresponding encoding scheme. For more information, refer to the Supported encoding scheme for composite codes subsection of the Supported encoding schemes, sub-types, and error correction schemes by code type section later in this chapter. Control types that apply to either part of a composite code also apply to the composite code as a whole. For the purposes of this chapter, composite codes will not be discussed explicitly. The following is an example of a composite code. Code type Sample MIL constant Composite code M_COMPOSITECODE Predefined SEMI code contexts MIL is distributed with three ISO-compatible SEMI code contexts, each containing a code model and code model settings that match the specification. These can be used directly, or modified to suit your needs. Code context file Specification Associated code type SEMI_T1-95r0303.mco SEMI T1-95 (Reapproved 0303) M_BC412 SEMI_T2-0298E.mco SEMI T2-0298E M_DATAMATRIX SEMI_T7-0303.mco SEMI T7-0303 M_DATAMATRIX To use a predefined SEMI code context, restore it using McodeRestore() with the appropriate file name. These files are located in the Matrox Imaging\\contexts folder. Once restored, the code context can be modified using the MIL Code module's functions. Supported code types 1D code types 2D code types Composite codes Predefined SEMI code contexts ",
      "wordCount": 668,
      "subEntries": []
    },
    {
      "id": "UG_codes_Supported_encoding_schemes_by_code_type",
      "version": null,
      "title": "Supported encoding schemes, sub-types, and error correction schemes by code type",
      "subTitles": [
        "Supported encoding schemes and sub-types",
        "Supported encoding schemes for 1D code types (except GS1 Databar)",
        "Supported encoding schemes and sub-types for the GS1 Databar code type",
        "Supported encoding schemes for 2D code types",
        "Supported encoding scheme for composite codes",
        "Supported error correction schemes",
        "Extended Channel Interpretation (ECI) encoding"
      ],
      "location": "MIL UG P03: 2D processing and analysis",
      "pageURL": "content\\UserGuide\\codes\\Supported_encoding_schemes_by_code_type.htm",
      "text": " Supported encoding schemes, sub-types, and error correction schemes by code type In many cases, each of the supported code types can use one of several encoding schemes and error correction schemes. In addition, composite codes and GS1 Databar 1D codes are families of codes, with each member being a sub-type and typically having a different encoding scheme. Supported encoding schemes and sub-types To read, grade, or write most code types, you must ensure that the proper encoding scheme is selected for your code model using McodeControl() with M_ENCODING; in some cases, M_ANY is supported. McodeDetect() can help you establish the encoding scheme if it supports the code type; for information, see the Automatically detecting the code type section later in this chapter. You can also train the encoding scheme using McodeTrain() with a sample set of your images. For information, see the Training read and grade operation settings section later in this chapter. Note that, for best results, specify the encoding scheme when reading a Code 39 code type. When reading or grading composite code types, both M_ENCODING and M_SUB_TYPE are used. M_SUB_TYPE allows you to specify multiple sub-types so that you can limit the number of sub-types that MIL tries to read or grade. For example, when dealing with a composite code, if you specify a sub-type of M_GS1_DATABAR_EXPANDED + M_EAN13, MIL reads your code more quickly because it will only look for these two family members as opposed to all the available sub-types. Supported encoding schemes for 1D code types (except GS1 Databar) The following table lists the encoding schemes supported by each 1D code type (except M_GS1_DATABAR): Encoding scheme (M_ENCODING) 1D code types (except GS1 Databar) M_BC412 and M_CODABAR M_CODE39 and M_CODE93 M_CODE128, M_EAN14, and M_GS1_128 M_IATA25, M_INDUSTRIAL25, M_INTERLEAVED25, M_PHARMACODE, M_PLANET, and M_POSTNET M_EAN8 M_EAN13 M_UPC_A M_UPC_E M_4_STATE M_ENC_ASCII — Yes 1 Yes — — — — — — M_ENC_EAN8_ADDON — — — — Yes — — — — M_ENC_EAN13_ADDON — — — — — Yes — — — M_ENC_UPCA_ADDON — — — — — — Yes — — M_ENC_UPCE_ADDON — — — — — — — Yes — M_ENC_NUM — — — Yes Yes Yes Yes Yes — M_ENC_STANDARD Yes Yes — — — — — — — M_ENC_KOREA_MAIL, M_ENC_US_MAIL 2 , and M_ENC_UK_MAIL — — — — — — — — Yes 1 Note that M_ENC_ASCII is only available for M_CODE128 and M_EAN14. 2 Note that this is the encoding type for Intelligent Mail Barcodes. Supported encoding schemes and sub-types for the GS1 Databar code type The following table lists the encoding schemes and sub-types supported by the GS1 Databar code type (M_GS1_DATABAR): Encoding scheme (M_ENCODING) Sub-type (M_SUB_TYPE) Image M_ENC_GS1_DATABAR_EXPANDED M_GS1_DATABAR_EXPANDED M_ENC_GS1_DATABAR_EXPANDED_STACKED M_GS1_DATABAR_EXPANDED_STACKED M_ENC_GS1_DATABAR_LIMITED M_GS1_DATABAR_LIMITED M_ENC_GS1_DATABAR_OMNI M_GS1_DATABAR_OMNI M_ENC_GS1_DATABAR_STACKED M_GS1_DATABAR_STACKED M_ENC_GS1_DATABAR_STACKED_OMNI M_GS1_DATABAR_STACKED_OMNI M_ENC_GS1_DATABAR_TRUNCATED M_GS1_DATABAR_TRUNCATED Supported encoding schemes for 2D code types The following table lists the encoding schemes supported by each 2D code type: Encoding scheme (M_ENCODING) 2D code types M_AZTEC M_DATAMATRIX M_DOTCODE M_MAXICODE M_MICROPDF417, M_PDF417, and M_TRUNCATED_PDF417 M_QRCODE M_MICROQRCODE M_ANY Yes Yes — Yes Yes Yes — M_ENC_ALPHA — Yes — — — — — M_ENC_ALPHANUM — Yes — — — — — M_ENC_ALPHANUM_PUNC — Yes — — — — — M_ENC_ASCII — Yes — — — — — M_ENC_AZTEC... Yes — — — — — — M_ENC_ISO8 — Yes Yes — — — — M_ENC_MODE2 — — — Yes — — — M_ENC_MODE3 — — — Yes — — — M_ENC_MODE4 — — — Yes — — — M_ENC_MODE5 — — — Yes — — — M_ENC_MODE6 — — — Yes — — — M_ENC_NUM — Yes — — — — — M_ENC_QRCODE_MODEL1 — — — — — Yes — M_ENC_QRCODE_MODEL2 — — — — — Yes — M_ENC_STANDARD — — — — Yes — Yes Supported encoding scheme for composite codes The following table lists the encoding schemes, 1D part, 2D part, and sub-types supported by composite codes. The supported composite codes have a 2D part that is either MicroPDF (CC-A or CC-B) or PDF417 (CC-C). The sub-type relates to the 1D part of the composite code, while the encoding scheme relates to both the 1D and 2D parts. Encoding scheme (M_ENCODING) M_COMPOSITECODE 1D part established by M_SUB_TYPE 2D part M_MICROPDF417 M_PDF417 M_ENC_EAN8 M_EAN8 Yes — M_ENC_EAN13 M_EAN13 Yes — M_ENC_GS1_128_MICROPDF417 M_GS1_128 Yes — M_ENC_GS1_128_PDF417 M_GS1_128 — Yes M_ENC_UPCA M_UPC_A Yes — M_ENC_UPCE M_UPC_E Yes — M_ENC_GS1_DATABAR_EXPANDED M_GS1_DATABAR_EXPANDED Yes — M_ENC_GS1_DATABAR_EXPANDED_STACKED M_GS1_DATABAR_EXPANDED_STACKED Yes — M_ENC_GS1_DATABAR_LIMITED M_GS1_DATABAR_LIMITED Yes — M_ENC_GS1_DATABAR_OMNI M_GS1_DATABAR_OMNI Yes — M_ENC_GS1_DATABAR_STACKED M_GS1_DATABAR_STACKED Yes — M_ENC_GS1_DATABAR_STACKED_OMNI M_GS1_DATABAR_STACKED_OMNI Yes — M_ENC_GS1_DATABAR_TRUNCATED M_GS1_DATABAR_TRUNCATED Yes — Supported error correction schemes In most cases, MIL can automatically detect the error correction scheme for read and grade operations. Similarly, MIL can automatically choose the best error correction scheme for most write operations. If your code type supports more than one error correction scheme and does not support M_ANY, you must specify the error correction scheme. To specify the error correction scheme, use McodeControl() with M_ERROR_CORRECTION. If you specify a scheme that is not supported by your code type, MIL returns an error. If your code type uses a checksum, when a discrepancy exists between the calculated and stored checksum, the read operation will yield no results. You can also train the error correction scheme using McodeTrain() with a sample set of your images. For information, see the Training read and grade operation settings section later in this chapter. The following table lists the error correction schemes supported by each 1D code type: Code type Error correction scheme M_ECC_CHECK_DIGIT M_ECC_NONE M_ECC_4STATE M_4_STATE Yes — Yes M_BC412 Yes Yes — M_CODABAR — Yes — M_CODE39 Yes Yes — M_CODE93 Yes — — M_CODE128 Yes — — M_EAN8 Yes — — M_EAN13 Yes — — M_EAN14 Yes — — M_GS1_128 Yes — — M_GS1_DATABAR Yes — — M_INTERLEAVED25 Yes Yes — M_PHARMACODE — Yes — M_PLANET Yes — — M_POSTNET Yes — — M_UPC_A Yes — — M_UPC_E Yes — — The following table lists the error correction schemes supported by each 2D code type: Code type Error correction scheme M_ANY M_ECC_200 M_ECC_H, M_ECC_L, M_ECC_M, M_ECC_Q M_ECC_REED_SOLOMON M_ECC_REED_SOLOMON_n M_AZTEC Yes 3 — — — — M_DATAMATRIX Yes 4 Yes — — — M_DOTCODE — — — Yes Yes M_MAXICODE — — — Yes — M_MICROPDF417 — — — Yes — M_MICROQRCODE Yes — Yes 5 — — M_PDF417 Yes — — — Yes M_QRCODE Yes — Yes — — M_TRUNCATED_PDF417 Yes — — — Yes 3 Note that M_ANY sets the percentage of the code to be used for error checking to 23%. 4 Note that M_ANY is not available for a Data Matrix code type when performing an McodeWrite() operation. 5 Note that M_MICROQRCODE does not support M_ECC_H. Extended Channel Interpretation (ECI) encoding McodeRead(), McodeGrade(), and McodeTrain() support occurrences of 2D code types (except M_MICROQRCODE) with an Extended Channel Interpretation (ECI) encoding. This is a piece of information embedded in a code occurrence that indicates that non-standard characters, such as Arabic or Mandarin characters, are used. To retrieve whether a code occurrence has an ECI encoding, use McodeGetResult() with M_IS_ECI. Supported encoding schemes, sub-types, and error correction schemes by code type Supported encoding schemes and sub-types Supported encoding schemes for 1D code types (except GS1 Databar) Supported encoding schemes and sub-types for the GS1 Databar code type Supported encoding schemes for 2D code types Supported encoding scheme for composite codes Supported error correction schemes Extended Channel Interpretation (ECI) encoding ",
      "wordCount": 1232,
      "subEntries": []
    },
    {
      "id": "UG_codes_Automatically_detecting_the_code_type",
      "version": null,
      "title": "Automatically detecting the code type",
      "subTitles": null,
      "location": "MIL UG P03: 2D processing and analysis",
      "pageURL": "content\\UserGuide\\codes\\Automatically_detecting_the_code_type.htm",
      "text": " Automatically detecting the code type You can automatically detect the code type, encoding scheme, and position of most 1D code occurrences in an image, using McodeDetect(). You can use this information to automatically or manually set up your code models with an appropriate code type and encoding scheme for the code occurrences in your images. Detecting the code type is especially useful when it is unknown because you need this information to add a code model. In addition, being specific about the encoding scheme, rather than M_ANY, can accelerate McodeRead() and McodeGrade() operations. You can use the positional results for graphical and debugging purposes. McodeDetect() supports all 1D code types, except postal, GS1 Databar, and Pharmacode code types. It cannot detect 2D or composite code types. Note that some code types are a subset of another. If a code occurrence has only the common features of these code types, McodeDetect() cannot distinguish if the code occurrence is of one type or the other at decode-time. In these cases, McodeDetect() reports the following: When the following code types cannot be differentiated Code type reported M_UPC_A and M_EAN13 M_UPC_A M_EAN14, M_GS1_128, and M_CODE128 M_EAN14 M_GS1_128 and M_CODE128 M_GS1_128 You can remove this ambiguity by restricting the possible code types when calling McodeDetect(). Another reason to restrict the possible code types is if you are not interested in detecting certain code types; this will accelerate McodeDetect(). Note that McodeDetect() does not take a code context. All information must be passed directly to the function. When you call McodeDetect(), you must specify the total number of code occurrences to find in the specified image, regardless of their code type. The function detects the specified number of code occurrences with the best quality. If it detects less than the specified number, McodeGetResult() with M_STATUS returns M_STATUS_DETECT_FAILED. To automatically add code models to a code context using the results of McodeDetect(), use McodeModel() with M_RESET_FROM_DETECTED_RESULTS. This first deletes all existing code models in the code context, and then adds a code model for each detected code type. If two code occurrences with the same code type but different encoding schemes are detected, only one code model of this type is added and its encoding scheme is set to M_ANY (if supported by the code type). The following example shows you how to automatically add code models to a code context using the results of McodeDetect(). It also shows you how to annotate a displayed image with the location and name of the detected code occurrences. codedetect.cpp If you don't want to delete the existing models in the context, you can manually add a code model to a code context using the results of McodeDetect(). To do so, perform the following: Retrieve the code type and encoding scheme of a detected code occurrence using McodeGetResult(), first with M_CODE_TYPE and then with M_ENCODING, respectively. Call McodeModel() with M_ADD, the code context, and the code type; this adds a code model of the specified code type to the context. Note that McodeDetect() can find multiple occurrences of the same code type and encoding scheme. Instead of adding multiple code models of the same code type and encoding scheme, increment the number of occurrences to find of that code model, using McodeControl() with the code model index and M_NUMBER. Set the encoding scheme of the newly added code model using McodeControl() with M_ENCODING. Repeat the process above for all occurrences detected. Note that you can also use McodeGetResult() with M_ALL to retrieve the above mentioned results; this retrieves the specified result for all code occurrences at once. Automatically detecting the code type ",
      "wordCount": 604,
      "subEntries": []
    },
    {
      "id": "UG_codes_Training_read_and_grade_operation_settings",
      "version": null,
      "title": "Training read and grade operation settings",
      "subTitles": [
        "Activating the control types to train",
        "Setting a code context from trained results",
        "Training images and verifying the training results",
        "An example"
      ],
      "location": "MIL UG P03: 2D processing and analysis",
      "pageURL": "content\\UserGuide\\codes\\Training_read_and_grade_operation_settings.htm",
      "text": " Training read and grade operation settings Once you have allocated a code context and added code models of the appropriate type to it, you can try reading or grading the code occurrences in your images using the default control type settings. For a more robust McodeRead() or McodeGrade() operation, you might need to customize the control type settings of the context and the code models so that they are optimized for your target images. The fastest way to set the most commonly adjusted control types is to train them using McodeTrain() with a sample set of your images. McodeTrain() establishes the optimal settings based on the code occurrences found in all the training images. If further adjustment is still needed, see the Customizing read and grade operation settings section later in this chapter. The following steps provide a basic methodology to train the control type settings of your context and its code models: Allocate a training result buffer to hold the recommended settings, using McodeAllocResult() with M_CODE_TRAIN_RESULT. Activate the control types to train. You can choose to activate all or some of the trainable control types, using McodeControl() with M_SET_TRAINING_STATE_ALL or using McodeControl() with the control type to activate combined with M_TRAIN, respectively. Note that if M_TIMEOUT is activated, it might affect other trained control types. Call McodeTrain() with the code context to train, the training result buffer, and a sample set of your images. Ensure that the train operation was successful using McodeGetResult() with M_STATUS. If successful, it should return M_STATUS_TRAIN_OK. Reconfigure a code context with the training results, using McodeControl() with M_RESET_FROM_TRAINED_RESULTS. Use the configured code context when calling McodeRead() or McodeGrade(). Activating the control types to train Typically, you activate all the trainable control types using McodeControl() with M_SET_TRAINING_STATE_ALL set to M_DEFAULT. If required, you can then disable the activation of a few control types that you don't want trained. To do so, call McodeControl() with the control type to deactivate combined with M_TRAIN and set the control value to M_DISABLE. For example, if you know that your code occurrences will never appear rotated, you can call McodeControl() with M_SEARCH_ANGLE + M_TRAIN and set the control value to M_DISABLE. Setting a code context from trained results McodeTrain() saves its results in the specified code train result buffer. Typically, you reconfigure a code context with these training results, using McodeControl() with M_RESET_FROM_TRAINED_RESULTS. This control type discards any existing code models from the context, and then adds the code models used for training to the context. If a control type was not trained, it is set to its value used during training; if a control type was trained, it is set to its trained value. If required, you can retrieve the recommended setting for a specific control type using McodeGetResult(). This is especially useful if you want to reconfigure the code context that was used during training. In this case, you can use the retrieved values to selectively change the control types of the context to their trained value. Note that some control types are inter-dependent; changing the setting of one control type to its trained value might not be optimal if the settings of other control types are not also changed. This is especially true for control types that are automatically activated for training if another control type is activated (for example, M_CELL_NUMBER_...). Training images and verifying the training results The recommended control type settings for a code context and its code models are based on the code occurrences found in all the training images. Each training image must have at least one occurrence of one of the code models. You can retrieve the buffer identifiers of the training images in which a code occurrence could not be read, using M_FAILED_IMAGES_ID. For the most robust training results, provide images of all the different situations in which you will need to read or grade code occurrences of the code models during the critical loop. You can retrieve or draw the results of the read operation that McodeTrain() internally performed on each training image. You can use this extra information to complement the status result. First, call McodeGetResult() with M_CODE_RESULT_ID. This returns the identifiers of the internal code read result buffers; there is one per training image. You can then pass one of these result buffer identifiers to McodeGetResult(), and retrieve any type of result available for an McodeRead() operation. You can also pass one of the result buffer identifiers to McodeDraw() to visualize the results for a specific training image. You can retrieve detailed information about the code models that were enabled for training, using McodeGetResult() with the M_TRAIN_... result types. For example, M_TRAIN_ENABLED_CONTROL_TYPES retrieves a list of control types that were enabled for each context or model. If McodeTrain() doesn't find at least one occurrence of one of the code models among the sample images, McodeGetResult() with M_STATUS returns M_STATUS_TRAIN_FAILED. An example The following example shows you how to train control type settings using McodeTrain(). It also shows you how retrieve some of the results obtained from the internal read operations, for display purposes. codetrain.cpp Training read and grade operation settings Activating the control types to train Setting a code context from trained results Training images and verifying the training results An example ",
      "wordCount": 877,
      "subEntries": []
    },
    {
      "id": "UG_codes_Customizing_read_operation_settings",
      "version": null,
      "title": "Customizing read and grade operation settings",
      "subTitles": [
        "Reading and grading multiple occurrences",
        "Child buffers",
        "Regions of interest",
        "Presearching",
        "Foreground color",
        "Setting the search speed",
        "Timing out your search",
        "Cell size and number",
        "Search angular range",
        "Dot spacing",
        "String size",
        "Reading EAN 14 code types",
        "Reading GS1-128 code types",
        "Distortion and deterioration",
        "Aztec, Data Matrix, DotCode, and QR code types",
        "PDF417 and TruncatedPDF417 code types",
        "Thresholding",
        "Determining whether your code type supports GS1"
      ],
      "location": "MIL UG P03: 2D processing and analysis",
      "pageURL": "content\\UserGuide\\codes\\Customizing_read_operation_settings.htm",
      "text": " Customizing read and grade operation settings This section provides information to consider and describes settings that you might have to change for McodeRead() or McodeGrade() operation. You can also train many of these settings using McodeTrain() with a sample set of your images. To establish which can be trained, refer to their description in McodeControl() in the MIL Reference; to increase efficiency when browsing control types, use filters to limit table values to those of that can be trained. For information on training, see the Training read and grade operation settings section earlier in this chapter. Reading and grading multiple occurrences The MIL Code module is designed to read and grade one or many code occurrences in an image; the module only supports searching for multiple occurrences of linear code types (excluding 4-State, GS1 Databar, Planet, and Postnet code types), the Data Matrix code type, and the DotCode code type. When reading or grading multiple code occurrences, multiple results (one set of results for each occurrence of each code model) can be retrieved using McodeGetResult(). If you want to read/grade more than one code occurrence in the image, set the number of code occurrences to read for each code model using McodeControl() with M_NUMBER. To set the total number of code occurrences to read, use McodeControl() with M_TOTAL_NUMBER; the default value is M_ALL, which finds the expected number of occurrences specified for each code model. For example, if an application must read one code occurrence in an image, you should add a code model to the code context for each possible code type that the code occurrence can be. Since only one code occurrence must be read for any image, you should set M_TOTAL_NUMBER to 1, and set M_NUMBER for each code model to 1. The following table further demonstrates the relationship between M_TOTAL_NUMBER and M_NUMBER, by showing an example of different combinations of possible results: Code context element Number of occurrences set Number of occurrences read or graded Ex. 1 Ex. 2 Ex. 3 Ex. 4 Ex. 5 Ex. 6 Ex. 7 Ex. 8 Context 5 (maximum) 5 5 5 5 5 5 5 5 Model 0 1 0 1 0 1 0 1 0 1 Model 1 3 0 0 1 1 2 2 3 3 Model 2 M_ALL 5 4 4 3 3 2 2 1 When reading multiple occurrences, it is recommended to set M_POSITION_ACCURACY to M_HIGH to increase the accuracy of the read. Child buffers For McodeRead() and McodeGrade(), it is recommended to use a child buffer, especially if your images contain more code occurrences than your code context is configured to read/grade; otherwise, MIL will select which code occurrences to read/grade, up to the specified maximum number of code occurrences (McodeControl() with M_TOTAL_NUMBER). Using child buffers is also recommended because it allows for a faster and more robust operation if your images contain other information that might be misinterpreted as a code occurrence. A quiet zone is an optional part of each linear code type's specification and a required part of each 2D code type's specification (except for Aztec). For best results, if a code occurrence has a quiet zone, your child buffer must be large enough to contain the quiet zone. Generally, the minimum quiet zone for a linear code type is ten times the width of the smallest bar and space. For a 2D code type, the width is generally a factor of the size of the cell. MIL uses the quiet zone to identify the beginning/end of the code occurrence. MIL can, in some cases, successfully read a code occurrence that does not meet the minimum requirements for the quiet zone; however, it is strongly recommended that code occurrences have adequate quiet zones to perform a robust McodeRead() or McodeGrade() operation and return accurate results. The extended quiet zone, referred to as the extended area of a code occurrence, is an optional part of the specification for the Aztec, Data Matrix, DotCode, QR, and Micro QR code types. It is an area 20 times the cell size beyond the quiet zone on all sides. If you are grading code occurrences including their extended area (M_EXTENDED_AREA_REFLECTANCE_CHECK), your child buffer must be large enough to contain their extended area. Regions of interest Another way to reduce the amount of processing to be performed on your image is to use an image with a region of interest (ROI). Similar to a child buffer, an ROI allows for a fast and robust McodeRead() or McodeGrade() operation. Only a rectangular M_VECTOR or M_VECTOR_AND_RASTER ROI, will be considered. To create such an ROI, use MbufSetRegion() with the ImageOrGraphicListId parameter set to the MIL identifier of a 2D graphics list, and the Operation parameter set to either M_RASTERIZE or M_NO_RASTERIZE. Presearching There are some situations where you cannot create a child buffer or an ROI for your McodeRead() or McodeGrade() operation. For example, when you cannot guarantee that the target is not in the same location each time it is read or graded by your application. In this case, you could use the MIL Code module's presearch algorithm. This helps MIL locate 2D code occurrences in the image prior to the read or grade operation. The presearch algorithm is only supported for 2D code occurrences, not including DotCode, and is disabled by default for efficiency. To set the presearch option, use McodeControl() with M_USE_PRESEARCH. Foreground color Setting the foreground color can improve the results of McodeRead() or McodeGrade(). To set the foreground color, use McodeControl() with M_FOREGROUND_VALUE. The default foreground color is black. In situations where the foreground color might change, set M_FOREGROUND_VALUE to M_FOREGROUND_ANY. Note that this impacts the performance of McodeRead() or McodeGrade(). Setting the search speed You can specify the speed at which to perform McodeRead() or McodeGrade(); the faster the speed, the less robust the operation. In general, the larger and more clearly defined the code occurrence, the better chance it has of being found at a speed higher than the default speed (M_MEDIUM). Specify the search speed using McodeControl() with M_SPEED. If you are having problems finding the code occurrence, you might want to search at a speed lower than the default. Timing out your search In certain cases, McodeRead() or McodeGrade() might take longer than necessary for your purposes. In this event, you have two options to reduce the reading or grading time. You can either specify a maximum decoding time for the operation using McodeControl() with M_TIMEOUT, or you can call McodeControl() with M_STOP_READ to stop the current McodeRead() or McodeGrade() operation when required. For the latter option, the call to McodeControl() must be done from another thread. Cell size and number In most cases, you should not have to specify the cell size or number of cells when reading or grading code occurrences; MIL can search for the specified code type and automatically determine the cell size and number of cells within the code occurrence. However, for some linear code types and 2D code types, such as Data Matrix and Maxicode, McodeRead() or McodeGrade() can perform a more robust operation if you specify the cell size (that is, the size of the cell in X). To increase both the speed and robustness of the operation for 2D code types, you can also specify the number of cells in the X and Y-direction; for M_PDF417, M_TRUNCATED_PDF417, and M_MICROPDF417 code types, instead of specifying the number of cells in the Y-direction, you specify the number of rows. MIL might have difficulty reading linear code occurrences if the cell size is less than 2 pixels, and 2D code occurrences if the cell size is less than 3 pixels, even if the size is specified. You specify the cell size as a range using McodeControl() with M_CELL_SIZE_MIN and M_CELL_SIZE_MAX. MIL will search for code occurrences with cells that fall within this range. If the cell size is not within the specified range, the code occurrence will not be found. It is highly recommended that you specify the best cell size range possible. This is especially important when using an adaptive threshold, discussed later in the Thresholding subsection of this section. To obtain the best results from a presearch when a code occurrence's cell size is less than 6 or greater than 10, you must specify the cell size minimum and maximum. You specify the number of cells using McodeControl() with M_CELL_NUMBER_X and M_CELL_NUMBER_Y. Note that specifying the number of cells is mostly useful when reading Aztec, PDF417, Truncated PDF417, Data Matrix, DotCode, and QRCode code types; the Maxicode code type has a fixed number of cells. For the DotCode code type, the sum of the number of rows and number of columns must be an odd number. For the PDF417 code type, M_CELL_NUMBER_X must equal 17c + 35, where c is the number of columns, and 35 represents the number of cells required for the start and stop patterns. For the Truncated PDF417 code type, M_CELL_NUMBER_X must equal 17c + 18, where c is the number of columns, and 18 represents the number of cells required for the start patterns. When used with M_PDF417, M_TRUNCATED_PDF417, and M_MICROPDF417 code types, M_CELL_NUMBER_Y represents the number of rows. Search angular range By default, McodeRead() and McodeGrade() read code occurrences if they fall within the angular range of 0±5°. If the code occurrence appears rotated in the image, specify another nominal angle using McodeControl() with M_SEARCH_ANGLE. If you are uncertain about the code occurrence's exact orientation or you expect a possible deviation of more than ±5° from the nominal angle, increase the angular range relative to M_SEARCH_ANGLE. Set the lower and upper deviations from the nominal angle using McodeControl() with M_SEARCH_ANGLE_DELTA_NEG and M_SEARCH_ANGLE_DELTA_POS. Optionally, for linear, PDF417, and TruncatedPDF417 code types, you can set the step by which to increment or decrement through the search angular range, using McodeControl() with M_SEARCH_ANGLE_STEP. If you don't explicitly specify this step, the search angular range algorithm will automatically establish a step. The search angular range algorithm will first search at the specified nominal angle. It will then toggle between incrementing and decrementing from the nominal angle, with each iteration moving further away from the initial search angle by the value of M_SEARCH_ANGLE_STEP (or the automatically established step). The process will continue until either the code occurrence is found, or the search falls outside of the range defined by M_SEARCH_ANGLE - M_SEARCH_ANGLE_DELTA_NEG and M_SEARCH_ANGLE + M_SEARCH_ANGLE_DELTA_POS. Note that M_SEARCH_ANGLE_STEP, M_SEARCH_ANGLE_DELTA_NEG and M_SEARCH_ANGLE_DELTA_POS are relative to the nominal angle set by M_SEARCH_ANGLE. While the nominal angle is relative to the input coordinate system specified using M_SEARCH_ANGLE_INPUT_UNITS, M_SEARCH_ANGLE_DELTA_NEG and M_SEARCH_ANGLE_DELTA_POS are not affected by the coordinate system used. For linear code types, as the angular range increases and/or the angular step decreases, the operation speed might decrease. You can sometimes speed up the search by disabling the search angular range algorithm and trying to read the code occurrence at the specified search (nominal) angle. If the code occurrence deviates from the nominal angle by a few degrees, as in the image below, McodeRead() and McodeGrade() can sometimes successfully read the code occurrence without explicitly searching through a range of angles. To disable the search angular range algorithm, call McodeControl() with M_SEARCH_ANGLE_MODE set to M_DISABLE. The angular range does not affect the speed of the operation when searching for 2D code types, and so it is not necessary to disable the search angular range algorithm. For linear code types, the Code module will not use the search angular range algorithm if M_SEARCH_ANGLE_DELTA_NEG and M_SEARCH_ANGLE_DELTA_POS both have a value less than or equal to 5°, regardless of M_SEARCH_ANGLE_MODE. In this instance, M_SEARCH_ANGLE_DELTA_NEG and M_SEARCH_ANGLE_DELTA_POS have no effect. For PDF417 and Truncated PDF417 code types, you can specify the angle of the scanlines using M_DECODE_ALGORITHM with M_SCANLINE_AT_ANGLE. This enables decoding using scanlines rotated to the orientation specified by M_SEARCH_ANGLE, without any localization. Select this algorithm if you have codes that do not completely respect their specification (for example, they are missing their quiet zone). Note that although this improves robustness, this might affect speed. To get the best performance, specify a precise M_SEARCH_ANGLE or use M_SEARCH_ANGLE_STEP, and ensure M_SCANLINE_HEIGHT is not set at a higher value than the row height. You can try disabling M_SEARCH_ANGLE_MODE to see if the Code module can still find the required code occurrences; this might improve the speed. If bearer bars are present and you are reading a bar code at an unknown angle, M_BEARER_BAR must be enabled. When bearer bars are caused by the background (such as, the bar code has a dark background that touches only one edge of the lines and spaces), then the speed of the read should be reduced (using M_SPEED set to M_VERY_LOW). When the search speed M_SPEED is set to M_VERY_LOW, a more exhaustive search algorithm is enabled that can exceed the specified angle range. In this case, the specified angle range is used as a starting reference for the search instead of as a search restriction. In some cases, the target code occurrence might be inverted. For linear code types, use McodeControl() with M_CODE_FLIP set to M_FLIP to have linear code occurrences read from right-to-left (as opposed to the standard left-to-right), before trying to read the code occurrence. If you use the setting M_ANY, MIL will decide whether the code occurrence needs to be flipped or not. The default value for M_CODE_FLIP is M_NO_FLIP. If M_CODE_FLIP does not support the code type of a code occurrence that is inverted, you can flip the code occurrence vertically or horizontally using MimFlip(). For 2D code types, the rotation is calculated as the angle between the bottom of the code and the X-axis of the input coordinate system. The bottom of the code is found reading the finder pattern to determine the orientation of the code. The images below show how the angle is affected by the code being rotated or flipped. Dot spacing Sometimes 2D matrix code occurrences are composed of dots, such as when a code occurrence is punched into an object. In an ideal situation, the cell containing the dot (and its surrounding border of white space) matches the expected cell size for your code type. However, often in these cases, the dots have some spacing between them, which can make the code occurrence more difficult to read. For best results, set the dot spacing using McodeControl() with M_DOT_SPACING_MIN and M_DOT_SPACING_MAX. Set each to a range that covers half the pixel distance between dots. If a 2D code occurrence composed of dots is printed rather than punched, and the cells overlap due to printing artifacts or ink spread, set M_DOT_SPACING_MIN to the minimum negative half the width of the overlap. Set M_DOT_SPACING_MAX to a value greater than M_DOT_SPACING_MIN, but keep the difference between the two relatively small. Note that for the DotCode code type, the dot spacing control types are ignored; for this code type, specify the dot size instead, using McodeControl() with M_DOT_SIZE. It is recommended to only use a negative dot spacing when the dots are much larger than the expected cell size (typically, when the dots overlap). In the image below, the gray circle represents the actual cell size, while the black dot represents the expected cell size. In this case, specifying a negative dot spacing will assist with future McodeRead() and McodeGrade() operations. Alternatively, when successive dots are not touching, setting a positive dot spacing will increase the overall size of the cells (that is, the space taken by the dots and the surrounding border of white space for each dot) until they reach the expected cell size. In the image below, there is an abundance of space between the dots. In this case, setting a positive dot spacing equal to half the distance between the dots will assist with future McodeRead() and McodeGrade() operations. The following is an example of a code occurrence that might need you to specify the dot spacing since its dots are too far apart. By changing the dot spacing better results might be obtained. The image on the right shows how MIL interprets the image after applying positive dot spacing. If the dots are too close together, specifying a negative dot spacing might result in better results. The image on the right shows how MIL interprets the image after applying negative dot spacing. String size You can optionally specify the size of the string encoded in the code occurrence to locate, using McodeControl() with M_STRING_SIZE_MIN and M_STRING_SIZE_MAX. Note that for M_QRCODE, M_MICROQRCODE, M_COMPOSITECODE, and M_GS1_DATABAR code types, the minimum and maximum string size is ignored when performing McodeRead() and McodeGrade() operations. If you have set M_ERROR_CORRECTION to M_ECC_CHECK_DIGIT, McodeRead() and McodeGrade() assume that there is a check digit at the end of the string. The specified string size should not include the check digit, since the check digit is not returned as part of the string. The following table lists code types that require a minimum and maximum string size to be specified: Code type String size Minimum Maximum M_POSTNET 5, 9, or 11 5, 9 or 11 M_PLANET 11 or 13 11 or 13 M_CODABAR 3 – M_EAN8 8 8 M_EAN13 13 13 M_UPC_A and M_UPC_E 12 12 Reading EAN 14 code types Strings encoded with the EAN 14 code type typically start with \"(01)\", which helps to identify the encoding type of the string. The string can be either 13 or 14 digits in length. Note that the string length should not include \"(01)\". The optional fourteenth digit is a check digit calculated based on the first 13-digits according to Modulo 10. Reading GS1-128 code types Strings encoded with the GS1-128 code type typically start with a two-digit number inside parentheses (for example, (13)). The parentheses surrounding the number will not be read as part of the encoded string, as long as the number matches one of the valid application identifiers for GS1-128 (UCC/EAN-128). If this number is invalid, the parentheses are read as normal characters. Distortion and deterioration If the code occurrence is distorted and/or deteriorated, McodeRead() and McodeGrade() might not be able to read it. In this case, you can apply a distortion compensation algorithm that increases the robustness of the operation. There are different algorithms that you can use, depending on the code type and the type of distortion present in the code occurrence. Aztec, Data Matrix, DotCode, and QR code types For an Aztec, Data Matrix, DotCode, or QR code occurrence that has different column widths or row heights, use McodeControl() with M_DECODE_ALGORITHM set to M_CODE_DEFORMED. This algorithm can also work in the presence of perspective distortion. The M_CODE_DEFORMED value is only available for these code types. This algorithm can be used for Data Matrix code occurrences that are skewed but still maintain parallelism, and those that are skewed beyond parallelism. When there is noise, damage, or distortion in the finder pattern, you can limit how much deviation to tolerate. Use M_FINDER_PATTERN_MAX_GAP to set the maximum allowable size of a gap (unintended space) in the finder pattern. Use M_FINDER_PATTERN_MINIMUM_LENGTH to set the minimum acceptable length of one of the \"arms\" of the finder pattern. Except for the DotCode type, in cases where the clock pattern/fixed pattern is too noisy but the code occurrence does not have any distortion (or only a very small amount of distortion), try setting M_DECODE_ALGORITHM to M_CODE_NOT_DEFORMED. Note that the use of a distortion compensation algorithm can lead to longer processing times for Aztec, Data Matrix, and QR code types; for optimal speed and robustness, it is best to adjust your setup instead. For the DotCode code type, M_CODE_DEFORMED is more efficient and robust than M_CODE_NOT_DEFORMED. PDF417 and TruncatedPDF417 code types You can read deteriorated and distorted PDF417 and TruncatedPDF417 code types using McodeControl() with M_DECODE_ALGORITHM set to M_SCANLINE_AT_ANGLE. For example, you can read PDF417 codes that are missing their first and/or last bar or are degraded. To use this functionality, you must use the controls M_SEARCH_ANGLE, M_SEARCH_ANGLE_DELTA_NEG, M_SEARCH_ANGLE_DELTA_POS, and M_SEARCH_ANGLE_STEP. When decoding, McodeRead() and McodeGrade() will rotate the scanlines using the values set by these control types and try to decode without assuming the complete integrity of the codes. Thresholding McodeRead() and McodeGrade() internally binarize the source image so as to separate code occurrences from the background. By default, the threshold value is automatically chosen and is suitable in most cases. However, if you think that a different thresholding mode and/or value would result in a better separation (and therefore in a more efficient operation), you can manually adjust these, using McodeControl() with M_THRESHOLD_MODE and M_THRESHOLD_VALUE, respectively. If the lighting is not uniform across the code occurrence (see the image below for an example) and dealing with 2D matrix code types, MicroPDF417, or linear code types (excluding 4-state, Planet and Postnet), use M_THRESHOLD_MODE with M_ADAPTIVE. This adaptive threshold mode computes, for each pixel, a threshold value based on the pixel's neighborhood. When dealing with linear code types (excluding 4-state, Planet, and Postnet) and using adaptive thresholding, you must specify the minimum contrast (McodeControl() with M_MINIMUM_CONTRAST) between the foreground and background in the target image so that McodeRead() and McodeGrade() reads the code occurrence properly. Valid values are between 1 and 255. The default value is 50. Generally, increasing the minimum contrast will make McodeRead() more robust to non-uniform lighting or noise so that the code occurrence is readable; however, in some instances, it could make a readable code occurrence unreadable. For example, if the contrast between a valid foreground pixel and its background is 25, and you set the minimum contrast to 50, the pixel will not be considered as a foreground pixel. Therefore, it is important to make sure that the minimum contrast value is not causing the operation to ignore code features. In most cases, you can probably estimate an appropriate minimum contrast by looking at your image. When dealing with 2D code types, the minimum contrast is automatically determined, so the adaptive threshold mode ignores the M_MINIMUM_CONTRAST setting. If you are having problems reading a code, try adjusting the minimum contrast using M_MINIMUM_CONTRAST with McodeControl(). Determining whether your code type supports GS1 While some code types have GS1 in their constant names (such as M_GS1_128 and M_GS1_DATABAR), many that can support GS1 do not. It could be instead specified by its subtype and/or its encoding scheme. To determine these values, use McodeInquire() with M_SUB_TYPE and M_ENCODING, respectively. For a listing of encoding and subtypes, see the Supported encoding scheme for composite codes subsection of the Supported encoding schemes, sub-types, and error correction schemes by code type section earlier in this chapter. The simplest way to determine whether your code type follows the industry standard for a GS1 Databar code (for linear codes and composite codes) or a GS1 symbology (for 2D codes), use McodeGetResult() with M_IS_GS1. This result type is available for Aztec, Data Matrix, DotCode, Code 128, EAN-14, GS1-128, GS1-Databar, QR codes, and composite codes. If M_IS_GS1 returns true, you can set McodeControl() with M_STRING_FORMAT to M_GS1_HUMAN_READABLE to specify that the returned string is human-readable (that is, contains GS1 Application Identifiers or separator strings, in brackets), or M_RAW_DATA to retrieve the string in a raw data format with separator characters. In the following GS-128 code sample, the raw format returns the following string: è010123456789012815051231. The human-readable version of this string, is returned as follows: (01)01234567890128(15)051231. Customizing read and grade operation settings Reading and grading multiple occurrences Child buffers Regions of interest Presearching Foreground color Setting the search speed Timing out your search Cell size and number Search angular range Dot spacing String size Reading EAN 14 code types Reading GS1-128 code types Distortion and deterioration Aztec, Data Matrix, DotCode, and QR code types PDF417 and TruncatedPDF417 code types Thresholding Determining whether your code type supports GS1 ",
      "wordCount": 3959,
      "subEntries": []
    },
    {
      "id": "UG_codes_Customizing_write_operation_settings",
      "version": null,
      "title": "Customizing write operation settings",
      "subTitles": [
        "Destination buffer size",
        "Special characters",
        "Foreground color",
        "Cell size, number, and shape",
        "Bearer bars",
        "Writing EAN 14 code types",
        "Writing GS1-128 code types"
      ],
      "location": "MIL UG P03: 2D processing and analysis",
      "pageURL": "content\\UserGuide\\codes\\Customizing_write_operation_settings.htm",
      "text": " Customizing write operation settings This section provides information to consider and describes settings that you might have to change for write operations. It is strongly recommended that you define your codes as completely as possible using the available control settings, since it will facilitate reading them later on. When writing a code, ensure that you are familiar with the requirements and restrictions of your chosen code type; otherwise, the code will not be generated and a MIL error will result. Destination buffer size The destination image buffer of the write operation should be large enough to hold the encoded string. For a given code type, cell size, and string, you can inquire about the minimum buffer size required by first calling McodeWrite() with its image buffer parameter set to M_NULL and then using McodeGetResult() with M_WRITE_SIZE_X and M_WRITE_SIZE_Y. Special characters If you need to encode unprintable characters, such as a carriage return or tab, use a code type that supports them. If you use McodeWrite() with M_ESCAPE_SEQUENCE, you can use ASCII codes to encode all unprintable characters. In the string to encode, the unprintable character's ASCII code must be in hexadecimal format and be preceded by \\x (for example, \\x0D for ASCII 13, which is the carriage return). If you want to encode the \"\\\" character in escape sequence mode, type \"\\\\\". The encoded string for a Codabar code type must be numeric, but can contain the following characters: minus (-), dollar sign ($), colon (:), slash (/), period (.), and plus (+). In addition, the string must start and end with any of the following characters: a, b, c, or d. The encoded string for a Maxicode code type with the M_ENC_MODE2 or M_ENC_MODE3 encoding scheme, must respect the structured carrier message format (the portion of the string that contains postal code, country code, and class of service information). Foreground color Setting the foreground color is essential for write operations. To set the foreground color, use McodeControl() with M_FOREGROUND_VALUE. The default foreground color is black. Cell size, number, and shape In most cases, you should not have to specify the cell size when writing codes; the default setting (McodeControl() with M_CELL_SIZE_MIN set to M_DEFAULT) is sufficient. In this case, the code is resized so as to just fit into the destination image of the operation, when possible. During a write operation, you can use McodeControl() with M_CELL_SIZE_MIN to force the cell size; the cell size is used to determine the size of the generated code. If you specify the required cell size with McodeControl(), you should ensure that the destination image has an appropriate size. See the Destination buffer size subsection of this section. The M_CELL_SIZE_MAX control type is not used in write operations. During a write operation, the number of cells will be automatically chosen to minimize the code written. To specify the number of cells in a 2D code, use McodeControl() with M_CELL_NUMBER_X and M_CELL_NUMBER_Y. If you specify more cells than are necessary to generate the code, fill characters will automatically be added. If you specify fewer cells than are necessary to generate the code, you will get a MIL error. Specifying the number of cells is mostly useful when writing PDF417, Truncated PDF417, Data Matrix, and QRCodes code types; the Maxicode code type has a fixed number of cells. If you specify fewer cells than are necessary to generate a DotCode, a code with the same aspect ratio at an appropriate size will be generated. For the PDF417 code type, M_CELL_NUMBER_X must equal 17c + 35, where c is the number of columns, and 35 represents the number of cells required for the start and stop patterns. For the Truncated PDF417 code type, M_CELL_NUMBER_X must equal 17c + 18, where c is the number of columns, and 18 represents the number of cells required for the start patterns. For Aztec, Data Matrix, DotCode, QR code, and Micro QR code types, you can specify the shape and size of the dots used to draw foreground cells by calling McodeControl() with M_DOT_SHAPE and M_DOT_SIZE, respectively. M_DOT_SIZE is useful for replicating real world situations where ink might bleed into neighboring cells, or not fill the cells. By default, the dot size is the same as the cell size. Bearer bars Note that MIL does not generate bar codes with bearer bars. To generate a code with bearer bars, generate the required code and then draw a rectangle at the top and bottom of the code using MgraRectFill(); the minimum width of the bearer bar (height of the rectangle) must respect the specifications of your code type. Writing EAN 14 code types Strings encoded with the EAN 14 code type should all start with \"(01)\", which helps to identify the encoding type of the string. If, for some reason, the string to encode does not start with \"(01)\", McodeWrite() will add it automatically. The string to encode as an EAN 14 code can be either 13 or 14 digits in length. The optional fourteenth digit is a check digit calculated based on the first 13 digits according to Modulo 10. If the fourteenth digit is provided, MIL will validate it. If it is not provided, however, MIL will calculate it and add it. Writing GS1-128 code types Strings encoded with the GS1-128 code type typically start with a two-digit number inside parentheses (for example, (13)). The parentheses surrounding the number will not be written as part of the encoded string, as long as the number matches one of the valid application identifiers for GS1-128 (EAN/UCC_128). If this number is invalid, the parentheses are written as normal characters in the code. Customizing write operation settings Destination buffer size Special characters Foreground color Cell size, number, and shape Bearer bars Writing EAN 14 code types Writing GS1-128 code types ",
      "wordCount": 969,
      "subEntries": []
    },
    {
      "id": "UG_codes_Retrieving_results",
      "version": null,
      "title": "Retrieving results",
      "subTitles": [
        "Drawing results"
      ],
      "location": "MIL UG P03: 2D processing and analysis",
      "pageURL": "content\\UserGuide\\codes\\Retrieving_results.htm",
      "text": " Retrieving results To retrieve results for all occurrences of all code models (or in the case of an McodeTrain() operation, for all code models), use McodeGetResult() with M_ALL and the result type for the result that you want returned. To retrieve a result for a specific code model occurrence (or in the case of an McodeTrain() operation, for a specific code model), use McodeGetResult() with the index of the occurrence. To increase efficiency when browsing result types, use filters to limit table values to those of interest based on operation type and code type. To retrieve the success of an McodeRead(), McodeGrade(), McodeTrain(), or McodeWrite() operation, use M_STATUS. A positive status is returned only when all conditions, set for all the code models, are met. Note that when reading multiple code occurrences and more than one McodeRead() operation fails, the error returned is the one you should probably fix first. For example, if you try to read two codes and one fails because the code was not found (M_STATUS_NOT_FOUND) and the other fails because the encoding type was unknown (M_STATUS_ENC_UNKNOWN), the latter is returned. Every occurrence of every code model is associated with a unique index within the result buffer after a successful code operation. When using McodeGetResult(), you must specify the index of the occurrence for which to retrieve results. The following table presents an example of a code result buffer, showing the result occurrence index, code model index, angle, and string for 6 occurrences of 4 models in a context. If, for instance, you wanted to get additional results about only one of these occurrences, you should pass the result occurrence index to McodeGetResult() along with the required result type. Results are ordered in the sequence that they are found. Result type Result occurrence index 0 1 2 3 4 5 M_CODE_MODEL_INDEX 3 3 1 0 2 0 M_ANGLE 9.0 7.0 2.0 4.0 0.0 0.0 M_STRING First occurrence of code model 3 Second occurrence of code model 3 Only occurrence of code model 1 First occurrence of code model 0 Only occurrence of code model 2 Second occurrence of code model 0 The result occurrence index is not explicitly returned by any function in the MIL Code module, instead it must be deduced from the order in which the results are returned by McodeGetResult(); results are always indexed in ascending order starting from zero. To retrieve the number of occurrences in a code result buffer, use McodeGetResult() with M_NUMBER. For each code occurrence read, you can retrieve the decoded string or the length of the string, using McodeGetResult() with M_STRING or M_STRING_SIZE, respectively. Combining M_ESCAPE_SEQUENCE with M_STRING will return the string with unprintable characters represented by their ASCII code (in hexadecimal notation, prefixed by \\x). Combining M_ESCAPE_SEQUENCE with M_STRING_SIZE will return the length of the decoded string with the ASCII characters used to represent unprintable characters included in the count. Drawing results The McodeDraw() function provides several operations for drawing results in any specified image buffer or 2D graphics list. By drawing into the display's overlay buffer or associating the 2D graphics list with the display, you can also annotate an image non-destructively (see the Annotating the displayed image non-destructively section of Chapter 25: Displaying an image). You can use a previously allocated 2D graphics context (see Chapter 26: Generating graphics) to control the drawing color, or use the default 2D graphics context (M_DEFAULT). Supported drawing operations include drawing the bounding box of the specified code occurrence (using M_DRAW_BOX) or a cross-like symbol at the mid-point of the code occurrence (using M_DRAW_POSITION). McodeDraw() can draw the code with its quiet zone (using M_DRAW_QUIET_ZONE) and (optionally) the extended area (using M_DRAW_EXTENDED_AREA). McodeDraw() can draw the scan path (using M_DRAW_SCAN_PROFILES) or the scan reflectance profiles of the code (M_DRAW_REFLECTANCE_PROFILE), as analyzed by the grade operation. The scan reflectance profile is generated from sampling the code along a single scan path using a specific aperture. The following is an example of a scan reflectance profile of the code. Unless otherwise specified, all scan paths will be drawn. To draw the path of a specific scan reflectance profile, specify the index of the scan reflectance profile using the ResultIndex parameter of McodeDraw(). The following is an example of 10 scan paths drawn over the existing image of the code. When drawing composite codes, you can draw either the 2D (M_2D_COMPONENT) or the 1D (M_LINEAR_COMPONENT) component of the code. Retrieving results Drawing results ",
      "wordCount": 742,
      "subEntries": []
    },
    {
      "id": "UG_codes_A_code_example",
      "version": null,
      "title": "A code example",
      "subTitles": null,
      "location": "MIL UG P03: 2D processing and analysis",
      "pageURL": "content\\UserGuide\\codes\\A_code_example.htm",
      "text": " A code example The code example MCode.cpp decodes a Code 39 (1D) code and a Data Matrix (2D) code. Specifically, MCode.cpp reads two different types of codes, using regions to limit the area in which they are found, using the Code functions in conjunction with other MIL functions. It then outlines the codes in the image, identifies the code types and decodes their strings, printing the results to the display. mcode.cpp To run this example, use the Matrox Example Launcher in the MIL Control Center. A code example ",
      "wordCount": 90,
      "subEntries": []
    }
  ]
}]
[{
  "id": "Example_PlaceHolder_ID",
  "version": "2024020714",
  "title": "Example_PlaceHolder_Title",
  "wordCount": 0,
  "subEntries": [
    {
      "id": "Examples_Processing_3dCalibration_2DCameraTo3DCameraMapping_CPP_2dcamerato3dcameramapping_cpp",
      "version": "2024020714",
      "title": "2dcamerato3dcameramapping.cpp",
      "location": "Sample Code from MIL Examples",
      "text": " Top //***************************************************************************************/ // // File name: 2DTo3DCameraMapping.cpp // Location: See Matrox Example Launcher in the MIL Control Center // // // Synopsis: This program contains an example of mapping a 2D camera image of a // scene to a 3D camera image of the same scene. // // Printable calibration grids in PDF format can be found in your \"Matrox Imaging/Images/\" // directory. // // Copyright (C) Matrox Electronic Systems Ltd., 1992-2024. // All Rights Reserved //**************************************************************************************/ #include &lt;mil.h&gt; #include &lt;cmath&gt; #include \"Utilities.h\" //**************************************************************************** // Structures. //**************************************************************************** struct SData { MIL_CONST_TEXT_PTR Color; MIL_CONST_TEXT_PTR Range; MIL_CONST_TEXT_PTR Grayscale; }; //**************************************************************************** // Constants. //**************************************************************************** // Info about the grid used for both cameras static const MIL_INT GRID_ROW_NUMBER = 18; // RowNumber static const MIL_INT GRID_COLUMN_NUMBER = 22; // ColumnNumber static const MIL_DOUBLE GRID_ROW_SPACING = 10; // RowSpacing (in mm) static const MIL_DOUBLE GRID_COLUMN_SPACING = 10; // ColumnSpacing (in mm) static const MIL_INT GRID_TYPE = M_CIRCLE_GRID; static const MIL_DOUBLE GRID_CIRCLE_RADIUS = 2.5; // Circle Radius (in mm) static const MIL_INT NB_CALIBRATION_IMAGES = 12; static const MIL_DOUBLE PI = 3.14159265358979323846; static const MIL_INT NB_CIRCLE_PTS = 8; static const MIL_DOUBLE RADIUS_MULTIPLIER = 1.4; static const MIL_DOUBLE DELTA_ANGLE = 2.0 * PI / (MIL_DOUBLE)NB_CIRCLE_PTS; //**************************************************************************** // Example files. //**************************************************************************** #define EX_PATH M_IMAGE_PATH MIL_TEXT(\"2DCameraTo3DCameraMapping/\") static const SData CALIBRATION_DATA[NB_CALIBRATION_IMAGES] = { {EX_PATH MIL_TEXT(\"Color1.mim\"), EX_PATH MIL_TEXT(\"TOFRange1.mbufc\") , EX_PATH MIL_TEXT(\"TOFGray1.mim\")}, {EX_PATH MIL_TEXT(\"Color2.mim\"), EX_PATH MIL_TEXT(\"TOFRange2.mbufc\") , EX_PATH MIL_TEXT(\"TOFGray2.mim\")}, {EX_PATH MIL_TEXT(\"Color3.mim\"), EX_PATH MIL_TEXT(\"TOFRange3.mbufc\") , EX_PATH MIL_TEXT(\"TOFGray3.mim\")}, {EX_PATH MIL_TEXT(\"Color4.mim\"), EX_PATH MIL_TEXT(\"TOFRange4.mbufc\") , EX_PATH MIL_TEXT(\"TOFGray4.mim\")}, {EX_PATH MIL_TEXT(\"Color5.mim\"), EX_PATH MIL_TEXT(\"TOFRange5.mbufc\") , EX_PATH MIL_TEXT(\"TOFGray5.mim\")}, {EX_PATH MIL_TEXT(\"Color6.mim\"), EX_PATH MIL_TEXT(\"TOFRange6.mbufc\") , EX_PATH MIL_TEXT(\"TOFGray6.mim\")}, {EX_PATH MIL_TEXT(\"Color7.mim\"), EX_PATH MIL_TEXT(\"TOFRange7.mbufc\") , EX_PATH MIL_TEXT(\"TOFGray7.mim\")}, {EX_PATH MIL_TEXT(\"Color8.mim\"), EX_PATH MIL_TEXT(\"TOFRange8.mbufc\") , EX_PATH MIL_TEXT(\"TOFGray8.mim\")}, {EX_PATH MIL_TEXT(\"Color9.mim\"), EX_PATH MIL_TEXT(\"TOFRange9.mbufc\") , EX_PATH MIL_TEXT(\"TOFGray9.mim\")}, {EX_PATH MIL_TEXT(\"Color10.mim\"), EX_PATH MIL_TEXT(\"TOFRange10.mbufc\"), EX_PATH MIL_TEXT(\"TOFGray10.mim\")}, {EX_PATH MIL_TEXT(\"Color11.mim\"), EX_PATH MIL_TEXT(\"TOFRange11.mbufc\"), EX_PATH MIL_TEXT(\"TOFGray11.mim\")}, {EX_PATH MIL_TEXT(\"Color12.mim\"), EX_PATH MIL_TEXT(\"TOFRange12.mbufc\"), EX_PATH MIL_TEXT(\"TOFGray12.mim\")} }; MIL_CONST_TEXT_PTR COLOR_SCENE_DATA = EX_PATH MIL_TEXT(\"GiftBoxesColor.mim\"); MIL_CONST_TEXT_PTR TOF_SCENE_RANGE_DATA = EX_PATH MIL_TEXT(\"GiftBoxesRange.mbufc\"); //**************************************************************************** // Function declarations. //**************************************************************************** void PrintHeader(); MIL_INT ExecuteZhangCalibration(MIL_ID MilSystem, MIL_ID MilCalibration); void AddCalibrationGrid(MIL_ID MilCalibration, MIL_ID MilDisplayImage, MIL_ID MilGraphicList, MIL_INT ImageIndex); void PrintCalibrationErrors(MIL_ID MilCalibration, MIL_ID MilGraphicList); MIL_UNIQUE_3DGEO_ID FindCameraRigidMatrix(MIL_ID MilSystem, MIL_ID MilColorCal); void ExtractGridLocations(MIL_ID MilSystem, MIL_ID MilGridGrayscale, MIL_ID MilGridRange, SVector3D&lt;MIL_DOUBLE&gt;&amp; GridPointsCamera); MIL_UNIQUE_3DGEO_ID ComputeRigidMatrixTransformation(MIL_ID MilSystem, const SVector3D&lt;MIL_FLOAT&gt;&amp; SrcPts, const SVector3D&lt;MIL_FLOAT&gt;&amp; TargetPts); void MapColorToPointCloud(MIL_ID MilSystem, MIL_ID MilColorCalibration, MIL_ID MilSceneContainer, MIL_ID MilColorBuffer, MIL_ID MilTOFToColorMatrixTrans); void InterpolateColorAtPixels(MIL_ID MilSystem, MIL_ID MilColorBuffer, MIL_ID MilSceneContainer3D, const SVector2D&lt;MIL_DOUBLE&gt;&amp; PixelCoordR); //***************************************************************************** // Prints the example's description. //***************************************************************************** void PrintHeader() { MosPrintf(MIL_TEXT(\"[EXAMPLE NAME]\\n\") MIL_TEXT(\"2DCameraTo3DCameraMapping\\n\\n\") MIL_TEXT(\"[SYNOPSIS]\\n\") MIL_TEXT(\"This example shows how to map a 2D camera image of a scene\\n\") MIL_TEXT(\"to a 3D camera image of the same scene.\\n\\n\") MIL_TEXT(\"[MODULES USED]\\n\") MIL_TEXT(\"Modules used: Application, System, Display, Graphics, Buffer,\\n\") MIL_TEXT(\"Calibration, 3D Image Processing, 3D Display, 3D Geometry, and 3D Graphics.\\n\\n\")); } //***************************************************************************** // Calibrates a color camera using the Zhang method. //***************************************************************************** MIL_INT ExecuteZhangCalibration(MIL_ID MilSystem, MIL_ID MilCalibration) { // Set a 2D display. auto MilDisplay = MdispAlloc(MilSystem, M_DEFAULT, MIL_TEXT(\"M_DEFAULT\"), M_DEFAULT, M_UNIQUE_ID); MdispControl(MilDisplay, M_TITLE, MIL_TEXT(\"Calibration grid\")); MdispControl(MilDisplay, M_WINDOW_INITIAL_SIZE_X, DISPLAY_2D_SIZE_X); MdispControl(MilDisplay, M_WINDOW_INITIAL_SIZE_Y, DISPLAY_2D_SIZE_Y); MdispControl(MilDisplay, M_SCALE_DISPLAY, M_ENABLE); auto MilGraphicList = MgraAllocList(MilSystem, M_DEFAULT, M_UNIQUE_ID); MdispControl(MilDisplay, M_ASSOCIATED_GRAPHIC_LIST_ID, MilGraphicList); // Allocate an image buffer to load the calibration captures. const auto SizeX = MbufDiskInquire(CALIBRATION_DATA[0].Color, M_SIZE_X, M_NULL); const auto SizeY = MbufDiskInquire(CALIBRATION_DATA[0].Color, M_SIZE_Y, M_NULL); auto MilDisplayImage = MbufAllocColor(MilSystem, 3, SizeX, SizeY, 8 + M_UNSIGNED, M_IMAGE + M_PROC + M_DISP, M_UNIQUE_ID); MbufClear(MilDisplayImage, 0.0); MdispSelect(MilDisplay, MilDisplayImage); MdispControl(MilDisplay, M_VIEW_MODE, M_AUTO_SCALE); // Add each calibration grid capture to calibration context. MosPrintf(MIL_TEXT(\"A set of captures of the calibration grid at different poses\\n\")); MosPrintf(MIL_TEXT(\"will be accumulated by the calibration context.\\n\\n\")); for(MIL_INT ImageIndex = 0; ImageIndex &lt; NB_CALIBRATION_IMAGES; ++ImageIndex) { MosPrintf(MIL_TEXT(\"Adding calibration grid #%d/%d to the calibration context...\\r\"), ImageIndex + 1, NB_CALIBRATION_IMAGES); AddCalibrationGrid(MilCalibration, MilDisplayImage, MilGraphicList, ImageIndex); } MosPrintf(MIL_TEXT(\"\\n\\n\")); MosPrintf(MIL_TEXT(\"The calibration will now be performed. This can take a few seconds...\\n\\n\")); MdispSelect(MilDisplay, M_NULL); // Calibrate the camera. MappTimer(M_TIMER_RESET, M_NULL); McalGrid(MilCalibration, M_NULL, M_NULL, M_NULL, M_NULL, M_NULL, M_NULL, M_NULL, M_NULL, M_DEFAULT, M_DEFAULT); const auto ComputationTime = MappTimer(M_TIMER_READ, M_NULL); // Verify that calibration succeeded. const auto CalibrationStatus = McalInquire(MilCalibration, M_CALIBRATION_STATUS, M_NULL); if(CalibrationStatus == M_CALIBRATED) { MosPrintf(MIL_TEXT(\"The calibration was successful and took %.3f s.\\n\"), ComputationTime); // Show calibration results. PrintCalibrationErrors(MilCalibration, MilGraphicList); WaitForKey(); } else { return M_FAIL; } return M_SUCCESS; } //***************************************************************************** // Adds a calibration grid to the calibration context. //***************************************************************************** void AddCalibrationGrid(MIL_ID MilCalibration, MIL_ID MilGridBuffer, MIL_ID MilGraphicList, MIL_INT ImageIndex) { // Load the image of the calibration grid to the display. MbufLoad(CALIBRATION_DATA[ImageIndex].Color, MilGridBuffer); // Add this grid (note the use of M_ACCUMULATE). McalGrid(MilCalibration, MilGridBuffer, 0.0, 0.0, 0.0, // GridOffset GRID_ROW_NUMBER, GRID_COLUMN_NUMBER, GRID_ROW_SPACING, GRID_COLUMN_SPACING, M_ACCUMULATE, GRID_TYPE); // Verify that the operation behaved as expected. const auto CalibrationStatus = McalInquire(MilCalibration, M_CALIBRATION_STATUS, M_NULL); if(CalibrationStatus == M_CALIBRATING) { // Draw the features extracted from the grid in the overlay (only for the first grid). if(ImageIndex == 0) { MgraControl(M_DEFAULT, M_COLOR, PIXEL_COLOR); McalDraw(M_DEFAULT, MilCalibration, MilGraphicList, M_DRAW_IMAGE_POINTS, ImageIndex, M_DEFAULT); MosPrintf(MIL_TEXT(\"\\n\\n\")); MosPrintf(MIL_TEXT(\"The image of the first calibration grid is shown.\\n\")); MosPrintf(MIL_TEXT(\"The extracted features, displayed in green, will be used to calibrate the camera.\\n\\n\")); WaitForKey(); } // Clear the graphic list. MgraClear(M_DEFAULT, MilGraphicList); } else { MosPrintf(MIL_TEXT(\"The grid was not found.\\n\\n\")); WaitForKey(); } } //***************************************************************************** // Prints the calibration errors. //***************************************************************************** void PrintCalibrationErrors(MIL_ID MilCalibration, MIL_ID MilGraphicList) { MIL_DOUBLE AveragePixelError, AverageWorldError; McalInquire(MilCalibration, M_GLOBAL_AVERAGE_PIXEL_ERROR, &amp;AveragePixelError); McalInquire(MilCalibration, M_GLOBAL_AVERAGE_WORLD_ERROR, &amp;AverageWorldError); MosPrintf(MIL_TEXT(\"The average calibration error is %.3f pixels or %.3f mm.\\n\\n\"), AveragePixelError, AverageWorldError); } //***************************************************************************** // Finds and returns the rigid matrix transformation from the 3D camera // to the color camera. //***************************************************************************** MIL_UNIQUE_3DGEO_ID FindCameraRigidMatrix(MIL_ID MilSystem, MIL_ID MilColorCal) { // Prepare 3D and 2D displays. auto Mil3DDisplay = Alloc3dDisplay(MilSystem, 0, 0, DISPLAY_3D_SIZE_X, DISPLAY_3D_SIZE_Y, MIL_TEXT(\"3D camera\")); auto GraList3D = (MIL_ID)M3ddispInquire(Mil3DDisplay, M_3D_GRAPHIC_LIST_ID, M_NULL); auto MilColorDisplay = Alloc2dDisplay(MilSystem, DISPLAY_3D_SIZE_X, 0, DISPLAY_2D_SIZE_X, DISPLAY_2D_SIZE_Y, MIL_TEXT(\"Color camera\")); auto MilGraListColor = MgraAllocList(MilSystem, M_DEFAULT, M_UNIQUE_ID); MdispControl(MilColorDisplay, M_ASSOCIATED_GRAPHIC_LIST_ID, MilGraListColor); const auto NbPoses = NB_CALIBRATION_IMAGES; const auto NbGridCircles = GRID_ROW_NUMBER * GRID_COLUMN_NUMBER; SVector3D&lt;MIL_FLOAT&gt; AllGridColorCam; SVector3D&lt;MIL_FLOAT&gt; AllGrid3DCam; SVector3D&lt;MIL_DOUBLE&gt; Grid3DCam; SVector3D&lt;MIL_DOUBLE&gt; GridColorWorld; SVector3D&lt;MIL_DOUBLE&gt; GridColorCam; AllGrid3DCam.reserve(NbPoses * NbGridCircles); AllGridColorCam.reserve(NbPoses * NbGridCircles); MosPrintf(MIL_TEXT(\"To compute the rigid matrix transformation between the two cameras,\\n\")); MosPrintf(MIL_TEXT(\"a set of captures of the calibration grid at %d different poses are used.\\n\\n\"), NbPoses); // Loop through each set of poses. for(MIL_INT Index = 0; Index &lt; NbPoses; ++Index) { MosPrintf(MIL_TEXT(\"Processing pose #%d/%d...\\r\"), Index + 1, NbPoses); // Restore depth, grayscale, and color images of current pose. auto MilContainer = MbufRestore(CALIBRATION_DATA[Index].Range, MilSystem, M_UNIQUE_ID); MIL_ID RangeId = MbufInquireContainer(MilContainer, M_COMPONENT_RANGE, M_COMPONENT_ID, M_NULL); auto Mil3DGrayscaleBuffer = MbufRestore(CALIBRATION_DATA[Index].Grayscale, MilSystem, M_UNIQUE_ID); auto MilColorBuffer = MbufRestore(CALIBRATION_DATA[Index].Color, MilSystem, M_UNIQUE_ID); // Extract positions of the grid points in the 3D camera coordinate system. ExtractGridLocations(MilSystem, Mil3DGrayscaleBuffer, RangeId, Grid3DCam); // Retrieve the positions of the grid points in the world coordinate system, // from the color image. McalGrid(MilColorCal, MilColorBuffer, 0.0, 0.0, 0.0, // GridOffset GRID_ROW_NUMBER, GRID_COLUMN_NUMBER, GRID_ROW_SPACING, GRID_COLUMN_SPACING, M_DISPLACE_CAMERA_COORD, GRID_TYPE); McalInquire(MilColorCal, M_CALIBRATION_WORLD_POINTS_X, GridColorWorld.Xs); McalInquire(MilColorCal, M_CALIBRATION_WORLD_POINTS_Y, GridColorWorld.Ys); McalInquire(MilColorCal, M_CALIBRATION_WORLD_POINTS_Z, GridColorWorld.Zs); // Display the point cloud and the color image. auto PCLabel = M3ddispSelect(Mil3DDisplay, MilContainer, M_SELECT, M_DEFAULT); M3ddispSetView(Mil3DDisplay, M_VIEW_ORIENTATION, M_BOTTOM_VIEW, M_DEFAULT, M_DEFAULT, M_DEFAULT); M3ddispSetView(Mil3DDisplay, M_DISTANCE, CAMERA_3D_DISTANCE, M_DEFAULT, M_DEFAULT, M_DEFAULT); MdispSelect(MilColorDisplay, MilColorBuffer); // Display the grid points (only for first pose). if(Index == 0) { auto GridPtsLabel = M3dgraDots(GraList3D, M_ROOT_NODE, M_DEFAULT, Grid3DCam.Xs, Grid3DCam.Ys, Grid3DCam.Zs, M_NULL, M_NULL, M_NULL, M_DEFAULT); M3dgraControl(GraList3D, GridPtsLabel, M_COLOR, WORLD_COLOR); M3dgraControl(GraList3D, GridPtsLabel, M_THICKNESS, GRID_PT_THICKNESS); auto MilGraContext = MgraAlloc(MilSystem, M_UNIQUE_ID); MgraControl(MilGraContext, M_COLOR, PIXEL_COLOR); McalDraw(MilGraContext, MilColorCal, MilGraListColor, M_DRAW_IMAGE_POINTS, Index, M_DEFAULT); MosPrintf(MIL_TEXT(\"\\n\\n\")); MosPrintf(MIL_TEXT(\"The point cloud and the color image of the first pose are shown.\\n\")); MosPrintf(MIL_TEXT(\"The grid points' location in the 3D camera coordinate system (red) and\\n\")); MosPrintf(MIL_TEXT(\"in the color camera coordinate system (green) are extracted and stored\\n\")); MosPrintf(MIL_TEXT(\"for the computation of the transformation matrix.\\n\\n\")); WaitForKey(); M3dgraRemove(GraList3D, GridPtsLabel, M_DEFAULT); MgraClear(MilGraContext, MilGraListColor); } else { // Sleep for display visualization purposes. MosSleep(SLEEP_TIME); } if(GridColorWorld.size() != Grid3DCam.size()) { MosPrintf(MIL_TEXT(\"Error - The number of 2D points do not match the number of 3D points.\\n\\n\")); continue; } // Transform the grid points from world coordinate system // to the color camera's coordinate system. GridColorCam.resize(GridColorWorld.size()); McalTransformCoordinate3dList(MilColorCal, M_ABSOLUTE_COORDINATE_SYSTEM, M_CAMERA_COORDINATE_SYSTEM, M_DEFAULT, GridColorWorld.Xs, GridColorWorld.Ys, GridColorWorld.Zs, GridColorCam.Xs, GridColorCam.Ys, GridColorCam.Zs, M_DEFAULT); // Store the current pose's grid points in both // camera's coordinate systems. for(MIL_INT i = 0; i &lt; (MIL_INT)Grid3DCam.size(); ++i) { AllGrid3DCam.push_back((MIL_FLOAT)Grid3DCam.Xs[i], (MIL_FLOAT)Grid3DCam.Ys[i], (MIL_FLOAT)Grid3DCam.Zs[i]); AllGridColorCam.push_back((MIL_FLOAT)GridColorCam.Xs[i], (MIL_FLOAT)GridColorCam.Ys[i], (MIL_FLOAT)GridColorCam.Zs[i]); } } M3ddispSelect(Mil3DDisplay, M_NULL, M_CLOSE, M_DEFAULT); MosPrintf(MIL_TEXT(\"\\n\\n\")); MosPrintf(MIL_TEXT(\"The computation of the transformation matrix will now be performed...\\n\\n\")); // Compute the transformation matrix. auto MilTOFToColorTransMatrix = ComputeRigidMatrixTransformation(MilSystem, AllGrid3DCam, AllGridColorCam); return MilTOFToColorTransMatrix; } //***************************************************************************** // Given a grayscale and a noisy range image of a calibration grid, // extracts the grid points in the camera coordinate system. //***************************************************************************** void ExtractGridLocations(MIL_ID MilSystem, MIL_ID MilGrayscaleGridBuffer, MIL_ID MilRangeGridBuffer, SVector3D&lt;MIL_DOUBLE&gt;&amp; GridPointsCamera) { // Extract the grid points in the pixel coordinate system. auto MilCalibration = McalAlloc(MilSystem, M_LINEAR_INTERPOLATION, M_DEFAULT, M_UNIQUE_ID); McalGrid(MilCalibration, MilGrayscaleGridBuffer, 0.0, 0.0, 0.0, // GridOffset GRID_ROW_NUMBER, GRID_COLUMN_NUMBER, GRID_ROW_SPACING, GRID_COLUMN_SPACING, M_DEFAULT, GRID_TYPE); SVector2D&lt;MIL_DOUBLE&gt; GridPointsPixel; McalInquire(MilCalibration, M_CALIBRATION_IMAGE_POINTS_X, GridPointsPixel.Xs); McalInquire(MilCalibration, M_CALIBRATION_IMAGE_POINTS_Y, GridPointsPixel.Ys); // Transform the grid points to the world coordinate system. MIL_INT NbGridPoints = GridPointsPixel.size(); SVector2D&lt;MIL_DOUBLE&gt; GridPointsWorld; McalTransformCoordinateList(MilCalibration, M_PIXEL_TO_WORLD, M_DEFAULT, GridPointsPixel.Xs, GridPointsPixel.Ys, GridPointsWorld.Xs, GridPointsWorld.Ys); // Depending on the technology used, many 3d cameras are inaccurate on dark objects. // Because the circles in the calibration grid are black, their 3d coordinates are // too noisy to be used directly. Instead, the coordinates of surrounding white points // are used to approximate the center of each circle. const auto WorldRadius = GRID_CIRCLE_RADIUS; SVector2D&lt;MIL_DOUBLE&gt; CircleSamplesWorld(NB_CIRCLE_PTS); SVector2D&lt;MIL_DOUBLE&gt; CirclePointsPixel(NB_CIRCLE_PTS); GridPointsCamera.resize(NbGridPoints); // For each grid point... for(MIL_INT i = 0; i &lt; NbGridPoints; i++) { // Uniformly sample points on a circle encompassing the grid circle. for(MIL_INT j = 0; j &lt; NB_CIRCLE_PTS; j++) { CircleSamplesWorld.Xs[j] = GridPointsWorld.Xs[i] + (WorldRadius * RADIUS_MULTIPLIER) * std::cos(DELTA_ANGLE * j); CircleSamplesWorld.Ys[j] = GridPointsWorld.Ys[i] + (WorldRadius * RADIUS_MULTIPLIER) * std::sin(DELTA_ANGLE * j); } // Retrieve the sample points in the 3D camera coordinate system. McalTransformCoordinateList(MilCalibration, M_WORLD_TO_PIXEL, M_DEFAULT, CircleSamplesWorld.Xs, CircleSamplesWorld.Ys, CirclePointsPixel.Xs, CirclePointsPixel.Ys); std::vector&lt;MIL_FLOAT&gt; CircleSamplesCamera; MbufGetList(MilRangeGridBuffer, M_DEFAULT, CirclePointsPixel.Xs, CirclePointsPixel.Ys, M_DEFAULT, CircleSamplesCamera); // Approximate the grid point as the center of the sample points. MIL_DOUBLE GridPointCameraX = 0; MIL_DOUBLE GridPointCameraY = 0; MIL_DOUBLE GridPointCameraZ = 0; for(MIL_INT j = 0; j &lt; NB_CIRCLE_PTS; j++) { GridPointCameraX += CircleSamplesCamera[j]; GridPointCameraY += CircleSamplesCamera[j + NB_CIRCLE_PTS]; GridPointCameraZ += CircleSamplesCamera[j + 2 * NB_CIRCLE_PTS]; } GridPointCameraX /= NB_CIRCLE_PTS; GridPointCameraY /= NB_CIRCLE_PTS; GridPointCameraZ /= NB_CIRCLE_PTS; // Store the grid point. GridPointsCamera.Xs[i] = GridPointCameraX; GridPointsCamera.Ys[i] = GridPointCameraY; GridPointsCamera.Zs[i] = GridPointCameraZ; } } //***************************************************************************** // Compute the rigid matrix transformation from the source // coordinate system to the target coordinate system. //***************************************************************************** MIL_UNIQUE_3DGEO_ID ComputeRigidMatrixTransformation(MIL_ID MilSystem, const SVector3D&lt;MIL_FLOAT&gt;&amp; SrcPts, const SVector3D&lt;MIL_FLOAT&gt;&amp; TargetPts) { // Put the source and target points in MIL arrays. const MIL_INT Size = SrcPts.size(); auto MilSrcPts = MbufAllocColor(MilSystem, 3, Size, 1, 32 + M_FLOAT, M_ARRAY, M_UNIQUE_ID); auto MilTgtPts = MbufAllocColor(MilSystem, 3, Size, 1, 32 + M_FLOAT, M_ARRAY, M_UNIQUE_ID); MbufPutColor(MilSrcPts, M_SINGLE_BAND, 0, SrcPts.Xs); MbufPutColor(MilSrcPts, M_SINGLE_BAND, 1, SrcPts.Ys); MbufPutColor(MilSrcPts, M_SINGLE_BAND, 2, SrcPts.Zs); MbufPutColor(MilTgtPts, M_SINGLE_BAND, 0, TargetPts.Xs); MbufPutColor(MilTgtPts, M_SINGLE_BAND, 1, TargetPts.Ys); MbufPutColor(MilTgtPts, M_SINGLE_BAND, 2, TargetPts.Zs); // Compute the transformation matrix. auto MilTOFToColorTransMatrix = M3dgeoAlloc(MilSystem, M_TRANSFORMATION_MATRIX, M_DEFAULT, M_UNIQUE_ID); auto MilTransResult = M3dimAllocResult(MilSystem, M_FIND_TRANSFORMATION_RESULT, M_DEFAULT, M_UNIQUE_ID); M3dimFindTransformation(M_FIND_TRANSFORMATION_CONTEXT_RIGID, MilSrcPts, MilTgtPts, MilTransResult, M_DEFAULT); // Verify computation was successful and print RMS error. const auto Status = M3dimGetResult(MilTransResult, M_STATUS, M_NULL); const auto RmsError = M3dimGetResult(MilTransResult, M_RMS_ERROR, M_NULL); if(Status == M_SUCCESS) { MosPrintf(MIL_TEXT(\"The transformation matrix was successfully found.\\n\")); MosPrintf(MIL_TEXT(\"The root-mean-square error is %.3f mm.\\n\\n\"), RmsError); WaitForKey(); } else { MosPrintf(MIL_TEXT(\"The transformation matrix was not found.\\n\\n\")); MosPrintf(MIL_TEXT(\"Press any key to exit.\\n\")); MosGetch(); exit(EXIT_FAILURE); } M3dimCopyResult(MilTransResult, MilTOFToColorTransMatrix, M_TRANSFORMATION_MATRIX, M_DEFAULT); return MilTOFToColorTransMatrix; } //***************************************************************************** // Maps the color image to the point cloud. //***************************************************************************** void MapColorToPointCloud(MIL_ID MilSystem, MIL_ID MilColorCalibration, MIL_ID MilColorBuffer, MIL_ID MilSceneContainer, MIL_ID MilTOFToColorMatrixTrans) { // Transform the container from the 3D camera coordinate system // to the color camera's coordinate system (CCS). auto MilSceneContainerColorCS = MbufAllocContainer(MilSystem, M_PROC | M_DISP, M_DEFAULT, M_UNIQUE_ID); M3dimMatrixTransform(MilSceneContainer, MilSceneContainerColorCS, MilTOFToColorMatrixTrans, M_DEFAULT); // Retrieve size of point cloud. auto RangeId = MbufInquireContainer(MilSceneContainerColorCS, M_COMPONENT_RANGE, M_COMPONENT_ID, M_NULL); const auto SizeX = MbufInquire(RangeId, M_SIZE_X, M_NULL); const auto SizeY = MbufInquire(RangeId, M_SIZE_Y, M_NULL); const auto Size = SizeX * SizeY; // Transform the points to the color camera's pixel coordinate system. std::vector&lt;MIL_FLOAT&gt; PointsColorCSPlanar; MbufGet(RangeId, PointsColorCSPlanar); SVector3D&lt;MIL_DOUBLE&gt; PointsColorCS(Size); for(MIL_INT i = 0; i &lt; Size; ++i) { PointsColorCS.Xs[i] = (MIL_FLOAT)PointsColorCSPlanar[i]; PointsColorCS.Ys[i] = (MIL_FLOAT)PointsColorCSPlanar[Size + i]; PointsColorCS.Zs[i] = (MIL_FLOAT)PointsColorCSPlanar[2 * Size + i]; } SVector2D&lt;MIL_DOUBLE&gt; PointsColorPixelCS(Size); McalTransformCoordinate3dList(MilColorCalibration, M_CAMERA_COORDINATE_SYSTEM, M_PIXEL_COORDINATE_SYSTEM, M_DEFAULT, PointsColorCS.Xs, PointsColorCS.Ys, PointsColorCS.Zs, PointsColorPixelCS.Xs, PointsColorPixelCS.Ys, M_NULL, M_DEFAULT); // Interpolate color at the specified pixel coordinates. InterpolateColorAtPixels(MilSystem, MilColorBuffer, MilSceneContainer, PointsColorPixelCS); } //***************************************************************************** // Interpolates the color buffer at the specified pixel coordinates // and adds it as a reflectance component to the container. //***************************************************************************** void InterpolateColorAtPixels(MIL_ID MilSystem, MIL_ID MilColorBuffer, MIL_ID MilSceneContainer, const SVector2D&lt;MIL_DOUBLE&gt;&amp; PixelCoordinates) { const MIL_INT NbPixels = PixelCoordinates.size(); auto RangeId = MbufInquireContainer(MilSceneContainer, M_COMPONENT_RANGE, M_COMPONENT_ID, M_NULL); const auto SizeX = MbufInquire(RangeId, M_SIZE_X, M_NULL); const auto SizeY = MbufInquire(RangeId, M_SIZE_Y, M_NULL); // Interpolate the colors at the specified pixel coordinates. std::vector&lt;MIL_UINT8&gt; InterpolatedColors; MbufGetList(MilColorBuffer, M_DEFAULT, PixelCoordinates.Xs, PixelCoordinates.Ys, M_BILINEAR, InterpolatedColors); // Store the colors as the reflectance component of the container. auto SceneRefBuffer = MbufAllocComponent(MilSceneContainer, 3, SizeX, SizeY, M_UNSIGNED + 8, M_IMAGE + M_PROC, M_COMPONENT_REFLECTANCE, M_NULL); MbufPutColor(SceneRefBuffer, M_PLANAR, M_ALL_BANDS, InterpolatedColors); } //***************************************************************************** // Main function. //***************************************************************************** int MosMain() { PrintHeader(); // Allocate a MIL Application and System. auto MilApplication = MappAlloc(M_NULL, M_DEFAULT, M_UNIQUE_ID); auto MilSystem = MsysAlloc(M_DEFAULT, M_SYSTEM_HOST, M_DEFAULT, M_DEFAULT, M_UNIQUE_ID); // Ensure data files exist. if(!CheckForRequiredMILFile(CALIBRATION_DATA[0].Color)) return EXIT_FAILURE; MosPrintf(MIL_TEXT(\"The color camera will be calibrated using the M_ZHANG_BASED calibration mode.\\n\\n\")); WaitForKey(); // Calibrate color camera using Zhang method. auto MilColorCalibration = McalAlloc(MilSystem, M_ZHANG_BASED, M_DEFAULT, M_UNIQUE_ID); const auto Status = ExecuteZhangCalibration(MilSystem, MilColorCalibration); if(Status == M_FAIL) { MosPrintf(MIL_TEXT(\"The calibration failed.\\n\\n\") MIL_TEXT(\"Press any key to exit.\\n\")); MosGetch(); return EXIT_FAILURE; } // Compute transformation matrix from 3D camera to color camera. auto MilTOFToColorTransMatrix = FindCameraRigidMatrix(MilSystem, MilColorCalibration); // Restore image capture of scene. auto MilSceneColorBuffer = MbufRestore(COLOR_SCENE_DATA, MilSystem, M_UNIQUE_ID); // Retrieve depth map capture of scene. auto MilSceneContainer = MbufRestore(TOF_SCENE_RANGE_DATA, MilSystem, M_UNIQUE_ID); // Display point cloud. auto Mil3DDisplay = Alloc3dDisplay(MilSystem); M3ddispControl(Mil3DDisplay, M_TITLE, MIL_TEXT(\"3D camera\")); M3ddispControl(Mil3DDisplay, M_SIZE_X, DISPLAY_3D_SIZE_X); M3ddispControl(Mil3DDisplay, M_SIZE_Y, DISPLAY_3D_SIZE_Y); M3ddispSelect(Mil3DDisplay, MilSceneContainer, M_SELECT, M_DEFAULT); M3ddispSetView(Mil3DDisplay, M_VIEW_ORIENTATION, M_BOTTOM_VIEW, M_DEFAULT, M_DEFAULT, M_DEFAULT); M3ddispSetView(Mil3DDisplay, M_DISTANCE, CAMERA_3D_DISTANCE, M_DEFAULT, M_DEFAULT, M_DEFAULT); // Display color image of scene. auto MilDisplay = MdispAlloc(MilSystem, M_DEFAULT, MIL_TEXT(\"M_DEFAULT\"), M_DEFAULT, M_UNIQUE_ID); MdispControl(MilDisplay, M_TITLE, MIL_TEXT(\"Color camera\")); MdispControl(MilDisplay, M_WINDOW_INITIAL_POSITION_X, DISPLAY_3D_SIZE_X); MdispControl(MilDisplay, M_WINDOW_INITIAL_SIZE_X, DISPLAY_2D_SIZE_X); MdispControl(MilDisplay, M_WINDOW_INITIAL_SIZE_Y, DISPLAY_2D_SIZE_Y); MdispControl(MilDisplay, M_SCALE_DISPLAY, M_ENABLE); MdispSelect(MilDisplay, MilSceneColorBuffer); MdispControl(MilDisplay, M_VIEW_MODE, M_AUTO_SCALE); MosPrintf(MIL_TEXT(\"The color camera calibration and the transformation matrix will be used\\n\")); MosPrintf(MIL_TEXT(\"to map the shown color image on the displayed point cloud.\\n\\n\")); WaitForKey(); // Perform color mapping to point cloud. MapColorToPointCloud(MilSystem, MilColorCalibration, MilSceneColorBuffer, MilSceneContainer, MilTOFToColorTransMatrix); MosPrintf(MIL_TEXT(\"The point cloud with the mapped color component is shown.\\n\\n\")); MosPrintf(MIL_TEXT(\"Press any key to end.\\n\")); MosGetch(); M3ddispSelect(Mil3DDisplay, M_NULL, M_CLOSE, M_DEFAULT); return EXIT_SUCCESS; } ",
      "wordCount": 2340
    }
  ]
}]
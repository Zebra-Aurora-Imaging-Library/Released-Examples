[{
  "id": "Example_PlaceHolder_ID",
  "version": "2024020714",
  "title": "Example_PlaceHolder_Title",
  "wordCount": 0,
  "subEntries": [
    {
      "id": "Examples_Processing_3dPreprocessing_3dOutlierPointsRemoval_CPP_3doutlierpointsremoval_cpp",
      "version": "2024020714",
      "title": "3doutlierpointsremoval.cpp",
      "location": "Sample Code from MIL Examples",
      "text": " Top //***************************************************************************************/ // // File name: 3dOutlierPointsRemoval.cpp // Location: See Matrox Example Launcher in the MIL Control Center // // // Synopsis: This program demonstrates how to remove outliers from point clouds. // // Copyright (C) Matrox Electronic Systems Ltd., 1992-2024. // All Rights Reserved //***************************************************************************************/ #include &lt;mil.h&gt; #include \"Utilities.h\" #include \"../../../3dUtil/C++/Display3dLinker.h\" #include &lt;cstdlib&gt; //****************************************************************************** // Example files. //****************************************************************************** #define EX_PATH(x) (M_IMAGE_PATH MIL_TEXT(\"3dOutlierPointsRemoval/\") MIL_TEXT(x)) static MIL_STRING LIGHT_CAP_FILE = EX_PATH(\"LightCap.mbufc\"); static MIL_STRING LIGHT_CAPS_DEPTH_MAP_FILE = EX_PATH(\"LightCapsDepthMapContainer.mbufc\"); static MIL_STRING BOXES_FILE = EX_PATH(\"Boxes.mbufc\"); static MIL_STRING EARPHONES_FILE = EX_PATH(\"Earphone.ply\"); CDisplayLinker* DisplayLinkerP; //***************************************************************************** // Constants. //***************************************************************************** static const MIL_INT NB_3D_OUTLIER_REMOVAL_MODES = 3; static const MIL_INT MIN_NB_NEIGHBORS_LIGHT_CAP = 25; static const MIL_INT ORGANIZED_SIZE_LIGHT_CAP = 7; static const MIL_DOUBLE DISTANCE_FACTOR_LIGHT_CAP = 9.0; static const MIL_DOUBLE STD_DEV_FACTOR_LIGHT_CAP = 4.5; static const MIL_DOUBLE PROB_THRESHOLD_FACTOR_LIGHT_CAP = 1.2; static const MIL_INT MIN_NB_NEIGHBORS_BOXES = 25; static const MIL_DOUBLE DISTANCE_FACTOR_BOXES = 12.0; static const MIL_DOUBLE STD_DEV_FACTOR_BOXES = 4.0; static const MIL_DOUBLE PROB_THRESHOLD_FACTOR_BOXES = 2.2; static const MIL_DOUBLE STD_DEV_FACTOR_EARPHONES = 2.5; static const MIL_INT MORPH_STRUCT_SIZE_LIGHT_CAPS = 7; static const MIL_INT MORPH_NB_ITER = 1; static const MIL_FLOAT MORPH_DIFF_Z_OUTLIER_DISTANCE = 0.5; // in mm. //****************************************************************************** // Function declarations. //****************************************************************************** void PrintHeader(); void RunLightCapCase(MIL_ID MilSystem, MIL_ID MilScannedPointCloud, MIL_ID SrcDisplay, std::vector&lt;DstResult&gt;&amp; DstDisplays); void RunBoxesCase(MIL_ID MilSystem, MIL_ID MilScannedPointCloud, MIL_ID SrcDisplay, std::vector&lt;DstResult&gt;&amp; DstDisplays); void RunEarphoneCase(MIL_ID MilSystem, MIL_ID MilScannedPointCloud, MIL_ID SrcDisplay, std::vector&lt;DstResult&gt;&amp; DstDisplays); void RunLightCapsDepthCase(MIL_ID MilSystem, MIL_ID MilSrcDepthMapContainer, MIL_ID MilSrcDisplay, MIL_ID MilDstDisplay); //******************************************************************************* // Prints the Example's description. //******************************************************************************* void PrintHeader() { MosPrintf(MIL_TEXT(\"[EXAMPLE NAME]\\n\") MIL_TEXT(\"3dOutlierPointsRemoval\\n\\n\") MIL_TEXT(\"[SYNOPSIS]\\n\") MIL_TEXT(\"This example demonstrates different ways of removing outliers\\n\") MIL_TEXT(\"from point clouds and depth maps.\\n\\n\") MIL_TEXT(\"[MODULES USED]\\n\") MIL_TEXT(\"Modules used: 3D Image Processing, 3D Display, 3D Geometry,\\n\") MIL_TEXT(\"3D Graphics, and Buffer.\\n\\n\")); } //******************************************************************************* // Main function. //******************************************************************************* int MosMain(void) { PrintHeader(); // Allocate a MIL Application and System. auto MilApplication = MappAlloc(M_NULL, M_DEFAULT, M_UNIQUE_ID); auto MilSystem = MsysAlloc(M_DEFAULT, M_SYSTEM_HOST, M_DEFAULT, M_DEFAULT, M_UNIQUE_ID); WaitForKey(); // Allocate displays and destination buffers. auto MilSrcDisplay = Alloc3dDisplayId(MilSystem, SRC_DISPLAY_INFO.PositionX, SRC_DISPLAY_INFO.PositionY, SRC_DISPLAY_INFO.Size, SRC_DISPLAY_INFO.Size, SRC_DISPLAY_INFO.Title); if(!MilSrcDisplay) return EXIT_FAILURE; std::vector&lt;DstResult&gt; DstResults(NB_3D_OUTLIER_REMOVAL_MODES); std::vector&lt;MIL_ID&gt; Displays(NB_3D_OUTLIER_REMOVAL_MODES + 1); Displays[0] = MilSrcDisplay; for (int i = 0; i &lt; NB_3D_OUTLIER_REMOVAL_MODES; ++i) { const auto DispInfo = DST_DISPLAY_INFO[i]; auto MilPC = MbufAllocContainer(MilSystem, M_PROC | M_DISP, M_DEFAULT, M_UNIQUE_ID); auto MilOutlierPoints = MbufAllocContainer(MilSystem, M_PROC | M_DISP, M_DEFAULT, M_UNIQUE_ID); auto MilDisplay = Alloc3dDisplayId(MilSystem, DispInfo.PositionX, DispInfo.PositionY, DispInfo.Size, DispInfo.Size, DispInfo.Title); if(!MilDisplay) return EXIT_FAILURE; auto GraList = M3ddispInquire(MilDisplay, M_3D_GRAPHIC_LIST_ID, M_NULL); DstResults[i] = DstResult(MilPC.release(), MilOutlierPoints.release(), MilDisplay.release(), GraList); Displays[i + 1] = DstResults[i].Display; } // Synchronize the displays. CDisplayLinker DisplayLinker(Displays); DisplayLinkerP = &amp;DisplayLinker; // Run the first case. auto MilLightCapPC = RestoreFile(MilSystem, LIGHT_CAP_FILE); if(!MilLightCapPC) return EXIT_FAILURE; MbufConvert3d(MilLightCapPC, MilLightCapPC, M_NULL, M_DEFAULT, M_DEFAULT); RunLightCapCase(MilSystem, MilLightCapPC, MilSrcDisplay, DstResults); // Run the second case. auto MilBoxesPC = RestoreFile(MilSystem, BOXES_FILE); if(!MilBoxesPC) return EXIT_FAILURE; MbufConvert3d(MilBoxesPC, MilBoxesPC, M_NULL, M_DEFAULT, M_DEFAULT); RunBoxesCase(MilSystem, MilBoxesPC, MilSrcDisplay, DstResults); // Run the third case. auto MilHeadsetPC = RestoreFile(MilSystem, EARPHONES_FILE); if(!MilHeadsetPC) return EXIT_FAILURE; MbufConvert3d(MilHeadsetPC, MilHeadsetPC, M_NULL, M_DEFAULT, M_DEFAULT); DstResults[1].SetDisplayTitle(MIL_TEXT(\"M_STD_DEVIATION threshold mode\")); DstResults[2].SetDisplayTitle(MIL_TEXT(\"M_ROBUST_STD_DEVIATION threshold mode\")); Displays = {MilSrcDisplay, DstResults[1].Display, DstResults[2].Display}; DisplayLinker.SetDisplays(Displays); DstResults.erase(DstResults.begin()); RunEarphoneCase(MilSystem, MilHeadsetPC, MilSrcDisplay, DstResults); // Run the fourth case. auto MilLightCapsDepthMap = RestoreFile(MilSystem, LIGHT_CAPS_DEPTH_MAP_FILE); if(!MilLightCapsDepthMap) return EXIT_FAILURE; Displays = {MilSrcDisplay, DstResults[1].Display}; DisplayLinker.SetDisplays(Displays); DstResults.erase(DstResults.begin()); M3ddispSelect(DstResults[0].Display, M_NULL, M_CLOSE, M_DEFAULT); M3ddispSelect(MilSrcDisplay, M_NULL, M_CLOSE, M_DEFAULT); RunLightCapsDepthCase(MilSystem, MilLightCapsDepthMap, MilSrcDisplay, DstResults[0].Display); // Close all the displays. for(auto display: Displays) M3ddispSelect(display, M_NULL, M_CLOSE, M_DEFAULT); return 0; } //******************************************************************************* // Remove outliers from the light cap point cloud using various modes. //******************************************************************************* void RunLightCapCase(MIL_ID MilSystem, MIL_ID MilScannedPC, MIL_ID SrcDisplay, std::vector&lt;DstResult&gt;&amp; DstResults) { // Different outlier removal modes. const auto NbModes = DstResults.size(); DisplayLinkerP-&gt;StopLink(); // Display scanned point cloud. M3ddispSelect(SrcDisplay, MilScannedPC, M_SELECT, M_DEFAULT); for (int i = 0; i &lt; DstResults.size(); ++i) { M3ddispSelect(DstResults[i].Display, MilScannedPC, M_SELECT, M_DEFAULT); } M3ddispSetView(SrcDisplay, M_VIEW_BOX, M_WHOLE_SCENE, M_DEFAULT, M_DEFAULT, M_DEFAULT); DisplayLinkerP-&gt;StartLink(); auto GraSrcList = M3ddispInquire(SrcDisplay, M_3D_GRAPHIC_LIST_ID, M_NULL); const auto NbSrcPoints = M3dimGet(MilScannedPC, M_COMPONENT_CONFIDENCE, M_NULL, M_DEFAULT, M_NULL, M_NULL, M_NULL); MosPrintf(MIL_TEXT(\"A scanned light cap with %i points is shown.\\n\\n\"), NbSrcPoints); WaitForKey(); MosPrintf(MIL_TEXT(\"The outliers are removed using: \\n\") MIL_TEXT(\" 1) M_NUMBER_WITHIN_DISTANCE outlier mode\\n\") MIL_TEXT(\" 2) M_LOCAL_DISTANCE outlier mode + M_ROBUST_STD_DEVIATION threshold mode\\n\") MIL_TEXT(\" 3) M_LOCAL_DENSITY_PROBABILITY outlier mode\\n\\n\")); MosPrintf(MIL_TEXT(\"The outliers are shown in red.\\n\\n\")); // Allocate the outlier mask buffer. const auto SizeX = MbufInquireContainer(MilScannedPC, M_COMPONENT_RANGE, M_SIZE_X, M_NULL); const auto SizeY = MbufInquireContainer(MilScannedPC, M_COMPONENT_RANGE, M_SIZE_Y, M_NULL); auto MilOutlierMask = MbufAlloc2d(MilSystem, SizeX, SizeY, M_UNSIGNED + 8, M_IMAGE | M_PROC, M_UNIQUE_ID); // Define the outlier removal context using the M_NUMBER_WITHIN_DISTANCE outlier mode. DstResults[0].Context = M3dimAlloc(MilSystem, M_OUTLIERS_CONTEXT, M_DEFAULT, M_UNIQUE_ID); M3dimControl(DstResults[0].Context, M_OUTLIER_MODE, M_NUMBER_WITHIN_DISTANCE); M3dimControl(DstResults[0].Context, M_MINIMUM_NUMBER_NEIGHBORS, MIN_NB_NEIGHBORS_LIGHT_CAP); M3dimControl(DstResults[0].Context, M_NEIGHBOR_SEARCH_MODE, M_ORGANIZED); M3dimControl(DstResults[0].Context, M_NEIGHBORHOOD_ORGANIZED_SIZE, ORGANIZED_SIZE_LIGHT_CAP); auto MilStatResult = M3dimAllocResult(MilSystem, M_STATISTICS_RESULT, M_DEFAULT, M_UNIQUE_ID); M3dimStat(M_STAT_CONTEXT_DISTANCE_TO_NEAREST_NEIGHBOR, MilScannedPC, MilStatResult, M_DEFAULT); const auto AveDistance = M3dimGetResult(MilStatResult, M_DISTANCE_TO_NEAREST_NEIGHBOR_AVERAGE, M_NULL); M3dimControl(DstResults[0].Context, M_NEIGHBORHOOD_DISTANCE_MODE, M_USER_DEFINED); M3dimControl(DstResults[0].Context, M_NEIGHBORHOOD_DISTANCE, DISTANCE_FACTOR_LIGHT_CAP * AveDistance); // Define the outlier removal context using the M_LOCAL_DISTANCE outlier mode + // M_ROBUST_STD_DEVIATION threshold mode. DstResults[1].Context = M3dimAlloc(MilSystem, M_OUTLIERS_CONTEXT, M_DEFAULT, M_UNIQUE_ID); M3dimControl(DstResults[1].Context, M_NEIGHBOR_SEARCH_MODE, M_ORGANIZED); M3dimControl(DstResults[1].Context, M_NEIGHBORHOOD_ORGANIZED_SIZE, ORGANIZED_SIZE_LIGHT_CAP); M3dimControl(DstResults[1].Context, M_STD_DEVIATION_FACTOR, STD_DEV_FACTOR_LIGHT_CAP); // Define the outlier removal context using the M_LOCAL_DENSITY_PROBABILITY outlier mode. DstResults[2].Context = M3dimAlloc(MilSystem, M_OUTLIERS_CONTEXT, M_DEFAULT, M_UNIQUE_ID); M3dimControl(DstResults[2].Context, M_NEIGHBOR_SEARCH_MODE, M_ORGANIZED); M3dimControl(DstResults[2].Context, M_NEIGHBORHOOD_ORGANIZED_SIZE, ORGANIZED_SIZE_LIGHT_CAP); M3dimControl(DstResults[2].Context, M_OUTLIER_MODE, M_LOCAL_DENSITY_PROBABILITY); M3dimControl(DstResults[2].Context, M_PROBABILITY_THRESHOLD_FACTOR, PROB_THRESHOLD_FACTOR_LIGHT_CAP); // Remove outliers and compute the processing time. std::vector&lt;MIL_INT&gt; NbOutliers(NbModes); std::vector&lt;MIL_INT&gt; CompTimes(NbModes); // in ms. for (int i = 0; i &lt; NbModes; ++i) { M3dimOutliers(DstResults[i].Context, MilScannedPC, DstResults[i].PC, MilOutlierMask, M_DEFAULT); CompTimes[i] = TimeComputation(MilScannedPC, DstResults[i]); auto NbInliers = M3dimGet(DstResults[i].PC, M_COMPONENT_CONFIDENCE, M_NULL, M_DEFAULT, M_NULL, M_NULL, M_NULL); NbOutliers[i] = NbSrcPoints - NbInliers; M3dimCrop(MilScannedPC, DstResults[i].OutlierPoints, MilOutlierMask, M_NULL, M_SAME, M_DEFAULT); DrawOutlierPoints(DstResults[i]); } // Print the results. MosPrintf(MIL_TEXT(\"Outlier mode Nb outliers Processing time (in ms)\\n\")); MosPrintf(MIL_TEXT(\"M_NUMBER_WITHIN_DISTANCE %d %d \\n\"), NbOutliers[0], CompTimes[0]); MosPrintf(MIL_TEXT(\"M_LOCAL_DISTANCE %d %d \\n\"), NbOutliers[1], CompTimes[1]); MosPrintf(MIL_TEXT(\"M_LOCAL_DENSITY_PROBABILITY %d %d \\n\\n\"), NbOutliers[2], CompTimes[2]); MosPrintf(MIL_TEXT(\"For this point cloud, all three approaches produce similar results.\\n\") MIL_TEXT(\"For such cases, the M_NUMBER_WITHIN_DISTANCE outlier mode is usually preferred\\n\") MIL_TEXT(\"as on most systems it is the most computationally efficient mode.\\n\\n\")); M3ddispControl(SrcDisplay, M_AUTO_ROTATE, M_ENABLE); WaitForKey(); M3ddispControl(SrcDisplay, M_AUTO_ROTATE, M_DISABLE); M3ddispSetView(SrcDisplay, M_AZIM_ELEV_ROLL, 270, 0, 0, M_DEFAULT); for (auto&amp; Result : DstResults) { M3dgraRemove(Result.GraList, M_ALL, M_DEFAULT); M3ddispSelect(Result.Display, Result.PC, M_ADD, M_DEFAULT); } // Calculate and draw the semi-oriented bounding box. M3dimStat(M_STAT_CONTEXT_SEMI_ORIENTED_BOX, MilScannedPC, MilStatResult, M_DEFAULT); const auto SrcHeight = M3dimGetResult(MilStatResult, M_SIZE_Z, M_NULL); DrawBoundingBox(MilSystem, MilStatResult, GraSrcList); auto DstHeightSum = 0.0; for (auto&amp; Result : DstResults) { M3dimStat(M_STAT_CONTEXT_SEMI_ORIENTED_BOX, Result.PC, MilStatResult, M_DEFAULT); DstHeightSum += M3dimGetResult(MilStatResult, M_SIZE_Z, M_NULL); DrawBoundingBox(MilSystem, MilStatResult, Result.GraList); } auto const DstHeight = DstHeightSum / (MIL_DOUBLE)NbModes; auto const HeightRatio = SrcHeight / DstHeight; MosPrintf(MIL_TEXT(\"The outliers are removed from the displays and the point clouds' bounding boxes\\n\") MIL_TEXT(\"are shown. The original scanned point cloud's bounding box is %3.1f times \\n\") MIL_TEXT(\"taller than necessary due to the outliers.\\n\\n\"), HeightRatio); WaitForKey(); // Remove all graphics from displays. M3dgraRemove(GraSrcList, M_ALL, M_DEFAULT); for (auto&amp; Result : DstResults) { M3dgraRemove(Result.GraList, M_ALL, M_DEFAULT); } } //******************************************************************************* // Remove outliers from the boxes point cloud using various modes. //******************************************************************************* void RunBoxesCase(MIL_ID MilSystem, MIL_ID MilScannedPC, MIL_ID SrcDisplay, std::vector&lt;DstResult&gt;&amp; DstResults) { // Different outlier removal modes. const auto NbModes = DstResults.size(); DisplayLinkerP-&gt;StopLink(); // Display scanned point cloud. M3ddispSelect(SrcDisplay, MilScannedPC, M_SELECT, M_DEFAULT); for(auto&amp; Result : DstResults) { M3ddispSelect(Result.Display, MilScannedPC, M_SELECT, M_DEFAULT); } // Set view. M3ddispSetView(SrcDisplay, M_VIEWPOINT, -450, -6035, 575, M_DEFAULT); M3ddispSetView(SrcDisplay, M_UP_VECTOR, 0.5, 0, -1, M_DEFAULT); M3ddispSetView(SrcDisplay, M_INTEREST_POINT, 740, -120, 1445, M_DEFAULT); DisplayLinkerP-&gt;StartLink(); const auto NbSrcPoints = M3dimGet(MilScannedPC, M_COMPONENT_CONFIDENCE, M_NULL, M_DEFAULT, M_NULL, M_NULL, M_NULL); MosPrintf(MIL_TEXT(\"A point cloud of 2 boxes, which has %i points, is shown.\\n\\n\"), NbSrcPoints); WaitForKey(); MosPrintf(MIL_TEXT(\"The outliers are removed using: \\n\") MIL_TEXT(\" 1) M_NUMBER_WITHIN_DISTANCE outlier mode\\n\") MIL_TEXT(\" 2) M_LOCAL_DISTANCE outlier mode + M_ROBUST_STD_DEVIATION threshold mode\\n\") MIL_TEXT(\" 3) M_LOCAL_DENSITY_PROBABILITY outlier mode\\n\\n\")); MosPrintf(MIL_TEXT(\"The outliers are shown in red.\\n\\n\")); // Allocate the outlier mask buffer. const auto SizeX = MbufInquireContainer(MilScannedPC, M_COMPONENT_RANGE, M_SIZE_X, M_NULL); const auto SizeY = MbufInquireContainer(MilScannedPC, M_COMPONENT_RANGE, M_SIZE_Y, M_NULL); auto MilOutlierMask = MbufAlloc2d(MilSystem, SizeX, SizeY, M_UNSIGNED + 8, M_IMAGE | M_PROC, M_UNIQUE_ID); // Define the outlier removal context using the M_NUMBER_WITHIN_DISTANCE outlier mode. DstResults[0].Context = M3dimAlloc(MilSystem, M_OUTLIERS_CONTEXT, M_DEFAULT, M_UNIQUE_ID); M3dimControl(DstResults[0].Context, M_OUTLIER_MODE, M_NUMBER_WITHIN_DISTANCE); M3dimControl(DstResults[0].Context, M_MINIMUM_NUMBER_NEIGHBORS, MIN_NB_NEIGHBORS_BOXES); auto MilStatResult = M3dimAllocResult(MilSystem, M_STATISTICS_RESULT, M_DEFAULT, M_UNIQUE_ID); M3dimStat(M_STAT_CONTEXT_DISTANCE_TO_NEAREST_NEIGHBOR, MilScannedPC, MilStatResult, M_DEFAULT); const auto AveDistance = M3dimGetResult(MilStatResult, M_DISTANCE_TO_NEAREST_NEIGHBOR_AVERAGE, M_NULL); M3dimControl(DstResults[0].Context, M_NEIGHBORHOOD_DISTANCE_MODE, M_USER_DEFINED); M3dimControl(DstResults[0].Context, M_NEIGHBORHOOD_DISTANCE, DISTANCE_FACTOR_BOXES * AveDistance); // Define the outlier removal context using the M_LOCAL_DISTANCE outlier mode + M_ROBUST_STD_DEVIATION threshold mode. DstResults[1].Context = M3dimAlloc(MilSystem, M_OUTLIERS_CONTEXT, M_DEFAULT, M_UNIQUE_ID); M3dimControl(DstResults[1].Context, M_STD_DEVIATION_FACTOR, STD_DEV_FACTOR_BOXES); // Define the outlier removal context using the M_LOCAL_DENSITY_PROBABILITY outlier mode. DstResults[2].Context = M3dimAlloc(MilSystem, M_OUTLIERS_CONTEXT, M_DEFAULT, M_UNIQUE_ID); M3dimControl(DstResults[2].Context, M_OUTLIER_MODE, M_LOCAL_DENSITY_PROBABILITY); M3dimControl(DstResults[2].Context, M_PROBABILITY_THRESHOLD_FACTOR, PROB_THRESHOLD_FACTOR_BOXES); // Remove outliers. std::vector&lt;MIL_INT&gt; NbOutliers(NbModes); for (int i = 0; i &lt; NbModes; ++i) { M3dimOutliers(DstResults[i].Context, MilScannedPC, DstResults[i].PC, MilOutlierMask, M_DEFAULT); auto NbInliers = M3dimGet(DstResults[i].PC, M_COMPONENT_CONFIDENCE, M_NULL, M_DEFAULT, M_NULL, M_NULL, M_NULL); NbOutliers[i] = NbSrcPoints - NbInliers; M3dimCrop(MilScannedPC, DstResults[i].OutlierPoints, MilOutlierMask, M_NULL, M_SAME, M_DEFAULT); DrawOutlierPoints(DstResults[i]); } // Print the results. MosPrintf(MIL_TEXT(\"Outlier mode Nb outliers \\n\")); MosPrintf(MIL_TEXT(\"M_NUMBER_WITHIN_DISTANCE %d \\n\"), NbOutliers[0]); MosPrintf(MIL_TEXT(\"M_LOCAL_DISTANCE %d \\n\"), NbOutliers[1]); MosPrintf(MIL_TEXT(\"M_LOCAL_DENSITY_PROBABILITY %d \\n\\n\"), NbOutliers[2]); MosPrintf(MIL_TEXT(\"For this case, the M_NUMBER_WITHIN_DISTANCE and M_LOCAL_DISTANCE outlier modes\\n\") MIL_TEXT(\"falsely classify sparse regions as outliers. The M_LOCAL_DENSITY_PROBABILITY\\n\") MIL_TEXT(\"outlier mode does a better job and should generally be favored for \\n\") MIL_TEXT(\"point clouds with non-uniform density.\\n\\n\")); WaitForKey(); // Remove all graphics from displays. auto GraSrcList = M3ddispInquire(SrcDisplay, M_3D_GRAPHIC_LIST_ID, M_NULL); M3dgraRemove(GraSrcList, M_ALL, M_DEFAULT); for (auto&amp; Result : DstResults) { M3dgraRemove(Result.GraList, M_ALL, M_DEFAULT); } } //******************************************************************************* // Remove outliers from the earphone point cloud using various modes. //******************************************************************************* void RunEarphoneCase(MIL_ID MilSystem, MIL_ID MilScannedPC, MIL_ID SrcDisplay, std::vector&lt;DstResult&gt;&amp; DstResults) { // Different outlier removal modes. const auto NbModes = DstResults.size(); DisplayLinkerP-&gt;StopLink(); // Display scanned point cloud. M3ddispSelect(SrcDisplay, MilScannedPC, M_SELECT, M_DEFAULT); for (auto&amp; Result : DstResults) { M3ddispSelect(Result.Display, MilScannedPC, M_SELECT, M_DEFAULT); } // Set view. M3ddispSetView(SrcDisplay, M_VIEWPOINT, 140, 35, 1095, M_DEFAULT); M3ddispSetView(SrcDisplay, M_UP_VECTOR, 0.5, 0.5, 0, M_DEFAULT); M3ddispSetView(SrcDisplay, M_INTEREST_POINT, 95, -45, 400, M_DEFAULT); DisplayLinkerP-&gt;StartLink(); const auto NbSrcPoints = M3dimGet(MilScannedPC, M_COMPONENT_CONFIDENCE, M_NULL, M_DEFAULT, M_NULL, M_NULL, M_NULL); MosPrintf(MIL_TEXT(\"A point cloud of an earphone case, which has %i points, is shown.\\n\"), NbSrcPoints); MosPrintf(MIL_TEXT(\"The point cloud is polluted by some outliers far from the earphone\\n\") MIL_TEXT(\"case (left middle of the display).\\n\\n\")); WaitForKey(); MosPrintf(MIL_TEXT(\"The outliers are removed using: \\n\") MIL_TEXT(\" 1) M_LOCAL_DISTANCE outlier mode + M_STD_DEVIATION threshold mode\\n\") MIL_TEXT(\" 2) M_LOCAL_DISTANCE outlier mode + M_ROBUST_STD_DEVIATION threshold mode\\n\\n\")); MosPrintf(MIL_TEXT(\"Generally, these 2 approaches produce similar results, except for scenarios\\n\") MIL_TEXT(\"where outliers exist far away from the main scene.\\n\\n\")); MosPrintf(MIL_TEXT(\"The outliers are shown in red.\\n\\n\")); // Allocate the outlier mask buffer. const auto SizeX = MbufInquireContainer(MilScannedPC, M_COMPONENT_RANGE, M_SIZE_X, M_NULL); const auto SizeY = MbufInquireContainer(MilScannedPC, M_COMPONENT_RANGE, M_SIZE_Y, M_NULL); auto MilOutlierMask = MbufAlloc2d(MilSystem, SizeX, SizeY, M_UNSIGNED + 8, M_IMAGE | M_PROC, M_UNIQUE_ID); // Define the outlier removal context using the M_LOCAL_DISTANCE outlier mode + M_STD_DEVIATION threshold mode. DstResults[0].Context = M3dimAlloc(MilSystem, M_OUTLIERS_CONTEXT, M_DEFAULT, M_UNIQUE_ID); M3dimControl(DstResults[0].Context, M_DISTANCE_THRESHOLD_MODE, M_STD_DEVIATION); M3dimControl(DstResults[0].Context, M_STD_DEVIATION_FACTOR, STD_DEV_FACTOR_EARPHONES); // Define the outlier removal context using the M_LOCAL_DISTANCE outlier mode + M_ROBUST_STD_DEVIATION threshold mode. DstResults[1].Context = M3dimAlloc(MilSystem, M_OUTLIERS_CONTEXT, M_DEFAULT, M_UNIQUE_ID); M3dimControl(DstResults[1].Context, M_STD_DEVIATION_FACTOR, STD_DEV_FACTOR_EARPHONES); // Remove outliers. std::vector&lt;MIL_INT&gt; NbOutliers(NbModes); for (int i = 0; i &lt; NbModes; ++i) { M3dimOutliers(DstResults[i].Context, MilScannedPC, DstResults[i].PC, MilOutlierMask, M_DEFAULT); auto NbInliers = M3dimGet(DstResults[i].PC, M_COMPONENT_CONFIDENCE, M_NULL, M_DEFAULT, M_NULL, M_NULL, M_NULL); NbOutliers[i] = NbSrcPoints - NbInliers; M3dimCrop(MilScannedPC, DstResults[i].OutlierPoints, MilOutlierMask, M_NULL, M_SAME, M_DEFAULT); DrawOutlierPoints(DstResults[i]); } // Print the results. MosPrintf(MIL_TEXT(\"Threshold mode Nb outliers \\n\")); MosPrintf(MIL_TEXT(\"M_STD_DEVIATION %d \\n\"), NbOutliers[0]); MosPrintf(MIL_TEXT(\"M_ROBUST_STD_DEVIATION %d \\n\\n\"), NbOutliers[1]); MosPrintf(MIL_TEXT(\"The far-lying outliers skew the local average distance distribution of the\\n\") MIL_TEXT(\"point cloud. The M_ROBUST_STD_DEVIATION threshold mode uses robust statistics\\n\") MIL_TEXT(\"to accurately identify outliers in the main scene, unlike the M_STD_DEVIATION\\n\") MIL_TEXT(\"threshold mode.\\n\\n\")); WaitForKey(); auto MilStatResult = M3dimAllocResult(MilSystem, M_STATISTICS_RESULT, M_DEFAULT, M_UNIQUE_ID); M3dimStat(M_STAT_CONTEXT_CENTROID, DstResults[1].PC, MilStatResult, M_DEFAULT); MIL_DOUBLE Cx = M3dimGetResult(MilStatResult, M_CENTROID_X, M_NULL); MIL_DOUBLE Cy = M3dimGetResult(MilStatResult, M_CENTROID_Y, M_NULL); MIL_DOUBLE Cz = M3dimGetResult(MilStatResult, M_CENTROID_Z, M_NULL); DisplayLinkerP-&gt;StopLink(); MosPrintf(MIL_TEXT(\"A zoomed-in view of the earphone case is shown.\\n\\n\")); M3ddispSetView(SrcDisplay, M_VIEWPOINT, 270, -45, 950, M_DEFAULT); M3ddispSetView(SrcDisplay, M_UP_VECTOR, 0, 1, 0, M_DEFAULT); M3ddispSetView(SrcDisplay, M_INTEREST_POINT, Cx, Cy, Cz, M_DEFAULT); DisplayLinkerP-&gt;StartLink(); WaitForKey(); auto GraSrcList = M3ddispInquire(SrcDisplay, M_3D_GRAPHIC_LIST_ID, M_NULL); M3dgraRemove(GraSrcList, M_ALL, M_DEFAULT); for (auto&amp; Result: DstResults) { M3dgraRemove(Result.GraList, M_ALL, M_DEFAULT); } M3ddispSelect(DstResults[1].Display, M_NULL, M_CLOSE, M_DEFAULT); } //******************************************************************************* // Remove outliers for a depth map container of the light caps using morphology. //******************************************************************************* void RunLightCapsDepthCase(MIL_ID MilSystem, MIL_ID MilSrcDepthMapContainer, MIL_ID MilSrcDisplay, MIL_ID MilDstDisplay) { // Get the size of the depth map container range. const auto RangeSizeX = MbufInquireContainer(MilSrcDepthMapContainer, M_COMPONENT_RANGE, M_SIZE_X, M_NULL); const auto RangeSizeY = MbufInquireContainer(MilSrcDepthMapContainer, M_COMPONENT_RANGE, M_SIZE_Y, M_NULL); const auto MaxValue = MbufInquireContainer(MilSrcDepthMapContainer, M_COMPONENT_RANGE, M_MAX, M_NULL); const auto MilSrcRange = MbufInquireContainer(MilSrcDepthMapContainer, M_COMPONENT_RANGE, M_COMPONENT_ID, M_NULL); // Setup the 3D displays. MIL_INT Disp3dSizeY = DISP_MAX_SIZE_Y - RangeSizeY - 2 * WINDOWS_OFFSET_Y; M3ddispControl(MilSrcDisplay, M_TITLE, SRC_DEPTH_MAP_DISPLAY_TITLE); M3ddispControl(MilSrcDisplay, M_SIZE_X, RangeSizeX); M3ddispControl(MilSrcDisplay, M_SIZE_Y, Disp3dSizeY); M3ddispControl(MilDstDisplay, M_TITLE, DST_DEPTH_MAP_DISPLAY_TITLE); M3ddispControl(MilDstDisplay, M_SIZE_X, RangeSizeX); M3ddispControl(MilDstDisplay, M_SIZE_Y, Disp3dSizeY); M3ddispControl(MilDstDisplay, M_WINDOW_INITIAL_POSITION_X, RangeSizeX); M3ddispControl(MilDstDisplay, M_WINDOW_INITIAL_POSITION_Y, 0); M3ddispSetView(MilSrcDisplay, M_INTEREST_POINT, 58, 55, 2.9, M_DEFAULT); M3ddispSetView(MilSrcDisplay, M_DISTANCE, 190, M_DEFAULT, M_DEFAULT, M_DEFAULT); M3ddispSetView(MilSrcDisplay, M_AZIM_ELEV_ROLL, 233.95, -42.74, 196.86, M_DEFAULT); // Set the display's rotation axis center. This will keep the // behaviour of auto rotate consistent as we move its interest point. M3ddispCopy(M_VIEW_INTEREST_POINT, MilSrcDisplay, M_ROTATION_AXIS_CENTER, M_DEFAULT); // Setup the 2D displays. auto MilDispLut = MbufAllocColor(MilSystem, 3, MaxValue + 1, 1, 8 + M_UNSIGNED, M_LUT, M_UNIQUE_ID); MgenLutFunction(MilDispLut, M_COLORMAP_TURBO + M_LAST_GRAY, M_DEFAULT, M_COLOR_GRAY, M_DEFAULT, M_DEFAULT, M_DEFAULT, M_DEFAULT); auto MilSrcDisplay2d = MdispAlloc(MilSystem, M_DEFAULT, MIL_TEXT(\"M_DEFAULT\"), M_DEFAULT, M_UNIQUE_ID); MdispControl(MilSrcDisplay2d, M_TITLE, SRC_DEPTH_MAP_DISPLAY_TITLE); MdispControl(MilSrcDisplay2d, M_WINDOW_INITIAL_POSITION_Y, Disp3dSizeY + WINDOWS_OFFSET_Y); MdispLut(MilSrcDisplay2d, MilDispLut); auto MilDstDisplay2d = MdispAlloc(MilSystem, M_DEFAULT, MIL_TEXT(\"M_DEFAULT\"), M_DEFAULT, M_UNIQUE_ID); MdispControl(MilDstDisplay2d, M_TITLE, DST_DEPTH_MAP_DISPLAY_TITLE); MdispControl(MilDstDisplay2d, M_WINDOW_INITIAL_POSITION_X, RangeSizeX); MdispControl(MilDstDisplay2d, M_WINDOW_INITIAL_POSITION_Y, Disp3dSizeY + WINDOWS_OFFSET_Y); MdispLut(MilDstDisplay2d, MilDispLut); // Display the source depth map data. M3ddispSelect(MilSrcDisplay, MilSrcDepthMapContainer, M_SELECT, M_DEFAULT); MdispSelect(MilSrcDisplay2d, MilSrcRange); MosPrintf(MIL_TEXT(\"A source depth map container of various objects is shown.\\n\") MIL_TEXT(\"The depth data contains some outliers due to the scanning process.\\n\") MIL_TEXT(\"The data can be structured using opening morphology. The opening also removes\\n\") MIL_TEXT(\"the outliers, but maintains the missing data regions intact.\\n\\n\")); WaitForKey(); // Allocate the destination container as a clone. auto MilDstDepthMapContainer = MbufClone(MilSrcDepthMapContainer, M_DEFAULT, M_DEFAULT, M_DEFAULT, M_DEFAULT, M_DEFAULT, M_COPY_SOURCE_DATA, M_UNIQUE_ID); auto MilDstRange = MbufInquireContainer(MilDstDepthMapContainer, M_COMPONENT_RANGE, M_COMPONENT_ID, M_NULL); // Perform an open morphology on the depth map container. auto MilStruct = MbufAlloc2d(MilSystem, MORPH_STRUCT_SIZE_LIGHT_CAPS, MORPH_STRUCT_SIZE_LIGHT_CAPS, 32 + M_UNSIGNED, M_STRUCT_ELEMENT, M_UNIQUE_ID); MbufClear(MilStruct, 0); MimMorphic(MilSrcDepthMapContainer, MilDstDepthMapContainer, MilStruct, M_OPEN, MORPH_NB_ITER, M_GRAYSCALE); // Display the destination depth map data. M3ddispSelect(MilDstDisplay, MilDstDepthMapContainer, M_SELECT, M_DEFAULT); MdispSelect(MilDstDisplay2d, MilDstRange); MosPrintf(MIL_TEXT(\"The result of the opening morphology is displayed.\\n\\n\")); WaitForKey(); // Disable the display updates. MdispControl(MilSrcDisplay2d, M_UPDATE, M_DISABLE); M3ddispControl(MilSrcDisplay, M_UPDATE, M_DISABLE); // Compute a mask of the points whose Z value was modified above a threshold. These are considered to be the outliers. auto MilDistanceImage = MbufAlloc2d(MilSystem, RangeSizeX, RangeSizeY, 32 + M_FLOAT, M_IMAGE + M_PROC, M_UNIQUE_ID); auto MilOutlierMask = MbufAlloc2d(MilSystem, RangeSizeX, RangeSizeY, 8 + M_UNSIGNED, M_IMAGE + M_PROC, M_UNIQUE_ID); M3dmetDistance(MilDstDepthMapContainer, MilSrcDepthMapContainer, MilDistanceImage, M_ABSOLUTE_DISTANCE_Z_TO_SURFACE, M_DEFAULT, M_DEFAULT); MimBinarize(MilDistanceImage, MilOutlierMask, M_GREATER, MORPH_DIFF_Z_OUTLIER_DISTANCE, M_NULL); MbufClearCond(MilOutlierMask, 0, M_NULL, M_NULL, MilDistanceImage, M_EQUAL, MIL_FLOAT_MAX); // Show the outliers in the overlay. const auto TransparentColor = MdispInquire(MilSrcDisplay2d, M_TRANSPARENT_COLOR, M_NULL); auto MilOverlay = MdispInquire(MilSrcDisplay2d, M_OVERLAY_ID, M_NULL); MbufClear(MilOverlay, M_COLOR_RED); MbufClearCond(MilOverlay, M_RGB888_r(TransparentColor), M_RGB888_g(TransparentColor), M_RGB888_b(TransparentColor), MilOutlierMask, M_NOT_EQUAL, MIL_UINT8_MAX); // Draw the points in the display. auto MilSrcGraList = M3ddispInquire(MilSrcDisplay, M_3D_GRAPHIC_LIST_ID, M_NULL); auto MilOutlierPoints = MbufClone(MilSrcDepthMapContainer, M_DEFAULT, M_DEFAULT, M_DEFAULT, M_DEFAULT, M_DEFAULT, M_COPY_SOURCE_DATA, M_UNIQUE_ID); MbufControl(MilOutlierMask, M_COMPONENT_TYPE, M_COMPONENT_CONFIDENCE); MbufCopyComponent(MilOutlierMask, MilOutlierPoints, M_DEFAULT, M_APPEND, M_DEFAULT); auto OutlierPointsLabel = M3dgraAdd(MilSrcGraList, M_DEFAULT, MilOutlierPoints, M_NO_LINK); M3dgraControl(MilSrcGraList, OutlierPointsLabel, M_COLOR, M_COLOR_RED); M3dgraControl(MilSrcGraList, OutlierPointsLabel, M_COLOR_COMPONENT, M_NULL); // Reenable the display updates. M3ddispControl(MilSrcDisplay, M_UPDATE, M_ENABLE); MdispControl(MilSrcDisplay2d, M_UPDATE, M_ENABLE); MosPrintf(MIL_TEXT(\"Points whose depths were modified by more than %.2f mm\\n\") MIL_TEXT(\"could be considered as outliers.\\n\\n\"), MORPH_DIFF_Z_OUTLIER_DISTANCE); MosPrintf(MIL_TEXT(\"Press any key to end.\\n\\n\")); MosGetch(); // Remove all graphics from displays. M3ddispSelect(MilSrcDisplay, M_NULL, M_REMOVE, M_DEFAULT); M3ddispSelect(MilDstDisplay, M_NULL, M_REMOVE, M_DEFAULT); } ",
      "wordCount": 2428
    }
  ]
}]
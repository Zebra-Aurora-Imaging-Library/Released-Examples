[{
  "id": "UG_display",
  "version": "2024020714",
  "title": "Displaying an image",
  "subTitles": null,
  "location": "MIL UG P04: 2D related information",
  "pageURL": "content\\UserGuide\\display\\ChapterInformation.htm",
  "text": " Chapter 25: Displaying an image This chapter discusses the display of image buffers, in detail. It shows you how to display several images simultaneously, and discusses some of the special display effects that can be achieved. Overview Types of displays Windowed display Exclusive display MILweb display Displaying buffers of different data depths M_BIT_SHIFT M_AUTO_SCALE M_MULTI_BYTES M_TRANSPARENT Displaying an image in a user-defined window Using MdispSelectWindow() Removing a buffer from the display Displaying multiple buffers Panning and zooming Explicitly specifying the amount to pan and zoom Panning and zooming the display interactively Annotating the displayed image non-destructively Annotating images using the overlay mechanism Overlay buffer behavior Camera calibration and overlay considerations Transparency (keying) Using a 2D graphics list Opacity Using GDI annotations Using regions of interest Opacity Examples Mapping 1-band images through a LUT upon display Selecting the LUT to use for display Restrictions when displaying using LUT ",
  "wordCount": 149,
  "subEntries": [
    {
      "id": "UG_display_Overview",
      "version": null,
      "title": "Overview",
      "subTitles": null,
      "location": "MIL UG P04: 2D related information",
      "pageURL": "content\\UserGuide\\display\\Overview.htm",
      "text": " Overview MIL can display images. It will use the most appropriate graphics controller for display purposes. MIL will typically display the image on the computer running the main MIL application (master computer); however, MIL can also display an image on a remote computer on your network. To display an image buffer, you must allocate the buffer with a displayable attribute (M_DISP). In addition, you must allocate a 2D display, using MdispAlloc() or MappAllocDefault(), on the same system as the buffer. Once both are allocated, use MdispSelect() to select the image buffer to display. A buffer can be displayed on the local computer or a remote computer, in a window on the desktop or without a window on a dedicated screen in exclusive mode. Besides other display effects, you can pan and zoom the displayed image, as well as overlay annotations on the displayed image non-destructively using the overlay mechanism or a 2D graphics list. If using MIL's overlay mechanism, you can overlay any image on the displayed image and select the transparency color; when you pan and zoom the displayed image, the overlay data is also panned and zoomed. An image buffer, or any of its child buffers, can be selected on more than one display. MIL documentation uses the term display memory to refer to physical display (graphics controller) memory. Overview ",
      "wordCount": 224,
      "subEntries": []
    },
    {
      "id": "UG_display_Types_of_displays",
      "version": null,
      "title": "Types of displays",
      "subTitles": [
        "Windowed display",
        "Exclusive display",
        "MILweb display"
      ],
      "location": "MIL UG P04: 2D related information",
      "pageURL": "content\\UserGuide\\display\\Types_of_displays.htm",
      "text": " Types of displays You can allocate a display so that an image buffer selected to this display is: Displayed in a window on a Windows desktop screen. This is called a windowed display (M_WINDOWED). Displayed on a dedicated screen that is also a Windows desktop screen. This is called an exclusive display (M_EXCLUSIVE). Displayed by one or more MILweb clients over a network. This is called a MILweb display (M_WEB). You must specify the required type of display upon allocating the display, with MdispAlloc(). Windowed display An image buffer selected to a windowed display is presented within a window on the Windows desktop screen(s). To choose a windowed display, set the InitFlag parameter of MdispAlloc() to M_WINDOWED. Windowed displays can be presented on a desktop that is displayed using one screen or multiple screens. We refer to these screens, either one or many, as the Windows desktop screen(s). Your desktop can be extended over screens at different resolutions. All windowed displays are displayed in their own MIL default window (or, as discussed later, in a user-allocated window). This window is transparently tracked and updated with the image buffer selected to the display; that is, if the window moves or is occluded, the window is automatically updated with the image buffer accordingly. Multiple windowed displays can be allocated and selected for display. The display's device number should always be set to M_DEFAULT. Based on the specified format, MIL will find the best device to use when displaying an image. For windowed displays, the display format parameter of MdispAlloc() is ignored. When you select an image buffer to a windowed display, Windows will create a display that has the same size as the image, unless such a display would not fit on the Windows desktop or would be too small. If the image is too large to fit in the largest possible window at the resolution of the selected display, the top-left corner of the image will be aligned with the top-left corner of the largest possible window, and the right and bottom portion of the image, the part that exceeds the window, will not be displayed; to view the missing portions of the image, you can pan the displayed image (see the Panning and zooming section later in this chapter for more information). If the image is smaller in size than the smallest possible window, the image will be centered in the smallest possible window, and the surrounding area will be filled with the background color (MdispControl() with M_BACKGROUND_COLOR). If the window is enlarged or maximized, the image will remain the same size and centered. For windowed displays, MIL does not typically communicate directly with the graphics controller, but uses the normal Windows mechanisms to display images. Upon selecting a windowed display, MIL uses internal image buffers to store the selected image buffer and overlay information; it then uses Windows GDI functions for the final blit to screen. When allocating a windowed display for a Distributed MIL application, you can set the SystemId parameter to a remote system. Image buffers selected to such a display are presented on the local computer by default. However, if required, you can allocate the display so that image buffers are presented on the remote computer. For more information on allocating such a display, see Chapter 62: Distributed MIL. Exclusive display An image selected to an exclusive display is presented full-screen, without a windowed border or frame, on one of the Windows desktop screens. The image buffer is presented at the center of the screen. This screen is referred to as an exclusive screen. To use an exclusive display, your Windows desktop should be using more than one screen. Allocating an exclusive display on the main screen might not be convenient; if you do so, the MIL exclusive display will hide third-party applications designed to start on the main screen and hide the Windows taskbar. When allocating an exclusive display using MdispAlloc(), you can set the display number parameter of MdispAlloc() to M_DEFAULT, or to the position of the display device in a 3x3 multi-screen arrangement. For exclusive displays, M_DEFAULT will select the best available screen, avoiding the main desktop screen if possible. In screen arrangements of up to 3x3 screens, you can select the display device by specifying its position in the arrangement; you can specify that the screen is at the bottom, top, left, right, and/or center of the multi-screen arrangement (for example, M_BOTTOM + M_RIGHT). Additionally, when allocating an exclusive display using MdispAlloc(), you must specify the required video output format for the screen. You can set it to the current Windows resolution for the screen (M_CURRENT_RESOLUTION) or you can select a video configuration format (VCF) with the required resolution. If the image is too large to fit on screen given the selected display resolution, the top-left corner of the image will be aligned with the top-left corner of the screen, and the right and bottom portion of the image, the part that exceeds the screen area, will not be displayed; to view the missing portions of the image, you can pan the displayed image (see the Panning and zooming section later in this chapter for more information). If the image is smaller in size than the screen area, the image will be centered on screen, and the surrounding area will be filled with the background color (MdispControl() with M_BACKGROUND_COLOR). By default, the mouse cursor cannot move over an exclusive display; however, you can remove this restriction using MdispControl() with M_RESTRICT_CURSOR. In addition, by default, the display reacts to standard key strokes, but you can disable this behavior using MdispControl() with M_KEYBOARD_USE. For exclusive displays, MIL does not typically communicate directly with the graphics controller, but uses the normal Windows mechanisms to display images. Upon selecting an exclusive display, MIL uses internal image buffers to store the selected image buffer and overlay information; it then uses Windows GDI functions for the final blit to screen. When allocating an exclusive display for a Distributed MIL application, you can set the SystemId parameter to a remote system. Image buffers selected to such a display are presented on the local computer by default. However, if required, you can allocate the display so that image buffers are presented on the remote computer. For more information on allocating such a display, see Chapter 62: Distributed MIL. If only using one screen, you can hook a function to a keypress or mouse movement, using MdispHookFunction() with either M_KEY... or M_MOUSE.... Once the display event occurs, the exclusive display could be freed to allow the user to perform other work on the single screen. MILweb display An image selected to a MILweb display is presented by one or more instances of connected MILweb client applications (running on the local computer or a remote computer). To use a MILweb display, your MIL application should be configured to be a MILweb server application (for more information, see Chapter 58: Using MILweb to monitor your application). The MILweb server application will not actually show the display; it will transmit the selected buffer to connected instances of the MILweb client applications (when they establish a connection with the display). You can create a MILweb client application using the provided JavaScript or C/C++ MILweb API. You can write a client application for a variety of different platforms, including compatible web browsers. Regardless of the chosen API, the remote computer is not required to have MIL installed, have a MIL license, nor contain Matrox hardware to run a MILweb client application. MILweb displays support most of the same functionality as windowed displays. It is possible to interact with a MILweb display through a MILweb client application. By interacting with the display, the user can pan, zoom, and transform the image. If the display is annotated by a 2D graphics list that has been made editable, the user is also able to edit those annotations interactively. Only one client can have interactive control of the display at a time. When a change is made, the updated content of the display is sent to all connected clients. For more information on using MILweb, including how to create a MILweb client application, see Chapter 58: Using MILweb to monitor your application. Types of displays Windowed display Exclusive display MILweb display ",
      "wordCount": 1383,
      "subEntries": []
    },
    {
      "id": "UG_display_Displaying_buffers_of_different_data_depths",
      "version": null,
      "title": "Displaying buffers of different data depths",
      "subTitles": [
        "M_BIT_SHIFT",
        "M_AUTO_SCALE",
        "M_MULTI_BYTES",
        "M_TRANSPARENT"
      ],
      "location": "MIL UG P04: 2D related information",
      "pageURL": "content\\UserGuide\\display\\Displaying_buffers_of_different_data_depths.htm",
      "text": " Displaying buffers of different data depths Displayable image buffers usually have a depth of 8 bits (or 8 bits per band, in the case of color images). You can also display images of other depths (for example, 1-bit or 16-bit images). Using MdispControl() with M_VIEW_MODE, you can control the way such buffers are actually displayed. The M_VIEW_MODE control type provides different modes of displaying non 8-bit images: M_BIT_SHIFT. M_AUTO_SCALE. M_MULTI_BYTES. M_TRANSPARENT. M_DEFAULT. Note that M_VIEW_MODE is not available for network displays. M_BIT_SHIFT The M_BIT_SHIFT setting will right bit-shift the pixel values of the image by the specified number of bits upon updating the display. Specify the number of bits by which to shift using the M_VIEW_BIT_SHIFT control type. M_AUTO_SCALE The M_AUTO_SCALE setting remaps the pixel values to the display range such that the minimum and maximum values in the image (not the full range of the buffer) are set to 0 and 255, respectively. M_AUTO_SCALE is the default setting of M_VIEW_MODE when displaying a 1-bit buffer. If the image buffer contains a single value, its corresponding displayed value is determined by linearly remapping the full range of the buffer (for example, (0 to 64K) to (0 to 255)). MIL-Lite does not support displaying a 32-bit image buffer in a display that has its M_VIEW_MODE control type set to M_AUTO_SCALE, unless you have purchased the MIL Image Analysis license. M_MULTI_BYTES The M_MULTI_BYTES setting is primarily useful when grabbing from a multi-tap camera. This setting displays each byte of the image in separate display pixels. For instance, each pixel of a 16-bit image will occupy two consecutive display pixels; each pixel of a 32-bit image will occupy four consecutive display pixels. This mode is only supported for 16-bit and 32-bit 1-band images. M_TRANSPARENT The M_TRANSPARENT setting will display only the 8 least-significant bits of the image. No pixel remapping is performed. This is the default setting unless a 1-bit buffer is used. Displaying buffers of different data depths M_BIT_SHIFT M_AUTO_SCALE M_MULTI_BYTES M_TRANSPARENT ",
      "wordCount": 332,
      "subEntries": []
    },
    {
      "id": "UG_display_Displaying_an_image_in_a_userdefined_window",
      "version": null,
      "title": "Displaying an image in a user-defined window",
      "subTitles": [
        "Using MdispSelectWindow()"
      ],
      "location": "MIL UG P04: 2D related information",
      "pageURL": "content\\UserGuide\\display\\Displaying_an_image_in_a_userdefined_window.htm",
      "text": " Displaying an image in a user-defined window Images selected to a windowed display using MdispSelect() are presented in a default window created by MIL. This function dynamically creates a window on the Windows desktop for the specified display, if the display is not already selected. The created window respects any window control type setting associated with the display using an Mdisp...() function. Alternatively, for windowed displays, you can choose to display image buffers in a user-defined window, using MdispSelectWindow(). Note that the window does not require the same dimensions as the image buffer. If the defined window is of a different dimension than the image buffer, any excess window area will be left untouched or any excess image area will be cropped. Using MdispSelectWindow() The MdispSelectWindow() function is similar to MdispSelect(), except that it allows you to specify the handle of the user-defined window or child window to use for display, rather than displaying into a MIL created window. This user-defined window is automatically refreshed when the display is modified (for example, when the image data is modified). You can use MdispSelectWindow() with M_NULL to remove the image from the display. The user-defined window must have a window handle of type HWND or X11. You can use, for example, the Windows API functions to create a window with an HWND handle, and third-party functions (such as GTK, Tkinter, or Qt) to create an X11 window handle. In addition, if the handle parameter of MdispSelectWindow() is set to zero, this function behaves like MdispSelect(). Note that, to use a display with a window created using the third-party GTK, Tkinter, or Qt frameworks, you should enable a special mode. You can enable the mode using MdispControl() with M_GTK_MODE, M_TK_MODE, or M_QT_MODE, respectively. These modes prevent the display from appearing incorrectly when the window is moved or resized, while introducing a small amount of latency. To select an image to a user-defined window, the display cannot be allocated on a remote computer (MdispAlloc() with M_REMOTE_DISPLAY). Note that, by default, mouse and keyboard use are disabled in a user-defined window. You can enable mouse and keyboard use in a user-defined window using MdispControl() with M_MOUSE_USE and M_KEYBOARD_USE, respectively. The following example shows how to display an image in a user-defined window, grab into such a window, and remove the image from the display. mdispwindowqt.cpp Displaying an image in a user-defined window Using MdispSelectWindow() ",
      "wordCount": 401,
      "subEntries": []
    },
    {
      "id": "UG_display_Removing_a_buffer_from_the_display",
      "version": null,
      "title": "Removing a buffer from the display",
      "subTitles": null,
      "location": "MIL UG P04: 2D related information",
      "pageURL": "content\\UserGuide\\display\\Removing_a_buffer_from_the_display.htm",
      "text": " Removing a buffer from the display To remove an image buffer from the display, you can use MdispSelect() or MdispSelectWindow() with M_NULL, depending on which function was used to select the buffer to the display. For MIL windowed displays, this closes the associated window; whereas for user-defined windowed displays, this leaves the associated window open but leaves it blank. For exclusive displays, this causes the display to disappear, allowing the desktop to reappear on the screen. To display a different image buffer, you are not required to remove the current buffer from the display; selecting another buffer for display automatically updates the display with the new buffer. You can only remove the entire image buffer from the display. Therefore, when displaying a parent buffer, you cannot remove one of its child buffers from the display. Once you have finished using a display, you must free it using MdispFree(). Freeing the display, or freeing the buffer currently selected to the display, produces the same visual effect as when using MdispSelect() or MdispSelectWindow() with M_NULL. Removing a buffer from the display ",
      "wordCount": 181,
      "subEntries": []
    },
    {
      "id": "UG_display_Displaying_multiple_buffers",
      "version": null,
      "title": "Displaying multiple buffers",
      "subTitles": null,
      "location": "MIL UG P04: 2D related information",
      "pageURL": "content\\UserGuide\\display\\Displaying_multiple_buffers.htm",
      "text": " Displaying multiple buffers You can view one image buffer at a time in a display, but you can view multiple image buffers using multiple displays. Select the image buffers to different displays, using MdispSelect(). Using multiple windowed displays, you can view more than one buffer at the same time on the Windows desktop screen(s). For exclusive displays, you can have as many displays as you have appropriate screens; however, you can have only one display at a time on a given screen. To view more than one image at a time in one display, use child buffers. For example, you can display the source and destination images of an operation, using the following steps: Allocate a large displayable image buffer (big enough to contain the source and destination images) using MbufAlloc2d() or MbufAllocColor(). This buffer will be known as the parent buffer. Allocate two non-overlapping child buffers within it, using MbufChild2d() or MbufChildColor(). Select the parent buffer for display using MdispSelect(). Use one of the child buffers as the source image buffer and the other as a destination image buffer of the operation. The following example shows how to display multiple image buffers in a single display. The source image, Bird.mim, is loaded into a child of a displayable image buffer and then used as the source of an image processing operation (increasing the image luminance). The result is stored in the other child of the same image displayable buffer. mbufcolor.cpp For MIL-Lite, the luminance operation is not performed; the image is merely copied from the left child buffer to the right. Displaying multiple buffers ",
      "wordCount": 267,
      "subEntries": []
    },
    {
      "id": "UG_display_Panning_and_zooming",
      "version": null,
      "title": "Panning and zooming",
      "subTitles": [
        "Explicitly specifying the amount to pan and zoom",
        "Panning and zooming the display interactively"
      ],
      "location": "MIL UG P04: 2D related information",
      "pageURL": "content\\UserGuide\\display\\Panning_and_zooming.htm",
      "text": " Panning and zooming At times, your image buffer might be larger than the display, or have details that are too fine or too small to see. You can associate panning and zooming effects with the display to view specific parts of the image. Panning displaces an image horizontally and/or vertically on the display; panning is also known as scrolling. Zooming replicates or subsamples the pixels of an image upon display by a specified factor. You can explicitly specify the amount to pan and zoom; alternatively, for windowed and exclusive displays, you can allow a user to pan and zoom the display interactively. Explicitly specifying the amount to pan and zoom Regardless of the display type, you can explicitly specify the amount to pan and zoom the display. To pan displayed images, use MdispPan() and specify the required X- and Y-panning offsets in image pixels. To center images in the display, use MdispControl() with M_CENTER_DISPLAY instead. To zoom displayed images in the horizontal and/or vertical direction with floating-point precision, use MdispZoom() with the required X- and Y-zoom factors; to reduce the size of the displayed images, specify a zoom factor less than 1. The specified zoom factors also affect the panning offsets since these offsets are specified in image pixels. For example, if the X-zoom factor is set to 4, panning by an X-offset of one image pixel results in panning by 4 pixels in the horizontal direction on the display. Instead of explicitly specifying a zoom factor, you can automatically scale the displayed images to fit the display, using MdispControl() with M_SCALE_DISPLAY. M_SCALE_DISPLAY ensures that the image aspect ratio is maintained. If you use M_SCALE_DISPLAY, the explicitly specified zoom factors (MdispZoom()) and pan settings (MdispPan()) will be overwritten. For an example of zooming, refer to mimconvolve.cpp, where the display is zoomed by a factor of 2 to better demonstrate the result of an image processing operation (spatial filtering operation). Panning and zooming the display interactively With windowed and exclusive displays, it is possible to pan and zoom images interactively, using either the mouse or the keyboard. You can use the mouse wheel to zoom in or out of the image; to do so, scroll the wheel up or down, respectively. In addition, you can pan the image by clicking on the image and dragging in the required direction. You can also use the keyboard to pan and zoom the display interactively. To do so, you can use the keys associated with the MIL display. + Increases the X- and Y-zoom factors. - Decreases the X- and Y-zoom factors. Page-up Scrolls the image buffer up to the previous display section. Page-down Scrolls the image buffer down to the next display section. Up arrow Scrolls the image buffer up to the previous row. Down arrow Scrolls the image buffer down to the next row. Left arrow Scrolls the image buffer left by one pixel. Right arrow Scrolls the image buffer right by one pixel. Ctrl-Up arrow Scrolls the image buffer up to the previous display section. Ctrl-Down arrow Scrolls the image buffer down to the next display section. Ctrl-Left arrow Scrolls the image buffer left to the previous display section. Ctrl-Right arrow Scrolls the image buffer right to the next display section. Note that the window must have the focus for the keys to work. To give focus to an exclusive display, you must permit the mouse cursor to move over the display, using MdispControl() with M_RESTRICT_CURSOR. By default, mouse and keyboard use is enabled for MIL windowed and exclusive displays and disabled for user-defined windowed displays. To enable or disable mouse use in the display, use MdispControl() with M_MOUSE_USE. You can also set whether the mouse cursor changes shape if interactive panning or zooming is possible using MdispControl() with M_MOUSE_CURSOR_CHANGE. To enable or disable keyboard use, use MdispControl() with M_KEYBOARD_USE. Panning and zooming Explicitly specifying the amount to pan and zoom Panning and zooming the display interactively ",
      "wordCount": 658,
      "subEntries": []
    },
    {
      "id": "UG_display_Annotating_the_displayed_image_nondestructively",
      "version": null,
      "title": "Annotating the displayed image non-destructively",
      "subTitles": [
        "Annotating images using the overlay mechanism",
        "Overlay buffer behavior",
        "Camera calibration and overlay considerations",
        "Transparency (keying)",
        "Using a 2D graphics list",
        "Opacity",
        "Using GDI annotations",
        "Using regions of interest",
        "Opacity",
        "Examples"
      ],
      "location": "MIL UG P04: 2D related information",
      "pageURL": "content\\UserGuide\\display\\Annotating_the_displayed_image_nondestructively.htm",
      "text": " Annotating the displayed image non-destructively There are four ways to annotate an image on display: Using MIL's overlay mechanism. Using a 2D graphics list. Using GDI annotations. Using a region of interest (ROI). Annotating images using the overlay mechanism For all types of displays, you can annotate the displayed image non-destructively using MIL's overlay mechanism. To make use of this functionality, do the following: Enable the overlay mechanism, using MdispControl() with M_OVERLAY set to M_ENABLE. Select an image buffer to the display, using MdispSelect(). Since the overlay mechanism is enabled, this will not only display the selected image, but it will also associate a temporary overlay buffer with the display. This buffer is referred to as the display's overlay buffer. The overlay buffer can be used to annotate the underlying image with an effect called transparency, or keying. For more information, see Transparency (Keying). To access the display's overlay buffer, use MdispInquire() with M_OVERLAY_ID to determine the MIL identifier of the buffer. Annotate the display's overlay buffer as required. For example, to write text in the overlay buffer, you can use MgraText(). Note that since this temporary overlay buffer is a real image buffer, any function (except grabbing) can be used. You can also annotate the displayed image buffer or the overlay buffer with Windows GDI annotations. For information, see the Using GDI annotations subsection of this section. The overlay buffer will have the same size as its associated image (not the size of the display). In addition, for windowed displays, it will have the same number of bands and depth as the desktop; for exclusive displays, it will have the same number of bands and depth as the selected display format. Overlay buffer behavior When an image is selected to a display that has an associated overlay buffer, and you select another image to that display, one of the following occurs: If the new image has the same format and size as the image currently selected to that display, the current overlay buffer is not freed. Any annotations will, therefore, remain until you clear the overlay buffer (either using MbufClear(), or using MdispControl() with M_OVERLAY_CLEAR). If the new image has a different format or size than the image currently selected to that display, the contents of the current overlay buffer are copied to a temporary buffer, the current overlay buffer is freed, another overlay buffer is created, and the annotations of the old overlay buffer are copied from the temporary buffer into the new overlay buffer. The new overlay buffer has the same size as the new image selected to the display. The identifier of the old overlay buffer is now obsolete. To inquire the identifier of this newly created overlay buffer, use MdispInquire() with the M_OVERLAY_ID inquire type. Camera calibration and overlay considerations MIL tries to keep the camera calibration information of the overlay buffer synchronized with the camera calibration information of the buffer selected to the display. Note that camera calibration is not available with MIL-Lite. MIL will copy the camera calibration information of the selected buffer to the overlay buffer at the following moments: When the overlay buffer is allocated. When a buffer is selected to the display. When the camera calibration information of the selected buffer is modified. Note that if the camera calibration information of the overlay buffer is modified with McalAssociate(), MbufClear(), or some other function, the camera calibration information of the selected buffer will not be updated accordingly. However, changing the camera calibration information of the selected buffer will re-copy the camera calibration information of the selected buffer to the overlay buffer, even if the camera calibration information of the overlay buffer was manually changed. Transparency (keying) The display's overlay buffer annotates the image selected to the display using transparency. Transparency, also known as keying, is a mechanism that replaces pixels of an image that are of the specified transparency (keying) color with the underlying areas of another image. Using transparency, annotations made to the overlay buffer in a color other than the transparency color will annotate the image selected to the display. When allocating a display (MdispAlloc()), the transparency color is automatically set to a default color, which is generally appropriate. Use MdispInquire() with M_TRANSPARENT_COLOR to determine the transparency color. If required, select another transparency color using MdispControl() with M_TRANSPARENT_COLOR. If you are using an 8-bit display resolution (256 colors), set the transparency color to a value between 0 and 255. If you are using a non 8-bit display resolution (15-bit, 16-bit, 24-bit, or 32-bit color resolution), call the macro M_RGB888() and specify the RGB value. For example: MdispControl(DisplayID, M_TRANSPARENT_COLOR, M_RGB888(20,32,24)); When the display's overlay buffer is created, it is cleared to the effective transparency color. If the transparency color is changed after the overlay buffer is created, the buffer will not be cleared to the new color. In addition to making parts of the overly buffer transparent using keying, you can change the opacity of the annotations in the overlay buffer using MdispControl() with M_OVERLAY_OPACITY. For more information, see the Opacity subsection of this section. Using a 2D graphics list You can associate a 2D graphics list to the display. In this case, the vector-based graphics, contained within the 2D graphics list, will be used to annotate the display non-destructively. To perform such annotations, you must specify a valid 2D graphics list identifier, using MdispControl() with M_ASSOCIATED_GRAPHIC_LIST_ID. You must have previously allocated the 2D graphics list, using MgraAllocList(), and added one or more graphics to it, using MIL graphic functions (for example, MgraText() or using the M...Draw() functions). For more information, see the 2D graphics list section of Chapter 26: Generating graphics. By default, modifications to the graphics within the list (added, deleted, or altered graphics) will be immediately reflected in the non-destructive annotation of the display. To change this behavior, use MdispControl() with M_UPDATE_GRAPHIC_LIST. To release the 2D graphics list from memory, use MgraFree(). If the associated 2D graphics list is freed, it is automatically disassociated from the display. When you annotate the display non-destructively using a 2D graphics list, the zooming behavior of the display will be different than if you had annotated the display using the typical overlay mechanism. With the overlay mechanism, annotations are zoomed by resizing the overlay pixels, which can cause pixelation (loss of clarity), the loss of some annotations, or a change in line thickness. However, such effects do not occur when zooming a display that has 2D graphics list annotations (which are vector-based). Notice how, in the example above, neither the size of the text nor the quality of the rectangle is affected by the zoom factor, for annotations with a 2D graphics list. In addition, using a 2D graphics list, you can draw anywhere on the display. It does not have to be over the image buffer selected to the display. You can change the opacity of the annotations in the 2D graphics list using MdispControl() with M_OVERLAY_OPACITY. For more information, see the Opacity subsection of this section. Opacity When annotating a display using an overlay buffer or 2D graphics list, you can set the opacity of the annotations. To do so, use MdispControl() with M_OVERLAY_OPACITY (for the overlay buffer) or M_GRAPHIC_LIST_OPACITY (for the 2D graphics list) to set the opacity. Opacity is expressed as a percentage. A value of 100 specifies to show the annotations as completely opaque, and an opacity of 0 specifies to show the annotations as completely transparent (the annotations will not be visible). For an overlay buffer, pixels that you have made transparent using keying remain completely transparent regardless of this setting. Using GDI annotations Besides using MIL functions (for example, MgraText()) to annotate your display, you can draw GDI annotations in the buffer selected to the display or in the display's overlay buffer. To perform this technique with a Windows operating system: Allocate a device context (DC) for either the image buffer or the overlay buffer of the display using MbufControl() with M_DC_ALLOC. Windows GDI annotation functions require a DC to draw. You cannot allocate a DC for an image buffer that is not associated with a display. If you draw using the DC of the image buffer selected to the display, drawing will be destructive (that is, the data of the image buffer is actually changed). Inquire the identifier of the device context (DC) created in the previous step using MbufInquire() with the M_DC_HANDLE inquire type. Paint your annotations using Windows GDI annotation functions with the DC. Free the device context (DC), using MbufControl() with M_DC_FREE. Notify MIL that the display needs to be updated with the GDI annotations, using MbufControl() with M_MODIFIED. When drawing GDI annotations using this technique, the images are drawn using the buffer's coordinates, and the annotations will follow the underlying image when the display is zoomed or panned. However, the size of the overlay buffer is limited to the size of the selected image buffer. It is not possible to draw outside those limits. The following portion of MIL code shows the creation of the device context for the overlay buffer, the inquiring of the device context, and the drawing and writing in the overlay buffer (see also, MDispOverlay.cpp). HDC hCustomDC; HGDIOBJ hpen, hpenOld; MIL_TEXT_CHAR chText[80]; SIZE TxtSz; RECT Txt; int Count; /* Create a device context for drawing. */ MbufControl(MilOverlayImage, M_DC_ALLOC, M_DEFAULT); /* Inquire the handle of the device context. */ hCustomDC = ((HDC)MbufInquire(MilOverlayImage, M_DC_HANDLE, M_NULL)); if (hCustomDC){ /* Create a blue pen. */ hpen=CreatePen(PS_SOLID, 1, RGB(0, 0, 255)); hpenOld = SelectObject(hCustomDC,hpen); /* Draw a cross in the overlay buffer. */ MoveToEx(hCustomDC,0,ImageHeight/2,NULL); LineTo(hCustomDC,ImageWidth,ImageHeight/2); MoveToEx(hCustomDC,ImageWidth/2,0,NULL); LineTo(hCustomDC,ImageWidth/2,ImageHeight); /* Write text in the overlay buffer. */ MosStrcpy(chText, 80, MIL_TEXT(\"GDI Overlay Text \")); Count = (int) MosStrlen(chText); GetTextExtentPoint(hCustomDC, chText, Count, &amp;TxtSz); Txt.left = (MIL_INT32)(ImageWidth*3/18); Txt.top = (MIL_INT32)(ImageHeight*4/6); Txt.right = (MIL_INT32)(Txt.left + TxtSz.cx); Txt.bottom = (MIL_INT32)(Txt.top + TxtSz.cy); SetTextColor(hCustomDC,RGB(0, 0, 255)); DrawText(hCustomDC, chText, Count, &amp;Txt, DT_RIGHT); Txt.left = (MIL_INT32)(ImageWidth*12/18); Txt.top = (MIL_INT32)(ImageHeight*4/6); Txt.right = (MIL_INT32)(Txt.left + TxtSz.cx); Txt.bottom = (MIL_INT32)(Txt.top + TxtSz.cy); SetTextColor(hCustomDC,RGB(255, 0, 0)); DrawText(hCustomDC, chText, Count, &amp;Txt, DT_RIGHT); /* Deselect and destroy the blue pen. */ SelectObject(hCustomDC,hpenOld); DeleteObject(hpen); } /* Free the created device context. */ MbufControl(MilOverlayImage, M_DC_FREE, M_DEFAULT); /* Signal MIL that the overlay buffer was modified. */ MbufControl(MilOverlayImage, M_MODIFIED, M_DEFAULT); Using regions of interest Regions of interest (ROIs) can be used to restrict processing/analysis to a subset of data in an image buffer; see the Regions of interest subsection of the Child buffers, regions of interest, and fixturing section of Chapter 2: Building an application for details. You can set how to display the pixels that are in and not in the ROI using MdispControl() with M_REGION_INSIDE_SHOW and M_REGION_OUTSIDE_SHOW respectively; you can display the pixels with or without an overlay. Opacity When applying an overlay to the pixels in or not in the ROI, you can adjust the opacity. To set the overlay opacity for the pixels in the ROI, use MdispControl() with M_REGION_INSIDE_SHOW set to M_GRAPHIC_LIST_OPACITY. To set the overlay opacity for the pixels not in the ROI, use MdispControl() with M_REGION_OUTSIDE_SHOW set to M_GRAPHIC_LIST_OPACITY. Examples Below are two examples showing an overlay applied to the pixels not in the ROI of an image with an overlay opacity of 100% (left) and 50% (right). The image on the left is created using this code snippet. MdispControl(DispId, M_REGION_OUTSIDE_COLOR, M_COLOR_RED); MdispControl(DispId, M_REGION_OUTSIDE_SHOW, M_OPAQUE); The image on the right is created using this code snippet. MdispControl(DispId, M_GRAPHIC_LIST_OPACITY, 50); MdispControl(DispId, M_REGION_OUTSIDE_COLOR, M_COLOR_RED); MdispControl(DispId, M_REGION_OUTSIDE_SHOW, M_GRAPHIC_LIST_OPACITY); Annotating the displayed image non-destructively Annotating images using the overlay mechanism Overlay buffer behavior Camera calibration and overlay considerations Transparency (keying) Using a 2D graphics list Opacity Using GDI annotations Using regions of interest Opacity Examples ",
      "wordCount": 1941,
      "subEntries": []
    },
    {
      "id": "UG_display_Mapping_1band_images_through_a_LUT_upon_display",
      "version": null,
      "title": "Mapping 1-band images through a LUT upon display",
      "subTitles": [
        "Selecting the LUT to use for display",
        "Restrictions when displaying using LUT"
      ],
      "location": "MIL UG P04: 2D related information",
      "pageURL": "content\\UserGuide\\display\\Mapping_1band_images_through_a_LUT_upon_display.htm",
      "text": " Mapping 1-band images through a LUT upon display Upon display, you can map 1-band images through a specified LUT to control their gray levels or to display them in color; the LUT maps the image pixels to precalculated values on display. The following are some situations for which you can use a LUT to produce required display effects: When displaying monochrome images, you might want to view the images with each gray intensity in a different color. For example, you can associate specific colors to ranges of temperatures obtained by an infrared camera. When displaying monochrome images, you might want to invert the image values. For example, when grabbing a film negative, you can negate the video and display the film as it will be printed. Selecting the LUT to use for display Upon display, you can map all 1-band image buffers selected to a specified display through a specified LUT, or you can map only a specified 1-band image buffer through a LUT. To do so: Allocate an 8-bit LUT buffer using MbufAlloc1d() or MbufAllocColor() with M_LUT. The LUT buffer must have 2 depth of image buffer(s) to map number of entries (for example, to map 8-bit images, the LUT buffer should have 256 entries. Generate the data into the LUT buffer using MgenLutRamp(), or load the data into it, using MbufPut(). Associate the LUT buffer with the required display using MdispLut(), or to a particular image buffer using MbufControl() with M_ASSOCIATED_LUT. In the former case, all image buffers selected to the specified display are mapped through the LUT. In the latter case, only the specified image buffer is mapped and when the image buffer is saved, the LUT data is saved with it. Depending on the required display effect, associate either a 1-band or 3-band LUT buffer with the display or image buffer. For example, to invert the values of an image on display, use a 1-band M_LUT buffer that maps each pixel to the maximum pixel value minus the current pixel value; you can use MgenLutRamp() to generate the LUT data for such a mapping. To view a 1-band image buffer with each gray intensity in a different color, use a 3-band M_LUT buffer; to achieve this effect, you can also use the MdispLut() predefined 3-band pseudo-color LUT buffer, M_PSEUDO, instead of allocating your own LUT buffer. If both the display and the selected image buffer have an associated LUT buffer, the one associated with the display is respected. To disassociate a LUT buffer from a display or image buffer, use MdispLut() with M_DEFAULT, or MbufControl() with M_ASSOCIATED_LUT and M_DEFAULT, respectively. Restrictions when displaying using LUT When displaying using a LUT, note the following: If the content of a LUT buffer changes while the image is selected on the display, the changes will not take effect until you call MdispLut() again. You cannot associate a 3-band image buffer with a LUT buffer, nor can you select a 3-band image buffer to a display that is associated with a LUT buffer. In addition, the image buffer must be an 8- or 16-bit buffer. If these conditions are not respected, an error is generated. The view mode of the display cannot be set to M_AUTO_SCALE or M_MULTI_BYTES. The number of LUT buffer entries must be the same as the maximum number of intensities that can be represented in the displayed image buffer. In other words, if you want to map an 8-bit image buffer (that is, an image that can have 256 intensities), your LUT buffer must also have 256 entries. Mapping 1-band images through a LUT upon display Selecting the LUT to use for display Restrictions when displaying using LUT ",
      "wordCount": 614,
      "subEntries": []
    }
  ]
}]
[{
  "id": "UG_distributed-mil",
  "version": "2024020714",
  "title": "Distributed MIL",
  "subTitles": null,
  "location": "MIL UG P11: Miscellaneous",
  "pageURL": "content\\UserGuide\\distributed-mil\\ChapterInformation.htm",
  "text": " Chapter 62: Distributed MIL This chapter describes how to set up a Distributed MIL application. Distributed MIL allows for multiple MIL systems to interact across a network. Distributed MIL overview Setup and installation Client-server architecture Basic concepts for Distributed MIL Preparing computers for Distributed MIL Setting up the Distributed MIL server on remote computers Managing network connections and ports Cluster modes and port range Firewall configuration Licensing considerations Controlling configuration Steps to create a Distributed MIL controlling configuration Allocating DMIL remote systems Allocating a remote system by default Execution of MIL functions on remote systems Remote displays Default values on remote systems Files on remote systems Asynchronous calls Multi-threading Executing a user-defined function on the remote system Monitoring configuration Steps to create a Distributed MIL monitoring configuration Cluster manager Publishing application Monitoring application Using published MIL identifiers Displaying a published image buffer Message mailboxes Message mailbox allocation and use Message mailbox operation modes Steps to using a message mailbox Distributed MIL on your local computer Developing and debugging a Distributed MIL application Steps to use Distributed MIL on your local computer Best practice ",
  "wordCount": 185,
  "subEntries": [
    {
      "id": "UG_distributed-mil_Distributed_MIL_overview",
      "version": null,
      "title": "Distributed MIL overview",
      "subTitles": [
        "Setup and installation",
        "Client-server architecture"
      ],
      "location": "MIL UG P11: Miscellaneous",
      "pageURL": "content\\UserGuide\\distributed-mil\\Distributed_MIL_overview.htm",
      "text": " Distributed MIL overview Distributed MIL (DMIL) allows a MIL application running on one computer to access or use the resources of other computers, for example, to distribute processing, to grab remotely and display locally, or to monitor their buffers and other objects. There are two Distributed MIL configurations: Controlling configuration. A Distributed MIL setup comprised of a single MIL controlling application that uses DMIL to allocate MIL systems on remote computers to share in processing and other MIL operations; the DMIL remote systems can collaborate with each other and with local systems. You would typically use this to distribute the processing of a MIL application among several computers. Monitoring configuration. A Distributed MIL setup comprised of a single MIL monitoring application that uses DMIL to monitor published MIL objects (for example, buffers) of one or more independent MIL publishing applications; the MIL publishing applications use DMIL to publish designated MIL objects. You would typically use this to create a MIL application on a local computer that monitors MIL applications running on remote computers. In both configurations, a group of computers interacting using Distributed MIL is called a cluster. A cluster can have up to 128 computers. Regardless of the configuration or whether running locally or running remotely, all MIL functions in a Distributed MIL cluster generally behave as they do when running on a single computer without Distributed MIL. All information in this chapter applies to both configurations, unless otherwise specified. Setup and installation To develop or run a Distributed MIL application, MIL/MIL-Lite must be installed on all computers in the cluster. All computers should have the same version of MIL installed, including Service Packs and Distributed MIL Updates, with appropriate licenses; see the Licensing considerations subsection of the Preparing computers for Distributed MIL section later in this chapter. The operating systems of computers in a cluster can be a mix of any MIL supported operating systems. If exchanging buffers across the network, it is recommended that the computers have at least a Gigabit Ethernet interface (1000BaseT). The connection between computers is generally made using TCP/IP with a client-server architecture. Client-server architecture Both Distributed MIL configurations use a client-server architecture. In a client-server architecture, a client makes requests to a server, which accepts the requests and returns a service. When you install Distributed MIL, the Distributed MIL server is installed. In the controlling configuration, the controlling application is the client, and it allocates the DMIL remote systems on computers running a Distributed MIL server. You must explicitly ensure that the Distributed MIL server is running on the remote computers; although by default, the Distributed MIL server is automatically running. For more information on managing the Distributed MIL server in the controlling configuration, see the Setting up the Distributed MIL server on remote computers subsection of the Preparing computers for Distributed MIL section later in this chapter. In the monitoring configuration, the monitoring application is the client and the publishing applications have Distributed MIL servers loaded in them. In this configuration, you do not directly manage the Distributed MIL server; it is transparently managed by the MIL functions that establish the connection between the monitoring and publishing applications. For more information on which functions manage the connections in a monitoring configuration, see the Monitoring configuration section later in this chapter. Typically, you use Distributed MIL to access or use the resources of other computers. However, there are occasions when it is useful to run a Distributed MIL configuration only using your local computer. For example, when developing or debugging a Distributed MIL cluster, it might be useful to test your cluster completely locally before deploying it across several computers, where you have to worry about possible connection issues. For more information, see the Distributed MIL on your local computer section later in this chapter. Distributed MIL overview Setup and installation Client-server architecture ",
      "wordCount": 643,
      "subEntries": []
    },
    {
      "id": "UG_distributed-mil_Basic_concepts",
      "version": null,
      "title": "Basic concepts for Distributed MIL",
      "subTitles": null,
      "location": "MIL UG P11: Miscellaneous",
      "pageURL": "content\\UserGuide\\distributed-mil\\Basic_concepts.htm",
      "text": " Basic concepts for Distributed MIL The basic concepts and vocabulary conventions for Distributed MIL are: Board-type system. A board-type system consists of a Matrox board (or third-party board that is compatible with MIL), the Host CPU and memory, and any available graphics controller. Cluster. A cluster is a group of computers interacting in a Distributed MIL setup. In the controlling configuration, a cluster is all the computers that are being used by a single controlling application. In this configuration, a remote computer can belong to one or multiple clusters, depending on how many controlling applications are connected to it. In the monitoring configuration, all connected computers, whether running monitoring or publishing applications, are part of a single cluster. Cluster manager. A cluster manager is a computer designated to manage application identifiers in a monitoring configuration cluster. Controlling configuration. A Distributed MIL setup with one controlling application that allocates one or more DMIL remote systems, typically on remote computers. The controlling configuration is used to distribute a single, typically processing heavy, MIL application across multiple computers. The controlling application manages the MIL systems allocated on all the computers in the cluster. Distributed MIL. Distributed MIL is a MIL feature which allows multiple computers to interact across a network, using a client-server architecture. There are two Distributed MIL configurations: the controlling configuration and the monitoring configuration. Distributed MIL server. The Distributed MIL server is a program running on a computer that allows the computer to handle requests made by a client application, which is either the controlling application or the monitoring application, depending on the configuration. DMIL remote system. A DMIL remote system is a MIL system typically allocated on a remote computer. Specifically, a DMIL remote system is a MIL system allocated in the Distributed MIL server's address space, which is separate from the main application's address space. Host-type system. A Host-type system consists of the Host CPU and memory, and any available graphics controller. Local computer. The local computer is the computer that is running the controlling application in the controlling configuration, or the monitoring application in the monitoring configuration. MIL system. A MIL system is a set of hardware components used to execute MIL operations. A MIL system can be either a board-type system or a Host-type system. A board-type system consists of a Matrox board (or third-party board that is compatible with MIL), the Host CPU and memory, and any available graphics controller. A Host-type system consists of the Host CPU and memory, and any available graphics controller. In the controlling configuration, MIL systems on a remote and local computer can collaborate within a MIL application using Distributed MIL. Monitoring application. A monitoring application is a MIL application which is connected to a publishing application and is able to access the MIL objects the publishing application publishes. Monitoring configuration. A Distributed MIL setup that involves two or more separate MIL applications, usually on separate computers, where one application, the monitoring application, accesses designated MIL objects from other applications, the publishing applications. Publishing application. A publishing application is a MIL application which is set up to publish its own MIL objects to a monitoring application. Remote computer. A remote computer is a computer separate from the local computer. In the controlling configuration, you typically allocate a DMIL remote system on a remote computer. In the monitoring configuration, the monitoring application typically connects to publishing applications on remote computers. Basic concepts for Distributed MIL ",
      "wordCount": 576,
      "subEntries": []
    },
    {
      "id": "UG_distributed-mil_Preparing_computers_for_Distributed_MIL",
      "version": null,
      "title": "Preparing computers for Distributed MIL",
      "subTitles": [
        "Setting up the Distributed MIL server on remote computers",
        "Managing network connections and ports",
        "Cluster modes and port range",
        "Firewall configuration",
        "Licensing considerations"
      ],
      "location": "MIL UG P11: Miscellaneous",
      "pageURL": "content\\UserGuide\\distributed-mil\\Preparing_computers_for_Distributed_MIL.htm",
      "text": " Preparing computers for Distributed MIL To use Distributed MIL, you must prepare all computers with the appropriate software. All computers that you want to use in a Distributed MIL configuration must have MIL/MIL-Lite installed with the Distributed MIL option selected. During MIL installation, select the Distributed MIL option from the tree in the MIL optional components pane of the Matrox Imaging Setup dialog box. You will then choose how to start the Distributed MIL server, which is discussed below. Once installation is complete, the Distributed MIL components, including the Distributed MIL server, are installed on the computer, along with MIL/MIL-Lite. You must make sure that all the computers in the cluster have the appropriate licenses. If exchanging image buffers across the network, it is recommended that the computers have at least a GigE Ethernet interface (1000BaseT). Setting up the Distributed MIL server on remote computers A computer must be running the Distributed MIL server to accept new incoming connections and to create new outgoing connections. The Distributed MIL server manages all of a remote computer's connections; the server transparently opens and closes the required connections as necessary. Distributed MIL typically manages the Distributed MIL server, but you can control when it starts and stops running. In the monitoring configuration, the MIL functions will completely manage the server regardless of any explicit attempts to control it. In the controlling configuration, you must ensure that the server is running on any computer on which you will allocate a DMIL remote system. During installation (and afterwards with the MILConfig utility), you can select to start the server as a service, start the server at logon, or start the server manually. You will typically want to start the Distributed MIL server as a service. This will cause the server to start automatically when you boot the computer, and to recover automatically if the server crashes; you won't need to logon to the computer to start the server. The Distributed MIL server cannot be running as a service on a remote computer if you plan to: Present a display on that computer. Access that computer's file system with current user credentials. In these cases, you must select to start the server at logon. To set it to run at logon, open the MILConfig utility and select Run at every logon with user credentials in the Server Settings pane, found under the Distributed MIL item. Then, before a Distributed MIL application can access the computer, you must logon to the computer; once logged on, the server will start automatically. When developing a distributed application using DMIL, you might need to share files between computers. You can specify an application context on a remote computer as a source or destination for MappFileOperation(); this allows you to easily transfer files between MIL applications with a single function call. You can also use MappFileOperation() to execute a program on the remote computer. For more information see the Working with files section of Chapter 2: Building an application. Managing network connections and ports You don't need to manage all the separate connections required between the computers in your cluster. However, you must establish a port on the remote computers to which their Distributed MIL server should listen for new connection requests, and that your application should access to initiate new connections. By default, the Distributed MIL server listens to port 57010 or 57020 for new connection requests when in the controlling configuration or the monitoring configuration, respectively. If the remote computer uses this port for other purposes, you can specify a different listening port number using the MILConfig utility on this computer. When you specify a non-default port for the server, you should specify that your controlling or monitoring application uses the same port to connect to the remote computer. You can change the default server connection port, which the local computer uses to connect to a remote computer, using the MILConfig utility on the local computer. If some of your remote computers don't use this default port, your controlling or monitoring application must explicitly specify the port to access on these remote computers. For an example of how to allocate a DMIL remote system on a specific port, see the Allocating DMIL remote systems subsection of the Controlling configuration section later in this chapter. For an example of how to connect to a publishing computer on a specific port, see the Monitoring application subsection of the Monitoring configuration section later in this chapter. Note that your application remains more portable if your application does not explicitly specify the port to access during system allocation. The connection between computers is typically made using TCP/IP. It is also possible, but not required, to specify a passkey server side (on the remote computer). This ensures that only MIL applications which specify the passkey during connection are given access. To set up the passkey, specify it in the MILConfig utility on the remote computer in the Server Settings pane; the passkey is a string of up to 16 case-sensitive alphanumeric characters. The controlling/monitoring computer must pass the passkey along with the system name, port, and system type to the remote system(s) or publishing application(s) when establishing a connection to the remote computer(s) using MsysAlloc() or MappOpenConnection() (depending on if you are using a MIL controlling configuration or a MIL monitoring configuration respectively). The remote computer will then validate the authenticity of the passkey which was passed to it from the controlling/monitoring application. Each remote computer in a Distributed MIL application can have a different passkey. Note that you cannot specify a passkey for a DMIL default system. Cluster modes and port range In the controlling configuration, the Distributed MIL server can exist in one of two cluster modes: single or multiple. By default, the server is set to single cluster mode, which specifies that the server will only be connected to a single controlling application. By specifying multiple cluster mode, the server is able to be connected to several independent controlling applications. When specifying how to start the Distributed MIL server, you can choose to start the server as a service in single cluster mode or in multiple cluster mode. You specify the cluster mode in the MILConfig utility. If the Distributed MIL server is in the default single cluster mode, the controlling application connects to the remote computer using the default or explicitly specified server connection port. If the Distributed MIL server is in multiple cluster mode, only the initial connection is made using the default or explicitly specified server connection port. You must establish a range of ports on the remote computer which the Distributed MIL server could use for subsequent connections. You can either use the default range or specify a range using the MILConfig utility on the remote computer. The connection to a remote computer in multiple cluster mode happens as follows: The controlling application connects to the remote computer using the default or explicitly specified server connection port. The remote computer spawns a new instance of the Distributed MIL server. The new instance of the Distributed MIL server selects a connection port from the range of specified ports on the remote computer. The remote computer informs the controlling application of the newly selected port. The controlling application disconnects from the remote computer. The controlling application reconnects to the remote computer using the port selected in step 3. In this process, the remote computer dynamically selects the port for its connections depending on which ports in its specified range are available; this port management technique allows for the computer to be part of multiple clusters. When running your application, you can confirm that connections have been set up properly by monitoring the Distributed MIL server's output using the MILConfig utility on the remote computer. Firewall configuration When using the TCP/IP communication layer, you will need to ensure that your networking equipment (for example, firewalls and proxy servers) has been configured properly so that it allows Distributed MIL to create all of its required connections. All computers must be able to accept data from each other on the specified TCP/IP port and port range. When dealing with computers that have Microsoft Windows Firewall enabled, a pop-up will appear during the execution of a MIL application whenever there is a need to use a port blocked by the firewall. Through this pop-up, you can configure the Microsoft Windows Firewall to allow the use of a specific port by a specific application. To optimize performance for computers behind a Microsoft Windows Firewall, you should unblock these ports using the MILConfig utility. On the Server Settings pane, accessed using the Distributed MIL - Controlling item, select the Microsoft Windows Firewall exception option. Alternatively, you can unblock ports directly using Microsoft Windows by navigating to the Control Panel and adding exceptions to the Microsoft Windows Firewall. Instead of unblocking the above-mentioned ports, you can disable the firewall for these ports using the Microsoft Windows Firewall interface. Disabling the firewall will stop the firewall software from watching the specified ports. Note that disabling the firewall on specific ports is not recommended if your computers are connected to a large network (such as, the internet). Licensing considerations To develop or run a Distributed MIL application, you must have the appropriate licenses: Product Mode of operation Licenses Required Computers running the controlling, monitoring, or publishing applications Computers with DMIL remote systems MIL Developing MIL development license. Runtime licenses for Distributed MIL and any MIL module that the computer actually uses. Running Runtime licenses for Distributed MIL and any MIL module that the computer actually uses. MIL-Lite Developing Supplemental licenses for Distributed MIL and any other functionality actually used that requires a supplemental license. Supplemental licenses for Distributed MIL and any other functionality actually used that requires a supplemental license. Running All computers in the cluster need a Distributed MIL license to either send or receive a DMIL command; a MIL development license includes Distributed MIL. In addition, each computer needs the licenses for any MIL modules/functionality that the computer actually uses. For example, if the controlling application on the local computer calls a Model Finder function using objects allocated on a remote computer, the operation will actually be performed on the remote computer; therefore, only the remote computer needs a Model Finder license. Note that when all remote computers in a controlling configuration are Zebra computers or smart cameras (for example, Zebra Supersight, Zebra 4Sight EV7, and Matrox Iris GTX), the local computer does not need a Distributed MIL license. For more information on licensing, see Chapter 68: Distribution and licensing. Preparing computers for Distributed MIL Setting up the Distributed MIL server on remote computers Managing network connections and ports Cluster modes and port range Firewall configuration Licensing considerations ",
      "wordCount": 1794,
      "subEntries": []
    },
    {
      "id": "UG_distributed-mil_Controlling_configuration",
      "version": null,
      "title": "Controlling configuration",
      "subTitles": [
        "Steps to create a Distributed MIL controlling configuration",
        "Allocating DMIL remote systems",
        "Allocating a remote system by default",
        "Execution of MIL functions on remote systems",
        "Remote displays",
        "Default values on remote systems",
        "Files on remote systems",
        "Asynchronous calls",
        "Multi-threading",
        "Executing a user-defined function on the remote system"
      ],
      "location": "MIL UG P11: Miscellaneous",
      "pageURL": "content\\UserGuide\\distributed-mil\\Controlling_configuration.htm",
      "text": " Controlling configuration In the controlling configuration, a local computer allocates a MIL application context and then allocates one or more DMIL remote systems. It can allocate multiple board-type and Host-type DMIL remote systems. The controlling application can only allocate remote systems on computers running the Distributed MIL server. The local computer runs the MIL controlling application, which manages the connection and communication with the remote systems. All resources in a controlling configuration cluster can be shared transparently (automatic connection), except when network address translation (NAT), port forwarding, or other address translation tools are used. If these tools are used, a remote system can only share resources with the controlling application. A simple controlling configuration cluster is illustrated below: Steps to create a Distributed MIL controlling configuration The following steps provide a basic methodology for creating a Distributed MIL controlling configuration: Allocate a MIL application context, using MappAlloc(). If required, allocate a system on the local computer, using MsysAlloc(). If you don't specify a target computer when allocating a system, MIL allocates the system locally on the current computer (local computer). Allocate a DMIL remote system on each of the remote computers, using MsysAlloc() with the target remote computer's identifier (for example, IP address). Note that to allocate a DMIL remote system on the local computer (for example, to test your application) specify \"localhost\" or 127.0.0.1 as the computer identifier. Call the MIL functions to perform the required operations, specifying objects allocated on these DMIL remote systems. Based on the objects passed, MIL will perform the functions on the most appropriate computer; if some of the objects are not on the selected computer, they will be copied to it. For this reason, MIL functions are most efficient when operating on objects whose systems are allocated on the same computer. Free all allocated objects using MappFree(), unless M_UNIQUE_ID was specified during allocation. Note that all allocated objects must be freed before freeing the MIL system context (MsysFree()), which must be freed before freeing the MIL application context (MappFree()). Before you can run a Distributed MIL application, you must prepare the local computer and each of the remote computers with the appropriate software. See the Preparing computers for Distributed MIL section earlier in this chapter. Allocating DMIL remote systems DMIL remote systems are allocated in a similar manner as all MIL systems, using MsysAlloc() and specifying the type of MIL system to allocate. The additional information needed to allocate a DMIL remote system is the name or identifier of the computer on which to allocate the remote system. To pass this information, the SystemDescriptor parameter of MsysAlloc() must specify the type of system to allocate, as well as identify the target remote computer on the network. To override the default Distributed MIL server connection port, SystemDescriptor should also specify the required port. The full syntax for the SystemDescriptor parameter is typically as follows: \"dmiltcp://RemoteComputerIdentifier:PortNumber/MILSystemType\" where RemoteComputerIdentifier should be replaced with the remote computer's name or IP address; MIL supports both IPv4 and IPv6 addresses. PortNumber should be replaced with the port that the local computer should access on the remote computer to initiate new connections, unless the default server connection port is appropriate; in which case, omit the \":\" and the port number. MILSystemType should be replaced with any valid MIL system type, such as M_SYSTEM_SOLIOS. The \"://\" and \"/\" are required separators. In the following case, you don't need to explicitly specify a server connection port; the default matches the port to which the Distributed MIL server is listening on the remote computer. /* Connection made without specifying port. */ MsysAlloc(MIL_TEXT(\"dmiltcp://192.168.53.4/M_SYSTEM_HOST\"), M_DEFAULT, M_DEFAULT, &amp;RemoteSystemId); Whereas in the following case, you must explicitly specify a server connection port because by default, it does not correspond to the port to which the Distributed MIL server is listening. In this case, the server connection port must be set to 58000 to establish a connection. /* In this case, the connection cannot be made without specifying the port - an error */ /* is generated with the following call. */ MsysAlloc(MIL_TEXT(\"dmiltcp://192.168.53.4/M_SYSTEM_HOST\"), M_DEFAULT, M_DEFAULT, &amp;RemoteSystemId); /* Since the port is specified and it matches the listening port on the remote computer,*/ /* the connection is made with the following call. */ MsysAlloc(MIL_TEXT(\"dmiltcp://192.168.53.4:58000/M_SYSTEM_HOST\"), M_DEFAULT, M_DEFAULT, &amp;RemoteSystemId); If you specify a server connection port, ensure that the specified port corresponds to the listening port on the target remote computer. The listening port can be configured using the MILConfig utility on the target remote computer. A typical IPv4 string has the format n.n.n.n, where n is a number between 0 and 255. A typical IPv6 string has the format x:x:x:x:x:x:x:x, where x is a hexadecimal number between 0000 and FFFF. If you are supplying an IPv6 address, you must use square brackets to separate the address from the port. For example: \"dmiltcp://[x:x:x:x:x:x:x:x]:PortNumber/MILSystemType\" Allocating a remote system by default You can set your local computer's default system to a DMIL remote system. This means that when you allocate a default system on your local computer, using MsysAlloc() with SystemDescriptor set to M_SYSTEM_DEFAULT, you will automatically set up a Distributed MIL controlling configuration with a connection to this default remote system. Your local computer's default system is set using the MILConfig utility. To reset your default system to a DMIL remote system, you must first register the remote system on your local computer. To register a remote system, open the MILConfig utility and enter the network computer's name or IP address, then select a system on that remote computer. This is done in the Registration pane, found in Distributed MIL - Controlling. Any single MIL system registered on the local computer, including the registered remote systems, can be chosen as the default system using the MILConfig utility on the Default Values pane, found under the General item. Note that a remote computer has a default system of its own. You can allocate the remote computer's default system by setting the SystemDescriptor parameter to \"dmiltcp://RemoteComputerIdentifier/M_SYSTEM_DEFAULT\". Execution of MIL functions on remote systems In the controlling configuration, MIL decides where to execute a MIL function based on the MIL objects passed as parameters to the function. Therefore, to perform the required operations on a remote computer, allocate a DMIL remote system on this computer and then pass objects allocated on this remote system to the corresponding MIL functions. When all of the MIL objects passed are allocated on the same DMIL remote system, MIL executes the function on the computer (processor) associated with this system. When the MIL objects passed are allocated on different systems, MIL establishes if there is a computer (processor) associated with one of the systems most suitable to execute the operation. To be suitable, MIL must be able to temporarily copy all relevant MIL objects to this computer. Only objects allocated with the MIL Buffer module (Mbuf...()) can be copied to another computer (portable); other objects are not portable. If a MIL object is not portable, the computer associated with this object is typically selected as the most suitable. If two of the MIL objects are not portable and are on different computers, an error is generated. If MIL establishes that a remote computer is the most suitable to execute a MIL function, the controlling application sends a command to this computer to execute the function. Then, using inter-system calls, the remote computer typically communicates directly with the other remote computers, to fetch a copy of any required MIL objects located on these computers and to send back any changes. Inter-system calls improve performance when multiple remote computers are involved. If an object is located on the local computer, inter-system calls are not used; the local computer will perform the required copy operations. Since additional copy operations are avoided, MIL functions are most efficient when operating on objects whose systems are all allocated on the same computer. Remote displays When you allocate a display on a DMIL remote system, you can select image buffers allocated on that system, to the display. By default, these buffers are displayed on the local computer. /* Allocate a display on a DMIL remote system, which displays image */ /* buffers on the local computer. */ MdispAlloc(RemoteSystemId, M_DEFAULT, MIL_TEXT(\"M_DEFAULT\"), M_WINDOWED, &amp;DisplayId); MdispSelect(DisplayId, RemoteImageBufId); If you want to display the buffers on the remote computer, specify M_REMOTE_DISPLAY when allocating the display. This is not supported for displays which display into a user-defined window. /* Allocate a display on a DMIL remote system, which displays image buffers */ /* on a remote computer. */ MdispAlloc(RemoteSystemId, M_DEFAULT, MIL_TEXT(\"M_DEFAULT\"), M_WINDOWED+M_REMOTE_DISPLAY, &amp;DisplayId); MdispSelect(DisplayId, RemoteImageBufId); When displaying on the local computer and the overlay mechanism is enabled, the display's overlay buffer is superimposed on the displayed buffer before the transfer. By default, the display is updated after each modification to the displayed buffer (or the overlay buffer), and the application waits for the data to be transferred to the display before continuing. When a buffer, located on a remote system, is displayed on the local computer, the update time can significantly slow down your application. To reduce delays, you can display in asynchronous mode using MdispControl() with M_ASYNC_UPDATE. This mode uses multiple internal buffers to queue the updates and allows the application to continue once the update has been queued. This maximizes your bandwidth usage while minimizing processing delays. To reduce transmission delays when the displayed buffer is modified, only the modified areas of the buffer are transmitted. By default, MIL sends updates from the remote system to the local computer as fast as possible, limited by the available bandwidth and transmission delay. However, when updating the display asynchronously, it is possible to set an upper limit to the number of updates to perform per second, using MdispControl() with M_UPDATE_RATE_MAX. When a limit is specified, you can assume that there will be a minimum delay of 1/ M_UPDATE_RATE_MAX between two consecutive updates. Between transmissions, updates are accumulated into one update. Alternatively, whether updating the display synchronously or asynchronously, you can use MdispControl() with M_UPDATE_RATE_DIVIDER to skip updates. In this case, you specify after how many buffer modifications to update the display with the last modification, regardless of the time lapsed. This is especially useful when performing continuous grabs. When using M_UPDATE_RATE_DIVIDER, if fewer than the specified number of buffer modifications occur, the display will not be updated; whereas with M_UPDATE_RATE_MAX, the display will eventually be updated. To reduce bandwidth usage, it is also possible to use compression so that the amount of data transmitted is minimal. You can activate compression using MdispControl() with M_COMPRESSION_TYPE. When enabled, data is compressed before being transmitted. The best compression rate is obtained with M_JPEG_LOSSY. The M_JPEG2000_LOSSY and M_JPEG2000_LOSSLESS compression types support much higher ratios of compression without compromising image quality. However, you should avoid the JPEG2000 compression types unless absolutely necessary since compression/decompression time is high; you should only use them when the benefits of compression outweigh the overhead associated with the compression/decompression. For example, you might need to use the JPEG2000 compression types when there are fine details in your image or overlay buffer. For both JPEG and JPEG2000 lossy compression types, you can manually adjust the compression factor by adjusting the quantization factor, using MdispControl() with M_Q_FACTOR. By default, the quantization factor for the compression is set to 80, but you can specify an integer value in the range of 1 to 99. The higher the factor, the more the compression, but the image quality suffers. To change the default settings, you can use the MILConfig utility on the remote computer. If you select the High quality display option in the MILConfig utility, the display is updated synchronously and compression is disabled by default; if you select the Optimized for bandwidth usage display option, the display is updated asynchronously and M_JPEG_LOSSY compression is used by default. Default values on remote systems When a function is executed on a remote computer and you select M_DEFAULT (or any local defaults such as M_SYSTEM_DEFAULT), the default value set up on that remote computer is used. The default value could have been setup when installing MIL on that computer or using the MILConfig utility on that computer. As mentioned above, the only exception is when allocating a display. When allocating a display on a remote system, the display appears, by default, on the local computer. The local computer's default video configuration format (VCF) is the format used. If you specify to have it appear on a remote computer (M_REMOTE_DISPLAY), the default VCF of the remote computer is used. Files on remote systems When a function takes a file name and is executed on the remote computer, MIL assumes that the file is on the local computer. To specify a file on the remote computer, prefix the specified file name with \"remote:///\" (for example, \"remote:///C:\\mydirectory\\myfile\"). Asynchronous calls Most functions executed on a remote computer are executed asynchronously. The function execution request is sent to the remote computer and the local call returns immediately, without waiting for the request to complete. Except for functions that return values (for example, allocation and inquire functions), almost all other functions are asynchronous. Asynchronous calls are queued on the remote computer and processed in the order that they were issued on a thread-by-thread basis. Multi-threading The controlling configuration supports multi-threading. Each thread in the controlling application has a corresponding thread on the remote system. All requests made on a specific thread in the controlling application are executed on the same corresponding thread on the remote system; the sequence of calls in a thread is respected. Threads on the remote system are independent and parallelism in the controlling application is respected. Executing a user-defined function on the remote system When time is of essence and you have a series of functions that need to be executed on a remote computer and some are synchronous, you can create a MIL user-defined function that is executed on the remote computer and that calls the required series of functions. This avoids unnecessary communication with the local computer. To develop such a MIL user-defined function, see Chapter 67: The MIL function development module. Controlling configuration Steps to create a Distributed MIL controlling configuration Allocating DMIL remote systems Allocating a remote system by default Execution of MIL functions on remote systems Remote displays Default values on remote systems Files on remote systems Asynchronous calls Multi-threading Executing a user-defined function on the remote system ",
      "wordCount": 2396,
      "subEntries": []
    },
    {
      "id": "UG_distributed-mil_Monitoring_configuration",
      "version": null,
      "title": "Monitoring configuration",
      "subTitles": [
        "Steps to create a Distributed MIL monitoring configuration",
        "Cluster manager",
        "Publishing application",
        "Monitoring application",
        "Using published MIL identifiers",
        "Displaying a published image buffer"
      ],
      "location": "MIL UG P11: Miscellaneous",
      "pageURL": "content\\UserGuide\\distributed-mil\\Monitoring_configuration.htm",
      "text": " Monitoring configuration When you have one or more MIL applications running locally or on remote computers, it can be convenient to monitor or manipulate some of the applications' MIL objects, such as buffers or contexts, from an application on your local computer. Distributed MIL can allow one MIL application on the local computer, known as the monitoring application, to monitor MIL objects of separate MIL applications, typically on separate computers, known as the publishing applications. The monitoring application is able to access only those MIL objects explicitly designated by the publishing applications. All other processes and MIL objects of the publishing application are not accessible to the monitoring application. When initially allocating a monitoring or publishing MIL application context, you must specify a computer as a cluster manager. The cluster manager keeps all the application identifiers unique within the cluster. The default cluster manager is specified using the MILConfig utility. The publishing applications can designate a permission level, either read only or read/write, for each of their own MIL objects; by default, all MIL objects' permission levels are set to non-accessible. When you publish an object, the publishing application opens the Distributed MIL server, which allows the monitoring application to then connect to the publishing application. Once connected, the monitoring application inquires a list of the MIL objects that the publishing application has designated as read only or read/write, and then interacts with these MIL objects according to their permission level. In a monitoring configuration cluster, both monitoring and publishing applications run independently, except for the explicit monitoring mentioned above. A simple monitoring configuration cluster is illustrated below: Steps to create a Distributed MIL monitoring configuration The following steps provide a basic methodology for creating a Distributed MIL monitoring configuration cluster: Set a computer as the cluster manager. Setup the publishing applications. Setup the monitoring application. Before you can run a Distributed MIL application, you must prepare all the computers with the appropriate software and licenses. See the Preparing computers for Distributed MIL section earlier in this chapter. Cluster manager A MIL cluster manager manages the identifiers of MIL application contexts in a Distributed MIL monitoring configuration cluster. This assures that application context identifiers are unique; duplicate identifiers can cause a conflict. The MIL cluster manager is a designated computer that has a valid version of MIL/MIL-Lite installed with the Distributed MIL option selected. The MIL cluster manager can be on a computer running the monitoring application, a publishing application, or any other stand alone MIL application. It can also be a computer not currently running any MIL application. When allocating a MIL application context, you must specify a MIL cluster manager that is currently active. You can activate a MIL cluster manager using the MILConfig utility on the computer designated as the cluster manager. The activation prompt is found in the Cluster Manager pane, accessible from the Distributed MIL item. To ensure the uniqueness of MIL application context identifiers across the cluster, all computers within a cluster must specify the same cluster manager. Publishing application A publishing application allows individual MIL objects to be accessed by a monitoring application. This is called publishing a MIL object. A publishing application can only be connected to a single monitoring application at a time. To create a publishing application: Allocate a MIL application context using MappAlloc() with its ServerDescription parameter set to the name or IP address of the computer designated as the cluster manager. Optionally, specify a non-default listening port for the publishing application using M_DMIL_CONNECTION_PORT. To use the default listening port, set using the MILConfig utility, you do not need to explicitly specify it. Note that the port must be unique if more than one MIL application will publish objects from the same computer. Set the global permission level for the application's objects to read/write or read only, using MappControl() with M_DMIL_CONNECTION set to either M_DMIL_CONTROL or M_DMIL_MONITOR, respectively. This activates the Distributed MIL server and allows the monitoring application to connect to this publishing application. Set the access to a particular MIL object, using MobjControl() with M_DMIL_PUBLISH set to either M_READ_WRITE or M_READ_ONLY. Any MIL object with a MIL identifier can be published in this manner, except for MIL displays (MdispAlloc()). A MIL object cannot have greater permission than the global permission level for the application. For instance, if the application permission level is set to read only, no individual MIL object in the application can be set to read/write. If the application permission level is set to disable (MappControl() with M_DMIL_CONNECTION set to M_DISABLE), no individual MIL object in the application can be set to either read only or read/write. Optionally, name the published MIL objects, using MobjControl() with M_OBJECT_NAME set to any string. If an object is named, you can more easily identify it from the monitoring application using either MappInquireConnection() or MobjInquire(). publishingapplication.cpp Monitoring application A monitoring application can access MIL objects published by a publishing application. This access can be read/write or read only. A monitoring application can be connected to multiple publishing applications at the same time. To create a monitoring application: Allocate a MIL application context using MappAlloc() with its ServerDescription parameter set to the name or IP address of the computer designated as the cluster manager. Open a connection to a remote or local computer that is running a publishing application, using MappOpenConnection(). You must specify the monitoring application's connection port if its default connection port, set using the MILConfig utility, is different from the publishing application's listening port. Note that the publishing application must have called MappControl() with M_DMIL_CONNECTION set to either M_DMIL_CONTROL or M_DMIL_MONITOR before a connection can take place. Inquire the MIL object's MIL_ID from the publishing application, using MappInquireConnection(). If you know the name that the publishing application assigned to the object (using MobjControl() with M_OBJECT_NAME), inquire that MIL object's MIL identifier using MappInquireConnection() set to M_DMIL_PUBLISHED_NAME. Inquire a list of published MIL identifiers using MappInquireConnection() with InquireType set to M_DMIL_PUBLISHED_LIST. You can limit this list to all published MIL identifiers of a single MIL object type by also specifying the required type of object. For example, you can inquire the list of all image buffers published by a specific publishing computer using MappInquireConnection() with M_DMIL_PUBLISHED_LIST and M_IMAGE. Repeat step 2 and step 3 for each publishing application you want the monitoring application to connect to. monitoringapplication.cpp Using published MIL identifiers A monitoring application uses the inquired MIL identifier from a publishing application as it would a local MIL identifier. The only difference is that it uses the MIL identifier of a published object rather than a local object. A monitoring application will typically process its functions on the local computer. For example, the monitoring application could call MimResize() and use an image buffer published by a publishing application as the source image. For the destination image, the function could specify a local image buffer or a published image buffer that is set to read/write. Regardless of the destination, the function would be processed on the local computer. In the process of using a published object, the monitoring application creates a local temporary copy of the published object, and then quickly deletes the local copy after using it. Despite deleting the local copy, the monitoring application retains a link to the original published object. Displaying a published image buffer The monitoring application can display an image buffer from a publishing application, provided that the published image buffer had originally been allocated with the M_DISP attribute. Note that the monitoring application cannot use a display from a publishing application. Publishing a display object will result in an error. To display a published image buffer, the monitoring application must allocate a display using MdispAlloc(). It must then select the published displayable image buffer using MdispSelect(). Any changes to the published image buffer in the publishing application will trigger the monitoring application to get the new version of the image buffer and automatically update its display. The publishing application does not have to display its own displayable image buffer for the monitoring application to display the image buffer. Note that if both the monitoring and publishing applications are displaying the same image buffer, there might be a small difference in the rate at which images grabbed or altered in this buffer are displayed on both computers, due to bandwidth limitations. Monitoring configuration Steps to create a Distributed MIL monitoring configuration Cluster manager Publishing application Monitoring application Using published MIL identifiers Displaying a published image buffer ",
      "wordCount": 1416,
      "subEntries": []
    },
    {
      "id": "UG_distributed-mil_Message_mailboxes",
      "version": null,
      "title": "Message mailboxes",
      "subTitles": [
        "Message mailbox allocation and use",
        "Message mailbox operation modes",
        "Steps to using a message mailbox"
      ],
      "location": "MIL UG P11: Miscellaneous",
      "pageURL": "content\\UserGuide\\distributed-mil\\Message_mailboxes.htm",
      "text": " Message mailboxes To pass messages between the publishing and the monitoring application in a monitoring configuration, you can use a message mailbox. Message mailboxes are, at their simplest, a MIL object for storing generic messages. The publishing application can use them, for example, to store a generated custom error message, image statistics, or image meta-data (such as EXIF information). Messages can be associated with a tag to identify the type of message. Although this is the expected use for message mailboxes, you can use them in a non-DMIL application. Message mailbox allocation and use To allocate a message mailbox, use MobjAlloc() with M_MESSAGE_MAILBOX. To write a message to a message mailbox, use the MobjMessageWrite() function. To read a message from a message mailbox, use the MobjMessageRead() function. To make the message mailbox accessible to the monitoring application, use MobjControl() with M_DMIL_PUBLISH. MobjMessageRead() will only read the message if it doesn't time out, and you pass it a sufficient amount of memory in which to write the read message. To establish the amount of memory to allocate to read the next message, you can call MobjMessageRead() with its MessagePtr parameter to M_NULL and use the return value. Alternatively, you can use MobjInquire() with M_MESSAGE_LENGTH to determine the size of the next message. MobjMessageRead() will also report the status of the operation, with a status of M_SUCCESS for a successful read operation, or a status of M_BUFFER_TOO_SMALL or M_READ_TIMEOUT if the read operation was not successful. Message mailbox operation modes When you allocate a message mailbox, you must specify the mode in which the mailbox should operate: overwrite mode (M_OVERWRITE) or queued mode (M_QUEUE). When a message mailbox operates in overwrite mode, it only allows one message to be stored in the mailbox at a time. When a new write (MobjMessageWrite()) operation occurs, the previous message is overwritten with the new message. This means that the current message can be read any number of times until a subsequent write operation occurs. When a message mailbox operates in a queued mode, multiple messages can be simultaneously stored in a queued mailbox. The queued mailbox operates in a first-in first-out (FIFO) fashion. That is, the first message stored in a queued mailbox is the first message to be read. Furthermore, unlike in overwrite mode, a message written to a queued mailbox is, by default, removed from the message mailbox upon a read operation. It is possible to override the behavior of deleting a message upon a read operation in a queued mailbox. To do so, call MobjMessageRead() with M_KEEP_IN_QUEUE; this will keep the message in the queued mailbox until the next read operation that doesn't make use of the M_KEEP_IN_QUEUE operation flag. This will cause the next message read from this queued mailbox to be the same message as was previously read. This could be useful if a publishing application needs to preview a message, written by the monitoring application, to determine if the message is relevant to that particular publishing application or if it's destined for another publishing application. By default, a queued mailbox can hold up to 100 messages, although you can change this limit using MobjControl() with M_QUEUE_SIZE. If the queue is full, the default behavior is to wait until the write times out, since there is the possibility of a read operation occurring before the timeout. You can also hook a function to the write timeout and have it quickly reset the message mailbox using MobjControl() with M_RESET. Instead of waiting for a timeout, you can have MobjMessageWrite() generate an error when the message mailbox is full, using MobjControl() with M_QUEUE_FULL_MODE set to M_ERROR. Steps to using a message mailbox The following steps provide a basic methodology for using the MIL message mailbox in a DMIL monitoring configuration. In the publishing application(s), perform the following steps: Allocate a message mailbox using MobjAlloc() with either M_OVERWRITE or M_QUEUE. Publish the message mailbox using MobjControl() with M_DMIL_PUBLISH. This allows the monitoring application access to the message mailbox. Write a message to the message mailbox using MobjMessageWrite(). This function also allows you to add a user-defined message tag to the message. The tag could indicate, for example, that the message contains image statistics. Free the allocated message mailbox using MobjFree() when it is no longer required, unless M_UNIQUE_ID was specified during allocation. In the monitoring application, perform the following steps: Inquire the message mailbox's MIL identifier from the publishing application using MappInquireConnection() with M_DMIL_PUBLISHED_NAME. Hook a user-defined function to handle when a new message is written to the message mailbox, using MobjHookFunction() with M_MESSAGE_RECEIVED. In the user-defined hook function, use MobjMessageRead() to read the message that triggered the hook function. Use the message's tag to determine what type of message the publishing application has classified the message as, and perform some action or processing. Message mailboxes Message mailbox allocation and use Message mailbox operation modes Steps to using a message mailbox ",
      "wordCount": 820,
      "subEntries": []
    },
    {
      "id": "UG_distributed-mil_Distributed_MIL_on_your_local_computer",
      "version": null,
      "title": "Distributed MIL on your local computer",
      "subTitles": [
        "Developing and debugging a Distributed MIL application",
        "Steps to use Distributed MIL on your local computer"
      ],
      "location": "MIL UG P11: Miscellaneous",
      "pageURL": "content\\UserGuide\\distributed-mil\\Distributed_MIL_on_your_local_computer.htm",
      "text": " Distributed MIL on your local computer Typically, Distributed MIL is used among one local computer and one or more remote computers. This could be to improve the performance of processing heavy applications or to allow a local computer to use or monitor a remote computer (for example, on the factory floor or in another country). However, you can use Distributed MIL to create a cluster consisting only of your local computer (for example, to test a Distributed MIL setup that will eventually be run over several computers). You can create this Distributed MIL cluster on your local computer whether in controlling or monitoring configuration, although the procedure is slightly different. Developing and debugging a Distributed MIL application When developing or debugging an application that will use a Distributed MIL cluster, it can be more efficient to set up a cluster on your local computer. For instance, when testing, you don't have to worry about connection issues, such as internet problems and network failures. You can focus solely on the logic of the application(s). Also, when transferring files from your local computer to the remote computer's folder structure during testing, it is faster, especially with large folders of test images. Finally, by setting up your Distributed MIL cluster on your local computer, you are able to develop the entire cluster before you have access to the actual remote computers. When testing a Distributed MIL cluster on your local computer, however, measuring load times and overall processing speed is useless. Steps to use Distributed MIL on your local computer The steps to run a Distributed MIL setup on your local computer are slightly different depending on the configuration: To run a controlling application that allocates a DMIL remote system on your local computer, you must: Ensure that your local computer is running the Distributed MIL server. For more information on running a Distributed MIL server on your local computer, see the Setting up the Distributed MIL server on remote computers subsection of the Preparing computers for Distributed MIL section earlier in this chapter. Note that the section is about running the Distributed MIL server on a remote computer, but the procedures are the same for running a Distributed MIL server on your local computer. Allocate a DMIL remote system on your local computer, using MsysAlloc() with SystemDescriptor set to MIL_TEXT(\"dmilshm://[Passkey:]localhost[:Port]/MILSystemType\"), where [Passkey] is replaced with the passkey specified in the server settings page of the MILConfig utility on the local computer, and MILSystemType is replaced with the type of MIL system (often a Matrox board) that you need to allocate. To run both a publishing application and a monitoring application on your local computer, you must: Publish MIL objects from one or more MIL applications running on your computer. These are now the publishing applications. Connect a monitoring application to the publishing application(s), using MappOpenConnection() with ConnectionDescriptor set to MIL_TEXT(\"dmilshm://[Passkey:]localhost[:Port]\"), where [Passkey] is replaced with the passkey specified in the server settings page of the MILConfig utility of the local computer. The previous steps outlined running a DMIL setup on your local computer using the DMIL SHM protocol. You can also use the TCP/IP protocol when using DMIL on your local computer, but the SHM protocol will provide faster performance. If you use the TCP/IP protocol, replace \"dmilshm\" with \"dmiltcp\" and either leave \"localhost\" as is or replace it with 127.0.0.1. For more information concerning setting the Passkey, please refer to the Managing network connections and ports subsection of the Preparing computers for Distributed MIL section earlier in this chapter. Distributed MIL on your local computer Developing and debugging a Distributed MIL application Steps to use Distributed MIL on your local computer ",
      "wordCount": 612,
      "subEntries": []
    },
    {
      "id": "UG_distributed-mil_Best_practice",
      "version": null,
      "title": "Best practice",
      "subTitles": null,
      "location": "MIL UG P11: Miscellaneous",
      "pageURL": "content\\UserGuide\\distributed-mil\\Best_practice.htm",
      "text": " Best practice When developing a Distributed MIL application, you should be aware of some network limitations and adhere to some good practices to develop the most efficient application. With regards to network usage, you should be aware of the following points: Even if high bandwidth is available with Gigabit Ethernet, latency is inherent to network communication. Latency can add up quickly when multiple synchronous successive calls are made. Saturation of the network link increases latency. Collisions on the network link increase latency. To implement an efficient Distributed MIL application, there are a few good practices that you should adhere to: Use a dedicated subnet for remote computers to minimize interference with other network traffic. Do not force the thread (MthrControl()) or system (MsysControl()) to be synchronous (M_THREAD_MODE set to M_SYNCHRONOUS). Use remote files as much as possible. Remote files can also be on a file server accessible by all remote computers. Avoid transmitting buffer data back and forth between computers. Avoid unnecessary inter-systems calls. Compensation means copy. For processing that involves lots of calls for each grabbed frame, consider a user-defined function (MfuncAlloc()). Allocate displays only if necessary. Use asynchronous mode for displays with the lowest possible frame rate. Best practice ",
      "wordCount": 203,
      "subEntries": []
    }
  ]
}]
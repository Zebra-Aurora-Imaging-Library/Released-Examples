[{
  "id": "Example_PlaceHolder_ID",
  "version": "2024020714",
  "title": "Example_PlaceHolder_Title",
  "wordCount": 0,
  "subEntries": [
    {
      "id": "Examples_General_MdispQt_CPP_aboutbox_cpp",
      "version": "2024020714",
      "title": "aboutbox.cpp",
      "location": "Sample Code from MIL Examples",
      "text": " Top /* * File name: aboutbox.cpp * Location: See Matrox Example Launcher in the MIL Control Center * */ // // Copyright (C) Matrox Electronic Systems Ltd., 1992-2024. // All Rights Reserved #ifdef _MSC_VER #pragma warning(disable:4127) #endif #include \"aboutbox.h\" #include \"ui_aboutbox.h\" #ifdef _MSC_VER #pragma warning(default:4127) #endif AboutBox::AboutBox(QWidget *parent) : QDialog(parent), ui(new Ui::AboutBox) { ui-&gt;setupUi(this); } AboutBox::~AboutBox() { delete ui; } void AboutBox::changeEvent(QEvent *e) { QDialog::changeEvent(e); switch (e-&gt;type()) { case QEvent::LanguageChange: ui-&gt;retranslateUi(this); break; default: break; } } #if (M_MIL_USE_LINUX &amp;&amp; !STATIC_QT5) || (M_MIL_USE_WINDOWS &amp;&amp; STATIC_QT5) #include \"moc_aboutbox.cpp\" #endif ",
      "wordCount": 89
    },
    {
      "id": "Examples_General_MdispQt_CPP_childframe_cpp",
      "version": "2024020714",
      "title": "childframe.cpp",
      "location": "Sample Code from MIL Examples",
      "text": " Top /* * File name: childframe.cpp * Location: See Matrox Example Launcher in the MIL Control Center * */ // // Copyright (C) Matrox Electronic Systems Ltd., 1992-2024. // All Rights Reserved #include \"childframe.h\" #include \"mdispqtview.h\" #ifdef _MSC_VER #pragma warning(disable:4127) #endif #include &lt;QtGui&gt; #include &lt;QLabel&gt; #include &lt;QScrollArea&gt; #include &lt;QStatusBar&gt; #include &lt;QMdiArea&gt; #ifdef _MSC_VER #pragma warning(default:4127) #endif ChildFrame::ChildFrame( QWidget* parent ) : QMainWindow(parent) { m_Ready = false; setAttribute(Qt::WA_DeleteOnClose); setWindowIcon(QIcon(\":/images/imaging.png\")); // create the view and set its parent m_View = new MdispQtView(this); setWindowTitle(m_View-&gt;filename()); setCentralWidget(m_View); m_FramerateIndicator = new QLabel( statusBar() ); statusBar()-&gt;addWidget(m_FramerateIndicator); m_ScaleIndicator = new QLabel( statusBar() ); statusBar()-&gt;addWidget(m_ScaleIndicator); m_MouseIndicator = new QLabel ( statusBar()); statusBar()-&gt;addWidget(m_MouseIndicator); UpdateStatusBarWithFrameRate(0.0); UpdateStatusBarWithScale(1.0, 1.0); UpdateStatusBarWithMousePosition(0, 0, 0.0, 0.0); connect( view(), SIGNAL(zoomFactorChanged(double, double)), SLOT(UpdateStatusBarWithScale(double, double)) ); connect( view(), SIGNAL(frameRateChanged(double)), SLOT(UpdateStatusBarWithFrameRate(double)) ); connect( view(), SIGNAL(filenameChanged(const QString&amp;)), SLOT(setWindowTitle(const QString&amp;)) ); connect( view(), SIGNAL(mousePositionChanged(long, long, double, double)), SLOT(UpdateStatusBarWithMousePosition(long, long, double, double))); connect( view(), SIGNAL(sizeChanged(long, long)), SLOT(UpdateContentSize(long, long))); connect( view(), SIGNAL(filenameChanged(const QString&amp; )), SLOT(setWindowTitle(QString))); installEventFilter(this); } MdispQtView* ChildFrame::view() { return m_View; } void ChildFrame::closeEvent( QCloseEvent* e ) { if ( view()-&gt;close() ) { emit childClosedSignal(); e-&gt;accept(); } else { e-&gt;ignore(); } } bool ChildFrame::eventFilter(QObject* /*object*/, QEvent *e) { if (m_View &amp;&amp; (e-&gt;type() == QEvent::ParentChange || e-&gt;type() == QEvent::Show)) { m_View-&gt;SelectWindow(); } return false; } //////////////////////////////////////////////////////////////////////// // MIL: Used to update status bar with frame rate //////////////////////////////////////////////////////////////////////// void ChildFrame::UpdateStatusBarWithFrameRate(double CurrentRate) { QString strCurrentRate = tr(\"Display Updates: %1 fps\").arg( CurrentRate, 0, 'f', 2 ); m_FramerateIndicator-&gt;setText(strCurrentRate); } //////////////////////////////////////////////////////////////////////// // MIL: Used to update status bar with zoom factor //////////////////////////////////////////////////////////////////////// void ChildFrame::UpdateStatusBarWithScale(double CurrentScaleX, double CurrentScaleY) { QString strCurrentScale = tr(\"%1,%2\").arg( CurrentScaleX, 0, 'f', 4).arg(CurrentScaleY, 0, 'f', 4 ); m_ScaleIndicator-&gt;setText(strCurrentScale); } //////////////////////////////////////////////////////////////////////// // MIL: Used to update status bar with Mouse Position //////////////////////////////////////////////////////////////////////// void ChildFrame::UpdateStatusBarWithMousePosition(long DispX, long DispY, double BufX, double BufY) { QString strCurrentMousePosition; strCurrentMousePosition=tr(\"M:(%1,%2)-&gt;(%3,%4)\").arg(DispX,3).arg(DispY,3).arg(BufX, 0,'f',2).arg(BufY, 0,'f',2); m_MouseIndicator-&gt;setText(strCurrentMousePosition); } QSize ChildFrame::sizeHint() const { QSize St(0,statusBar()-&gt;height()); if(m_View) return m_View-&gt;sizeHint() + St; else return QSize(300, 200); } void ChildFrame::UpdateContentSize(long SizeX, long SizeY) { Q_UNUSED(SizeX); Q_UNUSED(SizeY); parentWidget()-&gt;adjustSize(); } #if (M_MIL_USE_LINUX &amp;&amp; !STATIC_QT5) || (M_MIL_USE_WINDOWS &amp;&amp; STATIC_QT5) #include \"moc_childframe.cpp\" #endif ",
      "wordCount": 331
    },
    {
      "id": "Examples_General_MdispQt_CPP_mainframe_cpp",
      "version": "2024020714",
      "title": "mainframe.cpp",
      "location": "Sample Code from MIL Examples",
      "text": " Top /* * File name: mainframe.cpp * Location: See Matrox Example Launcher in the MIL Control Center * */ // // Copyright (C) Matrox Electronic Systems Ltd., 1992-2024. // All Rights Reserved #ifdef _MSC_VER #pragma warning(disable:4127) #endif #include \"mainframe.h\" #include \"ui_mainframe.h\" #include \"aboutbox.h\" #include \"childframe.h\" #include \"mdispqtview.h\" #include \"mdispqtapp.h\" #include &lt;QMdiArea&gt; #include &lt;QMessageBox&gt; #include &lt;QCloseEvent&gt; #include &lt;QFileDialog&gt; #include &lt;QMdiSubWindow&gt; #include &lt;QApplication&gt; #include &lt;QDesktopWidget&gt; #ifdef _MSC_VER #pragma warning(default:4127) #endif MainFrame::MainFrame(QWidget *parent) : QMainWindow(parent), ui(new Ui::MainFrame) { ui-&gt;setupUi(this); #if M_MIL_USE_WINDOWS ui-&gt;actionX11Annotation-&gt;setIcon(QIcon(\":/images/gdi.png\")); #else ui-&gt;actionX11Annotation-&gt;setVisible(false); #endif m_ViewModeComboBox = new QComboBox; m_ViewModeComboBox-&gt;addItem(tr(\"M_DEFAULT\"), VIEW_MODE_DEFAULT); m_ViewModeComboBox-&gt;addItem(tr(\"M_TRANSPARENT\"), VIEW_MODE_TRANSPARENT); m_ViewModeComboBox-&gt;addItem(tr(\"M_AUTO_SCALE\"), VIEW_MODE_AUTO_SCALE); m_ViewModeComboBox-&gt;addItem(tr(\"M_MULTI_BYTES\"), VIEW_MODE_MULTI_BYTES); m_ViewModeComboBox-&gt;addItem(tr(\"M_BIT_SHIFT:2\"), VIEW_MODE_BIT_SHIFT2); m_ViewModeComboBox-&gt;addItem(tr(\"M_BIT_SHIFT:4\"), VIEW_MODE_BIT_SHIFT4); m_ViewModeComboBox-&gt;addItem(tr(\"M_BIT_SHIFT:8\"), VIEW_MODE_BIT_SHIFT8); ui-&gt;DispToolBar-&gt;addWidget(m_ViewModeComboBox); m_MdiArea = new QMdiArea; setCentralWidget(m_MdiArea); setAttribute(Qt::WA_DeleteOnClose); connect( ui-&gt;actionExit, SIGNAL(triggered()), qApp, SLOT(closeAllWindows()) ); connect( ui-&gt;menuHelp, SIGNAL(aboutToShow()), this, SLOT(windowMenuAboutToShow()) ); connect( ui-&gt;action_Cascade, SIGNAL(triggered()), m_MdiArea, SLOT(cascadeSubWindows()) ); connect( ui-&gt;action_Tile, SIGNAL(triggered()), m_MdiArea, SLOT(tileSubWindows()) ); connect( m_MdiArea, SIGNAL(subWindowActivated(QMdiSubWindow *)), this, SLOT(windowActivated(QMdiSubWindow *)) ); m_WindowMapper = new QSignalMapper(this); connect(m_WindowMapper, SIGNAL(mapped(QWidget *)), this, SLOT(windowMenuActivated(QWidget *))); connect(m_ViewModeComboBox, SIGNAL(activated(int)), this, SLOT(ViewModeChanged(int))); QRect deskgeom = QApplication::desktop()-&gt;availableGeometry(this); resize(deskgeom.width() / 2, 2*deskgeom.height() / 3); updateActions(NULL); } MainFrame::~MainFrame() { delete ui; } void MainFrame::changeEvent(QEvent *e) { QMainWindow::changeEvent(e); switch (e-&gt;type()) { case QEvent::LanguageChange: ui-&gt;retranslateUi(this); break; default: break; } } ChildFrame* MainFrame::activeChild() { QMdiSubWindow *activeSubWindow = m_MdiArea-&gt;activeSubWindow(); if(activeSubWindow) return qobject_cast&lt;ChildFrame *&gt;(activeSubWindow-&gt;widget()); return NULL; } ChildFrame *MainFrame::CreateChildFrame() { ChildFrame* cf = new ChildFrame; cf-&gt;MdiArea(m_MdiArea); m_MdiArea-&gt;addSubWindow(cf); connect(cf, &amp;ChildFrame::childClosedSignal, [=]() { updateActions(nullptr); }); // to add actions return cf; } ////////////////////////////////////////// // Action Handler void MainFrame::on_actionAbout_triggered() { AboutBox about(this); about.exec(); } void MainFrame::closeEvent( QCloseEvent* e ) { m_MdiArea-&gt;closeAllSubWindows(); if (m_MdiArea-&gt;currentSubWindow()) e-&gt;ignore(); else e-&gt;accept(); } void MainFrame::on_actionNew_triggered() { ChildFrame* cf = CreateChildFrame(); if ( !cf-&gt;view()-&gt;newDoc() ) { cf-&gt;close(); } else { cf-&gt;show(); } } void MainFrame::on_actionOpen_triggered() { MdispQtApp* app = (MdispQtApp*)qApp; QString fn = QFileDialog::getOpenFileName( this, tr(\"Open File\"), app-&gt;m_ImagePath, tr(\"Images (*.mim *.bmp *.tif *.jpg *.jp2 *.png)\")); if ( !fn.isEmpty() ) { ChildFrame* cf = CreateChildFrame(); if ( !cf-&gt;view()-&gt;load(fn) ) { QMessageBox::warning( this, tr(\"MdispQt\"), tr(\"Could not load image from \\\"%1\\\".\").arg(fn), QMessageBox::Ok | QMessageBox::Default, QMessageBox::NoButton ); cf-&gt;close(); } else { QString Path = QFileInfo(fn).path(); if (!Path.isEmpty()) app-&gt;m_ImagePath = Path; cf-&gt;show(); } } } void MainFrame::on_actionSave_triggered() { ChildFrame* cf = activeChild(); if (cf) { cf-&gt;view()-&gt;save(); } } void MainFrame::on_actionSaveAs_triggered() { ChildFrame* cf = activeChild(); if (cf) { cf-&gt;view()-&gt;saveAs(); } } void MainFrame::on_actionClose_triggered() { ChildFrame* cf = activeChild(); if (cf) { cf-&gt;close(); if (m_MdiArea-&gt;currentSubWindow()) m_MdiArea-&gt;currentSubWindow()-&gt;close(); updateActions(NULL); } } void MainFrame::on_actionViewStdToolbar_triggered(bool on) { ChildFrame* cf = activeChild(); if (cf) { cf-&gt;statusBar()-&gt;setVisible(on); } else { statusBar()-&gt;setVisible(on); } } void MainFrame::on_actionGrabStart_triggered() { ChildFrame* cf = activeChild(); if (cf) { cf-&gt;view()-&gt;GrabStart(); updateActions(cf); } } void MainFrame::on_actionGrabStop_triggered() { ChildFrame* cf = activeChild(); if (cf) { cf-&gt;view()-&gt;GrabStop(); updateActions(cf); } } void MainFrame::on_actionShowHideOverlay_triggered(bool on) { ChildFrame* cf = activeChild(); if (cf) { cf-&gt;view()-&gt;Overlay(on); updateActions(cf); } } void MainFrame::on_actionRestrictedCursor_triggered(bool on) { ChildFrame* cf = activeChild(); if (cf) { cf-&gt;view()-&gt;RestrictCursor(on); updateActions(cf); } } void MainFrame::on_actionX11Annotation_triggered(bool on) { ChildFrame* cf = activeChild(); if (cf) { cf-&gt;view()-&gt;X11Annotations(on); updateActions(cf); } } void MainFrame::on_actionGraphicsAnnotations_triggered(bool on) { ChildFrame* cf = activeChild(); if (cf) { cf-&gt;view()-&gt;GraphicsAnnotations(on); updateActions(cf); } } void MainFrame::on_actionZoomIn_triggered() { ChildFrame* cf = activeChild(); if (cf) { cf-&gt;view()-&gt;ZoomIn(); updateActions(cf); } } void MainFrame::on_actionZoomOut_triggered() { ChildFrame* cf = activeChild(); if (cf) { cf-&gt;view()-&gt;ZoomOut(); updateActions(cf); } } void MainFrame::on_actionNoZoom_triggered() { ChildFrame* cf = activeChild(); if (cf) { cf-&gt;view()-&gt;NoZoom(); updateActions(cf); } } void MainFrame::on_actionScaleDisplay_triggered(bool on) { ChildFrame* cf = activeChild(); if (cf) { cf-&gt;view()-&gt;ScaleDisplay(on); updateActions(cf); } } void MainFrame::ViewModeChanged(int Mode) { switch(Mode) { case VIEW_MODE_DEFAULT: on_actionViewDefault_triggered(); break; case VIEW_MODE_TRANSPARENT: on_actionViewTransparent_triggered(); break; case VIEW_MODE_AUTO_SCALE: on_actionViewAutoScale_triggered(); break; case VIEW_MODE_MULTI_BYTES: on_actionVieewMultiBytes_triggered(); break; case VIEW_MODE_BIT_SHIFT2: on_actionViewBitShift2_triggered(); break; case VIEW_MODE_BIT_SHIFT4: on_actionViewBitShift4_triggered(); break; case VIEW_MODE_BIT_SHIFT8: on_actionViewBitShift8_triggered(); break; default: on_actionViewDefault_triggered(); break; } } void MainFrame::on_actionViewDefault_triggered() { ChildFrame* cf = activeChild(); if (cf) { cf-&gt;view()-&gt;ChangeViewMode(M_DEFAULT); updateActions(cf); } } void MainFrame::on_actionViewTransparent_triggered() { ChildFrame* cf = activeChild(); if (cf) { cf-&gt;view()-&gt;ChangeViewMode(M_TRANSPARENT); updateActions(cf); } } void MainFrame::on_actionViewAutoScale_triggered() { ChildFrame* cf = activeChild(); if (cf) { cf-&gt;view()-&gt;ChangeViewMode(M_AUTO_SCALE); updateActions(cf); } } void MainFrame::on_actionVieewMultiBytes_triggered() { ChildFrame* cf = activeChild(); if (cf) { cf-&gt;view()-&gt;ChangeViewMode(M_MULTI_BYTES); updateActions(cf); } } void MainFrame::on_actionViewBitShift2_triggered() { ChildFrame* cf = activeChild(); if (cf) { cf-&gt;view()-&gt;ChangeViewMode(M_BIT_SHIFT, 2); updateActions(cf); } } void MainFrame::on_actionViewBitShift4_triggered() { ChildFrame* cf = activeChild(); if (cf) { cf-&gt;view()-&gt;ChangeViewMode(M_BIT_SHIFT, 4); updateActions(cf); } } void MainFrame::on_actionViewBitShift8_triggered() { ChildFrame* cf = activeChild(); if (cf) { cf-&gt;view()-&gt;ChangeViewMode(M_BIT_SHIFT, 8); updateActions(cf); } } void MainFrame::on_actionDMILASyncDisable_triggered() { ChildFrame* cf = activeChild(); if (cf) { cf-&gt;view()-&gt;ChangeAsynchronousMode(false,M_DISABLE); updateActions(cf); } } void MainFrame::on_actionDMILASync1_triggered() { ChildFrame* cf = activeChild(); if (cf) { cf-&gt;view()-&gt;ChangeAsynchronousMode(true,1); updateActions(cf); } } void MainFrame::on_actionDMILASync5_triggered() { ChildFrame* cf = activeChild(); if (cf) { cf-&gt;view()-&gt;ChangeAsynchronousMode(true,5); updateActions(cf); } } void MainFrame::on_actionDMILASync10_triggered() { ChildFrame* cf = activeChild(); if (cf) { cf-&gt;view()-&gt;ChangeAsynchronousMode(true,10); updateActions(cf); } } void MainFrame::on_actionDMILASync15_triggered() { ChildFrame* cf = activeChild(); if (cf) { cf-&gt;view()-&gt;ChangeAsynchronousMode(true,15); updateActions(cf); } } void MainFrame::on_actionDMILASync30_triggered() { ChildFrame* cf = activeChild(); if (cf) { cf-&gt;view()-&gt;ChangeAsynchronousMode(true,30); updateActions(cf); } } void MainFrame::on_actionDMILASyncMax_triggered() { ChildFrame* cf = activeChild(); if (cf) { cf-&gt;view()-&gt;ChangeAsynchronousMode(true,M_INFINITE); updateActions(cf); } } void MainFrame::on_actionDMILCompressNone_triggered() { ChildFrame* cf = activeChild(); if (cf) { cf-&gt;view()-&gt;ChangeCompressionType(M_NULL); updateActions(cf); } } void MainFrame::on_actionDMILCompressLossy_triggered() { ChildFrame* cf = activeChild(); if (cf) { cf-&gt;view()-&gt;ChangeCompressionType(M_JPEG_LOSSY); updateActions(cf); } } void MainFrame::on_actionDMILCompressLossless_triggered() { ChildFrame* cf = activeChild(); if (cf) { cf-&gt;view()-&gt;ChangeCompressionType(M_JPEG_LOSSLESS); updateActions(cf); } } void MainFrame::on_actionDMILFactor60_triggered() { ChildFrame* cf = activeChild(); if (cf) { cf-&gt;view()-&gt;ChangeQFactor(60); updateActions(cf); } } void MainFrame::on_actionDMILFactor70_triggered() { ChildFrame* cf = activeChild(); if (cf) { cf-&gt;view()-&gt;ChangeQFactor(70); updateActions(cf); } } void MainFrame::on_actionDMILFactor75_triggered() { ChildFrame* cf = activeChild(); if (cf) { cf-&gt;view()-&gt;ChangeQFactor(70); updateActions(cf); } } void MainFrame::on_actionDMILFactor80_triggered() { ChildFrame* cf = activeChild(); if (cf) { cf-&gt;view()-&gt;ChangeQFactor(80); updateActions(cf); } } void MainFrame::on_actionDMILFactor82_triggered() { ChildFrame* cf = activeChild(); if (cf) { cf-&gt;view()-&gt;ChangeQFactor(82); updateActions(cf); } } void MainFrame::on_actionDMILFactor85_triggered() { ChildFrame* cf = activeChild(); if (cf) { cf-&gt;view()-&gt;ChangeQFactor(85); updateActions(cf); } } void MainFrame::on_actionDMILFactor87_triggered() { ChildFrame* cf = activeChild(); if (cf) { cf-&gt;view()-&gt;ChangeQFactor(87); updateActions(cf); } } void MainFrame::on_actionDMILFactor90_triggered() { ChildFrame* cf = activeChild(); if (cf) { cf-&gt;view()-&gt;ChangeQFactor(90); updateActions(cf); } } void MainFrame::on_actionDMILFactor92_triggered() { ChildFrame* cf = activeChild(); if (cf) { cf-&gt;view()-&gt;ChangeQFactor(92); updateActions(cf); } } void MainFrame::on_actionDMILFactor95_triggered() { ChildFrame* cf = activeChild(); if (cf) { cf-&gt;view()-&gt;ChangeQFactor(95); updateActions(cf); } } void MainFrame::on_actionDMILFactor99_triggered() { ChildFrame* cf = activeChild(); if (cf) { cf-&gt;view()-&gt;ChangeQFactor(99); updateActions(cf); } } void MainFrame::on_actionOverlayOpacityM_DEFAULT_triggered() { ChildFrame* cf = activeChild(); if (cf) { cf-&gt;view()-&gt;ChangeOverlayOpacity(M_DEFAULT); updateActions(cf); } } void MainFrame::on_actionOverlayOpacityM_DISABLE_triggered() { ChildFrame* cf = activeChild(); if (cf) { cf-&gt;view()-&gt;ChangeOverlayOpacity(M_DISABLE); updateActions(cf); } } void MainFrame::on_actionOverlayOpacity0_triggered() { ChildFrame* cf = activeChild(); if (cf) { cf-&gt;view()-&gt;ChangeOverlayOpacity(0); updateActions(cf); } } void MainFrame::on_actionOverlayOpacity20_triggered() { ChildFrame* cf = activeChild(); if (cf) { cf-&gt;view()-&gt;ChangeOverlayOpacity(20); updateActions(cf); } } void MainFrame::on_actionOverlayOpacity40_triggered() { ChildFrame* cf = activeChild(); if (cf) { cf-&gt;view()-&gt;ChangeOverlayOpacity(40); updateActions(cf); } } void MainFrame::on_actionOverlayOpacity60_triggered() { ChildFrame* cf = activeChild(); if (cf) { cf-&gt;view()-&gt;ChangeOverlayOpacity(60); updateActions(cf); } } void MainFrame::on_actionOverlayOpacity80_triggered() { ChildFrame* cf = activeChild(); if (cf) { cf-&gt;view()-&gt;ChangeOverlayOpacity(80); updateActions(cf); } } void MainFrame::on_actionOverlayOpacity100_triggered() { ChildFrame* cf = activeChild(); if (cf) { cf-&gt;view()-&gt;ChangeOverlayOpacity(100); updateActions(cf); } } void MainFrame::on_actionGLOpacityM_DEFAULT_triggered() { ChildFrame* cf = activeChild(); if (cf) { cf-&gt;view()-&gt;ChangeGraphicListOpacity(M_DEFAULT); updateActions(cf); } } void MainFrame::on_actionGLOpacityM_DISABLE_triggered() { ChildFrame* cf = activeChild(); if (cf) { cf-&gt;view()-&gt;ChangeGraphicListOpacity(M_DISABLE); updateActions(cf); } } void MainFrame::on_actionGLOpacity0_triggered() { ChildFrame* cf = activeChild(); if (cf) { cf-&gt;view()-&gt;ChangeGraphicListOpacity(0); updateActions(cf); } } void MainFrame::on_actionGLOpacity20_triggered() { ChildFrame* cf = activeChild(); if (cf) { cf-&gt;view()-&gt;ChangeGraphicListOpacity(20); updateActions(cf); } } void MainFrame::on_actionGLOpacity40_triggered() { ChildFrame* cf = activeChild(); if (cf) { cf-&gt;view()-&gt;ChangeGraphicListOpacity(40); updateActions(cf); } } void MainFrame::on_actionGLOpacity60_triggered() { ChildFrame* cf = activeChild(); if (cf) { cf-&gt;view()-&gt;ChangeGraphicListOpacity(60); updateActions(cf); } } void MainFrame::on_actionGLOpacity80_triggered() { ChildFrame* cf = activeChild(); if (cf) { cf-&gt;view()-&gt;ChangeGraphicListOpacity(80); updateActions(cf); } } void MainFrame::on_actionGLOpacity100_triggered() { ChildFrame* cf = activeChild(); if (cf) { cf-&gt;view()-&gt;ChangeGraphicListOpacity(100); updateActions(cf); } } void MainFrame::on_actionNewRectangle_triggered() { ChildFrame* cf = activeChild(); if (cf) { cf-&gt;view()-&gt;OnGraRectangle(); updateActions(cf); } } void MainFrame::on_actionNewArc_triggered() { ChildFrame* cf = activeChild(); if (cf) { cf-&gt;view()-&gt;OnGraCircle(); updateActions(cf); } } void MainFrame::on_actionNewPolygon_triggered() { ChildFrame* cf = activeChild(); if (cf) { cf-&gt;view()-&gt;OnGraPolygon(); updateActions(cf); } } void MainFrame::on_actionNewOrientedRect_triggered() { ChildFrame* cf = activeChild(); if(cf) { cf-&gt;view()-&gt;OnGraOrientedRect(); updateActions(cf); } } void MainFrame::on_actionNewArcThreePoints_triggered() { ChildFrame* cf = activeChild(); if(cf) { cf-&gt;view()-&gt;OnGraArcThreePoints(); updateActions(cf); } } void MainFrame::on_actionSelectgraphiccolor_triggered() { ChildFrame* cf = activeChild(); if (cf) { cf-&gt;view()-&gt;OnGraChooseColor(); updateActions(cf); } } void MainFrame::on_actionCycleDrawDir_triggered() { ChildFrame* cf = activeChild(); if (cf) { cf-&gt;view()-&gt;OnGraCycleDrawDir(); updateActions(cf); } } void MainFrame::on_actionToggleLineThickness_triggered() { ChildFrame* cf = activeChild(); if (cf) { cf-&gt;view()-&gt;OnGraToggleLineThickness(); updateActions(cf); } } void MainFrame::on_actionFillgraphic_triggered() { ChildFrame* cf = activeChild(); if (cf) { cf-&gt;view()-&gt;OnGraFill(); updateActions(cf); } } void MainFrame::windowMenuAboutToShow() { ui-&gt;menuHelp-&gt;clear(); ui-&gt;menuHelp-&gt;addAction(ui-&gt;action_Cascade); ui-&gt;menuHelp-&gt;addAction(ui-&gt;action_Tile); if ( m_MdiArea-&gt;subWindowList().isEmpty() ) { ui-&gt;action_Cascade-&gt;setEnabled(false); ui-&gt;action_Tile-&gt;setEnabled(false); } else { ui-&gt;action_Cascade-&gt;setEnabled(true); ui-&gt;action_Tile-&gt;setEnabled(true); } ui-&gt;menuHelp-&gt;addSeparator(); QList &lt;QMdiSubWindow *&gt; windows = m_MdiArea-&gt;subWindowList(); for ( int i=0; i&lt;windows.size(); i++ ) { QMdiSubWindow* subwindow = windows[i]; ChildFrame* cf = (ChildFrame*) subwindow-&gt;widget(); QString text; if(cf) text = tr(\"%1 %2\").arg(i+1).arg(cf-&gt;view()-&gt;filename()); else text = tr(\"%1 Image\").arg(i+1); QAction *action = ui-&gt;menuHelp-&gt;addAction(text); //connect(action,SIGNAL(triggered()), this, SLOT(windowMenuActivated(int))); action-&gt;setCheckable(true); action-&gt;setChecked(m_MdiArea-&gt;activeSubWindow() == subwindow); connect(action, SIGNAL(triggered()), m_WindowMapper, SLOT(map())); m_WindowMapper-&gt;setMapping(action, windows.at(i)); } } void MainFrame::windowMenuActivated( QWidget* w ) { if (w) { w-&gt;showNormal(); } w-&gt;setFocus(); } void MainFrame::windowActivated( QMdiSubWindow* w ) { if(w) updateActions((ChildFrame *)w-&gt;widget()); } void MainFrame::updateActions(ChildFrame *cf) { m_ViewModeComboBox-&gt;setEnabled(cf); ui-&gt;actionClose-&gt;setEnabled(cf); ui-&gt;actionSave-&gt;setEnabled(cf); ui-&gt;actionSaveAs-&gt;setEnabled(cf); ui-&gt;actionScaleDisplay-&gt;setEnabled(cf); ui-&gt;actionShowHideOverlay-&gt;setEnabled(cf); ui-&gt;actionX11Annotation-&gt;setEnabled(cf); ui-&gt;actionGraphicsAnnotations-&gt;setEnabled(cf); ui-&gt;actionViewDefault-&gt;setEnabled(cf); ui-&gt;actionViewTransparent-&gt;setEnabled(cf); ui-&gt;actionViewAutoScale-&gt;setEnabled(cf); ui-&gt;actionVieewMultiBytes-&gt;setEnabled(cf); ui-&gt;actionViewBitShift2-&gt;setEnabled(cf); ui-&gt;actionViewBitShift4-&gt;setEnabled(cf); ui-&gt;actionViewBitShift8-&gt;setEnabled(cf); if (cf) { MdispQtApp* app = (MdispQtApp*) qApp; MdispQtView* view = cf-&gt;view(); ui-&gt;actionGrabStart-&gt;setEnabled( app-&gt;m_numberOfDigitizer != 0 &amp;&amp; !(app-&gt;m_pGrabView &amp;&amp; app-&gt;m_isGrabStarted) ); ui-&gt;actionGrabStop-&gt;setEnabled( app-&gt;m_pGrabView &amp;&amp; app-&gt;m_isGrabStarted ); ui-&gt;actionShowHideOverlay-&gt;setChecked( cf-&gt;view()-&gt;IsOverlayEnabled() ); ui-&gt;menuOverlayOpacity-&gt;setEnabled( cf-&gt;view()-&gt;IsOverlayEnabled() ); ui-&gt;actionX11Annotation-&gt;setChecked( cf-&gt;view()-&gt;IsNativeAnnotationsEnabled() ); ui-&gt;actionGraphicsAnnotations-&gt;setChecked( cf-&gt;view()-&gt;IsGraphicsAnnotationsEnabled() ); ui-&gt;actionScaleDisplay-&gt;setChecked( cf-&gt;view()-&gt;IsScaleDisplayEnabled() ); ui-&gt;menuGraphicListOpacity-&gt;setEnabled(cf-&gt;view()-&gt;IsGraphicsAnnotationsEnabled()); ui-&gt;actionNewArc-&gt;setEnabled(cf-&gt;view()-&gt;IsGraphicsAnnotationsEnabled()); ui-&gt;actionNewRectangle-&gt;setEnabled(cf-&gt;view()-&gt;IsGraphicsAnnotationsEnabled()); ui-&gt;actionNewPolygon-&gt;setEnabled(cf-&gt;view()-&gt;IsGraphicsAnnotationsEnabled()); ui-&gt;actionNewOrientedRect-&gt;setEnabled(cf-&gt;view()-&gt;IsGraphicsAnnotationsEnabled()); ui-&gt;actionNewArcThreePoints-&gt;setEnabled(cf-&gt;view()-&gt;IsGraphicsAnnotationsEnabled()); ui-&gt;actionSelectgraphiccolor-&gt;setEnabled(cf-&gt;view()-&gt;IsGraphicsAnnotationsEnabled()); ui-&gt;actionFillgraphic-&gt;setEnabled(cf-&gt;view()-&gt;IsGraphicsAnnotationsEnabled()); ui-&gt;actionCycleDrawDir-&gt;setEnabled(cf-&gt;view()-&gt;IsGraphicsAnnotationsEnabled()); ui-&gt;actionToggleLineThickness-&gt;setEnabled(cf-&gt;view()-&gt;IsGraphicsAnnotationsEnabled()); if ( view-&gt;IsScaleDisplayEnabled() ) { ui-&gt;actionNoZoom-&gt;setEnabled(false); ui-&gt;actionZoomIn-&gt;setEnabled(false); ui-&gt;actionZoomOut-&gt;setEnabled(false); } else { ui-&gt;actionZoomIn-&gt;setEnabled( cf-&gt;view()-&gt;CurrentZoomFactorX() &lt; 16.0 ); ui-&gt;actionZoomOut-&gt;setEnabled( cf-&gt;view()-&gt;CurrentZoomFactorX() &gt; 1.0/16.0 ); ui-&gt;actionNoZoom-&gt;setEnabled(true); } if(cf-&gt;view()-&gt;IsExclusive()) { ui-&gt;actionRestrictedCursor-&gt;setEnabled(true); ui-&gt;actionRestrictedCursor-&gt;setChecked(view-&gt;CurrentRestrictCursor() == M_ENABLE); } else { ui-&gt;actionRestrictedCursor-&gt;setEnabled(false); } ui-&gt;actionX11Annotation-&gt;setEnabled(cf-&gt;view()-&gt;IsWindowed()); ui-&gt;actionViewDefault-&gt;setChecked(view-&gt;CurrentViewMode()==M_DEFAULT); ui-&gt;actionViewTransparent-&gt;setChecked(view-&gt;CurrentViewMode()==M_TRANSPARENT); ui-&gt;actionViewAutoScale-&gt;setChecked(view-&gt;CurrentViewMode()==M_AUTO_SCALE); ui-&gt;actionVieewMultiBytes-&gt;setChecked(view-&gt;CurrentViewMode()==M_MULTI_BYTES); ui-&gt;actionViewBitShift2-&gt;setChecked((view-&gt;CurrentViewMode()==M_BIT_SHIFT)&amp;&amp; (view-&gt;CurrentShiftValue()==2)); ui-&gt;actionViewBitShift4-&gt;setChecked((view-&gt;CurrentViewMode()==M_BIT_SHIFT)&amp;&amp; (view-&gt;CurrentShiftValue()==4)); ui-&gt;actionViewBitShift8-&gt;setChecked((view-&gt;CurrentViewMode()==M_BIT_SHIFT)&amp;&amp; (view-&gt;CurrentShiftValue()==8)); int ViewValue = VIEW_MODE_DEFAULT; switch(view-&gt;CurrentViewMode()) { case M_DEFAULT: ViewValue = VIEW_MODE_DEFAULT; break; case M_TRANSPARENT: ViewValue = VIEW_MODE_TRANSPARENT; break; case M_AUTO_SCALE: ViewValue = VIEW_MODE_AUTO_SCALE; break; case M_MULTI_BYTES: ViewValue = VIEW_MODE_MULTI_BYTES; break; case M_BIT_SHIFT: { if(view-&gt;CurrentShiftValue() == 2) ViewValue = VIEW_MODE_BIT_SHIFT2; else if(view-&gt;CurrentShiftValue() == 4) ViewValue = VIEW_MODE_BIT_SHIFT4; else if(view-&gt;CurrentShiftValue() == 8) ViewValue = VIEW_MODE_BIT_SHIFT8; } break; } m_ViewModeComboBox-&gt;setCurrentIndex(ViewValue); ui-&gt;actionOverlayOpacityM_DEFAULT-&gt;setChecked(view-&gt;OverlayOpacity()==M_DEFAULT); ui-&gt;actionOverlayOpacityM_DISABLE-&gt;setChecked(view-&gt;OverlayOpacity()==M_DISABLE); ui-&gt;actionOverlayOpacity0-&gt;setChecked(view-&gt;OverlayOpacity()==0); ui-&gt;actionOverlayOpacity20-&gt;setChecked(view-&gt;OverlayOpacity()==20); ui-&gt;actionOverlayOpacity40-&gt;setChecked(view-&gt;OverlayOpacity()==40); ui-&gt;actionOverlayOpacity60-&gt;setChecked(view-&gt;OverlayOpacity()==60); ui-&gt;actionOverlayOpacity80-&gt;setChecked(view-&gt;OverlayOpacity()==80); ui-&gt;actionOverlayOpacity100-&gt;setChecked(view-&gt;OverlayOpacity()==100); ui-&gt;actionGLOpacityM_DEFAULT-&gt;setChecked(view-&gt;GraphicListOpacity()==M_DEFAULT); ui-&gt;actionGLOpacityM_DISABLE-&gt;setChecked(view-&gt;GraphicListOpacity()==M_DISABLE); ui-&gt;actionGLOpacity0-&gt;setChecked(view-&gt;GraphicListOpacity()==0); ui-&gt;actionGLOpacity20-&gt;setChecked(view-&gt;GraphicListOpacity()==20); ui-&gt;actionGLOpacity40-&gt;setChecked(view-&gt;GraphicListOpacity()==40); ui-&gt;actionGLOpacity60-&gt;setChecked(view-&gt;GraphicListOpacity()==60); ui-&gt;actionGLOpacity80-&gt;setChecked(view-&gt;GraphicListOpacity()==80); ui-&gt;actionGLOpacity100-&gt;setChecked(view-&gt;GraphicListOpacity()==100); if(view-&gt;IsNetworkedSystem()) { ui-&gt;menuASynchronous_mode-&gt;setEnabled(true); ui-&gt;menuCompression-&gt;setEnabled(true); ui-&gt;menuQFactor-&gt;setEnabled(true); if(!view-&gt;IsInAsynchronousMode()) ui-&gt;actionDMILASyncDisable-&gt;setChecked(true); else { ui-&gt;actionDMILASync1-&gt;setChecked(view-&gt;AsynchronousFrameRate()==1); ui-&gt;actionDMILASync5-&gt;setChecked(view-&gt;AsynchronousFrameRate()==5); ui-&gt;actionDMILASync10-&gt;setChecked(view-&gt;AsynchronousFrameRate()==10); ui-&gt;actionDMILASync15-&gt;setChecked(view-&gt;AsynchronousFrameRate()==15); ui-&gt;actionDMILASync30-&gt;setChecked(view-&gt;AsynchronousFrameRate()==30); ui-&gt;actionDMILASyncMax-&gt;setChecked(view-&gt;AsynchronousFrameRate()==M_INFINITE); } ui-&gt;actionDMILCompressNone-&gt;setChecked(view-&gt;CompressionType()==M_NULL); ui-&gt;actionDMILCompressLossy-&gt;setChecked(view-&gt;CompressionType()==M_JPEG_LOSSY); ui-&gt;actionDMILCompressLossless-&gt;setChecked(view-&gt;CompressionType()==M_JPEG_LOSSLESS); ui-&gt;actionDMILFactor60-&gt;setChecked(view-&gt;QFactor()==60); ui-&gt;actionDMILFactor70-&gt;setChecked(view-&gt;QFactor()==70); ui-&gt;actionDMILFactor75-&gt;setChecked(view-&gt;QFactor()==75); ui-&gt;actionDMILFactor80-&gt;setChecked(view-&gt;QFactor()==80); ui-&gt;actionDMILFactor82-&gt;setChecked(view-&gt;QFactor()==82); ui-&gt;actionDMILFactor85-&gt;setChecked(view-&gt;QFactor()==85); ui-&gt;actionDMILFactor87-&gt;setChecked(view-&gt;QFactor()==87); ui-&gt;actionDMILFactor90-&gt;setChecked(view-&gt;QFactor()==90); ui-&gt;actionDMILFactor92-&gt;setChecked(view-&gt;QFactor()==92); ui-&gt;actionDMILFactor95-&gt;setChecked(view-&gt;QFactor()==95); ui-&gt;actionDMILFactor99-&gt;setChecked(view-&gt;QFactor()==99); } else { ui-&gt;menuASynchronous_mode-&gt;setEnabled(false); ui-&gt;menuCompression-&gt;setEnabled(false); ui-&gt;menuQFactor-&gt;setEnabled(false); } } else { ui-&gt;actionGrabStart-&gt;setEnabled(false); ui-&gt;actionGrabStop-&gt;setEnabled(false); ui-&gt;actionShowHideOverlay-&gt;setChecked(false); ui-&gt;menuOverlayOpacity-&gt;setEnabled(false); ui-&gt;actionX11Annotation-&gt;setChecked(false); ui-&gt;actionGraphicsAnnotations-&gt;setChecked(false); ui-&gt;actionZoomIn-&gt;setEnabled(false); ui-&gt;actionZoomOut-&gt;setEnabled(false); ui-&gt;actionNoZoom-&gt;setEnabled(false); ui-&gt;actionRestrictedCursor-&gt;setEnabled(false); ui-&gt;actionScaleDisplay-&gt;setEnabled(false); ui-&gt;menuASynchronous_mode-&gt;setEnabled(false); ui-&gt;menuCompression-&gt;setEnabled(false); ui-&gt;menuQFactor-&gt;setEnabled(false); ui-&gt;menuGraphicListOpacity-&gt;setEnabled(false); ui-&gt;actionNewArc-&gt;setEnabled(false); ui-&gt;actionNewRectangle-&gt;setEnabled(false); ui-&gt;actionNewPolygon-&gt;setEnabled(false); ui-&gt;actionNewOrientedRect-&gt;setEnabled(false); ui-&gt;actionNewArcThreePoints-&gt;setEnabled(false); ui-&gt;actionSelectgraphiccolor-&gt;setEnabled(false); ui-&gt;actionFillgraphic-&gt;setEnabled(false); ui-&gt;actionCycleDrawDir-&gt;setEnabled(false); ui-&gt;actionToggleLineThickness-&gt;setEnabled(false); } } #if (M_MIL_USE_LINUX &amp;&amp; !STATIC_QT5) || (M_MIL_USE_WINDOWS &amp;&amp; STATIC_QT5) #include \"moc_mainframe.cpp\" #endif ",
      "wordCount": 1685
    },
    {
      "id": "Examples_General_MdispQt_CPP_mdispqt_cpp",
      "version": "2024020714",
      "title": "mdispqt.cpp",
      "location": "Sample Code from MIL Examples",
      "text": " Top /* * File name: MdispQt.cpp * Location: See Matrox Example Launcher in the MIL Control Center * */ // // Copyright (C) Matrox Electronic Systems Ltd., 1992-2024. // All Rights Reserved #ifdef _MSC_VER #pragma warning(disable:4127) #endif #include &lt;QtGui&gt; #if QT_VERSION &gt;= QT_VERSION_CHECK(5, 0, 0) #include &lt;QApplication&gt; #endif #include \"mainframe.h\" #include \"mdispqtapp.h\" #if STATIC_QT5 #include &lt;QtPlugin&gt; #ifdef WIN32 Q_IMPORT_PLUGIN(QWindowsIntegrationPlugin) #else Q_IMPORT_PLUGIN(QXcbIntegrationPlugin) Q_IMPORT_PLUGIN(QXcbGlxIntegrationPlugin) #endif #endif #ifdef _MSC_VER #pragma warning(default:4127) #endif #if M_MIL_USE_LINUX #include &lt;X11/Xlib.h&gt; #undef Bool #if QT_VERSION &gt;= QT_VERSION_CHECK(5, 0, 0) void MessageOutput(QtMsgType type, const QMessageLogContext &amp;context, const QString &amp;msg) { QByteArray localMsg = msg.toLocal8Bit(); switch (type) { case QtDebugMsg: fprintf(stderr, \"Debug: %s (%s:%u, %s)\\n\", localMsg.constData(), context.file, context.line, context.function); break; case QtWarningMsg: #if QT_VERSION &gt;= QT_VERSION_CHECK(5, 5, 0) case QtInfoMsg: #endif break; case QtCriticalMsg: fprintf(stderr, \"Critical: %s (%s:%u, %s)\\n\", localMsg.constData(), context.file, context.line, context.function); break; case QtFatalMsg: fprintf(stderr, \"Fatal: %s (%s:%u, %s)\\n\", localMsg.constData(), context.file, context.line, context.function); abort(); } } #endif #endif int main(int argc, char *argv[]) { #if M_MIL_USE_LINUX XInitThreads(); #if QT_VERSION &gt;= QT_VERSION_CHECK(5, 0, 0) qInstallMessageHandler(MessageOutput); #endif #else qputenv(\"QT_QPA_PLATFORM\", \"windows:nowmpointer\"); #endif MdispQtApp app( argc, argv ); return app.exec(); } #if (M_MIL_USE_WINDOWS &amp;&amp; STATIC_QT5) #include \"qrc_mdispqt.cpp\" #endif ",
      "wordCount": 188
    },
    {
      "id": "Examples_General_MdispQt_CPP_mdispqtapp_cpp",
      "version": "2024020714",
      "title": "mdispqtapp.cpp",
      "location": "Sample Code from MIL Examples",
      "text": " Top /* * File name: mdispqtapp.cpp * Location: See Matrox Example Launcher in the MIL Control Center * */ // // Copyright (C) Matrox Electronic Systems Ltd., 1992-2024. // All Rights Reserved #include \"mdispqtapp.h\" #include \"mainframe.h\" #ifdef _MSC_VER #pragma warning(disable:4127) #endif #include &lt;QtGui&gt; #include &lt;QMessageBox&gt; #ifdef _MSC_VER #pragma warning(default:4127) #endif MdispQtApp::MdispQtApp( int&amp; argc, char** argv ) : QApplication( argc, argv ) , m_isCurrentlyHookedOnErrors(false) { m_MilDigitizer = M_NULL; connect(this, SIGNAL(message(const QString&amp;)), this, SLOT(OnErrorMessage(const QString&amp;)), Qt::BlockingQueuedConnection); // Allocate an application and system [CALL TO MIL] MappAllocDefault(M_DEFAULT, &amp;m_MilApplication, &amp;m_MilSystem, M_NULL, M_NULL, M_NULL); // Inquire MIL images path MIL_STRING ImagePath; MappInquire(M_DEFAULT, M_MIL_DIRECTORY_IMAGES, ImagePath); #if M_MIL_USE_WINDOWS m_ImagePath = QString::fromStdWString(ImagePath); #else m_ImagePath = QString::fromStdString(ImagePath); #endif // Hook MIL error on function DisplayError() [CALL TO MIL] MappHookFunction(M_DEFAULT, M_ERROR_CURRENT,DisplayErrorExt,M_NULL); m_isCurrentlyHookedOnErrors = true; // Disable MIL error message to be displayed as the usual way [CALL TO MIL] MappControl(M_DEFAULT, M_ERROR,M_PRINT_DISABLE); // Inquire number of digitizers available on the system [CALL TO MIL] MsysInquire(m_MilSystem,M_DIGITIZER_NUM,&amp;m_numberOfDigitizer); // Digitizer is available if (m_numberOfDigitizer) { // Allocate a digitizer [CALL TO MIL] MdigAlloc(m_MilSystem,M_DEFAULT,MIL_TEXT(\"M_DEFAULT\"),M_DEFAULT,&amp;m_MilDigitizer); // Inquire digitizer informations [CALL TO MIL] MdigInquire(m_MilDigitizer,M_SIZE_X,&amp;m_digitizerSizeX); MdigInquire(m_MilDigitizer,M_SIZE_Y,&amp;m_digitizerSizeY); MdigInquire(m_MilDigitizer,M_SIZE_BAND,&amp;m_digitizerNbBands); } // Initialize the state of the grab m_isGrabStarted = false; // Initialize GUI MainFrame* mf = new MainFrame(); //setMainWidget(mf); mf-&gt;show(); mf-&gt;on_actionNew_triggered(); } MdispQtApp::~MdispQtApp() { //Free the digitizer [CALL TO MIL] if(m_MilDigitizer) MdigFree (m_MilDigitizer); //Free the system [CALL TO MIL] if(m_MilSystem) MsysFree (m_MilSystem); if(m_MilApplication) { // Enable MIL error message to be displayed as the usual way [CALL TO MIL] MappControl(M_DEFAULT, M_ERROR,M_PRINT_ENABLE); // Unhook MIL error on function DisplayError() [CALL TO MIL] if(m_isCurrentlyHookedOnErrors) { MappHookFunction(M_DEFAULT, M_ERROR_CURRENT+M_UNHOOK,DisplayErrorExt,M_NULL); m_isCurrentlyHookedOnErrors = false; } // Free the application [CALL TO MIL] MappFree(m_MilApplication); } } ///////////////////////////////////////////////////////////////////////// // MIL: Hook-handler function: DisplayError() ///////////////////////////////////////////////////////////////////////// MIL_INT MFTYPE MdispQtApp::DisplayErrorExt(MIL_INT /*HookType*/, MIL_ID EventId, void* /*UserDataPtr*/) { ((MdispQtApp*) qApp)-&gt;DisplayError(EventId); return M_NULL; } long MFTYPE MdispQtApp::DisplayError( MIL_ID EventId ) { MIL_STRING ErrorMessageFunction; MIL_STRING ErrorMessage; MIL_STRING ErrorSubMessage1; MIL_STRING ErrorSubMessage2; MIL_STRING ErrorSubMessage3; MIL_INT NbSubCode; QString QErrorMessage; //Retrieve error message [CALL TO MIL] MappGetHookInfo(EventId,M_MESSAGE+M_CURRENT_OPCODE,ErrorMessageFunction); MappGetHookInfo(EventId,M_MESSAGE+M_CURRENT,ErrorMessage); MappGetHookInfo(EventId,M_CURRENT_SUB_NB,&amp;NbSubCode); if (NbSubCode &gt; 2) MappGetHookInfo(EventId,M_MESSAGE+M_CURRENT_SUB_3,ErrorSubMessage3); if (NbSubCode &gt; 1) MappGetHookInfo(EventId,M_MESSAGE+M_CURRENT_SUB_2,ErrorSubMessage2); if (NbSubCode &gt; 0) MappGetHookInfo(EventId,M_MESSAGE+M_CURRENT_SUB_1,ErrorSubMessage1); #if M_MIL_USE_LINUX QErrorMessage = ErrorMessageFunction.c_str(); #else QErrorMessage = QString::fromWCharArray(ErrorMessageFunction.c_str()); #endif QErrorMessage = QErrorMessage + \"\\n\"; #if M_MIL_USE_LINUX QErrorMessage = QErrorMessage + ErrorMessage.c_str(); #else QErrorMessage = QErrorMessage + QString::fromWCharArray(ErrorMessage.c_str()); #endif if(NbSubCode &gt; 0) { QErrorMessage = QErrorMessage + \"\\n\"; #if M_MIL_USE_LINUX QErrorMessage = QErrorMessage + ErrorSubMessage1.c_str(); #else QErrorMessage = QErrorMessage + QString::fromWCharArray(ErrorSubMessage1.c_str()); #endif } if(NbSubCode &gt; 1) { QErrorMessage = QErrorMessage + \"\\n\"; #if M_MIL_USE_LINUX QErrorMessage = QErrorMessage + ErrorSubMessage2.c_str(); #else QErrorMessage = QErrorMessage + QString::fromWCharArray(ErrorSubMessage2.c_str()); #endif } if(NbSubCode &gt; 2) { QErrorMessage = QErrorMessage + \"\\n\"; #if M_MIL_USE_LINUX QErrorMessage = QErrorMessage + ErrorSubMessage3.c_str(); #else QErrorMessage = QErrorMessage + QString::fromWCharArray(ErrorSubMessage3.c_str()); #endif } QErrorMessage = QErrorMessage + \"\\n\\n\"; QErrorMessage = QErrorMessage + \"Do you want to continue error print?\"; QThread* current = QThread::currentThread(); if (current != QCoreApplication::instance()-&gt;thread()) emit message(QErrorMessage); else OnErrorMessage(QErrorMessage); return M_NULL; } void MdispQtApp::OnErrorMessage(const QString&amp; QErrorMessage) { if ( QMessageBox::warning( 0, tr(\"MIL Error\"), QErrorMessage, QMessageBox::Yes, QMessageBox::No ) == QMessageBox::No ) { MappHookFunction(M_DEFAULT, M_ERROR_CURRENT+M_UNHOOK,DisplayErrorExt,M_NULL); ((MdispQtApp*) qApp)-&gt;HookedOnErrors(false); } } #if (M_MIL_USE_LINUX &amp;&amp; !STATIC_QT5) || (M_MIL_USE_WINDOWS &amp;&amp; STATIC_QT5) #include \"moc_mdispqtapp.cpp\" #endif ",
      "wordCount": 505
    },
    {
      "id": "Examples_General_MdispQt_CPP_mdispqtview_cpp",
      "version": "2024020714",
      "title": "mdispqtview.cpp",
      "location": "Sample Code from MIL Examples",
      "text": " Top /* * File name: mdispqtview.cpp * Location: See Matrox Example Launcher in the MIL Control Center * */ // // Copyright (C) Matrox Electronic Systems Ltd., 1992-2024. // All Rights Reserved #ifdef _MSC_VER #pragma warning(disable:4127) #endif #include \"mdispqtview.h\" #include \"mdispqtapp.h\" #include \"childframe.h\" #include &lt;QtGui&gt; #if M_MIL_USE_LINUX #include &lt;cairo-xlib.h&gt; #include &lt;QX11Info&gt; #endif #include &lt;cmath&gt; #include &lt;cstdlib&gt; #if M_MIL_USE_LINUX #include &lt;X11/Xlib.h&gt; // For XClearArea, XSendEvent... #undef Bool #else #include &lt;windows.h&gt; #endif #include &lt;QColorDialog&gt; #include &lt;QScrollArea&gt; #include &lt;QFileDialog&gt; #include &lt;QMessageBox&gt; #include &lt;algorithm&gt; #ifdef _MSC_VER #pragma warning(default:4127) #endif #define NON_MOUSE_MASK (~(ButtonPressMask|ButtonReleaseMask|PointerMotionMask)) #define IMAGE_FILE M_IMAGE_PATH MIL_TEXT(\"BaboonRGB.mim\") MIL_INT MFTYPE MouseFct(MIL_INT /*HookType*/, MIL_ID EventID, void* UserDataPtr) { MdispQtView* pCurrentView = (MdispQtView *)UserDataPtr; if(pCurrentView) { MOUSEPOSITION MousePosition; MdispGetHookInfo(EventID, M_MOUSE_POSITION_X, &amp;MousePosition.m_DisplayPositionX); MdispGetHookInfo(EventID, M_MOUSE_POSITION_Y, &amp;MousePosition.m_DisplayPositionY); MdispGetHookInfo(EventID, M_MOUSE_POSITION_BUFFER_X, &amp;MousePosition.m_BufferPositionX); MdispGetHookInfo(EventID, M_MOUSE_POSITION_BUFFER_Y, &amp;MousePosition.m_BufferPositionY); pCurrentView-&gt;SetMousePosition(MousePosition); ((MdispQtApp*)qApp)-&gt;postEvent( pCurrentView, new MilMouseEvent(MousePosition)); } return 0; } MIL_INT MFTYPE GraphicListModifiedHookFct(MIL_INT /*HookType*/, MIL_ID EventID, void* UserDataPtr) { MdispQtView *pCurrentView = (MdispQtView *)UserDataPtr; if(pCurrentView) { MIL_INT State = M_NULL; MgraGetHookInfo(EventID, M_INTERACTIVE_GRAPHIC_STATE, &amp;State); if((State != M_STATE_WAITING_FOR_CREATION) &amp;&amp; (State != M_STATE_BEING_CREATED)) { pCurrentView-&gt;ResetPrimitiveCreation(); } } return 0; } MdispQtView::MdispQtView( QWidget* parent ) :QWidget(parent) , m_Modified(false) { m_InitDone = false; setAttribute(Qt::WA_OpaquePaintEvent, true); setAttribute(Qt::WA_PaintOnScreen, true); setAttribute(Qt::WA_NoSystemBackground, false); m_MilOverlayImage = M_NULL; // Overlay image buffer identifier m_MilDisplay = M_NULL; // Display identifier. m_MilGraphContext = M_NULL; m_MilGraphList = M_NULL; static int viewNumber = 0; m_Filename = QString(tr(\"Image%1.mim\")).arg(++viewNumber); m_FilenameValid = false; m_currentZoomFactorX = 1.0; m_currentZoomFactorY = 1.0; m_isWindowed = true; m_isExclusive = false; m_isOverlayEnabled = false; // Overlay state m_isOverlayInitialized = false; m_isScaleDisplayEnabled = false; m_isGraphicsAnnotationsEnabled = false; m_isNativeAnnotationsEnabled = false; m_currentViewMode = M_TRANSPARENT; m_currentShiftValue = M_NULL; m_isInAsynchronousMode = false; m_currentCompressionType = M_NULL; m_currentAsynchronousFrameRate = M_INFINITE; m_currentQFactor = M_DEFAULT; m_currentOverlayOpacity = M_DEFAULT; m_currentGraphicListOpacity = M_DEFAULT; m_currentRestrictCursor = M_ENABLE; m_PrimitiveInCreation = M_NULL; m_FrameRateTimer = startTimer(500); #if M_MIL_USE_LINUX m_GC = M_NULL; #endif } MdispQtView::~MdispQtView() { // Halt the grab, deselected the display, free the display and the image buffer // only if MbufAlloc was successful if (m_MilImage) { // Make sure display is deselected and grab is halt RemoveFromDisplay(); // Free image buffer [CALL TO MIL] MbufFree(m_MilImage); } #if M_MIL_USE_LINUX if(m_GC) XFreeGC(QX11Info::display(),m_GC); #endif } void MdispQtView::GrabStart() { // TODO: Add your command handler code here ///////////////////////////////////////////////////////////////////////// // MIL: Write code that will be executed on a grab start ///////////////////////////////////////////////////////////////////////// // If there is a grab in a view, halt the grab before starting a new one if(((MdispQtApp*)qApp)-&gt;m_isGrabStarted) ((MdispQtApp*)qApp)-&gt;m_pGrabView-&gt;GrabStop(); // Start a continuous grab in this view MdigGrabContinuous(((MdispQtApp*)qApp)-&gt;m_MilDigitizer, m_MilImage); // Update the variable GrabIsStarted ((MdispQtApp*)qApp)-&gt;m_isGrabStarted = true; // GrabInViewPtr is now a pointer to m_pGrabView view ((MdispQtApp*)qApp)-&gt;m_pGrabView = this; // Document has been modified m_Modified = true; ///////////////////////////////////////////////////////////////////////// // MIL: Write code that will be executed on a grab start ///////////////////////////////////////////////////////////////////////// } void MdispQtView::GrabStop() { // TODO: Add your command handler code here ///////////////////////////////////////////////////////////////////////// // MIL: Write code that will be executed on a grab stop ///////////////////////////////////////////////////////////////////////// // Halt the grab MdigHalt(((MdispQtApp*)qApp)-&gt;m_MilDigitizer); ((MdispQtApp*)qApp)-&gt;m_isGrabStarted = false; ///////////////////////////////////////////////////////////////////////// // MIL: Write code that will be executed on a grab stop ///////////////////////////////////////////////////////////////////////// } void MdispQtView::Overlay( bool on ) { // Enable overlay if (on &amp;&amp; !m_isOverlayEnabled) { MdispControl(m_MilDisplay, M_OVERLAY, M_ENABLE); //If overlay buffer as not been initialized yet, do it now. if(!m_isOverlayInitialized) InitializeOverlay(); m_isOverlayEnabled = true; } // Disable overlay else if (!on &amp;&amp; m_isOverlayEnabled) { // Disable the overlay display. [CALL TO MIL] MdispControl(m_MilDisplay, M_OVERLAY, M_DISABLE); m_isOverlayInitialized = false; m_isOverlayEnabled = false; } ///////////////////////////////////////////////////////////////////////// // MIL: Write code that will be executed when 'add overlay' is selected ///////////////////////////////////////////////////////////////////////// } void MdispQtView::Initialize() { // Allocate a display [CALL TO MIL] MdispAlloc(((MdispQtApp*)qApp)-&gt;m_MilSystem, M_DEFAULT, MIL_TEXT(\"M_DEFAULT\"), M_DEFAULT, &amp;m_MilDisplay); if(m_MilDisplay) { MIL_INT DisplayType = MdispInquire(m_MilDisplay, M_DISPLAY_TYPE, M_NULL); // Check display type [CALL TO MIL] if((DisplayType&amp;(M_WINDOWED|M_EXCLUSIVE)) !=M_WINDOWED) m_isWindowed = false; if(DisplayType&amp;(M_EXCLUSIVE)) m_isExclusive = true; ChangeViewMode(M_DEFAULT); if(IsNetworkedSystem()) { // Check compression type [CALL TO MIL] MdispInquire(m_MilDisplay, M_COMPRESSION_TYPE, &amp;m_currentCompressionType); // Check asynchronous mode [CALL TO MIL] m_isInAsynchronousMode = (MdispInquire(m_MilDisplay, M_ASYNC_UPDATE, M_NULL) == M_ENABLE); // Check asynchronous frame rate [CALL TO MIL] MdispInquire(m_MilDisplay, M_UPDATE_RATE_MAX, &amp;m_currentAsynchronousFrameRate); // Check Q factor [CALL TO MIL] MdispInquire(m_MilDisplay, M_Q_FACTOR, &amp;m_currentQFactor); // Check Overlay Opacity [CALL TO MIL] MdispInquire(m_MilDisplay, M_OVERLAY_OPACITY, &amp;m_currentOverlayOpacity); // Check Graphic List Opacity [CALL TO MIL] MdispInquire(m_MilDisplay, M_GRAPHIC_LIST_OPACITY, &amp;m_currentGraphicListOpacity); } if(m_isExclusive) { setAttribute(Qt::WA_PaintOnScreen, false); MdispInquire(m_MilDisplay, M_RESTRICT_CURSOR, &amp;m_currentRestrictCursor); } // Allow panning and zooming with the mouse [CALL TO MIL] MdispControl(m_MilDisplay, M_MOUSE_USE, M_ENABLE); // Tell Mil display we are using Qt.SDK. MdispControl(m_MilDisplay, M_QT_MODE, M_ENABLE); // Allow mouse cursor handling [CALL TO MIL] MdispControl(m_MilDisplay, M_MOUSE_CURSOR_CHANGE, M_ENABLE); // Hook a function to mouse-movement event, to update cursor position in status bar. MdispHookFunction(m_MilDisplay, M_MOUSE_MOVE, MouseFct, (void*)this); } m_InitDone = true; ///////////////////////////////////////////////////////////////////////// // MIL: Code that will be executed when a view is first attached to the document ///////////////////////////////////////////////////////////////////////// } void MdispQtView::RemoveFromDisplay() { //Halt grab if in process in THIS view if ((((MdispQtApp*)qApp)-&gt;m_pGrabView == this) &amp;&amp; ((MdispQtApp*)qApp)-&gt;m_isGrabStarted) { //Ask the digitizer to halt the grab [CALL TO MIL] MdigHalt(((MdispQtApp*)qApp)-&gt;m_MilDigitizer); ((MdispQtApp*)qApp)-&gt;m_isGrabStarted = false; } if (m_MilImage &amp;&amp; m_MilDisplay) { //Deselect the buffer from it's display object and given window [CALL TO MIL] MdispSelect(m_MilDisplay, M_NULL); // Hook from mouse-movement event. MdispHookFunction(m_MilDisplay, M_MOUSE_MOVE+M_UNHOOK, MouseFct, (void*)this); //Free GraphicList [CALL TO MIL] if(m_MilGraphList) { MgraFree(m_MilGraphList); m_MilGraphList = M_NULL; } if(m_MilGraphContext) { MgraFree(m_MilGraphContext); m_MilGraphContext = M_NULL; } //Free the display [CALL TO MIL] MdispFree(m_MilDisplay); m_MilDisplay = M_NULL; } } #if M_MIL_USE_WINDOWS void MdispQtView::resizeEvent(QResizeEvent*) { if(m_MilDisplay) { MdispControl(m_MilDisplay, M_UPDATE, M_NOW); } } #endif #if QT_VERSION &gt; QT_VERSION_CHECK(5, 0, 0) QPaintEngine* MdispQtView::paintEngine()const { if (!m_InitDone) return NULL; else if (m_MilDisplay &amp;&amp; m_isWindowed) return NULL; else return QWidget::paintEngine(); } #endif void MdispQtView::paintEvent( QPaintEvent* /*ev*/) { if(!m_MilDisplay) { QPainter p( this); QFont font; font.setStyleStrategy( QFont::NoAntialias ); font.setBold(true); p.setFont(font); p.setPen( QColor(255,0,0) ); p.drawText( 0, 0, width() , p.fontMetrics().height(), Qt::AlignCenter, tr(\"Display Allocation Failed!\") ); } else if (m_isWindowed) { if (m_isNativeAnnotationsEnabled) { #if M_MIL_USE_LINUX #if QT_VERSION &lt; QT_VERSION_CHECK(5, 0, 0) QPainter p( this); QFont font; p.setPen( QColor(255,0,255) ); p.drawText( 0, 0, contentsRect().width(), p.fontMetrics().height(), Qt::AlignCenter, tr(\"Window Annotations\") ); #else // PaintEngine is disabled use Xlib functions cairo_t *cr; cairo_text_extents_t extents; cairo_surface_t *surface = cairo_xlib_surface_create (QX11Info::display(), winId(), DefaultVisual(QX11Info::display(),0), contentsRect().width(), contentsRect().height()); cr = cairo_create (surface); cairo_select_font_face (cr, \"serif\", CAIRO_FONT_SLANT_NORMAL, CAIRO_FONT_WEIGHT_NORMAL); cairo_set_font_size (cr, 12.0); cairo_set_source_rgb (cr, 1.0, 0.0, 1.0); cairo_text_extents(cr, \"Window Annotation\", &amp;extents); cairo_move_to (cr, (m_isScaleDisplayEnabled)?(contentsRect().width()/2 - extents.width/2):(m_imageSizeX/2 - extents.width/2),20.0); cairo_show_text (cr, \"Window Annotation\"); cairo_destroy(cr); XFlush(QX11Info::display()); #endif #elif M_MIL_USE_WINDOWS // PaintEngine is disabled use GDi functions RECT rectangle; rectangle.top = 0; rectangle.left = 0; rectangle.right = rect().width(); rectangle.bottom = rect().height(); HDC hdc = GetDC((HWND)winId()); SetTextColor(hdc,RGB(255,0,255)); SetBkMode(hdc, TRANSPARENT); DrawText(hdc,L\"Window Annotation\", 17,&amp;rectangle, DT_CENTER); ReleaseDC((HWND)winId(), hdc); #endif } } else { // In external mode, write message in window QPainter p( this); QFont font; font.setStyleStrategy( QFont::NoAntialias ); font.setBold(true); p.setFont(font); p.setPen( QColor(0,0,0) ); p.drawText( 0, 0, m_isScaleDisplayEnabled ? width() : contentsRect().width(), p.fontMetrics().height(), Qt::AlignLeft, tr(\"Image Displayed on external screen\") ); } } void MdispQtView::timerEvent( QTimerEvent* e ) { if (m_MilDisplay) { if (e-&gt;timerId() == m_FrameRateTimer) { MIL_DOUBLE CurrentFrameRate = M_NULL; MdispInquire(m_MilDisplay, M_UPDATE_RATE, &amp;CurrentFrameRate); emit frameRateChanged(CurrentFrameRate); MIL_DOUBLE ZoomX = 1.0, ZoomY = 1.0; MdispInquire(m_MilDisplay, M_ZOOM_FACTOR_X, &amp;ZoomX); MdispInquire(m_MilDisplay, M_ZOOM_FACTOR_Y, &amp;ZoomY); emit zoomFactorChanged(ZoomX, ZoomY); } } } void MdispQtView::ZoomIn() { if(m_MilDisplay) { MIL_DOUBLE ZoomX =1.0, ZoomY =1.0; MdispInquire(m_MilDisplay,M_ZOOM_FACTOR_X, &amp;ZoomX); MdispInquire(m_MilDisplay,M_ZOOM_FACTOR_Y, &amp;ZoomY); if(ZoomX &lt;=8.0 &amp;&amp; ZoomY&lt;=8.0) { ZoomX*=2.0; ZoomY*=2.0; } //Perform zooming with MIL (using MdispZoom) Zoom( ZoomX, ZoomY); } } void MdispQtView::ZoomOut() { if(m_MilDisplay) { MIL_DOUBLE ZoomX =1.0, ZoomY =1.0; MdispInquire(m_MilDisplay,M_ZOOM_FACTOR_X, &amp;ZoomX); MdispInquire(m_MilDisplay,M_ZOOM_FACTOR_Y, &amp;ZoomY); if(ZoomX &gt;=0.125 &amp;&amp; ZoomY&gt;=0.125) { ZoomX/=2.0; ZoomY/=2.0; } //Perform zooming with MIL (using MdispZoom) Zoom( ZoomX, ZoomY ); } } void MdispQtView::NoZoom() { if(m_MilDisplay) { //Perform zooming with MIL Zoom(1.0, 1.0); MdispPan(m_MilDisplay, M_NULL,M_NULL); } } void MdispQtView::Zoom( MIL_DOUBLE ZoomFactorToApplyX, MIL_DOUBLE ZoomFactorToApplyY ) { if( m_MilDisplay) { //Apply zoom [CALL TO MIL] MdispZoom(m_MilDisplay, ZoomFactorToApplyX, ZoomFactorToApplyY); m_currentZoomFactorX = ZoomFactorToApplyX; m_currentZoomFactorY = ZoomFactorToApplyY; emit zoomFactorChanged(m_currentZoomFactorX, m_currentZoomFactorY); } } void MdispQtView::ScaleDisplay( bool on ) { if(m_MilDisplay) { #if M_MIL_USE_LINUX if(!on) { XClearWindow(QX11Info::display(), winId()); XFlush(QX11Info::display()); XSync(QX11Info::display(),False); } #endif //Using MIL, enable/disable Scale Display Mode [CALL TO MIL] MdispControl(m_MilDisplay, M_SCALE_DISPLAY, on ? M_ENABLE : M_DISABLE); m_isScaleDisplayEnabled = on; // clear contents repaint(); } } void MdispQtView::OnGraRectangle() { if(m_MilDisplay) { if(m_isGraphicsAnnotationsEnabled) { MgraControl(m_MilGraphContext, M_COLOR, M_COLOR_WHITE); MgraInteractive(m_MilGraphContext, m_MilGraphList, M_GRAPHIC_TYPE_RECT, M_DEFAULT, M_AXIS_ALIGNED_RECT); m_PrimitiveInCreation = M_AXIS_ALIGNED_RECT; } } } void MdispQtView::OnGraCircle() { if(m_MilDisplay) { if(m_isGraphicsAnnotationsEnabled) { MgraControl(m_MilGraphContext, M_COLOR, M_COLOR_YELLOW); MgraInteractive(m_MilGraphContext, m_MilGraphList, M_GRAPHIC_TYPE_ARC, M_DEFAULT, M_CIRCLE); m_PrimitiveInCreation = M_CIRCLE; } } } void MdispQtView::OnGraPolygon() { if(m_MilDisplay) { if(m_isGraphicsAnnotationsEnabled) { MgraControl(m_MilGraphContext, M_COLOR, M_COLOR_RED); MgraInteractive(m_MilGraphContext, m_MilGraphList, M_GRAPHIC_TYPE_POLYGON, M_DEFAULT, M_DEFAULT); m_PrimitiveInCreation = M_GRAPHIC_TYPE_POLYGON; } } } void MdispQtView::OnGraOrientedRect() { if(m_MilDisplay) { if(m_isGraphicsAnnotationsEnabled) { MgraControl(m_MilGraphContext, M_COLOR, M_COLOR_BLUE); MgraInteractive(m_MilGraphContext, m_MilGraphList, M_GRAPHIC_TYPE_RECT, M_DEFAULT, M_ORIENTED_RECT); m_PrimitiveInCreation = M_ORIENTED_RECT; } } } void MdispQtView::OnGraArcThreePoints() { if(m_MilDisplay) { if(m_isGraphicsAnnotationsEnabled) { MgraControl(m_MilGraphContext, M_COLOR, M_COLOR_GREEN); MgraInteractive(m_MilGraphContext, m_MilGraphList, M_GRAPHIC_TYPE_ARC, M_DEFAULT, M_ARC_THREE_POINTS); m_PrimitiveInCreation = M_ARC_THREE_POINTS; } } } void MdispQtView::OnGraChooseColor() { if(m_MilDisplay &amp;&amp; m_MilGraphList) { QColor c = QColorDialog::getColor(Qt::white,this); if(c.isValid()) { MIL_INT NewColor = M_RGB888(c.red(),c.green(), c.blue()); MgraControlList(m_MilGraphList, M_ALL_SELECTED, M_DEFAULT, M_COLOR, (MIL_INT)NewColor); MgraControlList(m_MilGraphList, M_ALL, M_DEFAULT, M_GRAPHIC_SELECTED, M_FALSE); } } } void MdispQtView::OnGraCycleDrawDir() { if(m_MilDisplay &amp;&amp; m_MilGraphList) { const MIL_INT NbValues = 4; MIL_INT DrawDirValues[NbValues] = { M_NONE, M_PRIMARY_DIRECTION, M_SECONDARY_DIRECTION, M_PRIMARY_DIRECTION + M_SECONDARY_DIRECTION }; MIL_INT NbGrph = 0; MgraInquireList(m_MilGraphList, M_LIST, M_DEFAULT, M_NUMBER_OF_GRAPHICS, &amp;NbGrph); MIL_INT DrawDirCurValueIdx = 0; MIL_INT NbSelectedGrph = 0; for(MIL_INT g = 0; g &lt; NbGrph; g++) // Finds the highest draw direction among selected graphics { if(MgraInquireList(m_MilGraphList, M_GRAPHIC_INDEX(g), M_DEFAULT, M_GRAPHIC_SELECTED, M_NULL) == M_TRUE) { MIL_INT GrphDrawDir = MgraInquireList(m_MilGraphList, M_GRAPHIC_INDEX(g), M_DEFAULT, M_DRAW_DIRECTION, M_NULL); if(GrphDrawDir == M_DEFAULT) { GrphDrawDir = M_NONE; } MIL_INT FoundIdx = std::find(&amp;DrawDirValues[0], &amp;DrawDirValues[NbValues], GrphDrawDir) - &amp;DrawDirValues[0]; if(FoundIdx &lt; NbValues) { DrawDirCurValueIdx = std::max(DrawDirCurValueIdx, FoundIdx); } ++NbSelectedGrph; } } if(NbSelectedGrph &gt; 0) { // toggle current value DrawDirCurValueIdx = (DrawDirCurValueIdx + 1) % NbValues; MgraControlList(m_MilGraphList, M_ALL_SELECTED, M_DEFAULT, M_DRAW_DIRECTION, DrawDirValues[DrawDirCurValueIdx]); } } } void MdispQtView::OnGraToggleLineThickness() { if(m_MilDisplay &amp;&amp; m_MilGraphList) { MIL_INT NbGrph = 0; MgraInquireList(m_MilGraphList, M_LIST, M_DEFAULT, M_NUMBER_OF_GRAPHICS, &amp;NbGrph); for(MIL_INT g = 0; g &lt; NbGrph; g++) { if(MgraInquireList(m_MilGraphList, M_GRAPHIC_INDEX(g), M_DEFAULT, M_GRAPHIC_SELECTED, M_NULL) == M_TRUE) { MIL_INT CurLineThickness = MgraInquireList(m_MilGraphList, M_GRAPHIC_INDEX(g), M_DEFAULT, M_LINE_THICKNESS, M_NULL); // Toggle thickness if(CurLineThickness &gt; 1) { MgraControlList(m_MilGraphList, M_GRAPHIC_INDEX(g), M_DEFAULT, M_LINE_THICKNESS, 1); } else { MgraControlList(m_MilGraphList, M_GRAPHIC_INDEX(g), M_DEFAULT, M_LINE_THICKNESS, 3); } } } } } void MdispQtView::OnGraFill() { if(m_MilDisplay &amp;&amp; m_MilGraphList) { MgraControlList(m_MilGraphList, M_ALL_SELECTED, M_DEFAULT, M_FILLED, M_TRUE); MgraControlList(m_MilGraphList, M_ALL, M_DEFAULT, M_GRAPHIC_SELECTED, M_FALSE); } } void MdispQtView::ChangeGraphicListOpacity(MIL_INT Opacity) { if(m_MilDisplay &amp;&amp; m_MilGraphList) { // Apply Opacity to display [CALL TO MIL] MdispControl(m_MilDisplay, M_GRAPHIC_LIST_OPACITY, Opacity); // Check if control worked correctly before considering it successful [CALL TO MIL] if((Opacity == M_DEFAULT) || (MdispInquire(m_MilDisplay, M_GRAPHIC_LIST_OPACITY, M_NULL) == Opacity)) { m_currentGraphicListOpacity = Opacity; } } } void MdispQtView::X11Annotations( bool on ) { m_isNativeAnnotationsEnabled = on; #if !M_MIL_USE_LINUX if(on) { MdispControl(m_MilDisplay, M_WINDOW_ANNOTATIONS, M_ENABLE); } else { MdispControl(m_MilDisplay,M_WINDOW_ANNOTATIONS,M_DISABLE); } #endif repaint(); } void MdispQtView::GraphicsAnnotations( bool on ) { if(m_MilDisplay) { m_isGraphicsAnnotationsEnabled = on; if(m_isGraphicsAnnotationsEnabled) { if(!m_MilGraphContext &amp;&amp; !m_MilGraphList) { MIL_INT BufSizeX = 0, BufSizeY = 0; MIL_INT Offset = 15; MgraAlloc(((MdispQtApp*)qApp)-&gt;m_MilSystem, &amp;m_MilGraphContext); MgraAllocList(((MdispQtApp*)qApp)-&gt;m_MilSystem, M_DEFAULT, &amp;m_MilGraphList); MdispControl(m_MilDisplay, M_ASSOCIATED_GRAPHIC_LIST_ID, m_MilGraphList); MdispControl(m_MilDisplay, M_UPDATE_GRAPHIC_LIST, M_DISABLE); MbufInquire(m_MilImage, M_SIZE_X, &amp;BufSizeX); MbufInquire(m_MilImage, M_SIZE_Y, &amp;BufSizeY); MgraClear(m_MilGraphContext, m_MilGraphList); MgraControl(m_MilGraphContext, M_COLOR, M_COLOR_LIGHT_BLUE); MgraRect(m_MilGraphContext, m_MilGraphList, Offset, Offset, BufSizeX - Offset, BufSizeY - Offset); MgraControl(m_MilGraphContext, M_COLOR, M_COLOR_GREEN); MgraControl(m_MilGraphContext, M_BACKGROUND_MODE, M_TRANSPARENT); MgraControl(m_MilGraphContext, M_TEXT_ALIGN_HORIZONTAL, M_CENTER); MgraControl(m_MilGraphContext, M_TEXT_ALIGN_VERTICAL, M_CENTER); MgraControl(m_MilGraphContext, M_FONT_SIZE, 24); MgraFont(m_MilGraphContext, M_FONT_DEFAULT_TTF); MgraText(m_MilGraphContext, m_MilGraphList, BufSizeX/2, Offset, MIL_TEXT(\"Interactive Graphic Annotations\")); //Initialize graphic list MdispControl(m_MilDisplay, M_UPDATE_GRAPHIC_LIST, M_ENABLE); MdispControl(m_MilDisplay, M_GRAPHIC_LIST_INTERACTIVE, M_ENABLE); MgraHookFunction(m_MilGraphList, M_INTERACTIVE_GRAPHIC_STATE_MODIFIED, GraphicListModifiedHookFct, (void*)this); } } else { MgraHookFunction(m_MilGraphList, M_INTERACTIVE_GRAPHIC_STATE_MODIFIED+M_UNHOOK, GraphicListModifiedHookFct, (void*)this); MdispControl(m_MilDisplay, M_ASSOCIATED_GRAPHIC_LIST_ID, M_NULL); if(m_MilGraphList) { MgraFree(m_MilGraphList); m_MilGraphList = M_NULL; } if(m_MilGraphContext) { MgraFree(m_MilGraphContext); m_MilGraphContext = M_NULL; } } } } void MdispQtView::ChangeViewMode(long ViewMode,long ShiftValue) { if(m_MilDisplay) { //Apply view mode on display [CALL TO MIL] MdispControl(m_MilDisplay, M_VIEW_MODE, ViewMode); if(ViewMode == M_BIT_SHIFT) MdispControl(m_MilDisplay, M_VIEW_BIT_SHIFT, ShiftValue); //Check if control worked correctly before considering it as successful [CALL TO MIL] if(MdispInquire(m_MilDisplay, M_VIEW_MODE,M_NULL)==ViewMode) { //Make sure ViewMode Mode combo box shows current view mode m_currentViewMode = ViewMode; m_currentShiftValue = ShiftValue; } } } void MdispQtView::ChangeCompressionType(MIL_INT CompressionType) { if(m_MilDisplay) { // Apply compression type to display [CALL TO MIL] MdispControl(m_MilDisplay, M_COMPRESSION_TYPE, CompressionType); // Check if control worked correctly before considering it successful [CALL TO MIL] if(MdispInquire(m_MilDisplay, M_COMPRESSION_TYPE, M_NULL) == CompressionType) { m_currentCompressionType = CompressionType; } } } void MdispQtView::ChangeAsynchronousMode(bool Enabled, MIL_INT FrameRate) { if(Enabled &amp;&amp; (FrameRate != m_currentAsynchronousFrameRate)) { if(m_MilDisplay) { // Apply asynchronous frame rate to display [CALL TO MIL] MdispControl(m_MilDisplay, M_UPDATE_RATE_MAX, FrameRate); // Check if control worked correctly before considering it successful [CALL TO MIL] if(MdispInquire(m_MilDisplay, M_UPDATE_RATE_MAX, M_NULL) == FrameRate) { m_currentAsynchronousFrameRate = FrameRate; } } } if((Enabled &amp;&amp; !m_isInAsynchronousMode) || (!Enabled &amp;&amp; m_isInAsynchronousMode)) { if(m_MilDisplay) { // Apply asynchronous update to display [CALL TO MIL] MdispControl(m_MilDisplay, M_ASYNC_UPDATE, (Enabled ? M_ENABLE : M_DISABLE)); // Check if control worked correctly before considering it successful [CALL TO MIL] if(MdispInquire(m_MilDisplay, M_ASYNC_UPDATE, M_NULL) == (Enabled ? M_ENABLE : M_DISABLE)) { m_isInAsynchronousMode = Enabled; } } } } void MdispQtView::ChangeQFactor(MIL_INT QFactor) { if(m_MilDisplay) { // Apply Q factor to display [CALL TO MIL] MdispControl(m_MilDisplay, M_Q_FACTOR, QFactor); // Check if control worked correctly before considering it successful [CALL TO MIL] if(MdispInquire(m_MilDisplay, M_Q_FACTOR, M_NULL) == QFactor) { m_currentQFactor = QFactor; } } } void MdispQtView::ChangeOverlayOpacity(MIL_INT Opacity) { if(m_MilDisplay) { // Apply Opacity to display [CALL TO MIL] MdispControl(m_MilDisplay, M_OVERLAY_OPACITY, Opacity); // Check if control worked correctly before considering it successful [CALL TO MIL] if((Opacity == M_DEFAULT) || (MdispInquire(m_MilDisplay, M_OVERLAY_OPACITY, M_NULL) == Opacity)) { m_currentOverlayOpacity = Opacity; } } } bool MdispQtView::IsNetworkedSystem() { bool NetworkedSystem = false; MIL_ID SystemId = ((MdispQtApp*)qApp)-&gt;m_MilSystem; // Check if system is networked (DistributedMIL) [CALL TO MIL] if(SystemId) NetworkedSystem = (MsysInquire(SystemId, M_LOCATION, M_NULL) == M_REMOTE); return NetworkedSystem; } void MdispQtView::InitializeOverlay() { // Initialize overlay if not already done if ((!m_isOverlayInitialized) &amp;&amp; (m_MilDisplay)) { //Only do it on a valid windowed display [CALL TO MIL] if (m_MilImage &amp;&amp; m_MilDisplay ) { // Prepare overlay buffer // //////////////////////////// // Enable display overlay annotations. MdispControl(m_MilDisplay, M_OVERLAY, M_ENABLE); // Inquire the Overlay buffer associated with the displayed buffer [CALL TO MIL] MdispInquire(m_MilDisplay, M_OVERLAY_ID, &amp;m_MilOverlayImage); // Clear the overlay to transparent. MdispControl(m_MilDisplay, M_OVERLAY_CLEAR, M_DEFAULT); // Disable the overlay display update to accelerate annotations. MdispControl(m_MilDisplay, M_OVERLAY_SHOW, M_DISABLE); // Draw MIL monochrome overlay annotation * //***************************************** // Inquire MilOverlayImage size x and y [CALL TO MIL] long imageWidth = MbufInquire(m_MilOverlayImage,M_SIZE_X,M_NULL); long imageHeight = MbufInquire(m_MilOverlayImage,M_SIZE_Y,M_NULL); // Set graphic text to transparent background. [CALL TO MIL] MgraControl(M_DEFAULT, M_BACKGROUND_MODE, M_TRANSPARENT); // Set drawing color to white. [CALL TO MIL] MgraControl(M_DEFAULT, M_COLOR, M_COLOR_WHITE); // Print a string in the overlay image buffer. [CALL TO MIL] MgraText(M_DEFAULT, m_MilOverlayImage, imageWidth/9, imageHeight/5, MIL_TEXT(\" -------------------- \")); MgraText(M_DEFAULT, m_MilOverlayImage, imageWidth/9, imageHeight/5+25, MIL_TEXT(\" - MIL Overlay Text - \")); MgraText(M_DEFAULT, m_MilOverlayImage, imageWidth/9, imageHeight/5+50, MIL_TEXT(\" -------------------- \")); // Print a green string in the green component overlay image buffer. [CALL TO MIL] MgraControl(M_DEFAULT, M_COLOR, M_COLOR_GREEN); MgraText(M_DEFAULT, m_MilOverlayImage, imageWidth*11/18, imageHeight/5, MIL_TEXT(\" -------------------- \")); MgraText(M_DEFAULT, m_MilOverlayImage, imageWidth*11/18, imageHeight/5+25, MIL_TEXT(\" - MIL Overlay Text - \")); MgraText(M_DEFAULT, m_MilOverlayImage, imageWidth*11/18, imageHeight/5+50, MIL_TEXT(\" -------------------- \")); // Draw GDI color overlay annotation * //************************************ // Disable hook to MIL error because control might not be supported MappControl(M_DEFAULT, M_ERROR_HOOKS, M_DISABLE); #if M_MIL_USE_LINUX // Create a device context to draw in the overlay buffer with Cairo. [CALL TO MIL] MbufControl(m_MilOverlayImage, M_SURFACE_ALLOC, M_COMPENSATION_ENABLE); // Reenable hook to MIL error MappControl(M_DEFAULT, M_ERROR_HOOKS, M_ENABLE); // Retrieve the cairo surface of the overlay [CALL TO MIL] cairo_surface_t *surface = (cairo_surface_t *)MbufInquire(m_MilOverlayImage, M_SURFACE_HANDLE, M_NULL); if (surface) { cairo_t *cr; MIL_TEXT_CHAR chText[80]; cr = cairo_create (surface); cairo_set_source_rgb (cr, 0, 0, 1); // Draw a blue cross in the overlay buffer. cairo_move_to (cr, 0, imageHeight/2); cairo_line_to (cr, imageWidth, imageHeight/2); cairo_stroke (cr); cairo_move_to (cr, imageWidth/2, 0); cairo_line_to (cr, imageWidth/2, imageHeight); cairo_stroke (cr); // Write Red text in the overlay buffer. MosStrcpy(chText, 80, \"X Overlay Text \"); cairo_set_source_rgb (cr, 1, 0, 0); cairo_set_font_size(cr, 13); cairo_move_to(cr, imageWidth*3/18, imageHeight*4/6); cairo_show_text(cr, chText); // Write Yellow text in the overlay buffer. cairo_set_source_rgb (cr, 1, 1, 0); cairo_set_font_size(cr, 13); cairo_move_to(cr, imageWidth*12/18,imageHeight*4/6); cairo_show_text(cr, chText); cairo_destroy(cr); XFlush(QX11Info::display()); XSync(QX11Info::display(),False); // Delete created cairo surface. [CALL TO MIL] MbufControl(m_MilOverlayImage, M_SURFACE_FREE, M_DEFAULT); // Signal MIL that the overlay buffer was modified. [CALL TO MIL] MbufControl(m_MilOverlayImage, M_MODIFIED, M_DEFAULT); } #else // Create a device context to draw in the overlay buffer with GDI. [CALL TO MIL] MbufControl(m_MilOverlayImage, M_DC_ALLOC, M_DEFAULT); // Reenable hook to MIL error MappControl(M_DEFAULT, M_ERROR_HOOKS, M_ENABLE); // Retrieve the HDC of the overlay [CALL TO MIL] HDC OverlayDC = (HDC)MbufInquire(m_MilOverlayImage, M_DC_HANDLE, M_NULL); if(OverlayDC != M_NULL) { HGDIOBJ hpen, hpenOld; POINT Hor[2]; POINT Ver[2]; SIZE TxtSz; RECT Txt; MIL_TEXT_CHAR chText[80]; int Count; /* Draw a blue cross. */ hpen=CreatePen(PS_SOLID, 1, RGB(0, 0, 255)); hpenOld = SelectObject(OverlayDC, hpen); Hor[0].x = (MIL_INT32)0; Hor[0].y = (MIL_INT32)(imageHeight/2); Hor[1].x = (MIL_INT32)imageWidth; Hor[1].y = (MIL_INT32)(imageHeight/2); Polyline(OverlayDC, Hor,2); Ver[0].x = (MIL_INT32)(imageWidth/2); Ver[0].y = (MIL_INT32)0; Ver[1].x = (MIL_INT32)(imageWidth/2); Ver[1].y = (MIL_INT32)imageHeight; Polyline(OverlayDC, Ver,2); SelectObject(OverlayDC, hpenOld); DeleteObject(hpen); /* Prepare transparent text annotations. */ SetBkMode(OverlayDC, TRANSPARENT); MosStrcpy(chText, 80, MIL_TEXT(\"GDI Overlay Text\")); Count = (int) MosStrlen(chText); GetTextExtentPoint(OverlayDC, chText, Count, &amp;TxtSz); /* Write red text. */ Txt.left = (MIL_INT32)(imageWidth*3/18); Txt.top = (MIL_INT32)(imageHeight*17/24); Txt.right = (MIL_INT32)(Txt.left + TxtSz.cx); Txt.bottom = (MIL_INT32)(Txt.top + TxtSz.cy); SetTextColor(OverlayDC,RGB(255, 0, 0)); DrawText(OverlayDC, chText, Count, &amp;Txt, DT_RIGHT); /* Write yellow text. */ Txt.left = (MIL_INT32)imageWidth*12/18; Txt.top = (MIL_INT32)imageHeight*17/24; Txt.right = (MIL_INT32)(Txt.left + TxtSz.cx); Txt.bottom = (MIL_INT32)(Txt.top + TxtSz.cy); SetTextColor(OverlayDC, RGB(255, 255, 0)); DrawText(OverlayDC, chText, Count, &amp;Txt, DT_RIGHT); // Delete created device context. [CALL TO MIL] MbufControl(m_MilOverlayImage, M_DC_FREE, M_DEFAULT); // Signal to MIL that the overlay buffer was modified. [CALL TO MIL] MbufControl(m_MilOverlayImage, M_MODIFIED, M_DEFAULT); } #endif // Now that overlay buffer is correctly prepared, we can show it [CALL TO MIL] MdispControl(m_MilDisplay, M_OVERLAY_SHOW, M_ENABLE); // Overlay is now initialized m_isOverlayInitialized = true; } } } void MdispQtView::RestrictCursor(bool on) { ///////////////////////////////////////////////////////////////////////// // MIL: Write code that will be executed when 'Restrict Cursor' menu item is clicked ///////////////////////////////////////////////////////////////////////// if(m_MilDisplay) { MdispControl(m_MilDisplay, M_RESTRICT_CURSOR,on?M_ENABLE:M_DISABLE); // Check if control worked correctly before considering it successful [CALL TO MIL] MdispInquire(m_MilDisplay, M_RESTRICT_CURSOR, &amp;m_currentRestrictCursor); } } bool MdispQtView::newDoc() { // Set buffer attributes if(((MdispQtApp*)qApp)-&gt;m_numberOfDigitizer) { m_bufferAttributes=M_IMAGE+M_DISP+M_GRAB+M_PROC; m_bufferAttributes=M_IMAGE+M_DISP+M_GRAB+M_PROC; m_imageSizeX = ((MdispQtApp*)qApp)-&gt;m_digitizerSizeX; m_imageSizeY = ((MdispQtApp*)qApp)-&gt;m_digitizerSizeY; m_NbBands = ((MdispQtApp*)qApp)-&gt;m_digitizerNbBands; // Allocate a buffer [CALL TO MIL] MbufAllocColor(((MdispQtApp*)qApp)-&gt;m_MilSystem, m_NbBands, m_imageSizeX, m_imageSizeY, 8+M_UNSIGNED, m_bufferAttributes, &amp;m_MilImage); // Clear the buffer [CALL TO MIL] MbufClear(m_MilImage,M_COLOR_BLACK); } else { MbufImport(IMAGE_FILE,M_DEFAULT,M_RESTORE,((MdispQtApp*)qApp)-&gt;m_MilSystem,&amp;m_MilImage); // Set SizeX and SizeY variable to the size of the buffer [CALL TO MIL] if (m_MilImage) { m_imageSizeX = MbufInquire(m_MilImage, M_SIZE_X, M_NULL); m_imageSizeY = MbufInquire(m_MilImage, M_SIZE_Y, M_NULL); m_NbBands = MbufInquire(m_MilImage, M_SIZE_BAND, M_NULL); } } UpdateContentSize(); // If not able to allocate a buffer, do not create a new document if(!m_MilImage) return false; Initialize(); return true; } bool MdispQtView::load( const QString&amp; fn ) { //Import image in buffer [CALL TO MIL] MIL_TEXT_CHAR *txt = new MIL_TEXT_CHAR[ fn.length() + 1 ]; #if M_MIL_USE_LINUX QByteArray ba = fn.toLocal8Bit(); const char *tmp = ba.data(); strncpy( txt, tmp, fn.length() ); #else fn.toWCharArray(txt); #endif txt[ fn.length() ] = 0; MbufImport(txt,M_DEFAULT,M_RESTORE,((MdispQtApp*)qApp)-&gt;m_MilSystem,&amp;m_MilImage); delete[] txt; // Set SizeX and SizeY variable to the size of the buffer [CALL TO MIL] if (m_MilImage) { Initialize(); m_imageSizeX = MbufInquire(m_MilImage,M_SIZE_X,M_NULL); m_imageSizeY = MbufInquire(m_MilImage,M_SIZE_Y,M_NULL); UpdateContentSize(); m_Filename = QFileInfo(fn).fileName(); m_FilenameValid = true; emit filenameChanged(m_Filename); return true; } else { return false; } } bool MdispQtView::save() { if ( !m_FilenameValid ) { return saveAs(); } bool SaveStatus; // Halt the grab if the current view has it [CALL TO MIL] if((((MdispQtApp*)qApp)-&gt;m_pGrabView == this) &amp;&amp; (((MdispQtApp*)qApp)-&gt;m_isGrabStarted == true)) MdigHalt(((MdispQtApp*)qApp)-&gt;m_MilDigitizer); // Save the current buffer [CALL TO MIL] #if !UNICODE QByteArray ba = m_Filename.toLocal8Bit(); const char *tmp = ba.data(); #else const wchar_t *tmp = (const wchar_t *) m_Filename.utf16(); #endif MbufExport(tmp, M_USE_EXTENSION, m_MilImage); // Verify if save operation was successful [CALL TO MIL] SaveStatus = (MappGetError(M_DEFAULT, M_CURRENT,M_NULL) == M_NULL_ERROR); // Document has been saved if (!((((MdispQtApp*)qApp)-&gt;m_pGrabView == this) &amp;&amp; (((MdispQtApp*)qApp)-&gt;m_isGrabStarted == true))) m_Modified = false; // Restart the grab if the current view had it [CALL TO MIL] if((((MdispQtApp*)qApp)-&gt;m_pGrabView == this) &amp;&amp; (((MdispQtApp*)qApp)-&gt;m_isGrabStarted == true)) MdigGrabContinuous(((MdispQtApp*)qApp)-&gt;m_MilDigitizer, m_MilImage); return SaveStatus; } bool MdispQtView::saveAs() { QString showName = strippedName(m_Filename); QString fn = QFileDialog::getSaveFileName(this, tr(\"Save File\"), tr(\"%1\").arg(showName), tr(\"Image Files (*.mim *.bmp *.tif *.jpg *.jp2 *.raw *.png)\")); if ( !fn.isEmpty() ) { m_Filename = fn; if (!m_Filename.contains('.')) { m_Filename+=\".mim\"; } m_FilenameValid = true; emit filenameChanged(strippedName(m_Filename)); return save(); } else { return false; } } const QString&amp; MdispQtView::filename() const { return m_Filename; } void MdispQtView::closeEvent( QCloseEvent* e ) { if ( IsModified() ) { switch ( QMessageBox::warning( this, tr(\"MdispQt Message\"), tr(\"Save changes to %1?\").arg(m_Filename), QMessageBox::Yes | QMessageBox::Default, QMessageBox::No, QMessageBox::Cancel | QMessageBox::Escape ) ) { case QMessageBox::Yes: { if ( save() ) { RemoveFromDisplay(); e-&gt;accept(); } else e-&gt;ignore(); } break; case QMessageBox::No: { RemoveFromDisplay(); e-&gt;accept(); } break; default: e-&gt;ignore(); break; } } else { RemoveFromDisplay(); e-&gt;accept(); } } QSize MdispQtView::sizeHint() const { return QSize(width(), height()); } void MdispQtView::UpdateContentSize() { int sizeX, sizeY; if(m_MilDisplay) { MIL_DOUBLE ZoomX =1.0, ZoomY =1.0; MdispInquire(m_MilDisplay, M_ZOOM_FACTOR_X, &amp;ZoomX); MdispInquire(m_MilDisplay, M_ZOOM_FACTOR_Y, &amp;ZoomY); if(ZoomX || ZoomY) { m_currentZoomFactorX = ZoomX; m_currentZoomFactorY = ZoomY; } } sizeX = int( m_imageSizeX * m_currentZoomFactorX ); sizeY = int( m_imageSizeY * m_currentZoomFactorY ); resize( sizeX, sizeY ); emit sizeChanged((long)(sizeX) , (long)(sizeY)); } void MdispQtView::UpdateMousePosition() { emit mousePositionChanged(m_LastMousePosition.m_DisplayPositionX, m_LastMousePosition.m_DisplayPositionY, m_LastMousePosition.m_BufferPositionX, m_LastMousePosition.m_BufferPositionY); // Reset mouse position m_LastMousePosition.Set(M_INVALID, M_INVALID, M_INVALID, M_INVALID); } void MdispQtView::customEvent(QEvent* e) { if (e-&gt;type() == QEvent::User +8) { MilMouseEvent* re = (MilMouseEvent*)e; MOUSEPOSITION Pos = re-&gt;MousePostion(); emit mousePositionChanged(Pos.m_DisplayPositionX, Pos.m_DisplayPositionY, Pos.m_BufferPositionX, Pos.m_BufferPositionY); // Reset mouse position m_LastMousePosition.Set(M_INVALID, M_INVALID, M_INVALID, M_INVALID); } } void MdispQtView::SelectWindow() { //Select the buffer from its display object and given window [CALL TO MIL] if(m_MilDisplay &amp;&amp; m_MilImage) { #if M_MIL_USE_LINUX XColor xcolor,exact; if (getenv(\"QT_XCB_NO_XI2_MOUSE\")) { XWindowAttributes attr; XGetWindowAttributes(QX11Info::display(),winId(),&amp;attr); // Do not select mouse event, it will be done by the MIL Display XSelectInput(QX11Info::display(),winId(), attr.your_event_mask &amp; NON_MOUSE_MASK); } XSetWindowBackground(QX11Info::display(), winId(), WhitePixel(QX11Info::display(),0)); m_GC = XCreateGC(QX11Info::display(), winId(), 0, 0); XAllocNamedColor(QX11Info::display(),DefaultColormap(QX11Info::display(),0),\"magenta\", &amp;xcolor,&amp;exact); XSetForeground(QX11Info::display(),m_GC, xcolor.pixel); XFlush(QX11Info::display()); XSync(QX11Info::display(),False); #endif MdispSelectWindow(m_MilDisplay, m_MilImage, (MIL_WINDOW_HANDLE)(m_isWindowed?winId():0)); } } #if (M_MIL_USE_LINUX &amp;&amp; !STATIC_QT5) || (M_MIL_USE_WINDOWS &amp;&amp; STATIC_QT5) #include \"moc_mdispqtview.cpp\" #endif ",
      "wordCount": 3487
    }
  ]
}]
[{
  "id": "Example_PlaceHolder_ID",
  "version": "2024020714",
  "title": "Example_PlaceHolder_Title",
  "wordCount": 0,
  "subEntries": [
    {
      "id": "Examples_Processing_DifferenceAnalysis_SimpleDefectDetection_CPP_defectdetectionexample_cpp",
      "version": "2024020714",
      "title": "defectdetectionexample.cpp",
      "location": "Sample Code from MIL Examples",
      "text": " Top //*************************************************************************************** // // File name: defectdetectionexample.cpp // Location: See Matrox Example Launcher in the MIL Control Center // // // Synopsis: This file contains the implementation of the CDefectDetectionExamplMngr class // that handles all the aspects of the defect detection example except the // processing part. // // Copyright (C) Matrox Electronic Systems Ltd., 1992-2024. // All Rights Reserved #include &lt;mil.h&gt; #include \"defectdetectionprocfunc.h\" #include \"defectdetectionexample.h\" //***************************************************************************** // Constants. //***************************************************************************** static const MIL_INT WINDOW_TITLE_HEIGHT = 60; static const MIL_INT IMAGE_SEPARATION_X = 30; static const MIL_INT TARGET_IMAGE_SEPARATION_Y = 30; static const MIL_DOUBLE MODEL_OFFSET_X = M_DEFAULT; static const MIL_DOUBLE MODEL_OFFSET_Y = M_DEFAULT; static const MIL_DOUBLE MODEL_SIZE_X = M_DEFAULT; static const MIL_DOUBLE MODEL_SIZE_Y = M_DEFAULT; static const MIL_INT HIST_BORDER = WINDOW_TITLE_HEIGHT; static const MIL_INT DEFECT_SIZE = 5; static const MIL_INT CLEAN_MORPH_SIZE = 1; static const MIL_DOUBLE GRADIENT_MASK_SMOOTHNESS = 50; static const MIL_DOUBLE TRIANGLE_LOWER_CUTOFF = 2; static const MIL_DOUBLE TRIANGLE_UPPER_CUTOFF = 255; static const MIL_DOUBLE BIN_CUMULATIVE_VALUE = 95.0; static const MIL_DOUBLE FIXED_DIFF_THRESHOLD = 10; static const MIL_DOUBLE NORMAL_VARIATIONS = 20; //***************************************************************************** // Constructor. Allocates MIL application, system and display. //***************************************************************************** CDefectDetectionExampleMngr::CDefectDetectionExampleMngr(MIL_CONST_TEXT_PTR SystemDescriptor) : m_MilApplication (M_NULL), m_MilSystem (M_NULL), m_MilDisplay (M_NULL), m_MilDisplayImage (M_NULL), m_MilGraList (M_NULL), m_MilGraContextTemplate (M_NULL), m_MilGraContextTarget (M_NULL), m_MilGraContextWarpedTarget (M_NULL), m_MilGraContextDifference (M_NULL), m_MilGraContextInspection (M_NULL), m_MilHistDisplay (M_NULL), m_MilHistDisplayImage (M_NULL), m_MilHistDispGraphicList (M_NULL), m_MilHistResult (M_NULL), m_MilDispTemplateImage (M_NULL), m_MilTemplateImage (M_NULL), m_MilTargetImage (M_NULL), m_MilWarpedTargetImage (M_NULL), m_MilDifferenceImage (M_NULL), m_MilInspectionImage (M_NULL), m_MilTemplateGradientMask (M_NULL), m_MilTemplateLumImage (M_NULL), m_MilTargetLumImage (M_NULL), m_MilDifferenceGrayImage (M_NULL), m_MilStructElement (M_NULL), m_MilModContext (M_NULL), m_MilModResult (M_NULL), m_MilBlobResult (M_NULL), m_BlobDrawLabel (M_NULL), m_MilBlobContext (M_NULL), m_MilFixturingOffset (M_NULL), m_TemplateSizeX (0), m_TemplateSizeY (0), m_DiffMethod (enAbsoluteDiff), m_BinMethod (enBiModal), m_OverlayTransparentColor (0), m_IsInteractive (false), m_ImageSpacing (IMAGE_SEPARATION_X), m_ModOccDrawStartIndex (0) { // Allocate application. MappAlloc(M_NULL, M_DEFAULT, &amp;m_MilApplication); // Allocate system (SystemDescriptor depends on subclass). MsysAlloc(M_DEFAULT, SystemDescriptor, M_DEFAULT, M_DEFAULT, &amp;m_MilSystem); // Allocate display. Set it to auto scale. MdispAlloc(m_MilSystem, M_DEFAULT, MIL_TEXT(\"M_DEFAULT\"), M_WINDOWED, &amp;m_MilDisplay); MdispControl(m_MilDisplay, M_SCALE_DISPLAY, M_ENABLE); // Allocate a graphic list and associate it with the display. MgraAllocList(m_MilSystem, M_DEFAULT, &amp;m_MilGraList); MdispControl(m_MilDisplay, M_ASSOCIATED_GRAPHIC_LIST_ID, m_MilGraList); // Allocate the histogram displays. MdispAlloc(m_MilSystem, M_DEFAULT, MIL_TEXT(\"M_DEFAULT\"), M_WINDOWED, &amp;m_MilHistDisplay); // Allocate the histogram display graphic list and image and initialize the histogram. MbufAlloc2d(m_MilSystem, 256 + 2*HIST_BORDER, 256 + 2*HIST_BORDER, 8+M_UNSIGNED, M_IMAGE+M_DISP, &amp;m_MilHistDisplayImage); MbufClear(m_MilHistDisplayImage, 0); MgraAllocList(m_MilSystem, M_DEFAULT, &amp;m_MilHistDispGraphicList); InitHistogram(); // Associate the graphic list to the display. MdispControl(m_MilHistDisplay, M_ASSOCIATED_GRAPHIC_LIST_ID, m_MilHistDispGraphicList); // Allocate an histogram result buffer. MimAllocResult(m_MilSystem, 256, M_HIST_LIST, &amp;m_MilHistResult); // Allocate structuring element. MbufAlloc2d(m_MilSystem, DEFECT_SIZE + 1, DEFECT_SIZE + 1, 32+M_UNSIGNED, M_STRUCT_ELEMENT, &amp;m_MilStructElement); MbufClear(m_MilStructElement, 0); // Allocate Model Finder. MmodAlloc(m_MilSystem, M_GEOMETRIC, M_DEFAULT, &amp;m_MilModContext); MmodAllocResult(m_MilSystem, M_DEFAULT, &amp;m_MilModResult); // Allocate Blob. MblobAllocResult(m_MilSystem, M_DEFAULT, M_DEFAULT, &amp;m_MilBlobResult); MblobAlloc(m_MilSystem, M_DEFAULT, M_DEFAULT, &amp;m_MilBlobContext);; // Allocate a calibration fixture. McalAlloc(m_MilSystem, M_FIXTURING_OFFSET, M_DEFAULT, &amp;m_MilFixturingOffset); } //***************************************************************************** // Destructor, free all MIL objects. //***************************************************************************** CDefectDetectionExampleMngr::~CDefectDetectionExampleMngr() { // Free the display images. FreeDisplayImages(); // Free the work images. FreeWorkImages(); // Free the structuring element. if(m_MilStructElement != M_NULL) MbufFree(m_MilStructElement); // Free Model Finder. if(m_MilModContext != M_NULL) { MmodFree(m_MilModContext); MmodFree(m_MilModResult); } // Free Blob. if(m_MilBlobResult != M_NULL) { MblobFree(m_MilBlobResult); MblobFree(m_MilBlobContext); } // Free the calibration fixture. if(m_MilFixturingOffset != M_NULL) McalFree(m_MilFixturingOffset); // Free the histogram. if(m_MilHistResult) MimFree(m_MilHistResult); // Free the histogram graphic list if(m_MilHistDispGraphicList != M_NULL) MgraFree(m_MilHistDispGraphicList); // Free the graphic list. if(m_MilGraList != M_NULL) MgraFree(m_MilGraList); //Free the histogram display selected image if(m_MilHistDisplayImage != M_NULL) MbufFree(m_MilHistDisplayImage); // Free the histogram display. if(m_MilHistDisplay != M_NULL) MdispFree(m_MilHistDisplay); // Free the display. if (m_MilDisplay != M_NULL) MdispFree(m_MilDisplay); // Free the system. if (m_MilSystem != M_NULL) MsysFree(m_MilSystem); // Free the application. if (m_MilApplication != M_NULL) MappFree(m_MilApplication); } //***************************************************************************** // Free the display associated images. //***************************************************************************** void CDefectDetectionExampleMngr::FreeDisplayImages() { if (m_MilDisplayImage != M_NULL) { MbufFree(m_MilDispTemplateImage); MbufFree(m_MilTargetImage); MbufFree(m_MilWarpedTargetImage); MbufFree(m_MilDifferenceImage); MbufFree(m_MilInspectionImage); MbufFree(m_MilTargetLumImage); MgraFree(m_MilGraContextTemplate); MgraFree(m_MilGraContextTarget); MgraFree(m_MilGraContextWarpedTarget); MgraFree(m_MilGraContextDifference); MgraFree(m_MilGraContextInspection); MbufFree(m_MilDisplayImage); } } //***************************************************************************** // Free the work images. //***************************************************************************** void CDefectDetectionExampleMngr::FreeWorkImages() { if (m_MilTemplateGradientMask != M_NULL) { MbufFree(m_MilTemplateGradientMask); MbufFree(m_MilTemplateLumGradientMask); MbufFree(m_MilTemplateLumImage); MbufFree(m_MilDifferenceGrayImage); MbufFree(m_MilTemplateImage); } } //***************************************************************************** // Load the template. Load the image, create a luminance version and defines // a model. //***************************************************************************** bool CDefectDetectionExampleMngr::LoadTemplate(MIL_CONST_TEXT_PTR TemplateImagePath) { bool LoadStatus = false; // Free the work images. FreeWorkImages(); if(TemplateImagePath == M_INTERACTIVE) MosPrintf(MIL_TEXT(\"Please choose a template image.\\n\\n\")); // Restore the template user image. MappControl(M_ERROR, M_PRINT_DISABLE); MIL_ID MilUserTemplate = MbufRestore(TemplateImagePath, m_MilSystem, M_NULL); MappControl(M_ERROR, M_PRINT_ENABLE); if(MilUserTemplate != M_NULL) { // Get the size of the user template. MbufInquire(MilUserTemplate, M_SIZE_X, &amp;m_TemplateSizeX); MbufInquire(MilUserTemplate, M_SIZE_Y, &amp;m_TemplateSizeY); if (m_TemplateSizeX &gt;= 16 &amp;&amp; m_TemplateSizeX &lt;= 1024 &amp;&amp; m_TemplateSizeY &gt;= 16 &amp;&amp; m_TemplateSizeY &lt;= 1024) { // Allocate the color template image and copy the user image. MbufAllocColor(m_MilSystem, 3, m_TemplateSizeX, m_TemplateSizeY, 8 + M_UNSIGNED, M_IMAGE + M_PROC, &amp;m_MilTemplateImage); MbufCopy(MilUserTemplate, m_MilTemplateImage); // Allocate the work images. MbufAlloc2d(m_MilSystem, m_TemplateSizeX, m_TemplateSizeY, 8 + M_UNSIGNED, M_IMAGE + M_PROC, &amp;m_MilDifferenceGrayImage); // Create the luminance version of the template. CreateLuminanceImage(m_MilTemplateImage, m_TemplateSizeX, m_TemplateSizeY, &amp;m_MilTemplateLumImage); // Create the gradient mask. CreateGradientMaskImage(m_MilTemplateImage, m_MilTemplateLumImage, GRADIENT_MASK_SMOOTHNESS, &amp;m_MilTemplateGradientMask, &amp;m_MilTemplateLumGradientMask); // Define the model from the template image. LoadStatus = DefineModelAndFixture(m_MilTemplateLumImage, m_MilModContext, m_MilFixturingOffset, MODEL_OFFSET_X, MODEL_OFFSET_Y, MODEL_SIZE_X, MODEL_SIZE_Y); } else { MosPrintf(MIL_TEXT(\"Unable to create model from the template image.\\n\") MIL_TEXT(\"The template image sizes must be between 16 and 1024.\\n\\n\")); } // Free the user template. MbufFree(MilUserTemplate); } else MosPrintf(MIL_TEXT(\"Unable to load template image.\\n\\n\")); return LoadStatus; } //***************************************************************************** // Initialize the example with the target image. Sets the display, creates a // luminance image of the target and calibrates the warped target with a uniform // calibration. //***************************************************************************** bool CDefectDetectionExampleMngr::InitializeExample(MIL_CONST_TEXT_PTR TargetImagePath, DifferenceExtractionMethod DiffMethod, BinarizationMethod BinMethod) { // Initialize the methods use. m_DiffMethod = DiffMethod; m_BinMethod = BinMethod; if(TargetImagePath == M_INTERACTIVE) MosPrintf(MIL_TEXT(\"Please choose a target image.\\n\\n\")); // Restore the target user image. MappControl(M_ERROR, M_PRINT_DISABLE); MIL_ID MilUserTarget = MbufRestore(TargetImagePath, m_MilSystem, M_NULL); MappControl(M_ERROR, M_PRINT_ENABLE); if(MilUserTarget != M_NULL) { // Get the size of the user target. MIL_INT TargetSizeX = MbufInquire(MilUserTarget, M_SIZE_X, M_NULL); MIL_INT TargetSizeY = MbufInquire(MilUserTarget, M_SIZE_Y, M_NULL); // Reset the display. ResetDisplay(TargetSizeX, TargetSizeY); // Copy the template image in the display. MbufCopy(m_MilTemplateImage, m_MilDispTemplateImage); // Copy the target image. MbufCopy(MilUserTarget, m_MilTargetImage); // Free the user target. MbufFree(MilUserTarget); // Create the luminance version of the target. Free it if it was allocated. CreateLuminanceImage(m_MilTargetImage, TargetSizeX, TargetSizeY, &amp;m_MilTargetLumImage); // Associate a uniform calibration to the warped target image. McalUniform(m_MilWarpedTargetImage, 0, 0, 1, 1, 0, M_DEFAULT); // Show the template coordinate and model information. ShowTargetAndTemplate(TargetImagePath); return true; } else { // Print error message. MosPrintf(MIL_TEXT(\"Unable to load target image.\\n\\n\")); return false; } } //***************************************************************************** // Main running function of the example. //***************************************************************************** void CDefectDetectionExampleMngr::Run(MIL_CONST_TEXT_PTR CaseInformationText) { // 1. Get the number of occurrences. m_NbOccurences = FindModel(m_MilModContext, m_MilTargetLumImage, m_MilModResult); if(m_NbOccurences &gt; 0) { // Show the occurrences found in the display. ShowAllOccurrences(); for(MIL_INT OccurrenceIdx = 0; OccurrenceIdx &lt; m_NbOccurences; OccurrenceIdx++) { // Clear the inspection image and of the difference image. ClearDefectDetection(); // 2. Align the target on the template based on the Model Finder result AlignImageBasedOnFixture(m_MilTargetImage, m_MilWarpedTargetImage, m_MilFixturingOffset, m_MilModResult, M_RESULT_MOD, OccurrenceIdx); // Show the warped occurrence in the target display. ShowWarpedOccurrence(OccurrenceIdx); // Set the initial methods. DifferenceExtractionMethod DiffMethod = m_DiffMethod; BinarizationMethod BinMethod = m_BinMethod; // Print the case information MosPrintf(MIL_TEXT(\"%s\\n\\n\"), CaseInformationText); m_ChangeDiff = true; m_ChangeBin = true; do { // Update the extracted differences if necessary. if(m_ChangeDiff) { // 3. Extract the differences. ExtractDifferences(m_MilTemplateImage, m_MilTemplateLumImage, m_MilTemplateGradientMask, m_MilTemplateLumGradientMask, m_MilWarpedTargetImage, m_MilDifferenceGrayImage, m_MilStructElement, DiffMethod); // Update the binarization if we have changed the difference image. m_ChangeBin = true; } // Update the binarization if necessary. if(m_ChangeBin) { // 4. Extract the defects. m_BinValue = ExtractDefects(m_MilDifferenceGrayImage, m_MilBlobResult, m_MilBlobContext, TRIANGLE_LOWER_CUTOFF, TRIANGLE_UPPER_CUTOFF, BIN_CUMULATIVE_VALUE, NORMAL_VARIATIONS, FIXED_DIFF_THRESHOLD, CLEAN_MORPH_SIZE, BinMethod); } // Show the defect detection. ShowDefectDetection(); // Show the histogram. ShowHistogram(); m_ChangeBin = false; m_ChangeDiff = false; }while(AskForMethod(DiffMethod, BinMethod)); //Remove the histogram MdispSelect(m_MilHistDisplay, M_NULL); } } else { MosPrintf(MIL_TEXT(\"No occurrence of the model were found in the target image\\n\") MIL_TEXT(\"Press any key to continue.\\n\\n\")); MosGetch(); } } //***************************************************************************** // Resets the display. //***************************************************************************** void CDefectDetectionExampleMngr::ResetDisplay(MIL_INT TargetSizeX, MIL_INT TargetSizeY) { // Compute the offsets and sizes of the different childs. MIL_INT InspectionChildOffsetX = 4 * IMAGE_SEPARATION_X + 3* m_TemplateSizeX; MIL_INT DispSizeX, TargetChildOffsetX; if(InspectionChildOffsetX + m_TemplateSizeX &gt; TargetSizeX + IMAGE_SEPARATION_X) { DispSizeX = InspectionChildOffsetX + m_TemplateSizeX + IMAGE_SEPARATION_X; TargetChildOffsetX = (DispSizeX - TargetSizeX)/2; m_ImageSpacing = IMAGE_SEPARATION_X; } else { DispSizeX = TargetSizeX + 2 * IMAGE_SEPARATION_X; TargetChildOffsetX = IMAGE_SEPARATION_X; m_ImageSpacing = (DispSizeX - 4 * m_TemplateSizeX)/5; } MIL_INT WarpedChildOffsetX = 2 * m_ImageSpacing + m_TemplateSizeX; MIL_INT DifferenceChildOffsetX = WarpedChildOffsetX + m_ImageSpacing + m_TemplateSizeX; InspectionChildOffsetX = DifferenceChildOffsetX + m_ImageSpacing + m_TemplateSizeX; MIL_INT TargetChildOffsetY = 3 * WINDOW_TITLE_HEIGHT + m_TemplateSizeY + TARGET_IMAGE_SEPARATION_Y; MIL_INT DispSizeY = TargetChildOffsetY + TargetSizeY + IMAGE_SEPARATION_X; // Free the displayed images. FreeDisplayImages(); // Clear the graphic list. MgraClear(M_DEFAULT, m_MilGraList); // Allocate the display image. MbufAllocColor(m_MilSystem, 3, DispSizeX, DispSizeY, 8+M_UNSIGNED, M_IMAGE+M_PROC+M_DISP, &amp;m_MilDisplayImage); // Allocate the works images that are childs of the display. MbufChild2d(m_MilDisplayImage, m_ImageSpacing, WINDOW_TITLE_HEIGHT, m_TemplateSizeX, m_TemplateSizeY, &amp;m_MilDispTemplateImage); MbufChild2d(m_MilDisplayImage, TargetChildOffsetX, TargetChildOffsetY, TargetSizeX, TargetSizeY, &amp;m_MilTargetImage); MbufChild2d(m_MilDisplayImage, WarpedChildOffsetX, WINDOW_TITLE_HEIGHT, m_TemplateSizeX, m_TemplateSizeY, &amp;m_MilWarpedTargetImage); MbufChild2d(m_MilDisplayImage, DifferenceChildOffsetX, WINDOW_TITLE_HEIGHT, m_TemplateSizeX, m_TemplateSizeY, &amp;m_MilDifferenceImage); MbufChild2d(m_MilDisplayImage, InspectionChildOffsetX, WINDOW_TITLE_HEIGHT, m_TemplateSizeX, m_TemplateSizeY, &amp;m_MilInspectionImage); // Clear the displayed image. MbufClear(m_MilDisplayImage, 0); // Select the image on the display. MdispSelect(m_MilDisplay, m_MilDisplayImage); // Allocate the graphic contexts of the childs of the overlay. MgraAlloc(m_MilSystem, &amp;m_MilGraContextTemplate); MgraControl(m_MilGraContextTemplate, M_DRAW_OFFSET_X, - (MIL_DOUBLE)m_ImageSpacing); MgraControl(m_MilGraContextTemplate, M_DRAW_OFFSET_Y, - WINDOW_TITLE_HEIGHT); MgraAlloc(m_MilSystem, &amp;m_MilGraContextTarget); MgraControl(m_MilGraContextTarget, M_DRAW_OFFSET_X, - (MIL_DOUBLE)TargetChildOffsetX); MgraControl(m_MilGraContextTarget, M_DRAW_OFFSET_Y, - (MIL_DOUBLE)TargetChildOffsetY); MgraAlloc(m_MilSystem, &amp;m_MilGraContextWarpedTarget); MgraControl(m_MilGraContextWarpedTarget, M_DRAW_OFFSET_X, - (MIL_DOUBLE)WarpedChildOffsetX); MgraControl(m_MilGraContextWarpedTarget, M_DRAW_OFFSET_Y, - WINDOW_TITLE_HEIGHT); MgraAlloc(m_MilSystem, &amp;m_MilGraContextDifference); MgraControl(m_MilGraContextDifference, M_DRAW_OFFSET_X, - (MIL_DOUBLE)DifferenceChildOffsetX); MgraControl(m_MilGraContextDifference, M_DRAW_OFFSET_Y, - WINDOW_TITLE_HEIGHT); MgraAlloc(m_MilSystem, &amp;m_MilGraContextInspection); MgraControl(m_MilGraContextInspection, M_DRAW_OFFSET_X, - (MIL_DOUBLE)InspectionChildOffsetX); MgraControl(m_MilGraContextInspection, M_DRAW_OFFSET_Y, - WINDOW_TITLE_HEIGHT); // Draw the display childs info. DrawDisplayChildInfo(m_MilGraContextTemplate , m_TemplateSizeX, m_TemplateSizeY, MIL_TEXT(\"Template Image\")); DrawDisplayChildInfo(m_MilGraContextTarget , TargetSizeX , TargetSizeY , MIL_TEXT(\"Target Image\")); DrawDisplayChildInfo(m_MilGraContextWarpedTarget, m_TemplateSizeX, m_TemplateSizeY, MIL_TEXT(\"Warped Target\")); DrawDisplayChildInfo(m_MilGraContextDifference , m_TemplateSizeX, m_TemplateSizeY, MIL_TEXT(\"Difference Image\")); DrawDisplayChildInfo(m_MilGraContextInspection , m_TemplateSizeX, m_TemplateSizeY, MIL_TEXT(\"Inspection Image\")); } //***************************************************************************** // Draw display child info. //***************************************************************************** void CDefectDetectionExampleMngr::DrawDisplayChildInfo(MIL_ID MilGraContext, MIL_INT ImageSizeX, MIL_INT ImageSizeY, MIL_CONST_TEXT_PTR ImageName) { // Set the text alignment and color of the graphic contexts. MgraControl(MilGraContext, M_TEXT_ALIGN_HORIZONTAL, M_CENTER); MgraControl(MilGraContext, M_TEXT_ALIGN_VERTICAL, M_BOTTOM); // Draw the names of the images over them. MgraControl(MilGraContext, M_COLOR, M_COLOR_CYAN); MgraText(MilGraContext, m_MilGraList, ImageSizeX/2, -WINDOW_TITLE_HEIGHT/2, ImageName); // Draw borders around the childs. MgraControl(MilGraContext, M_COLOR, M_COLOR_WHITE); MgraRectAngle(MilGraContext, m_MilGraList, ImageSizeX/2, ImageSizeY/2, ImageSizeX + m_ImageSpacing, ImageSizeY + WINDOW_TITLE_HEIGHT, 0, M_CENTER_AND_DIMENSION); } //***************************************************************************** // Create the luminance version of the source image. //***************************************************************************** void CDefectDetectionExampleMngr::CreateLuminanceImage(MIL_ID MilRGBSrc, MIL_INT SizeX, MIL_INT SizeY, MIL_ID *MilLumImagePtr) { MbufAlloc2d(m_MilSystem, SizeX, SizeY, 8+M_UNSIGNED, M_IMAGE+M_PROC, MilLumImagePtr); MimConvert(MilRGBSrc, *MilLumImagePtr, M_RGB_TO_L); } //***************************************************************************** // Displays the information of the template (model edges, coordinate system // and fixturing offset). //***************************************************************************** void CDefectDetectionExampleMngr::ShowTargetAndTemplate(MIL_CONST_TEXT_PTR TargetImagePath) { // Print intermediate info in the console. MIL_CONST_TEXT_PTR TargetImageName = GetFileName(TargetImagePath); MosPrintf(MIL_TEXT(\"The target image %s has been loaded \\n\"), TargetImageName); MosPrintf(MIL_TEXT(\"and is shown in the display.\\n\")); MosPrintf(MIL_TEXT(\"Press any key to continue.\\n\\n\")); MosGetch(); // Show the fixture offset and the coordinate system on the template. MgraControl(m_MilGraContextTemplate, M_COLOR, M_COLOR_YELLOW); McalDraw(m_MilGraContextTemplate, m_MilFixturingOffset, m_MilGraList, M_DRAW_FIXTURING_OFFSET, M_DEFAULT, M_DEFAULT); MgraControl(m_MilGraContextTemplate, M_COLOR, M_COLOR_GREEN); McalDraw(m_MilGraContextTemplate, M_NULL, m_MilGraList, M_DRAW_PIXEL_COORDINATE_SYSTEM+M_DRAW_FRAME, M_DEFAULT, M_DEFAULT); // Show the model edges. MgraControl(m_MilGraContextTemplate, M_COLOR, M_COLOR_RED); MmodDraw(m_MilGraContextTemplate, m_MilModContext, m_MilGraList, M_DRAW_EDGES, M_DEFAULT, M_ORIGINAL); // Print intermediate info in the console. MosPrintf(MIL_TEXT(\"The model's edges and the fixturing offset are shown in the \\n\")); MosPrintf(MIL_TEXT(\"template display.\\n\")); MosPrintf(MIL_TEXT(\"Press any key to continue.\\n\\n\")); MosGetch(); } //***************************************************************************** // Displays all the occurrences of the model that were found. //***************************************************************************** void CDefectDetectionExampleMngr::ShowAllOccurrences() { MgraControl(m_MilGraContextTarget, M_COLOR, M_COLOR_GREEN); for(MIL_INT i = 0; i &lt; m_NbOccurences; i++) { MmodDraw(m_MilGraContextTarget, m_MilModResult, m_MilGraList, M_DRAW_BOX, i, M_DEFAULT); MmodDraw(m_MilGraContextTarget, m_MilModResult, m_MilGraList, M_DRAW_POSITION, i, M_DEFAULT); if(i == 0) m_ModOccDrawStartIndex = MgraInquireList(m_MilGraList, M_LIST, M_DEFAULT, M_NUMBER_OF_GRAPHICS, M_NULL) - 2; } // Print intermediate info in the console. MosPrintf(MIL_TEXT(\"The occurrences found in the target image are shown in the target\\n\")); MosPrintf(MIL_TEXT(\"display.\\n\")); MosPrintf(MIL_TEXT(\"Press any key to continue.\\n\\n\")); MosGetch(); } //***************************************************************************** // Displays the current warped occurrence. //***************************************************************************** void CDefectDetectionExampleMngr::ShowWarpedOccurrence(MIL_INT OccurrenceIdx) { // Set the color of the occurences. All are green except the one to process which is red. for(MIL_INT i = 0, GraphicIndex = m_ModOccDrawStartIndex; i &lt; m_NbOccurences; i++) { MgraControlList(m_MilGraList, M_GRAPHIC_INDEX(GraphicIndex++), M_DEFAULT, M_COLOR, i == OccurrenceIdx? M_COLOR_RED : M_COLOR_GREEN); MgraControlList(m_MilGraList, M_GRAPHIC_INDEX(GraphicIndex++), M_DEFAULT, M_COLOR, i == OccurrenceIdx? M_COLOR_RED : M_COLOR_GREEN); } // Show the coordinate system of the warped target and of the fixtured target. MgraControl(m_MilGraContextTarget, M_COLOR, M_COLOR_RED); McalDraw(m_MilGraContextTarget, m_MilTargetImage, m_MilGraList, M_DRAW_RELATIVE_COORDINATE_SYSTEM+M_DRAW_FRAME, M_DEFAULT, M_DEFAULT); MgraControl(m_MilGraContextWarpedTarget, M_COLOR, M_COLOR_RED); McalDraw(m_MilGraContextWarpedTarget, m_MilWarpedTargetImage, m_MilGraList, M_DRAW_RELATIVE_COORDINATE_SYSTEM+M_DRAW_FRAME, M_DEFAULT, M_DEFAULT); // Print intermediate info in the console. MosPrintf(MIL_TEXT(\"The occurrence %i has been warped.\\n\"), (int)OccurrenceIdx); MosPrintf(MIL_TEXT(\"Will now proceed with the defect detection.\\n\")); MosPrintf(MIL_TEXT(\"Press any key to continue.\\n\\n\")); MosGetch(); } //***************************************************************************** // Displays the defect detection. //***************************************************************************** void CDefectDetectionExampleMngr::ShowDefectDetection() { if(m_ChangeDiff) { // Update the displayed difference image and inspection image(the displayed images are the same). MbufCopy(m_MilDifferenceGrayImage, m_MilDifferenceImage); MbufCopy(m_MilDifferenceGrayImage, m_MilInspectionImage); } if(m_ChangeBin) { if(m_BlobDrawLabel) MgraControlList(m_MilGraList, M_GRAPHIC_LABEL(m_BlobDrawLabel), M_DEFAULT, M_DELETE, M_DEFAULT); MgraControl(m_MilGraContextInspection, M_COLOR, M_COLOR_RED); MblobDraw(m_MilGraContextInspection, m_MilBlobResult, m_MilGraList, M_DRAW_BLOBS, M_DEFAULT, M_DEFAULT); MgraInquireList(m_MilGraList, M_LIST, M_DEFAULT, M_LAST_LABEL, &amp;m_BlobDrawLabel); } } //***************************************************************************** // Clears the defect detection. //***************************************************************************** void CDefectDetectionExampleMngr::ClearDefectDetection() { // Get the number of graphics in the graphic list. MIL_INT NbGraphics = MgraInquireList(m_MilGraList, M_LIST, M_DEFAULT, M_NUMBER_OF_GRAPHICS, M_NULL); // Clear all the primitives related to the defect detection. for(MIL_INT GraphicIndex = m_ModOccDrawStartIndex + m_NbOccurences*2; GraphicIndex &lt; NbGraphics; GraphicIndex++) MgraControlList(m_MilGraList, M_GRAPHIC_INDEX(GraphicIndex), M_DEFAULT, M_DELETE, M_DEFAULT); // Reset the blob draw label. m_BlobDrawLabel = M_NULL; } //***************************************************************************** // Prints a given method choices. //***************************************************************************** void CDefectDetectionExampleMngr::PrintMethodChoices(MIL_CONST_TEXT_PTR MethodTypeTag, MIL_CONST_TEXT_PTR *MethodsTags, MIL_INT NbMethod, MIL_TEXT_CHAR StartChar) { MosPrintf(MIL_TEXT(\"%s method:\\n\"), MethodTypeTag); for(MIL_INT i=0; i&lt;NbMethod; i++) MosPrintf(MIL_TEXT(\" %c. %s\\n\"), StartChar+i, MethodsTags[i]); MosPrintf(MIL_TEXT(\"\\n\")); } //***************************************************************************** // Prints the current methods. //***************************************************************************** void CDefectDetectionExampleMngr::PrintCurrentMethods(MIL_TEXT_CHAR DiffStartChar, MIL_TEXT_CHAR BinStartChar, DifferenceExtractionMethod DiffMethod, BinarizationMethod BinMethod) { MosPrintf(MIL_TEXT(\"Current methods for difference extraction and binarization:\\n\")); MosPrintf(MIL_TEXT(\"%c. %s\\n\"), DiffStartChar+DiffMethod, DifferenceExtractionMethodsTags[DiffMethod]); MosPrintf(MIL_TEXT(\"%c. %s\\n\\n\"), BinStartChar+BinMethod, BinarizationMethodsTags[BinMethod]); } //***************************************************************************** // Ask the user for interactive method choice. //***************************************************************************** bool CDefectDetectionExampleMngr::AskForInteractive() { // Ask the user if he wants to run the example in interactive mode. MosPrintf(MIL_TEXT(\"Do you want to run the example in interactive mode? (Y or N)\\n\\n\")); do { switch(MosGetch()) { case 'y': case 'Y': m_IsInteractive = true; return true; case 'n': case 'N': return false; } } while(1); return true; } //***************************************************************************** // Ask the user for a method modification. //***************************************************************************** bool CDefectDetectionExampleMngr::AskForMethod(DifferenceExtractionMethod &amp;DiffMethod, BinarizationMethod &amp;BinMethod) { if(m_IsInteractive) { // Print the methods currently in use. PrintCurrentMethods(MIL_TEXT('1'), MIL_TEXT('A'), DiffMethod, BinMethod); // Print the methods choices. PrintMethodChoices(MIL_TEXT(\"Difference extraction\"), DifferenceExtractionMethodsTags, enNbDiffMethod, MIL_TEXT('1')); PrintMethodChoices(MIL_TEXT(\"Binarization\"), BinarizationMethodsTags, enNbBinMethod, MIL_TEXT('A')); MosPrintf(MIL_TEXT(\"Other:\\n\")); MosPrintf(MIL_TEXT(\" Q. Continue\\n\\n\")); MosPrintf(MIL_TEXT(\"Your choice : \")); MIL_TEXT_CHAR Choice; while(!m_ChangeDiff &amp;&amp; !m_ChangeBin) { // Get the user's choice. Choice = (MIL_TEXT_CHAR)MosGetch(); switch(Choice) { case '1': m_ChangeDiff = true; DiffMethod = enAbsoluteDiff; break; case '2': m_ChangeDiff = true; DiffMethod = enColDistance; break; case '3': m_ChangeDiff = true; DiffMethod = enBottomHat; break; case '4': m_ChangeDiff = true; DiffMethod = enTopHat; break; case 'a': case 'A': m_ChangeBin = true; BinMethod = enBiModal; break; case 'b': case 'B': m_ChangeBin = true; BinMethod = enTriangleBisection; break; case 'c': case 'C': m_ChangeBin = true; BinMethod = enCumulHistPercentage; break; case 'd': case 'D': m_ChangeBin = true; BinMethod = enFixed; break; case 'q': case 'Q': MosPrintf(MIL_TEXT(\"Q. Continue\\n\\n\")); return false; default: break; } } if(m_ChangeDiff) MosPrintf(MIL_TEXT(\"%c. %s\\n\\n\"), Choice, DifferenceExtractionMethodsTags[DiffMethod]); else if(m_ChangeBin) MosPrintf(MIL_TEXT(\"%c. %s\\n\\n\"), Choice, BinarizationMethodsTags[BinMethod]); return true; } else { MosPrintf(MIL_TEXT(\"Press any key to continue.\\n\\n\")); MosGetch(); return false; } } //***************************************************************************** // Draws the histogram of the image //***************************************************************************** void CDefectDetectionExampleMngr::ShowHistogram() { // Calculate the histogram. MimHistogram(m_MilDifferenceGrayImage, m_MilHistResult); // Get the results of the histogram. MIL_INT Histogram[256]; MimGetResult(m_MilHistResult, M_VALUE+M_TYPE_MIL_INT, Histogram); // Get the maximum value of the histogram. MIL_INT MaxHistValue = -MIL_INT_MAX; for(MIL_INT i = ((MIL_INT) TRIANGLE_LOWER_CUTOFF); i &lt; 256; i++) MaxHistValue = Histogram[i] &gt; MaxHistValue ? Histogram[i] : MaxHistValue; if(MaxHistValue &lt; 1) { MaxHistValue = 1; } // Calculate the pixel scale. MIL_DOUBLE YPixelScale = 256.0 / MaxHistValue; // Disable the graphic updates. MdispControl(m_MilHistDisplay, M_UPDATE_GRAPHIC_LIST, M_DISABLE); // Update the histogram bands. for(MIL_INT i = 0; i &lt; 256; i++) { MIL_DOUBLE Width = Histogram[i]*YPixelScale; MgraControlList(m_MilHistDispGraphicList, M_GRAPHIC_INDEX(i), M_DEFAULT, M_RECTANGLE_WIDTH, Width &gt; 256.0 ? 256.0 : Width); } // Update the threshold MgraControlList(m_MilHistDispGraphicList, M_GRAPHIC_INDEX(256), M_DEFAULT, M_POSITION_X, (MIL_DOUBLE) (HIST_BORDER + m_BinValue + 0.5)); // Update the threshold text MIL_TEXT_CHAR BinValueString[4]; MosSprintf(BinValueString, 4, MIL_TEXT(\"%i\"), (int)m_BinValue); MgraControlList(m_MilHistDispGraphicList, M_GRAPHIC_INDEX(260), M_DEFAULT, M_DELETE, M_DEFAULT); MgraControl(M_DEFAULT, M_TEXT_ALIGN_HORIZONTAL, M_CENTER); MgraControl(M_DEFAULT, M_TEXT_ALIGN_VERTICAL, M_TOP); MgraControl(M_DEFAULT, M_COLOR, M_COLOR_BLUE); MgraText(M_DEFAULT, m_MilHistDispGraphicList, HIST_BORDER + m_BinValue + 0.5, 256 + HIST_BORDER + 5, BinValueString); // Enable The graphic updates. MdispControl(m_MilHistDisplay, M_UPDATE_GRAPHIC_LIST, M_ENABLE); // Select the image on the display to show it MdispSelect(m_MilHistDisplay, m_MilHistDisplayImage); } //***************************************************************************** // Initialize the Histogram //***************************************************************************** void CDefectDetectionExampleMngr::InitHistogram() { // Create the histogram bands. MgraControl(M_DEFAULT, M_COLOR, M_COLOR_GREEN); for(MIL_INT i = 0; i &lt; 256; i++) MgraRectAngle(M_DEFAULT, m_MilHistDispGraphicList, i+HIST_BORDER, 256.0 + HIST_BORDER, 1, 1, 90, M_CORNER_AND_DIMENSION + M_FILLED); // Create the threshold MgraControl(M_DEFAULT, M_COLOR, M_COLOR_BLUE); MgraLine(M_DEFAULT, m_MilHistDispGraphicList, HIST_BORDER, HIST_BORDER/2, HIST_BORDER, 261.0+HIST_BORDER); // Create the axis on the histogram. MgraControl(M_DEFAULT, M_COLOR, M_COLOR_RED); MgraLine(M_DEFAULT, m_MilHistDispGraphicList, HIST_BORDER, 256.0 + HIST_BORDER, HIST_BORDER, HIST_BORDER/2); MgraLine(M_DEFAULT, m_MilHistDispGraphicList, HIST_BORDER, 256.0 + HIST_BORDER, 256.0 + 3*HIST_BORDER/2, 256.0 + HIST_BORDER); // Create the histogram title. MgraControl(M_DEFAULT, M_COLOR, M_COLOR_CYAN); MgraControl(M_DEFAULT, M_TEXT_ALIGN_HORIZONTAL, M_CENTER); MgraControl(M_DEFAULT, M_TEXT_ALIGN_VERTICAL, M_TOP); MgraText(M_DEFAULT, m_MilHistDispGraphicList, 128.0 + HIST_BORDER, 0, MIL_TEXT(\"Histogram\")); //Draw the threshold text MgraControl(M_DEFAULT, M_TEXT_ALIGN_HORIZONTAL, M_CENTER); MgraControl(M_DEFAULT, M_TEXT_ALIGN_VERTICAL, M_TOP); MgraText(M_DEFAULT, m_MilHistDispGraphicList, HIST_BORDER, 256.0 + HIST_BORDER + 5, MIL_TEXT(\"\")); } ",
      "wordCount": 2702
    },
    {
      "id": "Examples_Processing_DifferenceAnalysis_SimpleDefectDetection_CPP_defectdetectionprocfunc_cpp",
      "version": "2024020714",
      "title": "defectdetectionprocfunc.cpp",
      "location": "Sample Code from MIL Examples",
      "text": " Top //*************************************************************************************** // // File name: defectdetectionprocfunc.cpp // Location: See Matrox Example Launcher in the MIL Control Center // // // Synopsis: This file contains the processing functions declarations // that are used to perform some simple defect detection. // // Copyright (C) Matrox Electronic Systems Ltd., 1992-2024. // All Rights Reserved #include &lt;mil.h&gt; #include &lt;math.h&gt; #include \"defectdetectionprocfunc.h\" //***************************************************************************** // Remaps to an 8 bit image. //***************************************************************************** void Remap8BitImage(MIL_ID MilSrcImage, MIL_ID MilDestImage, MIL_INT StartIndex, MIL_INT EndIndex, MIL_DOUBLE MinValue, MIL_DOUBLE MaxValue) { // Work on the same system of the SrcBufferId. MIL_ID MilSystem = MbufInquire(MilSrcImage, M_OWNER_SYSTEM, M_NULL); // Alloc the LUT. MIL_ID MilLut = MbufAlloc1d(MilSystem, 256, 32+M_FLOAT, M_LUT, M_NULL); // Generate the ramp. MgenLutRamp(MilLut, 0, MinValue, StartIndex, MinValue); MgenLutRamp(MilLut, StartIndex, MinValue, EndIndex, MaxValue); MgenLutRamp(MilLut, EndIndex, MaxValue, 255, MaxValue); // Apply the mapping. MimLutMap(MilSrcImage, MilDestImage, MilLut); // Free the buffers. MbufFree(MilLut); } //***************************************************************************** // Creates a gradient mask. //***************************************************************************** void CreateGradientMaskImage(MIL_ID MilTemplateImage, MIL_ID MilTemplateLumImage, MIL_DOUBLE GradientSmoothness, MIL_ID *MilGradientMaskImagePtr, MIL_ID *MilGradientLumMaskImagePtr) { // Get the owner system of the template image. MIL_ID MilSystem = MbufInquire(MilTemplateLumImage, M_OWNER_SYSTEM, M_NULL); // Get the size of the template image. MIL_INT TemplateSizeX = MbufInquire(MilTemplateLumImage, M_SIZE_X, M_NULL); MIL_INT TemplateSizeY = MbufInquire(MilTemplateLumImage, M_SIZE_Y, M_NULL); // Allocate the gradient mask images. MIL_ID MilGradientMaskColorImage = MbufAllocColor(MilSystem, 3, TemplateSizeX, TemplateSizeY, 8+M_UNSIGNED, M_IMAGE+M_PROC, M_NULL); MIL_ID MilGradientLumMaskImage = MbufAlloc2d(MilSystem, TemplateSizeX, TemplateSizeY, 8+M_UNSIGNED, M_IMAGE+M_PROC, M_NULL); MIL_ID MilGradientMaskImage = MbufAlloc2d(MilSystem, TemplateSizeX, TemplateSizeY, 8+M_UNSIGNED, M_IMAGE+M_PROC, M_NULL); MIL_ID MilLinearFilterIIRContext = MimAlloc(MilSystem, M_LINEAR_FILTER_IIR_CONTEXT, M_DEFAULT, M_NULL); MimControl(MilLinearFilterIIRContext, M_FILTER_TYPE, M_SHEN); MimControl(MilLinearFilterIIRContext, M_FILTER_SMOOTHNESS, GradientSmoothness); MimControl(MilLinearFilterIIRContext, M_FILTER_RESPONSE_TYPE, M_STEP); // Create the luminance gradient mask. MimDifferential(MilLinearFilterIIRContext, MilTemplateLumImage, M_NULL, M_NULL, M_NULL, MilGradientLumMaskImage, M_NULL, M_DEFAULT, M_GRADIENT, M_DEFAULT); // Create the gradient mask of each band. MimDifferential(MilLinearFilterIIRContext, MilTemplateImage, M_NULL, M_NULL, M_NULL, MilGradientMaskColorImage, M_NULL, M_DEFAULT, M_GRADIENT, M_DEFAULT); MimFree(MilLinearFilterIIRContext); // Create the gradient mask total image. MIL_ID MilGradientTotal = MbufAlloc2d(MilSystem, TemplateSizeX, TemplateSizeY, 32+M_UNSIGNED, M_IMAGE+M_PROC, M_NULL); MIL_ID MilGradientSquare = MbufAlloc2d(MilSystem, TemplateSizeX, TemplateSizeY, 16+M_UNSIGNED, M_IMAGE+M_PROC, M_NULL); MbufClear(MilGradientTotal, 0); for(MIL_INT BandIdx = 0; BandIdx &lt; 3; BandIdx++) { MIL_ID MilGradientBand = MbufChildColor(MilGradientMaskColorImage, M_RED &lt;&lt; BandIdx, M_NULL); MimArith(MilGradientBand, M_NULL, MilGradientSquare, M_SQUARE); MimArith(MilGradientTotal, MilGradientSquare, MilGradientTotal, M_ADD); MbufFree(MilGradientBand); } // Get the square root of the total of the gradient. MimArith(MilGradientTotal, M_NULL, MilGradientMaskImage, M_SQUARE_ROOT); // Since the IIR filter maximum value of the IIR filter is 127, we stretch back the two buffers to 255. static const MIL_INT MaxColorGradient = (MIL_INT)sqrt(127.0*127.0*3.0); Remap8BitImage(MilGradientMaskImage, MilGradientMaskImage, 0, MaxColorGradient, 0, 255); Remap8BitImage(MilGradientLumMaskImage, MilGradientLumMaskImage, 0, 127, 0, 255); if(MilGradientMaskImagePtr != M_NULL) *MilGradientMaskImagePtr = MilGradientMaskImage; else MbufFree(MilGradientMaskImage); if(MilGradientLumMaskImagePtr != M_NULL) *MilGradientLumMaskImagePtr = MilGradientLumMaskImage; else MbufFree(MilGradientLumMaskImage); MbufFree(MilGradientTotal); MbufFree(MilGradientSquare); MbufFree(MilGradientMaskColorImage); } //***************************************************************************** // Defines the model and the fixturing offset. //***************************************************************************** bool DefineModelAndFixture(MIL_ID MilTemplateLumImage, MIL_ID MilModContext, MIL_ID MilFixturingOffset, MIL_DOUBLE ModelOffsetX, MIL_DOUBLE ModelOffsetY, MIL_DOUBLE ModelSizeX, MIL_DOUBLE ModelSizeY) { // Remove the model from the context if there is one if(MmodInquire(MilModContext, M_CONTEXT, M_NUMBER_MODELS + M_TYPE_MIL_INT, M_NULL)) MmodDefine(MilModContext, M_DELETE, M_ALL, M_DEFAULT, M_DEFAULT, M_DEFAULT, M_DEFAULT); // Define the model image from the template image. MmodDefine(MilModContext, M_IMAGE, MilTemplateLumImage, ModelOffsetX, ModelOffsetY, ModelSizeX, ModelSizeY); // Check if the model is not empty. MIL_INT NbModelEdges = MmodInquire(MilModContext, 0, M_NUMBER_OF_CHAINED_EDGELS, M_NULL); if (NbModelEdges == 0) { MosPrintf(MIL_TEXT(\"Invalid template image. The resulting model is empty.\\n\\n\")); return false; } // Set the number of models to find to M_ALL and preprocess. MmodControl(MilModContext, 0, M_NUMBER, M_ALL); MmodPreprocess(MilModContext, M_DEFAULT); // Learn the fixture offset from the model. McalFixture(M_NULL, MilFixturingOffset, M_LEARN_OFFSET, M_MODEL_MOD, MilModContext, 0, M_DEFAULT, M_DEFAULT, M_DEFAULT); return true; } //***************************************************************************** // Finds the model and returns the number of occurrences. //***************************************************************************** MIL_INT FindModel(MIL_ID MilModContext, MIL_ID MilTargetImage, MIL_ID MilModResult) { // Find the model in the target image. MmodFind(MilModContext, MilTargetImage, MilModResult); // Get the number of occurrences. MIL_INT NbOfOccurrences; MmodGetResult(MilModResult, M_GENERAL, M_NUMBER+M_TYPE_MIL_INT, &amp;NbOfOccurrences); return NbOfOccurrences; } //***************************************************************************** // Aligns the SrcImage in the destination image based on the fixturing info. //***************************************************************************** void AlignImageBasedOnFixture(MIL_ID MilSrcImage, MIL_ID MilDestImage, MIL_ID MilFixturingOffset, MIL_ID MilFixtureProvider, MIL_INT ResultType, MIL_INT OccurenceIdx) { // Fixture the current occurrence. McalFixture(MilSrcImage, MilFixturingOffset, M_MOVE_RELATIVE, ResultType, MilFixtureProvider, OccurenceIdx, M_DEFAULT, M_DEFAULT, M_DEFAULT); // Warp the occurrence in the inspection image. McalTransformImage(MilSrcImage, MilDestImage, M_DEFAULT, M_BILINEAR+M_OVERSCAN_CLEAR, M_DEFAULT, M_WARP_IMAGE+M_USE_DESTINATION_CALIBRATION); } //***************************************************************************** // Extracts the defects from the difference image. //***************************************************************************** MIL_INT ExtractDefects(MIL_ID MilDifferenceGrayImage, MIL_ID MilBlobResult, MIL_ID MilBlobContext, MIL_DOUBLE TriangleLowerCutoff, MIL_DOUBLE TriangleUpperCutoff, MIL_DOUBLE BinCumulativeValue, MIL_DOUBLE NormalVariation, MIL_DOUBLE FixedDiffThreshold, MIL_INT CleanMorphSize, const BinarizationMethod BinMethod) { // Get the owner system and the size of the difference image. MIL_ID MilSystem = MbufInquire(MilDifferenceGrayImage, M_OWNER_SYSTEM, M_NULL); MIL_INT ImageSizeX = MbufInquire(MilDifferenceGrayImage, M_SIZE_X, M_NULL); MIL_INT ImageSizeY = MbufInquire(MilDifferenceGrayImage, M_SIZE_Y, M_NULL); // Allocate the binary image. MIL_ID MilInspectionBinImage = MbufAlloc2d(MilSystem, ImageSizeX, ImageSizeY, 1+M_UNSIGNED, M_IMAGE+M_PROC, M_NULL); // Binarize the image. MIL_INT BinValue; switch(BinMethod) { case enCumulHistPercentage: BinValue = MimBinarize(MilDifferenceGrayImage, M_NULL, M_PERCENTILE_VALUE, BinCumulativeValue, M_NULL); break; case enTriangleBisection: NormalVariation = (MIL_DOUBLE) MimBinarize(MilDifferenceGrayImage, M_NULL, M_TRIANGLE_BISECTION_BRIGHT, TriangleLowerCutoff, TriangleUpperCutoff); case enFixed: BinValue = (MIL_INT) (((NormalVariation + FixedDiffThreshold) &gt; 255) ? 255 : (NormalVariation + FixedDiffThreshold)); break; case enBiModal: default: BinValue = MimBinarize(MilDifferenceGrayImage, M_NULL, M_BIMODAL, M_NULL, M_NULL); break; } MimBinarize(MilDifferenceGrayImage, MilInspectionBinImage, M_FIXED + M_GREATER_OR_EQUAL, (MIL_DOUBLE) BinValue, M_NULL); // Clean the binary image. MimOpen(MilInspectionBinImage, MilInspectionBinImage, CleanMorphSize, M_BINARY); // Calculate the blobs. MblobCalculate(MilBlobContext, MilInspectionBinImage, M_NULL, MilBlobResult); // Free the binary image. MbufFree(MilInspectionBinImage); return BinValue; } //***************************************************************************** // Extracts the differences. //***************************************************************************** void ExtractDifferences(MIL_ID MilTemplateImage, MIL_ID MilTemplateLumImage, MIL_ID MilTemplateGradientMask, MIL_ID MilTemplateLumGradientMask, MIL_ID MilWarpedTarget, MIL_ID MilDifferenceGrayImage, MIL_ID MilStructElement, const DifferenceExtractionMethod DiffExtractMethod) { // Get the owner system and the size of the difference image. MIL_ID MilSystem = MbufInquire(MilDifferenceGrayImage, M_OWNER_SYSTEM, M_NULL); MIL_INT ImageSizeX = MbufInquire(MilDifferenceGrayImage, M_SIZE_X, M_NULL); MIL_INT ImageSizeY = MbufInquire(MilDifferenceGrayImage, M_SIZE_Y, M_NULL); // Create the luminance version of the Warped target if the difference method is not the color distance. MIL_ID MilWarpedTargetLum = M_NULL; if(DiffExtractMethod != enColDistance) { if(MbufInquire(MilWarpedTarget, M_SIZE_BAND, M_NULL) == 3) { // Allocate the warped target luminance image. MbufAlloc2d(MilSystem, ImageSizeX, ImageSizeY, 8+M_UNSIGNED, M_IMAGE+M_PROC, &amp;MilWarpedTargetLum); // Get the luminance of the warped target. MimConvert(MilWarpedTarget, MilWarpedTargetLum, M_RGB_TO_L); } else MilWarpedTargetLum = MilWarpedTarget; } // Extract the differences. switch(DiffExtractMethod) { case enAbsoluteDiff: MimArith(MilTemplateLumImage, MilWarpedTargetLum, MilDifferenceGrayImage, M_SUB_ABS); break; case enColDistance: McolDistance(MilTemplateImage, MilWarpedTarget, MilDifferenceGrayImage, M_NULL, M_DEFAULT, M_EUCLIDEAN, M_NO_NORMALIZE, M_DEFAULT); break; case enTopHat: MimMorphic(MilWarpedTargetLum, MilDifferenceGrayImage, MilStructElement, M_TOP_HAT, 1, M_GRAYSCALE); break; case enBottomHat: default: MimMorphic(MilWarpedTargetLum, MilDifferenceGrayImage, MilStructElement, M_BOTTOM_HAT, 1, M_GRAYSCALE); break; } // Substract the gradient mask to prevent edge effect. MimArith(MilDifferenceGrayImage, DiffExtractMethod == enColDistance ? MilTemplateGradientMask : MilTemplateLumGradientMask, MilDifferenceGrayImage, M_SUB+M_SATURATION); if(MilWarpedTargetLum &amp;&amp; MilWarpedTargetLum != MilWarpedTarget) MbufFree(MilWarpedTargetLum); } ",
      "wordCount": 1003
    },
    {
      "id": "Examples_Processing_DifferenceAnalysis_SimpleDefectDetection_CPP_simpledefectdetection_cpp",
      "version": "2024020714",
      "title": "simpledefectdetection.cpp",
      "location": "Sample Code from MIL Examples",
      "text": " Top //***************************************************************************************/ // // File name: SimpleDefectDetection.cpp // Location: See Matrox Example Launcher in the MIL Control Center // // // Synopsis: This program contains an example of defect detection using Model Finder, // Color and some image processing primitives. // See the PrintHeader() function below for detailed description. // // Copyright (C) Matrox Electronic Systems Ltd., 1992-2024. // All Rights Reserved #include &lt;mil.h&gt; #include \"defectdetectionprocfunc.h\" #include \"defectdetectionexample.h\" //**************************************************************************** // Example description. //**************************************************************************** void PrintHeader() { MosPrintf(MIL_TEXT(\"[EXAMPLE NAME]\\n\")); MosPrintf(MIL_TEXT(\"SimpleDefectDetection\\n\\n\")); MosPrintf(MIL_TEXT(\"[SYNOPSIS]\\n\")); MosPrintf(MIL_TEXT(\"This example demontrates how to perform basic defect detection \\n\")); MosPrintf(MIL_TEXT(\"using various methods to extract the differences and to binarize \\n\")); MosPrintf(MIL_TEXT(\"them. The application uses MIL's fixturing capabilities in \\n\")); MosPrintf(MIL_TEXT(\"conjunction with Model Finder to align target occurences with the \\n\")); MosPrintf(MIL_TEXT(\"template image.\\n\\n\")); MosPrintf(MIL_TEXT(\"[MODULES USED]\\n\")); MosPrintf(MIL_TEXT(\"Modules used: Application, system, display, buffer, graphic, \\n\")); MosPrintf(MIL_TEXT(\"image processing, model finder, blob, color.\\n\\n\")); MosPrintf(MIL_TEXT(\"Press any key to continue.\\n\\n\")); MosGetch(); } //**************************************************************************** // Constants. //**************************************************************************** // Filenames. #define EXAMPLE_IMAGE_PATH M_IMAGE_PATH MIL_TEXT(\"SimpleDefectDetection/\") static const MIL_INT NB_IMAGES = 5; static MIL_CONST_TEXT_PTR TEMPLATE_IMAGE_FILENAME[NB_IMAGES] = { EXAMPLE_IMAGE_PATH MIL_TEXT(\"Template.mim\"), EXAMPLE_IMAGE_PATH MIL_TEXT(\"Template.mim\"), EXAMPLE_IMAGE_PATH MIL_TEXT(\"Template.mim\"), EXAMPLE_IMAGE_PATH MIL_TEXT(\"TemplateBin.mim\"), EXAMPLE_IMAGE_PATH MIL_TEXT(\"Template.mim\"), }; static MIL_CONST_TEXT_PTR TARGET_IMAGE_FILENAMES[NB_IMAGES] = { EXAMPLE_IMAGE_PATH MIL_TEXT(\"Target.mim\"), EXAMPLE_IMAGE_PATH MIL_TEXT(\"TargetColorDefect.mim\"), EXAMPLE_IMAGE_PATH MIL_TEXT(\"TargetTriangle.mim\"), EXAMPLE_IMAGE_PATH MIL_TEXT(\"TargetTopHat.mim\"), EXAMPLE_IMAGE_PATH MIL_TEXT(\"TargetNoise.mim\"), }; static MIL_CONST_TEXT_PTR CASE_INFORMATION[NB_IMAGES] = { MIL_TEXT(\"The absolute value of difference of the grayscale image combined \\n\") MIL_TEXT(\"with the bimodal threshold is the general method used. It works \\n\") MIL_TEXT(\"when the defects are of any size but much stronger than the \\n\") MIL_TEXT(\"normal variations of the template. The defects intensity must \\n\") MIL_TEXT(\"create a single mode, while the background creates another.\"), MIL_TEXT(\"The color distance can be used instead of the absolute value of \\n\") MIL_TEXT(\"difference to extract differences that cannot be seen in the \\n\") MIL_TEXT(\"luminance image.\"), MIL_TEXT(\"The triangle bisection helps to extract all defects when the \\n\") MIL_TEXT(\"intensity of the defects forms multiple modes. The triangle \\n\") MIL_TEXT(\"binarization separates the background from the other differences.\"), MIL_TEXT(\"The morphological background substraction method, that uses a \\n\") MIL_TEXT(\"bottom hat or top hat, should be used when there is non-uniform \\n\") MIL_TEXT(\"lighting. The object should not contain structures thinner than \\n\") MIL_TEXT(\"the structuring element and the defect size cannot be greater \\n\") MIL_TEXT(\"than structuring element.\"), MIL_TEXT(\"The triangle bisection can also be used when there are normal\\n\") MIL_TEXT(\"small variations in the template, moving the background threshold\\n\") MIL_TEXT(\"to a higher value.\"), }; // Default methods. static const DifferenceExtractionMethod DEFAULT_DIFFERENCE_METHOD[NB_IMAGES] = { enAbsoluteDiff, enColDistance, enColDistance, enTopHat, enColDistance, }; static const BinarizationMethod DEFAULT_BINARIZATION_METHOD[NB_IMAGES] = { enBiModal, enBiModal, enTriangleBisection, enTriangleBisection, enTriangleBisection, }; //***************************************************************************** // Main. //***************************************************************************** int MosMain(void) { CDefectDetectionExampleMngr ExampleMngr(M_SYSTEM_HOST); // Print the header. PrintHeader(); // Ask the user if he wants to run the example interactive mode if(ExampleMngr.AskForInteractive()) { // Load the template image in the example. if(ExampleMngr.LoadTemplate(M_INTERACTIVE)) { // Initialize the example with the current target image. if(ExampleMngr.InitializeExample(M_INTERACTIVE, enAbsoluteDiff, enBiModal)) { // Run the example. ExampleMngr.Run(MIL_TEXT(\"\")); } } MosPrintf(MIL_TEXT(\"Press any key to end.\\n\\n\")); MosGetch(); } else { for(MIL_INT TargetIdx = 0; TargetIdx &lt; NB_IMAGES; TargetIdx++) { // Load the template image in the example. if(ExampleMngr.LoadTemplate(TEMPLATE_IMAGE_FILENAME[TargetIdx])) { // Initialize the example with the current target image. if(ExampleMngr.InitializeExample(TARGET_IMAGE_FILENAMES[TargetIdx], DEFAULT_DIFFERENCE_METHOD[TargetIdx], DEFAULT_BINARIZATION_METHOD[TargetIdx])) { // Run the example. ExampleMngr.Run(CASE_INFORMATION[TargetIdx]); } } } } } ",
      "wordCount": 519
    }
  ]
}]
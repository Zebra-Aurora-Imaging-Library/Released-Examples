[{
  "id": "UG_jpeg",
  "version": "2024020714",
  "title": "JPEG and JPEG2000 compression",
  "subTitles": null,
  "location": "MIL UG P04: 2D related information",
  "pageURL": "content\\UserGuide\\jpeg\\ChapterInformation.htm",
  "text": " Chapter 30: JPEG and JPEG2000 compression This chapter describes how to compress and decompress images. JPEG and JPEG2000 compression overview JPEG lossless JPEG lossy Interlaced JPEG JPEG2000 lossless and lossy JP2 standard Control options General steps Compression Decompression Sequences Multi-band buffers, color formats, and control settings - JPEG Multi-band buffers, color formats, and control settings - JPEG2000 Application-specific markers Controlling a JPEG compression JPEG lossless Predictive coding Huffman encoding JPEG lossy Restart markers JPEG2000 Preparation of source image Discrete wavelet transform (DWT) Quantization Bit-plane decomposition Arithmetic encoding Post-processing Improving results Working with tables Inquiring values in default tables Using your own table ",
  "wordCount": 104,
  "subEntries": [
    {
      "id": "UG_jpeg_JPEG_JPEG2000_compression_overview",
      "version": null,
      "title": "JPEG and JPEG2000 compression overview",
      "subTitles": [
        "JPEG lossless",
        "JPEG lossy",
        "Interlaced JPEG",
        "JPEG2000 lossless and lossy",
        "JP2 standard",
        "Control options"
      ],
      "location": "MIL UG P04: 2D related information",
      "pageURL": "content\\UserGuide\\jpeg\\JPEG_JPEG2000_compression_overview.htm",
      "text": " JPEG and JPEG2000 compression overview MIL allows you to compress and decompress images and sequences. Compression allows you to store more images in memory than would normally be possible. In addition, compression allows images to be transferred more quickly, since it reduces the amount of data that must be transferred. MIL supports both lossy and lossless JPEG and JPEG2000 compression algorithms. Note that during development and at runtime, compression support is reliant upon the presence of a compression/decompression package license. This license is only included by default with the development dongle for the full version of MIL. In other cases, this license must be purchased separately. Although processing operations support compressed source and/or destination image buffers, these operations take longer on a compressed image than on an uncompressed image. This is because the processing operation must decompress/compress the image before/after performing its operation. It is recommended that compressed images be used only for data transfer. JPEG lossless The JPEG lossless algorithm compresses images without any loss of information. Typically, the algorithm compresses images by a factor of 2:1, although a factor of 4:1 can sometimes be achieved. The JPEG lossless algorithm can compress 8- or 16-bit buffers with 1 or 3 bands. JPEG lossy The JPEG lossy algorithm compresses images by a variable factor but introduces some loss of information. The higher the compression factor, the more the compression, but the lower the image quality. The JPEG lossy algorithm can compress 8-bit buffers with 1 or 3 bands. To be compatible with most image-viewing software, MIL allows you to store compressed color images in YUV format. Interlaced JPEG MIL can perform a JPEG compression such that the image data is stored in separate fields. This is referred to as an interlaced JPEG compression. Unless otherwise stated, everything that applies to a JPEG compression also applies to an interlaced JPEG compression. JPEG2000 lossless and lossy JPEG2000 is another standard for image compression supported by MIL. When compared with regular JPEG lossy compression at the same compression ratio, JPEG2000 lossy compression provides better image quality. JPEG2000 lossless compression permits a smaller buffer size while retaining the same image quality as regular JPEG lossless compression. The JPEG2000 lossy and lossless algorithms can compress 8- or 16-bit buffers with 1 or 3 bands (RGB or YUV). For a more detailed description of supported features, see the JPEG2000 section later in this chapter. Note, however, that JPEG2000 is best suited for archiving purposes because of the processing time required to compress and decompress images; therefore, when JPEG2000 is used for grabbing, there is a risk of missing frames. JP2 standard In addition to saving files in the regular JPEG2000 lossless or lossy file format, it is also possible to save files in the JPEG2000 lossless format or lossy format using the JP2 standard. While the JPEG2000 file format is only a dump of the compressed image's data, the JP2 standard file format also contains an additional information header. Typically, this optional information contains intellectual property rights, color palette, color space definition, or application-specific data. The headers of JP2 files saved using MIL only include color specifications. If the image was previously loaded into a MIL buffer from a JP2 file, any information in the file header other than color specification will be lost. MIL adds the JP2 header when the buffer is exported to a file. Control options MIL allows you to control certain aspects of a compression. For example, you can use your own compression tables, although the default tables are suitable for most applications. JPEG and JPEG2000 compression overview JPEG lossless JPEG lossy Interlaced JPEG JPEG2000 lossless and lossy JP2 standard Control options ",
      "wordCount": 612,
      "subEntries": []
    },
    {
      "id": "UG_jpeg_General_steps",
      "version": null,
      "title": "General steps",
      "subTitles": [
        "Compression",
        "Decompression",
        "Sequences",
        "Multi-band buffers, color formats, and control settings - JPEG",
        "Multi-band buffers, color formats, and control settings - JPEG2000",
        "Application-specific markers"
      ],
      "location": "MIL UG P04: 2D related information",
      "pageURL": "content\\UserGuide\\jpeg\\General_steps.htm",
      "text": " General steps This section discusses general steps in compressing and decompressing images and sequences, as well as other aspects of compression. Note that during development and at runtime, compression support is reliant upon the presence of a compression/decompression package license. This license is only included by default with the development dongle for the full version of MIL. In other cases, this license must be purchased separately. Compression To compress an image and save it in an image buffer: Allocate a buffer in which to hold the compressed image. Use MbufAlloc...() with M_COMPRESS combined with a compression attribute value. Compressed buffers that are created using the MbufCreate...() functions should not be used as the destination buffer of a MIL function. However, if a buffer with an M_COMPRESS attribute is used as a source buffer for an operation, the data will be decompressed depending on the attributes of the destination buffer. If necessary, change the control settings of the buffer, using MbufControl(). For example, for a JPEG or JPEG2000 lossy compression, you might want to change the quantization factor (M_Q_FACTOR), which is one of the factors that determine the amount of compression. The default value of the quantization factor is 50; setting a lower value will produce marginal improvement in image quality and will result in a larger file size; setting a higher value will produce a smaller file, and therefore a poorer quality image. If the image to compress is stored in a buffer, use MbufCopy() to compress it into the buffer allocated in step 1. If it is stored in a file, use MbufImport(). You can also automatically compress your grabbed images. To do so, use MdigGrab() with a destination buffer that has an M_GRAB + M_COMPRESS + CompressionType attribute. Note that due to the computational complexity of JPEG2000 compression, grabbing into such a buffer presents a risk of missing frames. Compression operations are optimized when the uncompressed source buffer and the compressed destination buffer are in the same format. Typically, buffers in YUV16 format produce the best compromise for quality and speed. Note that, if you want the compressed image stored on file rather than in a buffer, use MbufExport() instead of MbufCopy(). In this case, there is no need to allocate a destination buffer. Decompression To decompress an image, use MbufCopy(), MbufImport(), or MbufExport(), depending on where the source image is stored (in a buffer or on file) and where you want results written (to a buffer or file). Before the decompression, you should not change any control settings in the source image; the same controls must be used for decompression, otherwise the image data will be lost. The only exception to this rule is for JPEG2000 lossy compression, where you can change the target size of the image (the M_TARGET_SIZE control type). Decompression operations are optimized when the compressed source and uncompressed destination buffers are in the same format. Typically, buffers in YUV16 format produce the best compromise for quality and speed. Decompressing a JPEG buffer into a YUV16 packed (YUYV) buffer might accelerate transfer to the display. Sequences When compressing sequences, you can use MbufImportSequence() to import a sequence of images from an audio video interleave (AVI) file into separate compressed buffers. You can use MbufExportSequence() to export a sequence of compressed image buffers to an AVI file. Multi-band buffers, color formats, and control settings - JPEG When you allocate a multi-band buffer for a JPEG lossy compression, you can specify that the compressed image be stored in an RGB or YUV format. YUV is convenient because most image-viewing software support compressed color images in YUV16 format. If you are performing a JPEG lossy compression on a YUV image, you can use the control types that specify luminance (such as M_QUANTIZATION_LUMINANCE) to control the Y band; to control the U and V bands, use the control types that specify chrominance (such as M_HUFFMAN_DC_CHROMINANCE). The control types without these suffixes control all bands. See the MIL Reference for the list of YUV-specific control types. When the specified compressed buffer format differs from that of the source image, MIL will internally convert the source image to the specified format before performing the compression. Multi-band buffers, color formats, and control settings - JPEG2000 When you allocate a multi-band buffer for a JPEG2000 compression, you can specify that the compressed image be stored in an RGB or YUV format. If you are compressing a multi-band buffer in JPEG2000, you can specify different control settings for each band. To do so, add M_RED, M_BLUE, or M_GREEN to your control type (for a YUV buffer, add M_Y, M_U, or M_V). Using the control type alone or with M_ALL_BANDS will control all bands. Application-specific markers During a compression, MIL adds some application-specific markers to the resulting image. Most other packages will ignore these markers and therefore be able to decompress the file. MIL itself ignores unrecognized markers when it decompresses files. General steps Compression Decompression Sequences Multi-band buffers, color formats, and control settings - JPEG Multi-band buffers, color formats, and control settings - JPEG2000 Application-specific markers ",
      "wordCount": 845,
      "subEntries": []
    },
    {
      "id": "UG_jpeg_Controlling_a_JPEG_compression",
      "version": null,
      "title": "Controlling a JPEG compression",
      "subTitles": [
        "JPEG lossless",
        "Predictive coding",
        "Huffman encoding",
        "JPEG lossy",
        "Restart markers"
      ],
      "location": "MIL UG P04: 2D related information",
      "pageURL": "content\\UserGuide\\jpeg\\Controlling_a_JPEG_compression.htm",
      "text": " Controlling a JPEG compression This section provides a brief overview of the JPEG lossless and lossy algorithms and of the controls you have over these algorithms. In general, you should only change these controls if you are familiar with the algorithm you are using. For detailed information about the JPEG lossless and lossy algorithms, see Information technology -- Digital compression and coding of continuous-tone still images: Requirements and guidelines, which is available from the International Standards Organization (http://www.iso.ch). For techniques to use to improve compression operations, see the Improving results section later in this chapter. Note that during development and at runtime, compression support is reliant upon the presence of a compression/decompression package license. This license is only included by default with the development dongle for the full version of MIL. In other cases, this license must be purchased separately. JPEG lossless The JPEG lossless algorithm is basically a two-step process. First, predictive coding is performed on the image. Then, the result is Huffman encoded. Predictive coding Predictive coding is based on the fact that adjacent pixels in an image generally have similar values. Therefore, the value of a pixel can be \"predicted\" from the values of its neighbor(s). The difference between the original value of the pixel and the predicted value requires fewer bits to store than the original pixel value. MIL supports three types of predictive coding: predictor #0 (no predictor), predictor #1 (the \"pixel-to-the-left\" predictor), and predictor #2 (the \"pixel-above\" predictor). By default, MIL uses the pixel-to-the-left to predict values, which is suitable for most images. In some applications, you might prefer to use the pixel-above predictor. You can also specify no predictor (predictor #0), but note that in this case, the values after predictive coding will be the same as the original values. This predictor can be useful if you have developed your own algorithm to take the place of predictive coding and only need your images Huffman encoded. Note that you must implement your own algorithm to use one of the other \"predictors\" supported by the JPEG lossless algorithm. You can use MbufControl() with the M_PREDICTOR control type to specify the predictor. Huffman encoding After an image has been predictive coded, Huffman encoding assigns a variable-length \"code word\" to each value. This code is based on the number of bits by which adjacent values differ. Values are assigned code words according to a DC Huffman table. You can use the default DC Huffman table or you can create your own table. If you want to use your own table, see the Working with tables section later in this chapter. JPEG lossy The JPEG lossy algorithm is outlined below. First the source image must be in the correct format before it can be compressed. Although the JPEG algorithm requires signed source data, the algorithm accepts both signed and unsigned data. Initially the algorithm internally treats all data as unsigned. Then a computational shift is performed to set all the values to signed. After the computational shift, a color conversion is performed if the source and destination buffers are in different formats, for example an RGB source buffer and a YUV destination buffer. Note that conversion to YUV introduces some loss. Afterwards, each 8x8 block of the image is represented in its frequency domain through a discrete cosine transform, resulting in 1 DC and 63 AC values. Each block is then quantized and Huffman encoded. Quantization divides each of the 64 values in a block by a specified value, according to a quantization table. After each block is quantized, Huffman encoding assigns a variable-length \"code word\" to each value. Each DC value in a block is assigned a code word according to a DC Huffman table. The AC values are assigned a code word according to an AC Huffman table. You can control a JPEG lossy compression by using your own quantization and/or Huffman tables. Restart markers When an image is compressed, MIL adds restart markers to the bit-stream of the compressed image. A restart marker is a special code that signifies that the encoded bit-stream has been padded to the next byte boundary before the encoding process was restarted. Restart markers can be useful if you are transmitting the compressed image over a medium that is susceptible to errors. If an error does occur and there are no restart markers, the error will propagate and affect subsequent data. However, if there are restart markers, the error will be confined to the data between markers. By default, MIL places restart markers after a certain number of rows of data have been encoded (for lossless compressions) or after a certain number of 8x8 blocks of data have been encoded (for lossy compressions). If necessary, you can use MbufControl() with the M_RESTART_INTERVAL control type to change the number of rows or blocks between restart markers. For a lossy compression with a high compression ratio, too many restart markers can significantly increase the size of the compressed image. In this case, you might want to increase the number of blocks between restart markers, especially if you are not transmitting the image over a noisy medium. In fact, if you are sure that the transmission medium is not noisy, you might want to set the restart interval to 0, that is, not use restart markers. This will increase the compression ratio, as well as reduce the time required to decompress the image. Controlling a JPEG compression JPEG lossless Predictive coding Huffman encoding JPEG lossy Restart markers ",
      "wordCount": 917,
      "subEntries": []
    },
    {
      "id": "UG_jpeg_JPEG2000",
      "version": null,
      "title": "JPEG2000",
      "subTitles": [
        "Preparation of source image",
        "Discrete wavelet transform (DWT)",
        "Quantization",
        "Bit-plane decomposition",
        "Arithmetic encoding",
        "Post-processing"
      ],
      "location": "MIL UG P04: 2D related information",
      "pageURL": "content\\UserGuide\\jpeg\\JPEG2000.htm",
      "text": " JPEG2000 This section provides a brief overview of the JPEG2000 lossy and lossless algorithms and the control you have over these algorithms. Everything applicable to lossy compression is applicable to lossless compression, unless otherwise stated. In general, you should only change compression controls if you are familiar with the algorithm (except for the quantization factor, which you can change without in-depth knowledge, using MbufControl() with M_Q_FACTOR). For techniques to use to improve compression operations, see the Improving results section later in this chapter. For more detailed information about the JPEG2000 algorithm, see http://www.jpeg.org. Note that during development and at runtime, compression support is reliant upon the presence of a compression/decompression package license. This license is only included by default with the development dongle for the full version of MIL. In other cases, this license must be purchased separately. There are two fundamental differences between the JPEG2000 and regular JPEG compression algorithms. The first is the use of a discrete wavelet transform (DWT), instead of a discrete cosine transform. The second is the use of arithmetic encoding instead of Huffman encoding as the entropy encoding technique; arithmetic encoding reduces the number of bits required to encode data, based on how frequently that data occurs in the image. When compared to regular JPEG compression, JPEG2000 supports much higher ratios of compression without compromising image quality. Note however, that JPEG2000 is best suited for archiving purposes because of the processing time required to compress and decompress images; therefore, JPEG2000 can be used for grabbing, but it presents a risk of missing frames. When compressing images with the JPEG2000 algorithm, MIL supports: Custom quantization tables (using MbufControl() with M_QUANTIZATION). Custom wavelet settings (setting the number of decomposition levels using MbufControl() with M_DECOMPOSITION_LEVEL). Saving files either in regular JPEG2000 format or in JPEG2000 format with the JP2 standard, as well as saving AVI sequences in JPEG2000 format. Band-specific compression settings. Easy control over image size and quality (setting the quantization factor using MbufControl() with M_Q_FACTOR). Specifying a target size for the compressed image when performing a JPEG2000 lossy compression (using MbufControl() with M_TARGET_SIZE). Tiling (only supported when using Matrox JPEG2000 compression acceleration hardware). Note that MIL does not support the following JPEG2000 features: Progressive encoding/decoding (layering). Random bit-stream access (ROI coding). The JP2 file format optional features. Error resilience (not typically used in imaging applications). The JPEG2000 compression consists of the following steps: Preparation of source image. Discrete wavelet transform. Quantization (lossy only). Bit-plane decomposition. Arithmetic encoding. Post-processing (lossy only). Preparation of source image Although the JPEG2000 algorithm requires signed source data, the algorithm accepts both signed and unsigned data. Initially the algorithm internally treats all data as unsigned. Then a computational shift is performed to set all the values to signed. After the computational shift, a color conversion is performed if the source and destination buffers are in different formats, for example an RGB source buffer and a YUV destination buffer. Note that conversion from RGB to YUV naturally introduces some loss. Discrete wavelet transform (DWT) After preparation of the source image, a lossy or lossless discrete wavelet transform (DWT) is applied to the image. The discrete wavelet transform both subsamples and spatially filters the image. Depending on the type of compression, the DWT uses one of two sets of filters: for lossy compression, a Daubechies 9-tap/7-tap filter is used, while a 5-tap/3-tap filter is used for lossless compression. The DWT subsamples and then separates the data into high frequency areas and low frequency areas; these areas are referred to as sub-bands. Each iteration, which consists of one pass of both the high and low frequency filters in both the horizontal and vertical directions, results in four sub-bands. Subsequent iterations of the transform are always applied on the top-left (low frequency) sub-band. MIL refers to each iteration of the DWT as a decomposition level. The default number of decomposition levels is 5, unless the width or the height of the image is less than or equal to 16 pixels; in which case, the number of decomposition levels is chosen so that the width or the height of the 4 smallest sub-bands of the image is 1 pixel. You can override the default using MbufControl() with M_DECOMPOSITION_LEVEL. For example, if your original image is 1024x768, by default, the number of decomposition levels is 5, and the size of the 4 smallest sub-bands is 32x24. If you set the M_DECOMPOSITION_LEVEL control type to 6, then the size of the smallest sub-bands would be 16x12. The largest number of decomposition levels is the one that yields a width or a height of 1 pixel for the 4 smallest sub-bands. After allocating the image buffer, you can inquire the number of decomposition levels that will be used, using MbufInquire() with M_DECOMPOSITION_LEVEL. After the wavelet transform, each pixel in the original image becomes a wavelet coefficient. There will always be as many wavelet coefficients as there were pixels in the original image. After the wavelet transform is applied, MIL no longer considers the data as an image. The larger sub-bands are further segmented into smaller regions, referred to as code-blocks. Smaller sub-bands are not segmented, and each contains one code-block. For example, if 64x64 code-blocks are used, the sub-band that is 128x128 contains four code-blocks, while the sub-bands that are 64x64, 32x32, and 16x16 each contain one code-block, as illustrated in the diagram below. Segmentation optimizes compression by grouping areas with similar values; when the values to compress are similar, the result is a better compression ratio. Segmentation also optimizes access to Host memory, thereby improving the performance of the quantization (for JPEG2000 lossy compression), bit-plane decomposition, and arithmetic encoding steps in the algorithm. Quantization During JPEG2000 lossy compression, the wavelet coefficients contained in each code-block are quantized based on both the sub-band in which they fall, and an entry in the quantization table. Quantization multiplies each wavelet coefficient by its sub-band's corresponding entry, the quantization coefficient, in the table. The sub-band's rank in significance, which is illustrated below, determines which entry in the quantization table is used. Note that the top-left sub-band is the most significant. JPEG2000 lossless compression does not use the quantization step. MIL automatically determines the values for the quantization table based on the number of sub-bands resulting from the DWT transform; that is, all images of the same depth that have five decomposition levels will use the same quantization table. The first entry (for sub-band 0) always has the largest quantization coefficient. When you adjust the quantization factor (using MbufControl() with M_Q_FACTOR), MIL scales all the quantization coefficients in the quantization table according to the specified factor. If you want more control, you can pass your own custom quantization table. To establish good values for a custom quantization table, you can inquire the default quantization coefficients. For more information, see the Working with tables section later in this chapter. Bit-plane decomposition After the wavelet coefficients are multiplied by the quantization coefficients, the code-blocks are decomposed into bit-planes. A bit-plane contains the nth bit of all the multiplied wavelet coefficients that occupy a specific code-block. Decomposition into bit-planes is necessary for arithmetic encoding and post-processing. A specific code-block might not have the same number of bit-planes as another code-block. Decomposition starts from the most-significant non-zero bit-plane of a code-block, and all subsequent bit-planes are decomposed, even eventual zero bit-planes. For example, the code-block in the diagram below contains coefficients that are 3 bits, and therefore will be decomposed into 3 bit-planes. Arithmetic encoding The bit-planes are then passed to the arithmetic encoder. The arithmetic encoder analyzes the bit-plane data to find redundancies, in other words, patterns of bits that occur frequently in the bit-planes. Using this information, the arithmetic encoder replaces repeating bit patterns, also called symbols, by shorter bit sequences. The more often a symbol occurs in the bit-plane data, the fewer bits into which that symbol will be coded. During lossless compression, the arithmetic encoder processes each bit-plane to produce a continuous bit-stream. Since arithmetic encoding is the final stage of compression, this bit-stream is actually the compressed image. During lossy compression, the arithmetic encoder produces several independent bit-streams; the post-processing step determines which bit-streams are concatenated in the final image. Post-processing Once the most-significant bit-plane of a code-block is encoded, its size in bytes is stored in memory, and MIL calculates how much error would be present in the decompressed image if the remaining bit-planes, for that code-block, were not arithmetically encoded. Once the second most-significant bit-plane of the code-block is arithmetically encoded, MIL calculates the error introduced in the decompressed image if only the first two bit-planes were compressed. As each remaining bit-plane is encoded, MIL repeats the same calculation until all the bit-planes have been processed. As an example only, the values in the following table represent the amount of distortion (error) with respect to the size in bytes of the encoded bit-planes of one code-block. Bit-plane (in order of significance) Compressed size in bytes Distortion 1 5 58817925.11 2 54 34495584.39 3 159 11160557.81 4 296 2633195.13 5 436 594555.28 6 574 94112.98 7 717 21139.81 8 863 4080.74 9 980 0.00 Then, the best compromise between decompressed image quality and requested size in bytes (using MbufControl() with M_TARGET_SIZE) is determined. Any encoded bit-planes that are not required are discarded after the best compressed image is determined for the specified size. The remaining encoded bit-planes are then concatenated in the final image. Determining an appropriate target size will require some trial and error, but a logical guess can be calculated by dividing the image's original size, in bytes, by the required compression ratio. For example, if you want to compress a 256-byte image by a factor of 16:1, you would specify a target size of 16 bytes. Post-processing is not performed in JPEG2000 lossless, and none of the encoded bit-planes are discarded; therefore, you cannot specify a target buffer size when performing a lossless compression. JPEG2000 Preparation of source image Discrete wavelet transform (DWT) Quantization Bit-plane decomposition Arithmetic encoding Post-processing ",
      "wordCount": 1673,
      "subEntries": []
    },
    {
      "id": "UG_jpeg_Improving_results",
      "version": null,
      "title": "Improving results",
      "subTitles": null,
      "location": "MIL UG P04: 2D related information",
      "pageURL": "content\\UserGuide\\jpeg\\Improving_results.htm",
      "text": " Improving results If the defaults do not meet your application requirements, you can try to improve your compression ratio using the following techniques. We recommend trying these techniques in the order they appear. Note that during development and at runtime, compression support is reliant upon the presence of a compression/decompression package license. This license is only included by default with the development dongle for the full version of MIL. In other cases, this license must be purchased separately. Regardless of the type of your compression operation, you should first remove extraneous noise from the image (if possible) using MIL processing functions. For JPEG lossy compression: Allocate a YUV buffer for compression. Increase the quantization factor using MbufControl() with M_Q_FACTOR. Decrease the restart interval. Change the quantization table (see the Working with tables section later in this chapter). Change the Huffman table (see the Working with tables section later in this chapter). For JPEG lossless compression: Try the other supported predictors using MbufControl() with M_PREDICTOR. Decrease the restart interval. For JPEG2000 lossy compression: Allocate a YUV buffer for compression. Increase the quantization factor using MbufControl() with M_Q_FACTOR. Decrease the target size using MbufControl() with M_TARGET_SIZE. Change the number of decomposition levels of the DWT using with M_DECOMPOSITION_LEVEL. Change the quantization table (see the Working with tables section later in this chapter). For JPEG2000 lossless compression: Change the number of decomposition levels of the DWT using MbufControl() with M_DECOMPOSITION_LEVEL. Improving results ",
      "wordCount": 241,
      "subEntries": []
    },
    {
      "id": "UG_jpeg_Working_with_tables",
      "version": null,
      "title": "Working with tables",
      "subTitles": [
        "Inquiring values in default tables",
        "Using your own table"
      ],
      "location": "MIL UG P04: 2D related information",
      "pageURL": "content\\UserGuide\\jpeg\\Working_with_tables.htm",
      "text": " Working with tables In some applications, the default quantization or Huffman tables might not be suitable. MIL allows you to create your own. You can inquire the default table values to help you determine appropriate values. You might have to select values by trial and error to determine the best ones for your application. For JPEG2000 compression, quantization multiplies coefficients, while in JPEG compression, quantization divides values. Whether you are inquiring the default tables or customizing your own, you must allocate arrays that are large enough to contain the data. The table below lists the tables that you can manipulate and their required array size for each compression algorithm. Compression algorithm Table type Buffer type, size, and attribute JPEG lossless DC Huffman 1-dimensional, 8+ M_UNSIGNED, 28 entries, M_ARRAY JPEG lossy DC Huffman 1-dimensional, 8+ M_UNSIGNED, 28 entries, M_ARRAY AC Huffman 1-dimensional, 8+ M_UNSIGNED, 178 entries, M_ARRAY Quantization 2-dimensional, 8+ M_UNSIGNED, 8x8 entries, M_ARRAY JPEG2000 lossy Quantization 1-dimensional, 32+ M_FLOAT, 3 N + 1 entries, where N is the number of decomposition levels, M_ARRAY Note that during development and at runtime, compression support is reliant upon the presence of a compression/decompression package license. This license is only included by default with the development dongle for the full version of MIL. In other cases, this license must be purchased separately. Inquiring values in default tables Inquiring the default values of a table is useful to determine values for your custom tables. The steps below outline this procedure. First, inquire the MIL identifier of the default table using MbufInquire(). Then, inquire the size of the table using the same function. Allocate a user array of the appropriate size for storing the default table values. Get the values from the inquired table in Step 1 and store them in the user array using MbufGet...(). Using your own table To use your own table: Allocate a buffer with an M_ARRAY attribute and of the same data type as the default table. Transfer the custom table values from the user array to the array buffer, using MbufPut...(), depending on the type of table. Associate the M_ARRAY buffer to the required M_COMPRESS image buffer, using the MbufControl() control types specific to your table (for example, use the M_HUFFMAN_AC control type for an AC Huffman table). Specifying these control types as-is, or combined with M_ALL_BANDS, controls all bands for JPEG2000. This is the default setting. For a JPEG2000 compression, you can associate a different table with each band of a multi-band buffer. To do so, add M_RED, M_BLUE, or M_GREEN to your control type for an RGB buffer, whereas for a YUV buffer, add M_Y, M_U, or M_V. For JPEG lossy compressions of YUV buffers, use the luminance and chrominance control types. The control types without these suffixes control all bands. If you set the M_Q_FACTOR control type after specifying a custom table, the custom table will be scaled. Working with tables Inquiring values in default tables Using your own table ",
      "wordCount": 495,
      "subEntries": []
    }
  ]
}]
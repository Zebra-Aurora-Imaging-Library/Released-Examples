[{
  "id": "UG_edge-finder",
  "version": "2024020714",
  "title": "Edge Finder",
  "subTitles": null,
  "location": "MIL UG P03: 2D processing and analysis",
  "pageURL": "content\\UserGuide\\edge-finder\\ChapterInformation.htm",
  "text": " Chapter 10: Edge Finder This chapter explains how to use the MIL Edge Finder module to extract and analyze edges in your image. MIL Edge Finder module Edges and Edge Finder Steps to extract and analyze edges Basic concepts for the MIL Edge Finder module Extracting the edges Basics of edge extraction Object contours versus line crests Object contours Line crests How edges are calculated Object contours Line crests Customizing the edge extraction settings Filter type Infinite Impulse Response (IIR) filters Finite Impulse Response (FIR) filters Smoothing for IIR filters Thresholding Edgel accuracy Magnitude type Filling the edge gaps Candidate constraint Region constraint Polarity constraint Continuity constraint Edge features Dimension features Feret diameter Circle fit and line fit Ellipse fit Location features Advanced features Convex perimeter Tortuosity Moment elongation Grouped features Calculating and retrieving results Sorting keys Retrieving the results Selecting the results Edge selection based on edge features Edge selection based on the inter-relationship of edges Edge selection based on the proximity of the edges to a point Internal processing buffers Derivatives Angles Magnitude Source image and mask Post-calculation Restrictions Annotating the results Advanced edge extraction Approximating the edges Masking the edges Cropping the edges Advanced thresholding Providing the image's derivatives Putting data into an Edge Finder result buffer Finding the closest edgels to a list of points Location-based constraints Edgel-based constraints Optimizing edge extractions Specify an area to process Perform post-calculation Optimize your control type settings Adjust the accuracy Building edge chains Adjust the extraction scale Specifying the IIR filter mode Specify the smoothness Specify the magnitude Setting the threshold Calculating the length of each edge Limiting the search radius Retrieving calibrated results Interfacing with Geometric Model Finder or Advanced Geometric Matcher MIL Edge Finder example ",
  "wordCount": 290,
  "subEntries": [
    {
      "id": "UG_edge-finder_MIL_Edge_Finder_module",
      "version": null,
      "title": "MIL Edge Finder module",
      "subTitles": [
        "Edges and Edge Finder"
      ],
      "location": "MIL UG P03: 2D processing and analysis",
      "pageURL": "content\\UserGuide\\edge-finder\\MIL_Edge_Finder_module.htm",
      "text": " MIL Edge Finder module The MIL Edge Finder module is a set of powerful functions that allow you to extract and analyze edges in a source image. Many applications can be implemented using the Edge Finder module, such as complex measurement operations, defect detection, shape recognition, and shape analysis. You can also perform advanced edge manipulations, such as closing broken edges. Edge Finder allows you to calculate a large number of edge features that can provide you with useful information, such as the edge's minimum and maximum Feret diameter. You can either calculate all required features for all edges, or perform a post-calculation on a refined subset of selected edges, which can speed up your processing time considerably. The Edge Finder module can also be used in conjunction with the MIL Geometric Model Finder and Advanced Geometric Matcher modules to define models from the result of an edge extraction or to find model occurrences in the result of an edge extraction. For more information, see the Geometric Model Finder module section of Chapter 8: Geometric Model Finder and the Advanced Geometric Matcher module section of Chapter 9: Advanced Geometric Matcher. If your source image is calibrated, results are calculated in the world coordinate system, otherwise they are calculated in the pixel coordinate system. Also, if your source image is calibrated, you can retrieve results in either real-world or pixel units. For more information about camera calibration, see Camera Calibration. Edges and Edge Finder Edges are curves that delineate a boundary. These can be established from intensity transitions in an image. Well-defined edges come from sharp transitions in value, typically found in highly-contrasted images. Conversely, weak edges come from gradual transitions in value, typically found in smooth images. Depending on your settings, Edge Finder will extract one of two edge types: object contours or line crests. An object contour is a type of edge that defines the outline of objects in an image. A line crest is a type of edge that defines the skeleton of objects in an image. Note that line crests should be used to extract edges from objects consisting of thin curvilinear shapes, such as fingerprints. In either case, edges are extracted from the source image and used to form the image's edge map, which represents how the image is defined as a set of edges. All Edge Finder operations, such as annotations and feature calculations are performed using the image's edge map. You can only extract line crests from grayscale images. However, you can extract object contours from both grayscale and color images. When operating on color images, Edge Finder takes into consideration all three bands (RGB) to establish the presence of an edge. MIL Edge Finder module Edges and Edge Finder ",
      "wordCount": 458,
      "subEntries": []
    },
    {
      "id": "UG_edge-finder_Steps_to_performing_an_edge_extraction_and_analysis",
      "version": null,
      "title": "Steps to extract and analyze edges",
      "subTitles": null,
      "location": "MIL UG P03: 2D processing and analysis",
      "pageURL": "content\\UserGuide\\edge-finder\\Steps_to_performing_an_edge_extraction_and_analysis.htm",
      "text": " Steps to extract and analyze edges The following steps provide a basic methodology for using the MIL Edge Finder module: Allocate an Edge Finder context, using MedgeAlloc(). If necessary, adjust general processing controls to fit your application, using successive calls to MedgeControl(). If necessary, select the required features to calculate, using successive calls to MedgeControl(). Allocate an Edge Finder result buffer to hold the results of the edge extraction, using MedgeAllocResult(). Calculate edges and edge features, using MedgeCalculate(). If necessary, exclude or delete edges that do not meet a required criterion, using MedgeSelect(). Excluded edges will be ignored in future calculations, while deleted edges will be removed from the Edge Finder result buffer. If necessary, select new features and perform a post-calculation, using MedgeCalculate(). Get the number of edges currently included and retrieve the required results from the Edge Finder result buffer, using MedgeGetResult(). Results for the excluded or deleted edges will not be returned. If necessary, get the coordinates of edgels from an Edge Finder result buffer that correspond to the closest neighbors from a list of user-specified source point coordinates, using MedgeGetNeighbors(). If necessary, copy data from user-supplied arrays to a specified Edge Finder result buffer, using MedgePut(). If necessary, draw edges and edge features, using MedgeDraw(). If necessary, save your Edge Finder context, using MedgeSave() or MedgeStream(). Free all your allocated objects, using MedgeFree(), unless M_UNIQUE_ID was specified during allocation. You can repeat steps 6, 7, and 8 until all the required results are obtained. Note that successively excluding or deleting unwanted edges and then calculating more features is the recommended procedure to achieve the required results, especially if you have a large number of unwanted edges. Steps to extract and analyze edges ",
      "wordCount": 288,
      "subEntries": []
    },
    {
      "id": "UG_edge-finder_Basic_concepts",
      "version": null,
      "title": "Basic concepts for the MIL Edge Finder module",
      "subTitles": null,
      "location": "MIL UG P03: 2D processing and analysis",
      "pageURL": "content\\UserGuide\\edge-finder\\Basic_concepts.htm",
      "text": " Basic concepts for the MIL Edge Finder module The basic concepts and vocabulary conventions for the MIL Edge Finder module are: Edge. A curve that delineates a boundary, which can be established from intensity transitions in an image. In Edge Finder, an edge is considered to be an edge chain and its features. Edgel. An elementary point (or edge element) within an edge. Edge angle. The angle between the horizontal axis and the edge's perpendicular direction at each edgel location. Edge chain. The set of connected edgels that construct an edge. Edge feature. Information describing an edge, such as its length. Edge magnitude. The strength of the edge at each edgel location. For object contours, the magnitude is the norm of the gradient vector at the edgel position. For line crests, the magnitude is equal to the maximum eigenvalue of the Hessian matrix at the edgel position. Edge map. The set of edges extracted from the source image. Filter support region. The number of neighboring pixels that are taken into account when computing the output pixel. The number of pixels taken into account can be finite or infinite, and is determined by the type of filter used to extract edges. Line crest edge. A type of edge that defines the skeleton of objects in an image. Typically, objects should be thin curvilinear shapes. Object contour edge. A type of edge that defines the outline of objects in an image. Typically, objects should not be thin curvilinear shapes. Post-calculation. Any calculation made to refine results after an initial edge calculation. Source image. The image from which the edges are extracted. After edge chains have been extracted, the terms edge chain and edge are used interchangeably. Basic concepts for the MIL Edge Finder module ",
      "wordCount": 294,
      "subEntries": []
    },
    {
      "id": "UG_edge-finder_Extracting_the_edges",
      "version": null,
      "title": "Extracting the edges",
      "subTitles": [
        "Basics of edge extraction",
        "Object contours versus line crests",
        "Object contours",
        "Line crests",
        "How edges are calculated",
        "Object contours",
        "Line crests"
      ],
      "location": "MIL UG P03: 2D processing and analysis",
      "pageURL": "content\\UserGuide\\edge-finder\\Extracting_the_edges.htm",
      "text": " Extracting the edges Before you write even the simplest application, it is important to have a basic understanding of how Edge Finder extracts edges, and what the differences are between the various types of edges (object contours and line crests). Note that if you are writing slightly more advanced applications, it is also worth having a more in-depth understanding of how edges are calculated. Basics of edge extraction Edge Finder uses operations that are based on differential analysis, where edges (either contours or line crests) are extracted by analyzing intensity transitions in images. Transitions in intensity can come from many physical phenomena, such as shadows and illumination variations. However, strong transitions are typically caused by the presence of an object contour or a line crest in the image, as illustrated below. Note that the main intensity transition in the image is observed in the perpendicular direction relative to the object border (for an object contour) or line shape (for a line crest). Edges are extracted in three general steps. First, a filtering process provides an enhanced image of the edges based on the computation of the image's derivatives. Second, detection and thresholding operations determine, from the image enhancement, all pertinent edge elements, or edgels, and accurately calculate their positions. Third, neighboring edgels are connected to build the edge chains (which results in the image's edge map), and features are calculated for each edge. To fit the requirements of your application, Edge Finder allows you to customize each step's corresponding processing controls. Edgels are connected into edge chains respecting the following constraints, whereby pixels are considered connected based on an 8-connected lattice: Consecutive edgels must occupy separate connected pixels. No branches are allowed (they start or end a separate chain). There must not be an edge in the edge map that is more than 1 pixel wide. You can control how edgels are connected using MedgeControl() with M_CHAIN_ALL_NEIGHBORS. If the control type is enabled, the chain is created using as much edgel information as possible. If disabled, the chain is created using the least amount of edgel information possible. Object contours versus line crests To properly analyze the structures present in an image, it is often useful to consider the image as a topographic surface, where the intensity of each pixel is seen as the elevation value of the surface. By doing so, contours and crests can be more easily understood. Object contours An object contour is the inter-pixel boundary that splits into thin layers (delaminates) the separation between the object and the image background, as illustrated below. The edge of the contour is located at the sharpest point within the intensity transition. Moreover, the intensity transition is strongest in the perpendicular direction to the object contour. Well-defined contours have sharp transitions in value. The smoother the image, the more gradual the change, and the weaker the contour. To allocate an Edge Finder context for object contours, use MedgeAlloc() with M_CONTOUR. Line crests A line crest is the skeleton of a thin curvilinear shape in the image, as illustrated below. The crest is located at the sharpest point of the Gaussian-like profile of the line shape. Moreover, the intensity transition is strongest in the perpendicular direction to the line crest. Well-defined line crests are thin and have sharp transitions in value. The smoother the image or the larger the lines, the more gradual the change, and the weaker the line crests. A line crest can either be darker (a valley-like Gaussian profile), lighter (a ridge-like Gaussian profile), or both darker and lighter than the image's background. To specify the color of the line crest to extract, set MedgeControl() with M_FOREGROUND_VALUE to M_FOREGROUND_BLACK, M_FOREGROUND_WHITE, or M_ANY. The default setting is M_FOREGROUND_BLACK. To allocate an Edge Finder context for line crests, use MedgeAlloc() with M_CREST. Typically, you should use M_CREST Edge Finder contexts for edges that are established from thin curvilinear shapes; otherwise, you might get unexpected results. How edges are calculated For basic applications, you need not know how Edge Finder calculates edges. However, an understanding of this process can help you solve more advanced problems, and adjust some advanced settings. Object contours The enhanced image of the object contours is achieved by calculating the gradient magnitude of each pixel in the image. The stronger the intensity transition, the greater the magnitude will be. The gradient magnitude is calculated at each pixel position from the image's first derivatives. It is defined as: where Ix and Iy are, respectively, the X and Y derivative values. They define the components of the gradient vector as: An edgel is located at the maximum value of the gradient magnitude over adjacent pixels, in the direction defined by the gradient vector. The gradient direction is the direction of the steepest ascent at an edgel in the image, while the gradient magnitude is the steepness of that ascent. Note that the gradient direction is also the perpendicular direction to the object contour. Well-defined contours are extracted from strong and sharp intensity transitions. Note that a strong contrast between the objects and their background improves the edge detector's robustness and location accuracy. Note that Edge Finder also supports 3-band images, when extracting object contours. The extraction process is similar to single band images, except the enhanced image of the object contours is achieved by calculating a generalized gradient magnitude of each pixel in the image, for each color band (RGB). Line crests The enhanced image of the line crests is achieved by calculating the Hessian magnitude of each pixel in the image. The stronger the crest, the greater the magnitude will be. The magnitude is defined as the maximum eigenvalue of the Hessian matrix, calculated at each pixel position from the image's second derivatives. The Hessian matrix is defined as: where Ixx , Iyy and Ixy are, respectively, the X, Y and cross second derivative values of the image. An edgel is located at the maximum value of the image magnitude over adjacent pixels, in the direction defined by the associated eigenvector. Well-defined line crests are extracted from strong and sharp intensity transitions. Note that a strong contrast between the lines and the image's background improves the edge detector's robustness and the location accuracy. Note that the sign of the magnitude at the crest's edgel locations changes with the color of the line crest. That is, a dark crest has a strong positive magnitude, while a light crest has a strong negative magnitude. The geometric interpretation of the magnitude and its associated orientation is the direction where the crest is the sharpest. Similar to object contours, this direction is also the direction perpendicular to the line crest. Extracting the edges Basics of edge extraction Object contours versus line crests Object contours Line crests How edges are calculated Object contours Line crests ",
      "wordCount": 1134,
      "subEntries": []
    },
    {
      "id": "UG_edge-finder_Customizing_the_edge_extraction_settings",
      "version": null,
      "title": "Customizing the edge extraction settings",
      "subTitles": [
        "Filter type",
        "Infinite Impulse Response (IIR) filters",
        "Finite Impulse Response (FIR) filters",
        "Smoothing for IIR filters",
        "Thresholding",
        "Edgel accuracy",
        "Magnitude type",
        "Filling the edge gaps",
        "Candidate constraint",
        "Region constraint",
        "Polarity constraint",
        "Continuity constraint"
      ],
      "location": "MIL UG P03: 2D processing and analysis",
      "pageURL": "content\\UserGuide\\edge-finder\\Customizing_the_edge_extraction_settings.htm",
      "text": " Customizing the edge extraction settings Once you have allocated an Edge Finder context with the right context type (using MedgeAlloc()), you can customize the image processing algorithm using MedgeControl(). For example, to fit the requirements of your application, you can select the appropriate: Edge extraction filter (M_FILTER_TYPE). Noise reduction factor (M_FILTER_SMOOTHNESS). Sensitivity of the edgel detection (M_THRESHOLD_MODE). Accuracy of the edgel positions (M_ACCURACY). You can also choose to fill in the edge gaps, which is the process of linking broken edges together based on a set of criteria (M_FILL_GAP_DISTANCE and M_FILL_GAP_ANGLE). Generally, the default control settings described in this section are sufficient for the majority of images. You should therefore adjust these settings only when dealing with very noisy images, extremely low or multi-contrast images, or images with very thin, refined features. In all cases, it is recommended that you try the default settings first and, if necessary, experiment with different settings to achieve the required edge map and accuracy. For more advanced information on extracting edges, see the Advanced edge extraction section later in this chapter. Note that the edge extraction process involves a denoising operation to even out rough edges and remove noise. The filter type, filter mode, kernel depth, noise reduction factor, and threshold mode all work in concert to control this operation, and ultimately determine which edges to extract. Changing any one of these factors will, to varying degrees, alter the edges that are extracted. Filter type The edge extraction filter is used to compute the source image's spatial derivatives, which in turn are used to calculate the edge's magnitude (Gradient or Hessian) and angle. It also establishes the contribution of each neighboring pixel to the edge calculation. You can set the type of filter used when performing the edge extraction using MedgeControl() with M_FILTER_TYPE. You can choose either an Infinite Impulse Response (IIR) edge extraction filter, or a Finite Impulse Response (FIR) edge extraction filter. The default filter type is the IIR filter, M_SHEN. IIR filters allow you to extract both crests and contours, while FIR filters only allow you to extract contours. IIR filters take many more settings into account than FIR filters do. For example, IIR filters also allow you to take advantage of Edge Finder's smoothing capabilities, while FIR filters ignore your smoothness setting. See \"J.-P. Cocquerez and S. Philippe. Analyse d'images: filtrage et segmentation . Paris, France: Collection: Enseignement de la physique, 1995. \" for more information on IIR and FIR filters. Infinite Impulse Response (IIR) filters MIL provides you with the following IIR filters to extract edges, which you can set using MedgeControl() with M_FILTER_TYPE: Shen-Castan (M_SHEN), which is an exponential weighting function, of the general form f(n) = Ke-a| n | . Deriche (M_DERICHE), which is an exponential weighting function, of the general form f(n) = K(a|n| + 1)e-a| n | . These filters generate the weight values for neighboring pixels. In both cases, K corresponds to a normalization coefficient and a depends on the M_FILTER_SMOOTHNESS setting in MedgeControl(). Note that the general forms of these filters are not used directly; their first and second derivatives are used for contour and crest extraction, respectively. The default filter, Shen-Castan, typically performs an effective edge extraction; it achieves a very good localization of edges, which makes it ideal for the majority of images. However, Shen-Castan can sometimes be unexpectedly sensitive to noise, or can yield inappropriate results if you are extracting unusually thick crests. If this is the case, you should try Deriche, which is better suited to handle these situations, since it places more emphasis on an edge's neighbors than Shen-Castan. The following image illustrates how the first derivative distribution of values can affect results for both Shen-Castan and Deriche: Finite Impulse Response (FIR) filters The M_FILTER_TYPE setting in MedgeControl() provides you with the following FIR filters to extract edges: Frei Chen (M_FREI_CHEN), which can be represented with the following convolution kernels: Prewitt (M_PREWITT), which can be represented with the following convolution kernels: Sobel (M_SOBEL), which can be represented with the following convolution kernels: Note that, as mentioned, FIR filters only allow you to extract contours. Smoothing for IIR filters The M_FILTER_SMOOTHNESS setting in MedgeControl() allows you to control the degree of smoothness applied in the edge extraction. The smoothing operation evens out rough edges and reduces noise; in effect, the smoothness factor affects which edges are extracted. The range of this control varies from 0 (no smooth) to 100 (a very strong smooth). The default setting is 50.0. Note that M_FILTER_SMOOTHNESS is only relevant if MedgeControl() with M_FILTER_TYPE is set to M_DERICHE or M_SHEN. For recursive IIR filters, increasing the smoothness control value does not affect the processing time. A very high smoothing level can result in a loss of important detail and a decrease in precision. Note that, the range of smoothing is not linear; that is, the higher the smoothing factor, the greater the difference between settings. For example, changing the smoothing from 30.0 to 50.0 is less significant than changing the smoothing from 50.0 to 70.0. The following animation demonstrates this non-linear change in smoothing: Thresholding Edge Finder determines which edges are extracted from the source image based on a thresholding of the magnitude of each edgel. More specifically, a hysteresis thresholding is used to perform the edge extraction. With this type of thresholding, the extracted edge chains are built such that the magnitude values of all connected edgels are stronger than the lower bound threshold value (M_THRESHOLD_LOW) and at least one edgel in each edge chain has a magnitude that is stronger than the upper bound threshold value (M_THRESHOLD_HIGH). For more information on edgel magnitude, see the Magnitude type subsection of this section. Thresholding can also be applied during post-calculation. In this case, threshold settings are applied to the Edge Finder result buffer, rather than the source image. Except for filtering operations, the edge extraction process is completely recalculated. As a result, all internal processing buffers (M_SAVE_...) must have been initially saved, using MedgeControl(). For more information on post-calculation, see the Post-calculation subsection of the Calculating and retrieving results section later in this chapter. Edge Finder provides several predefined threshold modes that automatically select appropriate values for the lower and the upper bound thresholds, based on an internal image evaluation and noise estimation. To automatically determine the threshold settings with which to extract edges, call MedgeControl() with M_THRESHOLD_MODE set to one of the following: M_VERY_HIGH, M_HIGH, M_MEDIUM, M_LOW, or M_DISABLE. Note that lower threshold modes result in a more sensitive edgel detection. The default setting (M_HIGH) is typically sufficient since it offers a robust detection of pertinent edgels, even from images presenting some contrast variations, noise, and non-uniform illumination. However, for multi-contrast images, or for images with a lot of noise or non-uniform illumination, some edges can be missed. In these cases, the setting M_MEDIUM should be used. If all relevant edges are still not being extracted, then use M_LOW, which will get all edges over a minimum noise-based estimated threshold. Finally, to extract all edgels in the image, use M_DISABLE, which will set the lower and upper bound threshold values to 0. Note that M_LOW and M_DISABLE should be used carefully since a large number of unnecessary edgels might be extracted. For images that have strong contrast, little noise, and consistent illumination, the M_VERY_HIGH setting can be used, since it will extract only the strongest edges. Note that M_VERY_HIGH should also be used carefully since pertinent edgels might not be extracted. In the majority of cases, Edge Finder's predefined threshold modes should provide you with sufficient thresholding control. However, for advanced applications, you might want to explicitly set the threshold bounds. To do so, set M_THRESHOLD_MODE to M_USER_DEFINED, and use the M_THRESHOLD_LOW and M_THRESHOLD_HIGH control types to specify the lower and upper threshold bounds, respectively. The default settings are 0. If M_THRESHOLD_MODE is not set to M_USER_DEFINED, your M_THRESHOLD_LOW and M_THRESHOLD_HIGH values have no effect. Note that the threshold bounds must be provided as positive values. However, for line crests, Edge Finder will consider these values to be negative and/or positive, depending on whether the edges were extracted as darker (negative edgel values), lighter (positive edgel values), or both darker and lighter (negative and positive edgel values) than the image's background. For more information on extracting line crests, see the Object contours versus line crests subsection of the Extracting the edges section earlier in this chapter. Advanced users might want to customize the behavior of the hysteresis thresholding; to do so, see the Advanced thresholding subsection of the Advanced edge extraction section later in this chapter. Note that when interfacing with the MIL Geometric Model Finder or Advanced Geometric Matcher module, you should use MedgeControl() with M_DETAIL_LEVEL to set the threshold mode. Note that an M_DETAIL_LEVEL setting overrides an M_THRESHOLD_MODE setting. For more information, see the Interfacing with Geometric Model Finder or Advanced Geometric Matcher section later in this chapter. See \"P. L. Rosin Edges: Saliency measures and automatic thresholding . Ispara, Italy: Institute for Remote Sensing Applications, 1995. \" for more information on automatic robust thresholding techniques for edge extraction. Edgel accuracy Edgels have a position and an angle. The M_ACCURACY and the M_ANGLE_ACCURACY settings in MedgeControl() determine the accuracy used to estimate edgel positions and angles. M_ACCURACY determines edgel positional accuracy, and can be set to one of the following: M_HIGH, M_VERY_HIGH, or M_DISABLE. The default setting is M_HIGH. When you set the accuracy to high, edgel positions are calculated with subpixel accuracy, which is typically sufficient. When you set the accuracy to very high, a mathematical model is used to compensate for the deformation introduced by the square shape of each pixel, resulting in very precise subpixel edgel accuracy. If you want to disable subpixel accuracy and calculate edgels with pixel precision, set M_ACCURACY to M_DISABLE. M_ANGLE_ACCURACY determines the precision with which to estimate edgel angles. By default, MIL uses a high degree of accuracy (M_HIGH), which establishes angles in increments of 360/256 degrees. To speed up the calculation, you can specify a lower degree of accuracy (M_LOW), which establishes angles in increments of 45 degrees. By setting M_ACCURACY to M_HIGH and M_ANGLE_ACCURACY to M_LOW, Edge Finder will compute edgel positions with subpixel accuracy and edgel angles to the closest 45 degree increment. This results in a good estimate of the orientation of the maximum gradient with only a slight reduction in computation time. Edgel accuracy varies with the image's dynamic range, sharpness, noise, and, to a lesser degree, with the orientation of the edge in the image. The best accuracy is achieved in well-contrasted, noise-free images. Theoretically, Edge Finder can provide a subpixel edgel location accuracy of up to 1/128th of a pixel. However, in real situations, it is reasonable to expect an accuracy from 1/10th of a pixel to 1/40th of a pixel, depending on physical limitations due to the transition's dynamic range and the image's noise. You can notice the accuracy of the edgels if you draw the edges of a zoomed region of the source image. To do so, call MgraControl() with appropriate M_DRAW_OFFSET_X, M_DRAW_OFFSET_Y, M_DRAW_ZOOM_X, and M_DRAW_ZOOM_Y values, then call MedgeDraw() with M_DRAW_EDGE. See \"F. Devernay A Fast and Efficient Subpixelic Edge Detector . Mulhouse, France: INRIA. in Quatriemes Journees ORASIS (CNRS), 1993. \" for more information on extracting the subpixel locations of edgels. Magnitude type You can specify the type of magnitude used to determine edgel positions using MedgeControl() with M_MAGNITUDE_TYPE. The magnitude type can be set to either M_NORM, where the gradient magnitude is used, or M_SQR_NORM, where the square of the gradient magnitude is used. The default setting is M_SQR_NORM. Since M_SQR_NORM uses the square of the gradient magnitude, it is faster, though less precise than M_NORM. Typically, M_SQR_NORM is used since it preserves a very good edgel location accuracy. Note that changing M_MAGNITUDE_TYPE can slightly modify the resulting edge map. Filling the edge gaps Edge Finder allows you to fill gaps between edges; that is, it allows you to automatically link the extremities of non-closed edges together, depending on their relative positions and orientations. Unexpected broken edges can occur when dealing with noisy images, and connecting them can significantly improve the quality of your results. To help you choose which edges can be linked, Edge Finder provides a series of constraints, described below. Note that edges will only be linked if they adhere to each constraint. Filling edge gaps can also be done in post-calculation; however, there are some restrictions that must be taken into account. For more information, see the Post-calculation subsection of the Calculating and retrieving results section later in this chapter. Candidate constraint You can choose whether to join an edge extremity with the other extremity of the same edge, or with an extremity of any edge. To connect an edge's extremity with the extremity of any edge, use MedgeControl() with M_FILL_GAP_CANDIDATE set to M_ANY. This is the default value. To connect the edge extremities of the same edge, use MedgeControl() with M_FILL_GAP_CANDIDATE set to M_SAME. This is the same as closing an open edge. The following animation illustrates candidate constraints. Region constraint The M_FILL_GAP_DISTANCE and M_FILL_GAP_ANGLE settings in MedgeControl() define the region where two edge extremities can be linked. That is, when searching for edge extremity candidates to fill edge gaps, M_FILL_GAP_DISTANCE sets the maximum distance radius, while M_FILL_GAP_ANGLE sets the aperture angle; the origin of the aperture angle is the tangent line to the line segment at the point of interest. Note that two edge extremities can only be linked if both meet the M_FILL_GAP_DISTANCE and M_FILL_GAP_ANGLE criteria, and if both are included in the search region of the other. The following animation illustrates region constraints. The gap distance (M_FILL_GAP_DISTANCE) must be specified in pixel units. The gap distance should be set carefully and large values should generally be avoided, otherwise the wrong edges can be connected. Typically, distance values should not exceed 5 pixels; however, if necessary, you can also specify no distance constraint (M_INFINITE). The default M_FILL_GAP_DISTANCE value is 0 (no edge linking) and the default M_FILL_GAP_ANGLE value is 360 degrees (all angles). Polarity constraint When searching for edge extremity candidates, you can also use the M_FILL_GAP_POLARITY control type to specify that only edges with a certain polarity can be linked. The edge's polarity indicates whether edges were established as a transition from light to dark, or vice versa. Two adjacent edgels will have \"same polarity\" if their angles are within a range of 180 degrees, and \"reverse polarity\" if their angles are outside the range of 180 degrees. By default (M_ANY), all edges that meet the distance and angle constraints are considered candidates, regardless of the edge's polarity. If M_FILL_GAP_POLARITY is set to M_SAME, only edges with the same polarity are considered potential candidates. If M_FILL_GAP_POLARITY is set to M_REVERSE, only edges with reverse polarity are considered potential candidates. Note that the M_SAME and M_REVERSE polarity settings are not available for M_CREST Edge Finder contexts. The following animation illustrates polarity constraints. Continuity constraint It is possible that multiple edges meet the distance (M_FILL_GAP_DISTANCE), angle (M_FILL_GAP_ANGLE), and polarity (M_FILL_GAP_POLARITY) settings. When this occurs, you must decide which edges should be linked. To help choose, Edge Finder provides a continuity constraint. The continuity constraint allows you to decide whether the candidate chosen to fill the edge gap is selected according to its proximity or its maximum continuity. To set the continuity constraint, use MedgeControl() with M_FILL_GAP_CONTINUITY. The range of this control varies from 0 to 100. When set to 0, the closest edge extremity is chosen to link edges together. When set to 100, the edge that gives the most continuous result (minimum curvature) is chosen. The default value is 50. In the following example, a candidate must be chosen to fill the gap with edge 1. If the continuity constraint is set to 100, edge 2 will be selected instead of edge 3; even though edge 3 is closer, edge 2 is more continuous. The following animation illustrates continuity constraints. Customizing the edge extraction settings Filter type Infinite Impulse Response (IIR) filters Finite Impulse Response (FIR) filters Smoothing for IIR filters Thresholding Edgel accuracy Magnitude type Filling the edge gaps Candidate constraint Region constraint Polarity constraint Continuity constraint ",
      "wordCount": 2705,
      "subEntries": []
    },
    {
      "id": "UG_edge-finder_Edge_features",
      "version": null,
      "title": "Edge features",
      "subTitles": [
        "Dimension features",
        "Feret diameter",
        "Circle fit and line fit",
        "Ellipse fit",
        "Location features",
        "Advanced features",
        "Convex perimeter",
        "Tortuosity",
        "Moment elongation",
        "Grouped features"
      ],
      "location": "MIL UG P03: 2D processing and analysis",
      "pageURL": "content\\UserGuide\\edge-finder\\Edge_features.htm",
      "text": " Edge features Edge Finder allows you to calculate many edge features that can provide useful information, such as the edge's length and center of gravity. To enable (M_ENABLE) or disable (M_DISABLE) the calculation of a specific edge feature, use MedgeControl(); you can also select a group of features for calculation in a single call. To know the calculation state of a feature, use MedgeInquire(). To retrieve the results of the feature calculation, use MedgeGetResult(). For more information on retrieving results, see the Retrieving the results subsection of the Calculating and retrieving results section later in this chapter. Note that the label feature (M_LABEL_VALUE) is the only edge feature that is enabled by default. The label value is a positive integer greater or equal to one; it is assigned to each edge in an image for identification. Each edge in an image has a unique label value. The label allows you to track or choose particular edges for drawing, edge manipulation, or result retrieval purposes. Typically, you should not disable the edge's label value. Edge features generally fall into one of the following groups: Dimension features (typically very fast to compute). Location features (typically fast to compute). Advanced features (can take some time to compute, due to their complexity). To compute features as efficiently as possible, you should calculate a few features first (preferably, the fastest), and eliminate as many unnecessary edges as possible. Then, post-calculate expensive features on the remaining edges. For more information on how to select and post-calculate edges, see the Calculating and retrieving results section later in this chapter. Note that, occasionally, enabling a feature for calculation will result in another feature being calculated and available for result retrieval. For example, enabling M_MOMENT_ELONGATION for calculation in MedgeControl() will allow you to retrieve the result of M_CENTER_OF_GRAVITY in MedgeGetResult(), even if you have disabled the calculation of the center of gravity. The following subsections list all the Edge Finder features that you can enable or disable for calculation using MedgeControl(), according to dimension, location, and advanced application. There is also a subsection on selecting a group of features for calculation in a single call. Note that only the more complicated features are explained in some detail. For a description of each feature, see MedgeControl() in the MIL Reference. Dimension features The Edge Finder dimension features are: M_CLOSURE M_ELLIPSE_FIT_MAJOR_AXIS M_FERET_X M_CIRCLE_FIT_CENTER_X M_ELLIPSE_FIT_MINOR_AXIS M_FERET_Y M_CIRCLE_FIT_CENTER_Y M_FAST_LENGTH M_FERET_GENERAL M_CIRCLE_FIT_COVERAGE M_FERET_BOX M_FERET_GENERAL_ANGLE M_CIRCLE_FIT_ERROR M_FERET_ELONGATION M_LENGTH M_CIRCLE_FIT_RADIUS M_FERET_MAX_ANGLE M_LINE_FIT_A M_ELLIPSE_FIT_ANGLE M_FERET_MAX_DIAMETER M_LINE_FIT_B M_ELLIPSE_FIT_CENTER_X M_FERET_MEAN_DIAMETER M_LINE_FIT_C M_ELLIPSE_FIT_CENTER_Y M_FERET_MIN_ANGLE M_LINE_FIT_ERROR M_ELLIPSE_FIT_COVERAGE M_FERET_MIN_DIAMETER M_SIZE M_ELLIPSE_FIT_ERROR Feret diameter A Feret diameter of an edge is its diameter at a specific angle. Several Feret diameters are illustrated in the diagram below. Note that the angle at which the Feret diameter is taken (relative to the horizontal axis) is specified as a subscript to F. Some features, such as the edge's maximum Feret diameter, are determined by testing the Feret diameter of the edge at several angles. You can specify the angular range to use to calculate the Feret features, using MedgeControl() with M_FERET_ANGLE_SEARCH_END and M_FERET_ANGLE_SEARCH_START. The search is done in the counter-clockwise direction. To set the number of angles to test within the specified angular range, use MedgeControl() with M_NUMBER_OF_FERETS. The difference between successive angles is (M_FERET_ANGLE_SEARCH_END - M_FERET_ANGLE_SEARCH_START) / M_NUMBER_OF_FERETS . The default number of angles tested is 8, which is typically sufficient. Note that increasing the number of Feret angles increases the accuracy of the results; however, it also increases the processing time. Circle fit and line fit The circle fit is calculated as the circle that best fits the edge, while the line fit is calculated as the line that best fits the edge. To calculate the coordinates of the center of the circle that is the best fit for each edge, use M_CIRCLE_FIT_CENTER_X and M_CIRCLE_FIT_CENTER_Y. To calculate the radius of the circle that is the best fit for each edge, use M_CIRCLE_FIT_RADIUS. To calculate the coefficients A, B, and C that define the line that is the best fit for each edge, use M_LINE_FIT_A, M_LINE_FIT_B, and M_LINE_FIT_C. Note that these coefficients are based on the linear equation, A x + B y + C = 0. To calculate the coverage of the circle fit, use M_CIRCLE_FIT_COVERAGE. The coverage indicates what angular fraction of the fitted circle is subtended by the radii going to the endpoints of the edge. The value returned is between 0.0 and 1.0, inclusive. For example, if the edge is closed, the coverage is 1.0 (100% coverage), for a quarter circle the coverage is 0.25 (25% coverage). Note that since a line is theoretically infinite, it is impractical to calculate its coverage. You can also calculate the error of either the circle fit or line fit using M_CIRCLE_FIT_ERROR or M_LINE_FIT_ERROR, respectively. These values are calculated as the average quadratic error of the fit. Ellipse fit The ellipse fit is calculated as the ellipse that best fits the edge. To calculate the coordinates of the center of the ellipse that is the best fit for each edge, use M_ELLIPSE_FIT_CENTER_X and M_ELLIPSE_FIT_CENTER_Y. To calculate the major and minor axes of the ellipse that is the best fit for each edge, use M_ELLIPSE_FIT_MAJOR_AXIS and M_ELLIPSE_FIT_MINOR_AXIS, respectively. To calculate the angle of the ellipse fit, use M_ELLIPSE_FIT_ANGLE. To calculate the error of the ellipse fit, use M_ELLIPSE_FIT_ERROR. This value is calculated as the average quadratic error of the fit. Location features The Edge Finder location features are: M_BOX M_CENTER_OF_GRAVITY_X M_POSITION_X M_BOX_X_MAX M_CENTER_OF_GRAVITY_Y M_POSITION_Y M_BOX_X_MIN M_CONTACT_POINTS M_X_MAX_AT_Y_MAX M_BOX_Y_MAX M_FIRST_POINT M_Y_MAX_AT_X_MIN M_BOX_Y_MIN M_FIRST_POINT_X M_X_MIN_AT_Y_MIN M_CENTER_OF_GRAVITY M_FIRST_POINT_Y M_Y_MIN_AT_X_MAX The following edge map illustrates where each edge location feature is located: Advanced features The Edge Finder advanced features are: M_AVERAGE_STRENGTH M_MOMENT_ELONGATION M_STRENGTH M_CONVEX_PERIMETER M_MOMENT_ELONGATION_ANGLE M_TORTUOSITY Convex perimeter If you enable the convex perimeter feature (M_CONVEX_PERIMETER), an approximation of the perimeter of each edge's convex hull will be calculated. Abstractly, an edge's convex perimeter is very much like taking a rubber band, and placing it tautly around the edge. The convex perimeter is derived by taking the diameter of the edge at different angles. The greater the number of Ferets used to calculate the diameter, the more accurate the approximation. Use MedgeControl() with M_NUMBER_OF_FERETS to adjust the number of Ferets. Note that increasing the number of Ferets increases the accuracy of the results; however, it also increases the processing time. Tortuosity An edge's tortuosity (M_TORTUOSITY) is the diagonal length of the edge's bounding box (M_BOX), divided by the length of the edge (M_LENGTH). Therefore, a non-tortuous edge (a straight line) will have a tortuosity of 1, while a tortuous edge (a curvy line) will have its tortuosity decreasing towards 0. A tortuosity that is close to 1 is considered low while a tortuosity that is close to 0 is considered high. Moment elongation The moment elongation (M_MOMENT_ELONGATION) is a geometric elongation measure of the edge. It is defined as the ratio of the principal values of the edge's inertial matrix, which corresponds to the principal directions of the edge shape. This can be approximately defined as the ratio between the edge's minimum and maximum moment. The elongation value varies from 0.0 to 1.0. Values closer to 1.0 are considered to have a low elongation, while values closer to 0.0 are considered to have a high elongation. Note that you can also calculate the angle of the principal axis along each edge's moment elongation, using M_MOMENT_ELONGATION_ANGLE. Grouped features The Edge Finder features that allow you to select a group of features for calculation in a single call are: M_ALL_FEATURES M_ELLIPSE_FIT M_BOX M_FERET_BOX M_CENTER_OF_GRAVITY M_FIRST_POINT M_CIRCLE_FIT M_LINE_FIT M_CONTACT_POINTS M_POSITION Each of these features has multiple features associated with it. Therefore, if you enable one of them for calculation, then all the features associated with it will also be enabled. For example, enabling M_CIRCLE_FIT will result in all the circle fit values of each edge to be calculated. This is equivalent to individually enabling each of the following: M_CIRCLE_FIT_CENTER_X, M_CIRCLE_FIT_CENTER_Y, M_CIRCLE_FIT_RADIUS, M_CIRCLE_FIT_ERROR, and M_CIRCLE_FIT_COVERAGE. The features that belong to each group is typically self evident. For a description of each, see MedgeControl(). Edge features Dimension features Feret diameter Circle fit and line fit Ellipse fit Location features Advanced features Convex perimeter Tortuosity Moment elongation Grouped features ",
      "wordCount": 1365,
      "subEntries": []
    },
    {
      "id": "UG_edge-finder_Calculating_and_retrieving_results",
      "version": null,
      "title": "Calculating and retrieving results",
      "subTitles": [
        "Sorting keys",
        "Retrieving the results",
        "Selecting the results",
        "Edge selection based on edge features",
        "Edge selection based on the inter-relationship of edges",
        "Edge selection based on the proximity of the edges to a point",
        "Internal processing buffers",
        "Derivatives",
        "Angles",
        "Magnitude",
        "Source image and mask",
        "Post-calculation",
        "Restrictions",
        "Annotating the results"
      ],
      "location": "MIL UG P03: 2D processing and analysis",
      "pageURL": "content\\UserGuide\\edge-finder\\Calculating_and_retrieving_results.htm",
      "text": " Calculating and retrieving results Once you have allocated an Edge Finder context and result buffer (MedgeAlloc() and MedgeAllocResult()), and have calculated the edge features (MedgeCalculate()), you can retrieve the results from your Edge Finder result buffer, using MedgeGetResult(). After the initial calculation, you can select edges that meet a specified criterion with MedgeSelect(), and post-calculate new features for them. By doing so, you can avoid unnecessarily calculating time-consuming edge features for all edges in a source image. For optimum performance, the source image buffer on which you make calculations should be a 1-band 8-bit unsigned buffer. Other buffer depths and types are generally accepted, but can slightly decrease performance. 3-band source image buffers are also supported, but only when extracting edge contours. When the source image buffer is a 32-bit floating-point buffer, Edge Finder uses floating-point precision calculations. In all cases, you can force the edge processing operations to use floating-point precision by enabling M_FLOAT_MODE in MedgeControl(). Note that changing this processing mode can slightly affect the resulting edge map; also, floating-point precision calculations will typically take more time. Occasionally, an operation can take an unexpectedly long time to calculate. To prevent this, you can use MedgeControl() with M_TIMEOUT to set a maximum edge extraction and calculation time. By default, there is no time limit. Sorting keys The results obtained from MedgeGetResult() can be sorted in ascending or descending order, by a maximum of three features assigned as sorting keys. To specify a feature as a sorting key, add M_SORTn_UP or M_SORTn_DOWN to the feature when selecting it for calculation using MedgeControl(). Assign the numbers 1, 2, or 3 to indicate the sorting precedence of the feature(s). Note that features will only be sorted after an MedgeCalculate(). You can also post-sort edges by assigning a sorting key to a previously calculated edge feature. Note that, although the post-calculation changes the order in which the edges are sorted, it does not change their label values, which were assigned at the edges' initial calculation. For more information on post-calculation, see the Post-calculation subsection of this section. Retrieving the results Edge Finder offers several types of results that provide considerable information on the nature of the extracted edges, such as magnitude and Feret values. This information can be retrieved for all edges or for a specified edge, from your result buffer. Typically, before retrieving any edge feature result, you should first retrieve the number of edges found in the image to determine the size of the result array needed to hold the results. To do so, use MedgeGetResult() with M_NUMBER_OF_CHAINS. Similarly, if you need to retrieve edgel results, such as the edgels' coordinates, magnitude, or angle values, you should also determine the size of the result array needed to hold the results. To do so, you must retrieve the number of extracted edgels for each edge using MedgeGetResult() with M_NUMBER_OF_CHAINED_EDGELS. Edge results are indexed as positive integers starting at 0 and, if applicable, are ordered with respect to the sorting keys. You can also label edges by enabling M_LABEL_VALUE in MedgeControl() (enabled by default). The edge's label value is a positive integer greater than or equal to 1. Each edge in an image is given a unique label value; that is, unlike an edge's index value, an edge's label value will not change, regardless of future operations. Edge Finder allows you to retrieve results for a particular edge or for all edges, using MedgeGetResult(). To retrieve results for a particular edge, you must specify either the edge's index or label value. However, since an edge's index value can change, it is recommended that you specify the label of the edge, especially if you want to perform selection and post-calculation operations. To retrieve results for all edges, you must specify M_ALL as the edge's index or label value. Note that before an edge feature can be returned with MedgeGetResult(), you must first enable the feature for calculation, using MedgeControl(), and then call MedgeCalculate(). Every edge feature, except for the label value (M_LABEL_VALUE), is disabled by default. For more information on edge features, see the Edge features section earlier in this chapter. To verify the availability of an edge feature (if it has been calculated), use MedgeGetResult(), and combine M_AVAILABLE to the specified result type. For a complete description of all possible results, see MedgeGetResult() in the MIL Reference. In general, results are returned in pixels, and coordinates are relative to the center of the top-left pixel in the source image. If you calculate edges using a calibrated source image, results are automatically returned in the output units specified by the associated camera calibration context of the source image. However, you can change the output units to pixel units or world units by setting MedgeControl() with M_RESULT_OUTPUT_UNITS to either M_PIXEL or M_WORLD, respectively. For more information, see Camera Calibration. Note that if your image is calibrated, results are calculated in the real world; therefore, retrieving results in pixel units instead of world units will typically be slower. Also note that, in the presence of distortion, some results are meaningless when converted from real-world to pixel units (for example, the Feret angles). For example, if an edge appears warped in the source image, but the camera calibration context of the source image compensates for this during the extraction, the resulting Feret angles are meaningful in the real-world coordinate system, and meaningless in the pixel coordinate system. Selecting the results If you do not have many unwanted edges, it is usually faster to simply calculate all required features for all edges. However, calculating many features on a large number of unwanted edges can be unnecessarily time-consuming. To speed up this process, you can use MedgeSelect() to select a subset of edges for calculation and result retrieval. Edges that meet the MedgeSelect() selection criteria can be included, excluded, or deleted from the result buffer. Further calculations are subsequently applied to included edges only. Excluded edges can be re-included at any time, while deleted edges are permanently removed from the result buffer. Typically, if you have many unwanted edges, you calculate (for all edges) only those features that allow you to distinguish between wanted and unwanted edges. Then, you exclude the unwanted edges from further calculations, and calculate all the required features for the remaining included edges. To arrive at the required set of results, you can make as many calls as necessary to MedgeSelect() and MedgeCalculate(). Any calculation made to refine results after an initial call to MedgeCalculate() is considered a post-calculation. Post-calculating edges can be an effective way of speeding up processing time, especially if advanced features are only calculated on a small subset of selected edges. For more information on post-calculation, see the Post-calculation subsection of this section. Note that, if at any time you calculate edges in a new source image, all current results will be discarded and replaced by the newly calculated edges. In addition, all selected features will be recalculated for all edges in the new source image. This means that you will have to restart the selection procedure. The MedgeSelect() function can be used to select edges based on one of the following: A calculated edge feature, where the edge selection depends on whether the specified edge feature meets the specified condition. The inter-relationship of edges, where the edge selection depends on whether edges meet the specified box or chain condition of the specified edge or group of edges. The current status of edges, where the edge selection depends on a specific edge, all edges, all included edges, or all excluded edges. These will be included, included only, excluded, excluded only, or deleted. For example, you can include only (M_INCLUDE_ONLY) the excluded edges (M_EXCLUDED_EDGES), which will essentially swap the previously included and excluded edges. The proximity of an edge or edges to a specified point, where the edge selection depends on the specified radius, and the nearest neighbor condition. Note that you can also use MedgeSelect() to crop and select a portion of a specified edge. For more information, see the Advanced edge extraction section later in this chapter. If the edges have been calculated using a calibrated source image, you must specify relevant values in the real world. If the edges have not been calculated using a calibrated source image, you must specify relevant values in pixels. Edge selection based on edge features You can include, exclude, or delete edges based on whether the specified edge feature meets the specified condition. The edge feature used to select the edges must have been previously calculated for the included edges. After several selection and post-calculation operations, an edge feature might not be available or might only be available for a few edges of the included subset. To verify the availability of an edge feature, use MedgeGetResult(), and combine M_AVAILABLE to the specified feature result type. The following code shows you how to apply a selection based on edge features: MedgeSelect(MilResult, M_DELETE, M_MOMENT_ELONGATION, M_LESS, 0.8, M_NULL); In this example, all edges with a moment elongation that is less than 0.8 are deleted. Edge selection based on the inter-relationship of edges You can include, exclude, or delete edges based on whether edges meet the specified box or chain condition. That is, you can include, exclude, or delete all edges that are inside or outside the bounding box of a specified edge or group of edges; similarly, you can include, exclude, or delete all edges that are inside or outside a specified edge or group of edges. Inside and outside chain conditions only take effect when the edge is closed. The following code shows you how to apply a selection based on the inter-relationship of edges: MedgeSelect(MilResult, M_EXCLUDE, M_INCLUDED_EDGES, M_INSIDE_CHAIN, M_NULL, M_NULL); In this example, all edges inside included edges are excluded. Edge selection based on the proximity of the edges to a point You can include, exclude, or delete edges based on their proximity to a specified point. You can select either the closest edge to a point, or all the edges in the specified vicinity of a point. Use MedgeControl() with M_NEAREST_NEIGHBOR_RADIUS to specify the maximum radius distance from the point. The following code shows you how to apply a selection based on the proximity of the edges to a point: MedgeSelect(MilResult, M_INCLUDE_ONLY, M_NULL, M_ALL_NEAREST_NEIGHBORS, Ax, Ay); In this example, only the edges closest to the point A (Ax, Ay), and within the radius r, are included. Internal processing buffers When performing edge extraction, Edge Finder uses internal processing buffers. These can be saved in the Edge Finder result buffer. The internal processing buffers are used when extracting edges. They include image derivative, angle, magnitude, source image, and mask buffers. Some results can only be post-calculated if the appropriate internal buffer(s) have been previously saved in the result buffer. For example, you can only post-calculate the strength of an edge feature if the internal magnitude buffer was initially saved. For more information, see the Post-calculation subsection of this section. Using MedgeControl(), you can set whether the internal processing buffers are saved. By default, the internal processing buffers are not saved (M_DISABLE). You must enable saving them in the result buffer, using MedgeControl(), before the first call to MedgeCalculate(). Saving these buffers does not affect processing time. Even if an internal processing buffer has been saved in the result buffer, you cannot access it directly. You can, however, allocate a new buffer with the same properties as the internal buffer and use MedgeDraw() to copy the contents of the internal buffer into the newly allocated buffer. To copy an internal result buffer you must: Use MedgeGetResult() to get the required information from the internal buffer. You will need the following information about the internal buffer to be cloned: The buffer range and bit depth of the buffer (add M_SIGN or M_SIZE_BIT to the internal buffer, respectively). Alternatively you can add M_TYPE, which returns both. The width and height of the buffer (add M_SIZE_X and M_SIZE_Y to the internal buffer). Allocate your own buffer, which should have the same properties as the internal buffer you want to copy. Use MedgeDraw() to copy the contents of the internal buffer into your own buffer. Derivatives You can save the internal derivative buffers used when extracting edges, in the Edge Finder result buffer. To save the buffers, use MedgeControl() with M_SAVE_DERIVATIVES. The following internal derivative buffers are stored within the Edge Finder result buffer: M_CROSS_DERIVATIVE_ID. This buffer contains the cross derivatives calculated from the source buffer. M_FIRST_DERIVATIVE_X_ID. This buffer contains the first derivatives in X-direction calculated from the source buffer. M_FIRST_DERIVATIVE_Y_ID. This buffer contains the first derivatives in the Y-direction calculated from the source buffer. M_SECOND_DERIVATIVE_X_ID. This buffer contains the second derivatives in the X-direction calculated from the source buffer. M_SECOND_DERIVATIVE_Y_ID. This buffer contains the second derivatives in the Y-direction calculated from the source buffer. Note that you can retrieve the first derivatives in the X- and Y-direction in one call using MedgeGetResult() with M_FIRST_DERIVATIVES_ID. You can also retrieve the second derivatives in the X- and Y-direction in one call using MedgeGetResult() with M_SECOND_DERIVATIVES_ID. Typically, you will let Edge Finder manage its own derivative images to perform the edge extraction. However, you can specify your own derivative image buffers, so that the edge extraction is done with them instead. For more information on derivative images, and how they are used to extract edges, see the Providing the image's derivatives subsection of the Advanced edge extraction section later in this chapter. Angles You can save the internal angle buffer used when extracting edges, in the Edge Finder result buffer, using MedgeControl() with M_SAVE_ANGLE. To retrieve information about the internal angle buffer, use MedgeGetResult() with M_ANGLE_ID. You can also save the angle value of the edge at each edgel position, in the Edge Finder result buffer, using MedgeControl() with M_SAVE_CHAIN_ANGLE; you can retrieve this information using MedgeGetResult() with M_CHAIN_ANGLE. Angle values refer to the angle between the horizontal axis and the edge's perpendicular direction at each edgel location. If you save the chain angle, the angle values of the extracted edges are saved. If you save the angle buffer, the angle values of all the edges in the source image are saved; in this case, the only relevant angle values are those whose edgels have a magnitude that is above the lower-bound threshold value. Angles are returned counter-clockwise and mapped in the range of 0 to 255. That is, 0 corresponds to 0, and 360 corresponds to 256. Note that for edge contours, the ascending gradient angle is returned. For line crests, the strongest gradient angle between 0 and 180 (either ascending or descending) is returned. When extracting edge contours from a color image, the angle of the polarity cannot be obtained. For example, it is impossible to determine if red is darker or lighter than green; therefore, it is impossible to ascertain the direction of the transition. Magnitude You can save the internal magnitude buffer used when extracting edges, in the Edge Finder result buffer, using MedgeControl() with M_SAVE_MAGNITUDE. To retrieve information about the internal magnitude buffer, use MedgeGetResult() with M_MAGNITUDE_ID. You can also save the magnitude value of the edge at each edgel position, in the Edge Finder result buffer, using MedgeControl() with M_SAVE_CHAIN_MAGNITUDE; you can retrieve this information using MedgeGetResult() with M_CHAIN_MAGNITUDE. For object contours, the magnitude is the norm of the gradient vector at the edgel position. For line crests, the magnitude is equal to the maximum eigenvalue of the Hessian matrix at the edgel position. If you save the chain magnitude, the magnitude values of the extracted edges are saved. If you save the magnitude buffer, the magnitude values of all the edges in the image are saved. For more information on magnitude, and how it is used to extract edges, see the Customizing the edge extraction settings section earlier in this chapter. Source image and mask You can save both the source image, and the image used to mask the source image, in the Edge Finder result buffer. To do so, use MedgeControl() with M_SAVE_IMAGE and M_SAVE_MASK, respectively. To retrieve information about the source image buffer, use MedgeGetResult() with M_IMAGE_ID. To retrieve information about the internal mask buffer, use MedgeGetResult() with M_MASK_ID. For more information on masking, see the Masking the edges subsection of the Advanced edge extraction section later in this chapter. Post-calculation To avoid repeatedly calculating time-consuming edge features for all edges in a source image, you can perform post-calculations on included edges of an Edge Finder result buffer to decrease processing time. The operation of selecting edges and adding new features can be repeated until the required result is calculated. Post-calculations are done with the result buffer only; that is, you should not provide a source image to MedgeCalculate(). If you do provide a source image, all current results will be discarded and replaced by the newly calculated edges. In addition, all selected features will be recalculated for all edges in the new source image. Restrictions Typically, anything that can be calculated can also be post-calculated. However, some post-calculations are not valid unless certain values have been initially saved. The internal magnitude buffer (MedgeControl() with M_SAVE_MAGNITUDE) must have been initially saved if you want to post-calculate the following: MedgeControl() with M_AVERAGE_STRENGTH. MedgeControl() with M_STRENGTH. MedgeControl() with M_SAVE_CHAIN_MAGNITUDE. Note that, if any of the values above were initially calculated, and you intend to fill edge gaps during post-calculation, the internal magnitude buffer (M_SAVE_MAGNITUDE) must have been initially saved. The internal angle buffer (MedgeControl() with M_SAVE_ANGLE) must have been initially saved if you want to post-calculate the following: MedgeControl() with M_SAVE_CHAIN_ANGLE. The M_FILL_GAP_POLARITY settings M_SAME or M_REVERSE. Note that, if any of the values above were initially calculated, and you intend to fill edge gaps during post-calculation, the internal angle buffer (M_SAVE_ANGLE) must have been initially saved. Thresholding can also be applied during post-calculation. In this case, all internal processing buffers (M_SAVE_...) must have been initially saved, in MedgeControl(). For more information, see the Thresholding subsection of the Customizing the edge extraction settings section earlier in this chapter. Annotating the results The MedgeDraw() function offers many drawing operations for annotating your results. You can, for example, draw a zoomed region of the edge map that was used to calculate results by specifying the appropriate values for M_DRAW_OFFSET_X, M_DRAW_OFFSET_Y, M_DRAW_ZOOM_X, and M_DRAW_ZOOM_Y, in MgraControl(). The relative origin values must be specified in pixels, and are relative to the coordinates of the top-left corner of the region in the source image, while the scale values specify the X- and Y-scaling factors used to fill the destination buffer. For example: You can also perform many other drawing operations with MedgeDraw(), such as draw a bounding box around each edge, a cross at each edge's center of gravity, or draw a cross at each edgel. In addition, you can draw the operation's numerical value by adding M_DRAW_VALUE to the following drawing operations: M_DRAW_CENTER_OF_GRAVITY, M_DRAW_POSITION, M_DRAW_FERET_MIN, M_DRAW_FERET_MAX, and M_DRAW_FERET_GENERAL. For example, if you add M_DRAW_VALUE to M_DRAW_CENTER_OF_GRAVITY, the center of gravity's coordinates are drawn within parenthesis, and centered above the drawing cross. Typically, all drawing operations in MedgeDraw() can be combined; you can, therefore, draw multiple effects simultaneously. For example, to draw the edge's chains, center of gravity, bounding box, and the source image's internal cross-derivative buffer, you would specify M_DRAW_EDGE + M_DRAW_CENTER_OF_GRAVITY + M_DRAW_BOX + M_DRAW_CROSS_DERIVATIVE. Note that only one internal drawing buffer can be drawn at a time; for example, you cannot combine M_DRAW_ANGLE and M_DRAW_MAGNITUDE in the same operation. You can either use a previously allocated 2D graphics context to control the drawing color, or you can use the default (M_DEFAULT) 2D graphics context. You can either draw directly into the selected image buffer, or non-destructively annotate in a display's overlay buffer. For more information on MIL graphics, see the Overview section of Chapter 25: Displaying an image. Note that, if the edges are calculated using a calibrated source image, Edge Finder takes the camera calibration into account; that is, drawings might be distorted, according to the camera calibration. For example, a straight line (in the world) might be drawn as a curve. For a complete list and explanation of each drawing operation, see MedgeDraw() in the MIL Reference. Calculating and retrieving results Sorting keys Retrieving the results Selecting the results Edge selection based on edge features Edge selection based on the inter-relationship of edges Edge selection based on the proximity of the edges to a point Internal processing buffers Derivatives Angles Magnitude Source image and mask Post-calculation Restrictions Annotating the results ",
      "wordCount": 3418,
      "subEntries": []
    },
    {
      "id": "UG_edge-finder_Advanced_edge_extraction",
      "version": null,
      "title": "Advanced edge extraction ",
      "subTitles": [
        "Approximating the edges ",
        "Masking the edges ",
        "Cropping the edges ",
        "Advanced thresholding",
        "Providing the image's derivatives ",
        "Putting data into an Edge Finder result buffer ",
        "Finding the closest edgels to a list of points ",
        "Location-based constraints ",
        "Edgel-based constraints "
      ],
      "location": "MIL UG P03: 2D processing and analysis",
      "pageURL": "content\\UserGuide\\edge-finder\\Advanced_edge_extraction.htm",
      "text": " Advanced edge extraction In addition to the fundamental edge extraction settings, Edge Finder provides advanced settings that allow you to write customized applications. Edges can be approximated, masked, cropped, and extracted using advanced thresholding settings. You can provide your own derivative images, and you can put data from user-supplied arrays into an Edge Finder result buffer. You can also get edgels, from an Edge Finder result buffer, which are the closest neighbors to a list of user-specified edgel coordinates. Approximating the edges If you are interested in a basic, geometric representation of the edge map, you can approximate your edges by specifying a polygonal segmentation. To do so, set MedgeControl() with M_CHAIN_APPROXIMATION to M_LINE. The default setting is M_DISABLE. When M_CHAIN_APPROXIMATION is set to M_LINE, each edge is piecewise approximated using a connected series of straight line segments, commonly called polylines. The polylines are defined by the set of automatically calculated vertex coordinates, which determine the location of the line segment ending points. Use MedgeGetResult() to retrieve the X- (M_VERTICES_X) and Y- (M_VERTICES_Y) coordinates of the vertices. This information can be retrieved for either a group of edges or a particular edge. You can also get the index of each vertices' corresponding edge or edgel, using MedgeGetResult() with M_VERTICES_CHAIN_INDEX and M_VERTICES_INDEX, respectively. The resolution of the edge approximation can be adjusted using MedgeControl() with M_APPROXIMATION_TOLERANCE. The range of this control varies from 0 to 100. When set to 0, a very fine approximation of the edges is performed. When set to 100, a coarse approximation of the edges is performed. The default value is 50. The following animation shows the effects of chain approximation. When M_CHAIN_APPROXIMATION is set to M_LINE, both the edge map and the edge approximation is calculated. When M_CHAIN_APPROXIMATION is disabled, only the edge map is calculated. Masking the edges The MedgeMask() function allows you to apply a mask to the source image of the Edge Finder operation. A mask is a binary image used to define irrelevant, inconsistent, or featureless areas in the source image. As a result, when a mask is set, subsequent calls to MedgeCalculate() will only extract edges in the source image's unmasked regions. To set a mask, you must specify an image buffer (also known as a mask buffer) that identifies the masked pixels, using MedgeMask(). A masked pixel in the source image corresponds to a non-zero value in the mask buffer. Mask buffers are useful for creating non-rectangular areas to be processed. For rectangular areas, it is more effective to set a mask with child buffers. For more information, see the Using child buffers, ROIs, or a copy to manipulate specific data areas section of Chapter 23: Data buffers. If necessary, you can remove the mask by setting the mask buffer identifier to M_NULL. You can also mask edges during post-calculation. To do so, you must apply the mask after the initial call to MedgeCalculate(). In this case, masked edges are excluded from the result buffer and subsequent calculations. Note that partially masked edges are cropped. Cropping the edges Selecting an edge or a group of edges for calculation and result retrieval is typically sufficient for the majority of cases. However, in some advanced applications, you might only be interested in one part of a single edge. In this case, you can use MedgeSelect() with M_CROP_CHAIN. Cropping an edge essentially means splitting one edge into two, thereby allowing you to choose only one of the edges to be included, excluded, or deleted from the Edge Finder result buffer. The selected portion receives a new label value, while the other portion keeps the original label value. You can make as many cropping operations as necessary to arrive at the required set of results. Note that all calculated edge features are updated after each cropping operation. To split an edge into two edges, you must specify the following: The edge to split. This is identified by the edge's label value. The point at which to split the edge. This is identified by the edgel's index value. The portion of the edge to select. This is identified by all edgels in the specified edge with index values that are greater than, less than, greater than or equal to, or less than or equal to, the point at which the edge was split. The following code shows you how to crop and exclude a portion of the currently included edge labeled 5. The code also shows how to crop and include a portion of the currently excluded edge labeled 3: MedgeSelect(MilResult, M_EXCLUDE, M_CROP_CHAIN, M_GREATER, 5, 24); MedgeSelect(MilResult, M_INCLUDE, M_CROP_CHAIN, M_GREATER, 3, 18); The following animation demonstrates the above code snippet: The edge labeled 5 is split into two edges at edgel 25. One edge consists of all edgels ranging from the start of edge 5 to the 24th edgel; this edge keeps the label 5 and is not selected for exclusion. The other edge consists of all edgels ranging from the 25th edgel to the end of edge 5; this edge gets a new label value and is selected for exclusion. The edge labeled 3 is split into two edges at edgel 18. One edge consists of all edgels ranging from the start of edge 3 to the 18th edgel; this edge keeps the label 3 and is not selected for inclusion. The other edge consists of all edgels ranging from the 18th edgel to the end of edge 3; this edge gets a new label value and is selected for inclusion. Advanced thresholding Edge Finder uses a hysteresis thresholding method to perform the edge extraction. That is, edge chains are extracted such that the magnitude values of all connected edgels are stronger than the lower bound threshold value, and at least one edgel in each edge chain has a magnitude that is stronger than the upper bound threshold value. For more information on thresholding, and on setting these bounds, see the Thresholding subsection of the Customizing the edge extraction settings section earlier in this chapter. Edge Finder also allows you to customize the behavior of the hysteresis thresholding using the MedgeControl() with M_THRESHOLD_TYPE. That is, M_THRESHOLD_TYPE allows you to set how the upper and lower bound threshold values will be used (as opposed to setting the bounds themselves). If you set M_THRESHOLD_TYPE to M_HYSTERESIS, both the lower bound threshold value and the upper bound threshold value will be used. This is the default setting. If you set M_THRESHOLD_TYPE to M_NO_HYSTERESIS, the lower bound threshold value is ignored, and is considered to be equal to the upper bound threshold value. If you set M_THRESHOLD_TYPE to M_FULL_HYSTERESIS, only the upper bound threshold value is used; the lower bound threshold value is ignored, and is considered to be 0. In this case, the extracted edges are sets of connected edgels such that the magnitude of at least one edgel in each edge is stronger than the upper bound threshold value. This type of thresholding can be used to extract edges in noise-free highly multi-contrast images. Providing the image's derivatives Typically, you will let Edge Finder manage its own derivative images to perform the edge extraction. However, you can specify your own derivative image buffers, so that the edge extraction is done with them instead. In this case, when you call MedgeCalculate(), set the source image to M_NULL, and specify the required derivative image buffers instead. For example: MedgeCalculate(MilEdgeContext, M_NULL, DerivX, DerivY, M_NULL, MilResult, M_DEFAULT); Note that, when specifying your own derivative image buffers, the majority of the processing control settings remain in effect, except for filter settings (for example, M_FILTER_SMOOTHNESS). Derivative image buffers must be 1-band 16-bit signed or 1-band 32-bit floating-point buffers. In addition, all derivative image buffers must be consistent (for example, they must have the same scaling factor), and they must be of the same type and size. When the derivative image buffers are 32-bit floating-point buffers, Edge Finder uses floating-point precision calculations. When extracting object contours, you must provide the image's first derivatives in both the X- and Y-directions. Note that the image derivatives must be consistent with the image axis; that is, if the intensity transition in the source image increases (from black to white) with the axis directions, the associated derivative values must be positive. Similarly, if the intensity transition in the source image decreases (from white to black) with the axis directions, the associated derivative values must be negative. When extracting line crests, you must provide the image's second derivatives in both the X- and Y-direction, as well as the image's cross derivative. Note that the image derivatives must be consistent with the image axis; that is, a light line crest in the source image must result in negative second derivative values. Similarly, a dark line crest in the source image must result in positive second derivative values. Putting data into an Edge Finder result buffer Typically, you will use the Edge Finder result buffer to hold edge extraction information after an edge selection and calculation. However, Edge Finder also allows you to copy data from user-supplied arrays into an Edge Finder result buffer, using MedgePut(). This can be useful if you want to construct an Edge Finder result buffer that cannot be obtained from one image. You can therefore combine results from multiple Edge Finder result buffers to, for example, build a complete model to add to a Model Finder context. For more information, see the Defining and adding models to your Model Finder context section of Chapter 8: Geometric Model Finder. Note that once edges are added to the Edge Finder result buffer, their features can be calculated with MedgeCalculate(). If edgels are calculated with pixel accuracy, you must provide edgels with coordinates that are integer values; in this case, the distance between consecutive edgels should be one pixel. If edgels are calculated with subpixel accuracy, you can provide edgels with coordinates that are double values; in this case, the distance between consecutive edgels is such that, each pixel touched by the edge corresponds to one edgel. To change the accuracy with which edgels are calculated, use MedgeControl() with M_ACCURACY. To add data to an Edge Finder result buffer, you must use MedgePut() to specify the following user-supplied arrays: The X-coordinate(s) of the edgel(s). The Y-coordinate(s) of the edgel(s). You must also specify the number of edgels that you want to add to the Edge Finder result buffer. If necessary, you can also provide arrays containing the index of the edge each edgel belongs to, the orientation of the edgel and the magnitude of the edgel. The information that you provide about the edges to add to the Edge Finder result buffer must be ordered on an edge by edge basis. For example, the following table illustrates how to supply X- and Y-coordinates for three distinct edges; note that the index provided is that of the edge each edgel belongs to: Array of X-coordinates Array of Y-coordinates Array of edge indices 1 2 1 2 3 1 2 4 1 3 3 1 1 9 2 2 9 2 2 8 2 4 6 3 5 6 3 Finding the closest edgels to a list of points From an Edge Finder result buffer, you can retrieve the coordinates of edgels that correspond to the closest neighbors from a list of user-specified source point coordinates. You must use MedgeGetNeighbors() to specify your input data, which must include the source points and, if necessary, a corresponding angle for each point. You can also set a series of constraints to which potential results (edgel candidates) must adhere before being returned. Only edgels that meet all constraints (if any are set) can be returned as the closest neighbors. To set the constraint(s), use MedgeControl(). You can either set simple constraints, advanced constraints, or both. Simple constraints are based on the location of the edgel candidate (the search region), while advanced constraints are typically based on the inner properties of the edgel candidate (the gradient angle). When applying constraints, you should first set the ones based on location. This will establish the search region in the Edge Finder result buffer, and generate a group of edgel candidates. If you do not apply any edgel-based constraints, then the candidates in this region that are closest to the source points will be returned. However, if you set advanced constraints, then only the edgels in this region that also adhere to these constraints can be returned. Advanced constraints are typically based on the source edgel's gradient angle. In this case, you must provide an angle value for each source point as part of your input data for MedgeGetNeighbors(). Therefore, the candidate edgel will only be returned if its gradient angle adheres to the constraint applied with the source angle. Note that an edgel's gradient angle is perpendicular to the edge, and is dependent on the edge extraction process. For more information on an edgel's gradient angle, see the How edges are calculated subsection of the Extracting the edges section earlier in this chapter. Location-based constraints You can use location-based constraints to limit the area within the Edge Finder result buffer from which edgels matching source points can be found. All edgels that do not fall within this area will be ignored. By default, the search region encompasses all edgels within the Edge Finder result buffer. The following MedgeControl() control types can be used to specify location-based constraints: M_SEARCH_ANGLE. M_SEARCH_ANGLE_SIGN. M_SEARCH_ANGLE_TOLERANCE. M_SEARCH_RADIUS_MAX. M_SEARCH_RADIUS_MIN. The maximum (M_SEARCH_RADIUS_MAX) and minimum (M_SEARCH_RADIUS_MIN) search radius constraints set the maximum and minimum distance radii in the Edge Finder result buffer that will be searched for the closest edgels. These values must be set in pixels. You must use MedgeGetNeighbors() to specify the source point from which the radii are measured. Together, M_SEARCH_RADIUS_MAX and M_SEARCH_RADIUS_MIN define a ring-like region, in the Edge Finder result buffer, that will be used to find the closest edgels. All edgels that fall outside this ring will be ignored. By default, the minimum distance radius is 0 pixels, and the maximum distance radius is an infinite number of pixels (M_INFINITE); that is, by default, the entire Edge Finder result buffer will be searched. Note that the M_INFINITE setting will retrieve all the closest edgels (one edgel per edge). The Edge Finder result buffer region that will be searched for the closest edgels can be further constrained to an angular sector within the area defined by the radius constraints (M_SEARCH_RADIUS_...). You can use M_SEARCH_ANGLE to define the search angle, and M_SEARCH_ANGLE_TOLERANCE to define the tolerance. The search angle is relative to the source angle set with MedgeGetNeighbors(), and the tolerance is applied to the resulting angle evenly; that is, half of the tolerance angle is applied in the positive direction, and half is applied in the negative direction. All edgels that are located within this angular sector (tolerance) can be returned. Any value between 0.0 to 360.0 can be set for both the search angle and tolerance. By default, M_SEARCH_ANGLE is set to 0.0 and M_SEARCH_ANGLE_TOLERANCE is set to 360.0 degrees; therefore, all edgels will be considered. For example, if you set M_SEARCH_ANGLE to 30.0, M_SEARCH_ANGLE_TOLERANCE to 30.0, and the source angle to 15, only edgels that fall between 30.0 and 60.0 will be considered. You can also set the sign of the angle that will be used to find the closest edgels with M_SEARCH_ANGLE_SIGN. The sign of the angle can be the same as (M_SAME) or the reverse of (M_REVERSE), the source angle set with MedgeGetNeighbors(). The default is M_SAME. The sign can also be set to M_SAME_OR_REVERSE, which means that it can be the same as, or the reverse of, the source angle. For example, if you set the source angle to 15, and the search angle and tolerance to 30.0, then edgels that fall within an angle that has the same sign would be located between 30.0 and 60.0, edgels that fall within an angle that has a reverse sign would be located between 210 and 240, and edgels that fall within an angle that has any sign would be located at either between 30.0 and 60.0, or between 210 and 240. Note that, if necessary, you can allow a point between two edgels to be returned, using M_GET_SUBEDGELS in MedgeGetNeighbors(). In this case, an edgel candidate is returned, as long as an edge (and not necessarily an edgel) is located within the search region. Edgel-based constraints As mentioned, location-based constraints limit the region in the Edge Finder result buffer that will be searched for the closest edgels. Edgel-based constraints, on the other hand, are applied to the edgels themselves. Only edgels that adhere to these constraints can be returned. Note that, if you have applied location-based constraints, only edgels within the defined search region will be considered. The following MedgeControl() control types are used to specify edgel-based constraints: M_NEIGHBOR_MAXIMUM_NUMBER. M_NEIGHBOR_MINIMUM_SPACING. M_NEIGHBOR_ANGLE. M_NEIGHBOR_ANGLE_TOLERANCE. The maximum number constraint (M_NEIGHBOR_MAXIMUM_NUMBER) sets the maximum number of closest edgels (that is, the N closest edgels) that can be returned, for each source point. The default maximum number is 1; therefore, the edgel closest to each source point is returned. The minimum spacing constraint (M_NEIGHBOR_MINIMUM_SPACING) sets the minimum distance separating closest edgel candidates within the same edge. Therefore, edgels that are too close together will not be returned. The spacing is set in number of edgels and must be greater than or equal to 1. The default minimum spacing is infinite (M_INFINITE), which means that there is no minimum distance (number of edgels) that must separate edgel candidates. The neighbor's angle constraint (M_NEIGHBOR_ANGLE) sets the gradient angle that an edgel must have, before being considered a candidate. M_NEIGHBOR_ANGLE is based on a source angle (for each source point), set with MedgeGetNeighbors(). The gradient angle of the edgel candidate can be the same (M_SAME), the reverse (M_REVERSE), or the same or reverse (M_SAME_OR_REVERSE) as the angle of the source point. The constraint can also be set to any angle (M_ANY); in this case, the source angle and the source point are ignored. The default is M_ANY. Note that M_NEIGHBOR_ANGLE can only be used if the M_SAVE_ANGLE internal buffer was initially saved. You can also set an angular tolerance for M_NEIGHBOR_ANGLE using M_NEIGHBOR_ANGLE_TOLERANCE. In this case, candidate edgels that have a gradient angle that falls within the specified angular range (tolerance) can be returned. The tolerance is applied to the M_NEIGHBOR_ANGLE value evenly; that is, half of the tolerance angle is applied in the positive direction, and half is applied in the negative direction. Any angle between 0.0 to 360.0 can be set as a tolerance. By default, M_NEIGHBOR_ANGLE_TOLERANCE is set to 180.0; therefore, only candidate edgels that have a gradient angle that is the same as the source angle will be considered. Note that setting M_NEIGHBOR_ANGLE_TOLERANCE to 360.0 is equivalent to setting the neighbor angle constraint to M_ANY; in either case, edgels with any gradient angle are considered. For example, if you set the angle of the source point to 45, M_NEIGHBOR_ANGLE to M_SAME_OR_REVERSE, and M_NEIGHBOR_ANGLE_TOLERANCE to 90, only edgels that have an angle between 0 and 90 or between 180 and 270 can be returned. In the following example, edgels 1 and 3 are considered the closest edgel candidates. Advanced edge extraction Approximating the edges Masking the edges Cropping the edges Advanced thresholding Providing the image's derivatives Putting data into an Edge Finder result buffer Finding the closest edgels to a list of points Location-based constraints Edgel-based constraints ",
      "wordCount": 3239,
      "subEntries": []
    },
    {
      "id": "UG_edge-finder_Optimizing_edge_extractions",
      "version": null,
      "title": "Optimizing edge extractions",
      "subTitles": [
        "Specify an area to process",
        "Perform post-calculation",
        "Optimize your control type settings",
        "Adjust the accuracy",
        "Building edge chains",
        "Adjust the extraction scale",
        "Specifying the IIR filter mode",
        "Specify the smoothness",
        "Specify the magnitude",
        "Setting the threshold",
        "Calculating the length of each edge",
        "Limiting the search radius",
        "Retrieving calibrated results"
      ],
      "location": "MIL UG P03: 2D processing and analysis",
      "pageURL": "content\\UserGuide\\edge-finder\\Optimizing_edge_extractions.htm",
      "text": " Optimizing edge extractions There are some things that you can do to optimize the edge extraction and/or speed up the calculation process: Specify an area to process. Perform post-calculations to calculate expensive features. Optimize your control type (MedgeControl()) settings. Retrieve calibrated results in world units. Specify an area to process Specify an area to process that contains all necessary edges. You can specify an area using a child buffer. All edgels that fall outside the area will be ignored, speeding up the edge extraction. For non-rectangular areas, you can specify the appropriate area using a mask (MedgeMask()). For more information on setting an area, see the Using child buffers, ROIs, or a copy to manipulate specific data areas section of Chapter 23: Data buffers, or the Masking the edges subsection of the Advanced edge extraction section earlier in this chapter. Perform post-calculation To compute features as efficiently as possible, you should calculate a few features first (preferably, the fastest), and eliminate as many unnecessary edges as possible. Then, post-calculate expensive features on the remaining edges. The process of calculating features and eliminating unnecessary edges can be repeated until the required result is calculated. Post-calculation greatly decreases processing time since MIL won't have to calculate the most time-consuming edge features for all edges. For more information on post-calculation, see the Post-calculation subsection of the Calculating and retrieving results section earlier in this chapter. Optimize your control type settings To compute features as efficiently as possible, you should optimize your MedgeControl() control type settings. Some settings result in faster calculations (MedgeCalculate()). Note that faster calculations do not mean better results and your application might require settings that take longer to calculate. Adjust the accuracy Use the minimum required accuracy (M_ACCURACY); decreasing the accuracy increases the speed of the calculation process. Disabling M_ACCURACY results in pixel precision, which although not very precise, is typically sufficiently accurate when extracting the edges of large objects. By default, the accuracy is set to M_HIGH; this results in subpixel edgel accuracy, but typically a slower calculation process. For more information on setting the accuracy, see the Edgel accuracy subsection of the Customizing the edge extraction settings section earlier in this chapter. Building edge chains If possible, reduce the detail level of edge chains by disabling M_CHAIN_ALL_NEIGHBORS. Disabling this control type increases the speed of the calculation but reduces the level of detail present in the edge chains. Enabling this control type results in slower calculations; however, the edge chains contain the most amount of edgel information possible. Note that by default, this control type is disabled. For more information on edge chains, see the Basics of edge extraction subsection of the Extracting the edges section earlier in this chapter. Adjust the extraction scale If possible, reduce the scale of the image when extracting edges, by setting M_EXTRACTION_SCALE to a value between 0.0 and 1.0. Reducing the extraction scale can increase the speed at which edges are found and extracted. Note however, this can result in less reliable results, including the loss of important details and/or reduced accuracy of the extraction results. An extraction scale greater than 1.0 will slow down the extraction. Once the edge extraction is complete, the results are scaled to the original scale of the image. Note that the default setting of 1.0 usually provides the most accurate search results. Specifying the IIR filter mode When using an IIR filter, it is generally faster to implement the filtering operation recursively, unless you implement it using kernel mode with a very small convolution kernel (for example, 3x3). If you use kernel mode with a large kernel, the calculation will be slower, although more accurate. Note that if you have dedicated hardware performing the operation, it is typically faster to use a convolution kernel. For more information on filters, see the Customizing the edge extraction settings section earlier in this chapter. Specify the smoothness If your image contains a lot of noise, increase the smoothness factor (M_FILTER_SMOOTHNESS). Increasing the smoothness factor reduces the noise, resulting in the edge extraction operation extracting fewer unwanted edges. This will typically decrease the time it takes to extract the edges. Be aware that in kernel mode, increasing the smoothness factor can increase the size of the convolution kernel, which increases the processing time. Note that a very high smoothing level can result in a loss of important detail and a decrease in precision. For more information on specifying the smoothness factor, see the Smoothing for IIR filters subsection of the Customizing the edge extraction settings section earlier in this chapter. Specify the magnitude Use the square of the gradient magnitude, by setting M_MAGNITUDE_TYPE to M_SQR_NORM. This optimizes the edge extraction while preserving a very good edgel result. M_SQR_NORM is calculated faster than M_NORM, but is less accurate. Note that for M_MAGNITUDE_TYPE, the default is M_SQR_NORM for contour Edge Finder contexts, and the default is M_NORM for crest Edge Finder contexts. For more information on the magnitude type, see the Magnitude type subsection of the Customizing the edge extraction settings section earlier in this chapter. Setting the threshold Use the highest possible threshold (M_THRESHOLD_MODE) that still detects all pertinent edgels. The lower the threshold, the more sensitive the edgel detection; that is, more edgels are detected. The default threshold mode is M_HIGH. For more information on thresholding, see the Thresholding subsection of the Customizing the edge extraction settings section earlier in this chapter. Calculating the length of each edge Calculate the length of each edge using M_FAST_LENGTH. M_FAST_LENGTH gives a coarser but faster approximation of the edge's length than M_LENGTH. For more information on calculating the length, see M_FAST_LENGTH and M_LENGTH in MedgeControl(). Limiting the search radius When retrieving the coordinates of edgels using MedgeGetNeighbors(), limit the search region using M_SEARCH_RADIUS_MAX, M_SEARCH_RADIUS_MIN, and M_SEARCH_ANGLE_TOLERANCE. All edgels that fall outside this region will be ignored, speeding up the edge extraction. For more information on setting the search radius, see the Location-based constraints subsection of the Advanced edge extraction section earlier in this chapter. Retrieving calibrated results If your image is calibrated, retrieve results in world units. Retrieving results in pixel units will typically be slower. Also note that, in the presence of distortion, some results are meaningless when converted from real-world to pixel units (for example, the Feret angles). For more information, see the Camera calibration - overview section of Chapter 28: Calibrating your camera setup. Optimizing edge extractions Specify an area to process Perform post-calculation Optimize your control type settings Adjust the accuracy Building edge chains Adjust the extraction scale Specifying the IIR filter mode Specify the smoothness Specify the magnitude Setting the threshold Calculating the length of each edge Limiting the search radius Retrieving calibrated results ",
      "wordCount": 1118,
      "subEntries": []
    },
    {
      "id": "UG_edge-finder_Interfacing_with_the_Geometric_Model_Finder_module",
      "version": null,
      "title": "Interfacing with Geometric Model Finder or Advanced Geometric Matcher",
      "subTitles": null,
      "location": "MIL UG P03: 2D processing and analysis",
      "pageURL": "content\\UserGuide\\edge-finder\\Interfacing_with_the_Geometric_Model_Finder_module.htm",
      "text": " Interfacing with Geometric Model Finder or Advanced Geometric Matcher The MIL Model Finder and Advanced Geometric Matcher (AGM) modules allow you to define models from an Edge Finder result buffer or find model occurrences in an Edge Finder result buffer. If you want to use Model Finder or AGM, and are also familiar with Edge Finder, you can perform specialized edge selections, which can reduce the unnecessary geometric complexity in both the model and/or the target image. For example, if you want to find model occurrences in an Edge Finder result buffer, you can use MedgeSelect() to select which edges to include in the buffer, based on one of several criteria. As a result, Model Finder/AGM will have much less information to analyze, thereby potentially speeding up the search for the model(s). Another way to speed up Model Finder's search for model(s) in the result of an edge extraction is to specify a lower scale for the edge extraction, using M_EXTRACTION_SCALE in MedgeControl(). M_EXTRACTION_SCALE must be set before calling MedgeCalculate(). Be aware that reducing the extraction scale can result in less reliable results, including, the loss of important details and/or can reduce the accuracy of the search result. Note that M_EXTRACTION_SCALE sets or returns the scale of the image at which to do the edge extraction. Once the extraction is complete, the results are scaled to the original scale of the image. Note that this does not apply to AGM. For use with AGM, M_EXTRACTION_SCALE must be set to 1 (default); otherwise, you will get a MIL error. To have further control over the edges that Model Finder/AGM uses, you can allocate an Edge Finder result buffer and add the required edge chains to the result buffer, using MedgePut(). This allows you to combine results from multiple result buffers, or create a target that contains user-defined edge chains. Note that you do not need to call MedgeCalculate() after adding edge chains to a result buffer. For more information on adding edge chains, see the Putting data into an Edge Finder result buffer subsection of the Advanced edge extraction section earlier in this chapter. Models and target images should use the same edge types (object contours or line crests). Therefore, if the target edges are object contours, the model edges must be object contours; if the target edges are line crests, the model edges must be line crests. If you expect to use an Edge Finder result buffer with Model Finder or AGM, you must enable M_MODEL_FINDER_COMPATIBLE or M_AGM_COMPATIBLE in MedgeControl() before the initial call to MedgeCalculate(). To add models defined from an Edge Finder result buffer to a Model Finder context, use M_EDGE_RESULT in MmodDefine(). To add a model defined from an Edge Finder result buffer to an AGM context, use M_EDGE_RESULT in MagmDefine(). To set the sensitivity with which edgels are detected, Edge Finder users can use MedgeControl() with either M_THRESHOLD_MODE or M_DETAIL_LEVEL. M_DETAIL_LEVEL helps users already familiar with Model Finder. This control type should only be used when interfacing with Model Finder or AGM. In MedgeControl(), the M_DETAIL_LEVEL setting overrides the M_THRESHOLD_MODE setting. The following is an example of a typical Edge Finder/Model Finder application: For more information on Model Finder, see the Geometric Model Finder module section of Chapter 8: Geometric Model Finder. For more information on AGM, see the Advanced Geometric Matcher module section of Chapter 9: Advanced Geometric Matcher. Interfacing with Geometric Model Finder or Advanced Geometric Matcher ",
      "wordCount": 575,
      "subEntries": []
    },
    {
      "id": "UG_edge-finder_MIL_Edge_Finder_example",
      "version": null,
      "title": "MIL Edge Finder example",
      "subTitles": null,
      "location": "MIL UG P03: 2D processing and analysis",
      "pageURL": "content\\UserGuide\\edge-finder\\MIL_Edge_Finder_example.htm",
      "text": " MIL Edge Finder example The Edge Finder example MEdge.cpp illustrates how the module can be used with the following source image: Specifically, MEdge.cpp shows how to define an Edge Finder context to extract and select object contours in the above source image. medge.cpp To run this example, use the Matrox Example Launcher in the MIL Control Center. MIL Edge Finder example ",
      "wordCount": 63,
      "subEntries": []
    }
  ]
}]
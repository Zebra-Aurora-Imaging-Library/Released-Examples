[{
  "id": "UG_calibration",
  "version": "2024020714",
  "title": "Calibrating your camera setup",
  "subTitles": null,
  "location": "MIL UG P04: 2D related information",
  "pageURL": "content\\UserGuide\\calibration\\ChapterInformation.htm",
  "text": " Chapter 28: Calibrating your camera setup This chapter describes how to use MIL's Calibration module. Camera calibration - overview Types of distortions Camera calibration mechanism Steps to performing a camera calibration Basic concepts for the MIL Camera Calibration module Coordinate systems Absolute world coordinate system Relative world coordinate system Tool coordinate system Camera coordinate system Robot base coordinate system Pixel coordinate system Camera calibration modes Uniform camera calibration and other 2D camera calibration modes Uniform mode Piecewise linear interpolation mode Perspective transformation mode 3D camera calibration modes Tsai-based mode Robotics mode Moving camera robotics mode Stationary camera robotics mode Steps to perform camera calibration in a 3D robotics mode Camera calibration propagation Processing calibrated images Saving and reloading a calibrated image Saving the calibration with the image file Saving the associated camera calibration context in a separate file Working with real-world units Getting results in world units Input settings in world units Angle convention in MIL Calibrating using calibration points from a grid Requirements for the image of the grid Requirements for the image of a circle grid Requirements for the image of a chessboard grid Defining the absolute coordinate system Determining the grid's reference calibration point Using the X- and Y-offsets Inverting the orientation of the Y-axis Calibrating with a partial chessboard grid Defining the relative coordinate system directly Calibrating a Tsai based camera calibration context when the camera is directly overhead Calibrating using a fiducial grid Requirements when calibrating your camera setup using a fiducial grid Defining the absolute coordinate system with a fiducial grid Determining the grid's reference calibration point Orientation of the fiducial grid in the image Specifying the position and orientation of the absolute coordinate system when calling McalGrid() Inquiring camera calibration information after successful calibration Calibrating multiple cameras or camera positions using a fiducial grid Multi-fiducial grids Calibrating using calibration points from a list Inquiring about your camera calibration Camera calibration status and errors Camera calibration accuracy Addressing calibration error due to problems finding calibration points Addressing calibration error due to problems creating the mapping function Inquiring pixel and world calibration points Position and orientation of coordinate systems Pinhole camera Physically correcting an image Generating lookup tables to correct images Scale and position of the corrected image Transformation cache Moving coordinate systems to reflect camera setup changes Types of transformation Translation Rotation Transforming coordinate systems Moving the camera after calibrating with a 3D-based camera calibration context Special considerations concerning the tool and camera coordinate systems Calibrating a camera setup that analyzes large objects Single camera fixed on a movable tool (manipulator): tool coordinate system example Single camera and movable object: relative coordinate system example Several fixed cameras and fixed object: grid offset example Propagating camera calibration information after performing a geometric operation How coordinates and non-positional results are transformed Transforming from the pixel to a specified world coordinate system Transforming from the world to the pixel coordinate system Transforming from one world coordinate system to another Generating unit vectors from the pixel coordinate system (or vice versa) Transforming coordinates from a depth map to a world coordinate system (or vice versa) Using piecewise linear camera calibrations Transforming Results Generating a grid for calibration Generating a grid using CalGenChessGrid Specifying the physical setup Specifying the grid's fiducials Printing the grid Adding printed fiducials to an existing chessboard grid ",
  "wordCount": 555,
  "subEntries": [
    {
      "id": "UG_calibration_Calibration_overview",
      "version": null,
      "title": "Camera calibration - overview",
      "subTitles": [
        "Types of distortions",
        "Camera calibration mechanism"
      ],
      "location": "MIL UG P04: 2D related information",
      "pageURL": "content\\UserGuide\\calibration\\Calibration_overview.htm",
      "text": " Camera calibration - overview MIL's Camera Calibration module (Mcal...()) allows you to map pixel coordinates to real-world coordinates. Camera calibration relates pixels to real locations and distances. For example, you could create the following relationship between a pixel and its size and location in the real world. This mapping can be used to get results from other MIL modules in real-world units or to input information to some modules in real-world units. The mapping can also be used to physically correct an image's distortions. By getting results in real-world units, you automatically compensate for any distortions in an image. Therefore, you can get accurate results despite an image's distortions. Defining the pixel-to-world mapping is known as camera calibration. A camera calibration context is used to hold the defined mapping, as well as certain control settings. Once you have created your camera calibration context, you can use it to: Transform pixel coordinates or results to their real-world equivalents. Physically correct an image. Automatically get results from applicable MIL processing and analysis modules in real-world units. Input values to applicable MIL analysis modules in real-world units. Camera calibration maps pixels of images to one plane in the real world. Using only the Camera Calibration module is not enough to obtain data about the depth of different points in your images. To retrieve depth information from your two-dimensional images, you must perform a 3D Reconstruction. Types of distortions You can use calibration if you have one or more of the following types of distortion: Non-unity aspect ratio distortion. Present when the X- and Y-axes have two different scale factors. This is evident, for example, if you know that the object in your image should be round and it appears as an ellipse. Rotation distortion. Present when the camera is perpendicular to the object grabbed in the image, but not aligned with the object's axes. Perspective distortion. Present when the camera is not perpendicular to the object grabbed in the image. Objects that are further away from the camera appear proportionally smaller than the same size objects closer to the camera. Other spatial distortions. Complex distortions, such as pin cushion and barrel-type distortions, fall in this category. These distortions can be compensated for by using a large number of small sections in the mapping function. The mapping in each area can be approximated with a linear interpolation function if the number of sections used is significantly larger than the corresponding area covered. The following animation gives examples of the different types of distortion: Camera calibration mechanism To perform the calibration, the module uses calibration points and a camera calibration mode, except in uniform camera calibration mode, which assumes only combinations of linear distortions. Calibration points are points in the image with known positions in the world. The module uses these points with the specified calibration mode to determine the world coordinates of all other points in the image. The calibration points can be explicitly specified or can be automatically calculated from an image of a grid and the world description of the grid. You can either use two-dimensional (2D) or three-dimensional (3D) camera calibration modes depending on the type of your imaging distortions and camera setup. Two 3D-based camera calibration modes are available in MIL. The first is based on the technique developed by Roger Y. Tsai. The second is used for a robotics setup that either has the camera mounted on the last joint of a robot arm, or where the camera is stationary and the robot arm is moving. The second mode also estimates the position and orientation of the robot base coordinate system with respect to the absolute coordinate system. Both 3D-based camera calibration modes support full 3D movement of your camera. However, all results are returned in a 2D coordinate system. This means that all points in an image are assumed to be on the same plane even if the plane is slanted. Camera calibration - overview Types of distortions Camera calibration mechanism ",
      "wordCount": 665,
      "subEntries": []
    },
    {
      "id": "UG_calibration_Steps_to_performing_a_calibration",
      "version": null,
      "title": "Steps to performing a camera calibration",
      "subTitles": null,
      "location": "MIL UG P04: 2D related information",
      "pageURL": "content\\UserGuide\\calibration\\Steps_to_performing_a_calibration.htm",
      "text": " Steps to performing a camera calibration The following steps provide a basic methodology for a typical camera calibration: Physically place the camera so that the working area is in the camera's field of view. Allocate a camera calibration context, using McalAlloc(). The camera calibration context will store the non-linear mapping between the pixel coordinate system and the world coordinate system, as well as information about the calibration setup, and the positions of all the coordinate systems. When allocating the context, specify the camera calibration mode. Calibrate your camera setup, using either McalGrid() or McalList() with M_FULL_CALIBRATION to map image pixels to world points in the camera calibration context. Associate the camera calibration context with an image or digitizer, using McalAssociate(), to enable working in real-world units. Once an image or digitizer is associated with a camera calibration context, it becomes known as a calibrated image or calibrated digitizer, respectively. Physically correct an image using McalTransformImage(). Save your camera calibration context using McalSave() or McalStream(). Free the camera calibration context using McalFree(), unless M_UNIQUE_ID was specified during allocation. You can skip all of the above steps if no non-linear distortion is present and uniform camera calibration mode is sufficient; simply call McalUniform() to associate the default uniform camera calibration context with an image. Whereas, additional steps are required in M_3D_ROBOTICS mode. For more information on robotics mode calibration, see the Robotics mode subsection of the 3D camera calibration modes section later in this chapter. Note that typically, if you physically move your camera, you will have to recalibrate. However, if you are using a 3D-based camera calibration mode, you can remain calibrated in the following two cases: If the movement is known, specify the transformation, using McalSetCoordinateSystem() with the camera coordinate system as the target coordinate system. If the movement is not known, you can have the new position calculated automatically using McalGrid() or McalList() with M_DISPLACE_CAMERA_COORD. Note that M_DISPLACE_CAMERA_COORD is not supported for an M_STATIONARY_CAMERA type of M_3D_ROBOTICS camera calibration. Steps to performing a camera calibration ",
      "wordCount": 338,
      "subEntries": []
    },
    {
      "id": "UG_calibration_Basic_concepts",
      "version": null,
      "title": "Basic concepts for the MIL Camera Calibration module",
      "subTitles": null,
      "location": "MIL UG P04: 2D related information",
      "pageURL": "content\\UserGuide\\calibration\\Basic_concepts.htm",
      "text": " Basic concepts for the MIL Camera Calibration module The basic concepts and vocabulary conventions for the MIL Camera Calibration module are: Axis. The axes of a coordinate system are used to specify the location of objects within a coordinate system. A coordinate system typically has as many axes as there are dimensions in the space it describes; these axes are typically perpendicular to each other. Camera calibration plane. Camera calibration plane is the world plane used to perform the initial camera calibration with a grid or a list of points. Calibrated image. A calibrated image is an image that has a camera calibration context associated with it. Calibrated digitizer. A digitizer with an associated camera calibration context is known as a calibrated digitizer. Images grabbed with a calibrated digitizer are automatically associated with the camera calibration context and become calibrated images as a result. Calibration points. Calibration points are points in an image with known real-world coordinates and used to establish the real-world coordinates of all other points in the image based on the selected camera calibration mode. Coordinates. Coordinates are used to define an object's location in space. Coordinates are typically expressed as a set of numbers. Each number in the set represents the object's distance from the origin along a corresponding axis. Coordinate system. Coordinate systems are used to position objects. Coordinate systems are characterized by their origin and their axes. Distortion. Distortion is an optical effect which causes objects in an image to appear deformed. Field of view. Field-of-view refers to the largest world region visible in an image at a given resolution. It is the extent of the observable world that is seen at any moment. Image plane. The plane defined in world units on which an object's image is projected. It is located in front of the camera's effective pinhole and is perpendicular to the camera's optical axis (Z-axis). Origin. The origin of a coordinate system is its reference point. At the origin, the position along all the axes of the coordinate system is zero; positions in the coordinate system are typically returned with respect to the origin. Pixel units. Pixel units are the most basic unit in an image. Pixel units are used to measure sizes, distances, and positions in an uncalibrated image. Pose. A pose is the position and orientation of an object in space. Real-world units. Real-world units are used to measure sizes, distances, and positions as they exist in the real world. Robot encoders. Robot encoders are the parts of a robot that measure the movement of the robot's arm and return it in human-readable units. Transformation. Transformations are used to move, rotate, or scale objects within a coordinate system. Typically, these transformations are represented using matrices. Transformations can also be used to convert measurements from pixel units to real-world units or vice versa. Working area. Working area is the area of the image from which you want real-world results. Basic concepts for the MIL Camera Calibration module ",
      "wordCount": 499,
      "subEntries": []
    },
    {
      "id": "UG_calibration_Coordinate_systems",
      "version": null,
      "title": "Coordinate systems",
      "subTitles": [
        "Absolute world coordinate system",
        "Relative world coordinate system",
        "Tool coordinate system",
        "Camera coordinate system",
        "Robot base coordinate system",
        "Pixel coordinate system"
      ],
      "location": "MIL UG P04: 2D related information",
      "pageURL": "content\\UserGuide\\calibration\\Coordinate_systems.htm",
      "text": " Coordinate systems MIL supports different coordinate systems to describe positions in your camera setup. The following diagram shows these coordinate systems using a sample camera setup. Notice that the tool's position is assigned to the last joint of the robot arm. The Z-axis for these 3D coordinate systems follow the right-hand rule; with the thumb, index, and middle fingers of your right hand at right angles to each other, the middle finger points in the direction of the positive Z-axis when the thumb represents positive X-axis and the index finger represents positive Y-axis. Legend Label Description Coordinates (as measured in the absolute coordinate system) A Origin of the absolute coordinate system (0, 0, 0) B Camera field of view from which image is captured (180, 130, 0) C Origin of the relative coordinate system (190, 145, 0) D Origin of the tool coordinate system (190, 155, -75) E Origin of the camera coordinate system 1 (190, 155, -60) F Origin of robot base coordinate system (160, 360, -20) 1 In the diagram above the camera is represented as an integrated wrist camera that moves with the robot arm. Note that MIL also supports alternative camera setups where the camera is not moving with the robot arm, and is fixed in a position where the camera's field of view is in range with the arm. Absolute world coordinate system The absolute world coordinate system is implicitly defined from the calibration points when calibrating the camera setup. The absolute world coordinate system is unmovable. Its unit of measure is user-defined (for example, mm, cm, or inches). Calibration relates the pixel coordinate system to the absolute world coordinate system. For the sake of simplicity, the absolute world coordinate system will be known as the absolute coordinate system. Relative world coordinate system The relative world coordinate system is the coordinate system used to locate and/or measure objects in the real world. By default, after calibration, positional results will be returned with respect to the relative world coordinate system, rather than the pixel coordinate system. Initially, the relative world coordinate system has the same position and orientation as the absolute coordinate system. However, to get results relative to some object, the relative coordinate system can be moved anywhere within the absolute coordinate system and rotated by any angle. Its unit of measure is the same as the absolute coordinate system. For the sake of simplicity, the relative world coordinate system will be known as the relative coordinate system. Tool coordinate system For most applications, the tool coordinate system can be ignored unless, for example, analyzing an object that cannot fit in a single image or working with 3D camera calibration modes. As such, by default, the tool coordinate system has the same position and orientation as the absolute coordinate system. Typically, moving the origin of the tool coordinate system is an indirect means of positioning the camera coordinate system. Since moving the camera coordinate system implies a different field of view, moving the origin of the tool coordinate system affects positional results taken from a calibrated image. The world coordinates of an image pixel taken before and after moving the tool coordinate system are not the same. For information about adjusting the tool position when analyzing an object that cannot fit in a single image, see the Calibrating a camera setup that analyzes large objects section later in this chapter. In 3D robotics, the tool coordinate system relates to the center-point of the tool that is located on the last joint of a robot arm. Depending on your type of camera setup, the robot arm also has either a camera or reference object/calibration grid mounted on the last joint of the robot arm. Moving the origin of the tool coordinate system is an indirect means of positioning the camera coordinate system, unless it is a stationary camera robotics setup where the camera coordinate system must remain fixed; for more information on robotics mode calibration, see the Robotics mode subsection of the 3D camera calibration modes section later in this chapter. Camera coordinate system The camera coordinate system is the coordinate system with an origin positioned at the center of the camera's lens and is only useful for 3D camera calibration modes. Its X-axis is oriented towards the right of the image, its Y-axis is oriented downwards in the image, and its Z-axis is oriented in the direction the camera is pointing (into the image). The 2D camera calibration modes do not estimate the position of the camera coordinate system; the movement of the camera coordinate system is accomplished by moving the tool coordinate system. The 3D camera calibration modes estimate the orientation and distance between the camera and the camera calibration plane as part of their algorithmic calculations; so when using these modes, the camera position is the position of the modeled pinhole camera calculated using Tsai-based algorithm. When dealing with a robotics setup where your camera is not stationary, moving the camera coordinate system is usually performed by moving the tool coordinate system. See the Moving coordinate systems to reflect camera setup changes section later in this chapter for more information on moving your camera. Moving the origin of the camera coordinate system affects positional results taken from a calibrated image. The world coordinates of an image pixel taken before and after moving the camera coordinate system are not the same. Robot base coordinate system The robot base coordinate system is the coordinate system with an origin positioned at the base of the robot arm. It is used by the robot software to set the tool coordinate system with respect to the robot's base and can be used to provide the Camera Calibration module with values returned by the robot encoder. This coordinate system is only available for robotics camera calibration modes; in these modes, you must define the relationship between the tool coordinate system and the robot base coordinate system before performing camera calibration. Even if its position and orientation with respect to the absolute coordinate system is originally unknown, the tool coordinate system can still be defined with respect to the robot base coordinate system. After performing full calibration, the relation between the robot base coordinate system and absolute coordinate system is established, as well as the relation between tool and absolute coordinate systems. Note that usually, you cannot move the robot base coordinate system unless the robotic encoders are set on a mobile robot base. Pixel coordinate system The pixel coordinate system is the coordinate system used to locate and/or measure objects in a non-calibrated image. Its unit of measure is pixels. Its origin, (0, 0), is the center of the image's top-left pixel. Its X-axis follows the first row of pixels, pointing to the right and the Y-axis follows the first column of pixels downwards. For more information, see the Pixel conventions and subpixel accuracy section of Chapter 23: Data buffers. Coordinate systems Absolute world coordinate system Relative world coordinate system Tool coordinate system Camera coordinate system Robot base coordinate system Pixel coordinate system ",
      "wordCount": 1176,
      "subEntries": []
    },
    {
      "id": "UG_calibration_Calibration_modes_overview",
      "version": null,
      "title": "Camera calibration modes",
      "subTitles": null,
      "location": "MIL UG P04: 2D related information",
      "pageURL": "content\\UserGuide\\calibration\\Calibration_modes_overview.htm",
      "text": " Camera calibration modes When you use McalAlloc() to create the camera calibration context, you have to specify the camera calibration mode. MIL supports the following camera calibration modes: Uniform mode: The most basic camera calibration mode available. 2D modes: Piecewise linear interpolation mode: Compensates for any kind of distortion and is very accurate for points located inside the working area. Perspective transformation mode: Compensates for rotation, translation, scale, and perspective distortions. The perspective transformation mode is accurate for points inside and outside the working area. 3D modes: Tsai-based mode: A true 3D camera calibration technique that determines the distance and orientation between the modeled camera and the image plane. Robotics mode: Estimates the position and orientation of the robot base coordinate system with respect to the absolute coordinate system for a moving or stationary camera setup. The following table provides a side-by-side feature comparison of the different camera calibration modes supported by MIL: Feature Uniform Linear interpolation Perspective transformation Tsai-based Robotics Moving camera Stationary camera Supports camera movement parallel to the image plane X X X X X Supports full 3-dimensional camera movement X X Supports working with coordinates that lie outside the calibration grid X (less accurate) X X X X Calculates the position of the robot base X X Calibrates with a single image only (optional) X X X Allows calibrating with the camera perpendicular to the camera calibration plane (0º angle of incidence) X X X X X Supports telecentric lenses X X X Supports one-dimensional distortions obtained from line-scan cameras X X X Corrects rotation, scale, and perspective distortion X X X X X Corrects lens distortion X X X X Corrects all types of distortion X Corrects lens distortion only and keeps other distortions uncorrected X X X Models the camera explicitly X X X Estimates the position of the camera and other known objects using known world points X X X Allows retrieval of the position and orientation of the robot's base coordinate system X X Allows proper calibration of cameras used for 3D reconstruction by M3dmapCalibrate() and M3dmapTriangulate() functions X X X Camera calibration modes ",
      "wordCount": 354,
      "subEntries": []
    },
    {
      "id": "UG_calibration_2D_Calibration_modes",
      "version": null,
      "title": "Uniform camera calibration and other 2D camera calibration modes",
      "subTitles": [
        "Uniform mode",
        "Piecewise linear interpolation mode",
        "Perspective transformation mode"
      ],
      "location": "MIL UG P04: 2D related information",
      "pageURL": "content\\UserGuide\\calibration\\2D_Calibration_modes.htm",
      "text": " Uniform camera calibration and other 2D camera calibration modes MIL's Camera Calibration module (Mcal...()) allows you to map pixel coordinates to real-world coordinates. The following modes range from the absolute basics of camera calibration (uniform mode) to the more advanced 2D camera calibration modes that can compensate for different types of distortion. Uniform mode The most basic camera calibration mode available is the uniform mode. This simple, uniform camera calibration can only map a linear translation, rotation, and scaling between the pixel and world coordinate systems. For a uniform camera calibration, you do not need to allocate a camera calibration context or call McalGrid() or McalList(), making it the fastest to set up. To provide uniform camera calibration information to an image, call McalUniform() and specify the scale, rotation, and offset between pixel and world coordinate systems. The following illustrations show the position of the pixel and absolute coordinate systems after three example uniform camera calibrations. You can also allocate a camera calibration context using McalAlloc() with M_UNIFORM_TRANSFORMATION. The context can be calibrated by calling McalGrid() or McalList(), which will determine the best linear mapping between the pixel and world coordinate system. If you pass a uniformly calibrated image to McalTransformImage(), the image will be rotated to remove the angle between the relative and pixel coordinate systems, and the scales will be adjusted to produce square pixels. For depth maps, a uniform camera calibration can include the mapping of a third dimension. You can call McalControl() with M_GRAY_LEVEL_SIZE_Z to specify how the gray level of each pixel maps to world coordinates, and with M_WORLD_POS_Z to specify what gray level corresponds to a height of 0 in world units. Piecewise linear interpolation mode Piecewise linear interpolation mode can compensate for any kind of distortion. In general, you should use this mode. It is very accurate for points located inside the working area. However, it is less accurate for points outside the working area. The piecewise linear interpolation mode fits a piecewise linear interpolation function to the specified set of images coordinates and their real-world equivalents. It performs a mapping of each point in the image to a point in the real world using bilinear interpolation between adjacent points. To allocate a piecewise linear interpolation camera calibration context, use McalAlloc() with M_LINEAR_INTERPOLATION. Note that piecewise linear interpolation mode does not support changing the distance between the camera and the camera calibration plane. Re-calibration is required in this case. Perspective transformation mode The perspective transformation mode can compensate for rotation, translation, scale, and perspective distortions. For such distortions, the perspective transformation mode is accurate for points inside and outside the working area. This mode cannot compensate for non-linear distortions such as lens distortions. The perspective transformation mode best fits a global perspective transformation function to the set of image coordinates and their real-world equivalents. It finds a projection of an image in a field of view into a 2D plane. To allocate a perspective transformation camera calibration context, use McalAlloc() with M_PERSPECTIVE_TRANSFORMATION. Note that perspective transformation mode does not support changing the distance between the camera and the camera calibration plane. Re-calibration is required in this case. Uniform camera calibration and other 2D camera calibration modes Uniform mode Piecewise linear interpolation mode Perspective transformation mode ",
      "wordCount": 544,
      "subEntries": []
    },
    {
      "id": "UG_calibration_3D_Calibration_modes",
      "version": null,
      "title": "3D camera calibration modes",
      "subTitles": [
        "Tsai-based mode",
        "Robotics mode",
        "Moving camera robotics mode ",
        "Stationary camera robotics mode ",
        "Steps to perform camera calibration in a 3D robotics mode"
      ],
      "location": "MIL UG P04: 2D related information",
      "pageURL": "content\\UserGuide\\calibration\\3D_Calibration_modes.htm",
      "text": " 3D camera calibration modes MIL's Camera Calibration module (Mcal...()) allows you to map pixel coordinates to real-world coordinates. The following are MIL's 3D camera calibration modes (based on Roger Y. Tsai's algorithm). These true 3D camera calibration techniques determine the distance and orientation between a modeled camera and the image plane. This allows for results to be inquired with respect to any defined plane, which can be useful in both robotic and non-robotic applications. Tsai-based mode Tsai-based mode is a camera calibration mode based on Roger Y. Tsai's algorithm. This mode models your camera as a pinhole camera and can compensate for rotation, translation, scale, perspective, and radial lens distortions. Tsai-based mode is a true 3D camera calibration technique which actually determines the distance and orientation between the modeled camera and the image plane. This allows for results to be inquired with respect to any defined plane. This mode allows for camera rotation about any axis without re-calibrating; you only need to specify the camera movement which has occurred. The mode requires a minimum of 6 points to perform a successful calibration and accuracy increases with the number of points. To allocate a Tsai-based camera calibration context, use McalAlloc() with M_TSAI_BASED. Tsai-based mode calculates several intrinsic and extrinsic attributes of the pinhole camera that is used to model the real-world camera. Intrinsic attributes characterize properties of the camera itself (such as the focal length and the radial distortion), whereas extrinsic attributes characterize the camera's position and orientation. Tsai-based mode does not estimate the following two intrinsic attributes that are needed for accurate calibration; you can adjust their values set by default if not correct: Aspect ratio of the camera's charge-coupled device (CCD) elements. This refers to the ratio of the horizontal dimension of a single CCD element to its vertical dimension. Tsai-based mode sets this ratio to 1 by default. If the aspect ratio given by the camera manufacturer is not 1, specify its actual aspect ratio using McalControl() with M_CCD_ASPECT_RATIO. Principal point. This refers to the point of intersection of the camera's optical axis with the image plane. You can specify the principal point using McalControl() with M_PRINCIPAL_POINT_X and M_PRINCIPAL_POINT_Y, prior to calibrating. If McalGrid() is used for calibration, the principal point will default to the central point of the image plane. If McalList() is used for calibration, it is mandatory to set the principal point prior to calibrating. In this case, it is recommended to set the principal point to the central pixel of the captured image. To successfully perform a full calibration using Tsai-based mode, you must ensure that the optical axis of your camera is at least 30º away from the axis perpendicular to the camera calibration plane. This angle provides the image perspective needed by Tsai-based mode to estimate some intrinsic and extrinsic attributes. For camera setups that require a camera whose optical axis is perpendicular to the camera calibration plane, you must perform two calibrations: the first calibration must be performed with the camera inclined with respect to the camera calibration plane, using McalGrid() or McalList() with M_FULL_CALIBRATION; the second calibration must be performed after repositioning the camera, such that its optical axis is perpendicular to the camera calibration plane, using McalGrid() or McalList() with M_DISPLACE_CAMERA_COORD. Instead of calibrating a second time, you can, alternatively, move the camera coordinate system using McalSetCoordinateSystem() if the movement is known with great precision. If you want to move the camera coordinate system by moving the tool coordinate system, you must first move the tool coordinate system as described in the Special considerations concerning the tool and camera coordinate systems subsection of the Moving coordinate systems to reflect camera setup changes section later in this chapter. Since this mode requires that the image has perspective distortion, you should not use this mode when using a camera with a telecentric lens; telecentric lenses negate perspective effects. Note that if you are using a robotics setup and need to transform positional results such that they are in the robot base coordinate system, you should calibrate using robotics mode. Alternatively, if you have already calibrated in tsai-based mode, you can use McalCalculateHandEye() to calculate the transformation required; this is not as efficient and accurate as calibrating directly in robotics mode. Robotics mode Robotics mode is a true 3D camera calibration technique that supports the robot base coordinate system. In addition to estimating the camera's intrinsic and extrinsic attributes, this mode also estimates the position and orientation of the robot base coordinate system with respect to the absolute coordinate system. Like the Tsai-based mode, robotics mode models the camera as an ideal pinhole camera. Therefore, the robotics mode estimates the same camera attributes estimated by Tsai-based mode. It also allows for results to be inquired with respect to any defined plane. After 3D camera calibration, it is possible to move the relative coordinate system to another plane without having to calibrate again. For an example of how to move the relative coordinate system, see the Moving the relative coordinate system to account for height section of Chapter 34: 3D analysis using planar views of an object. The robotics mode is comprised of two distinct types of camera setups: M_MOVING_CAMERA type of M_3D_ROBOTICS (also known as eye-in-hand calibration). M_STATIONARY_CAMERA type of M_3D_ROBOTICS (also known as eye-to-hand calibration). Moving camera robotics mode This calibration mode is used for camera setups where the camera is mounted on the last joint of a robot arm, while the calibration grid is stationary and in the camera's field of view. In this mode, a rigid link exists between the tool coordinate system and the camera coordinate system by default. You can disable the link between the coordinate systems by setting M_LINK_TOOL_AND_HEAD to M_DISABLE in McalControl(). The image below provides a visualization of what a typical M_MOVING_CAMERA setup looks like. Stationary camera robotics mode The second robotics calibration mode is an M_STATIONARY_CAMERA type of M_3D_ROBOTICS, or eye-to-hand calibration. This calibration mode is used for a camera setup where the camera is stationary and the robot arm, with a calibration grid mounted on the last joint, is moving. By default, this calibration mode does not have a rigid link between the camera coordinate system and the tool coordinate system. McalControl() with M_LINK_TOOL_AND_HEAD cannot be set to M_ENABLE because moving the tool coordinate system should not affect the camera coordinate system in this camera setup. The image below provides a visualization of what a typical M_STATIONARY_CAMERA setup looks like. Note that the placement of the stationary camera is not required to be overhead as depicted in the image. Note that in both McalGrid() and McalList(), M_DISPLACE_CAMERA_COORD is not supported for an M_STATIONARY_CAMERA type of M_3D_ROBOTICS camera calibration. Steps to perform camera calibration in a 3D robotics mode The following steps provide a basic methodology for performing camera calibration in a 3D robotics mode: Allocate a camera calibration context in robotics mode, use McalAlloc() with M_3D_ROBOTICS and set the ModeFlag parameter to specify your camera setup (M_MOVING_CAMERA or M_STATIONARY_CAMERA). Get the position and orientation of the tool holding the camera or grid, with respect to the robot base, using the robot software. Set the position and orientation for the tool coordinate system in the camera calibration context with respect to the robot base coordinate system using McalSetCoordinateSystem(). Call McalGrid() or McalList() with M_ACCUMULATE to store calibration points in the camera calibration context. Physically move the camera to a new position over the working area. You must rotate the tool along at least two non-parallel axes. Repeat steps 2 to 5 at least twice, to make a minimum total of three calls to McalGrid() with M_ACCUMULATE. Calling this function with M_ACCUMULATE more than 3 times improves the accuracy of the camera calibration. When you are done accumulating data, you must call McalGrid() or McalList() with M_FULL_CALIBRATION and no image/calibration points to perform the full camera calibration. Once you perform a full camera calibration, you can no longer accumulate camera calibration poses. Note that, you cannot set M_CALIBRATION_PLANE to M_ABSOLUTE_COORDINATE_SYSTEM for an M_STATIONARY_CAMERA type of M_3D_ROBOTICS camera calibration context. Once your 3D-based camera calibration context is calibrated, you can move your camera to a new location and automatically reposition the camera coordinate system, assuming that you are not calibrating an M_STATIONARY_CAMERA type of M_3D_ROBOTICS. To automatically reposition the coordinate system, you can use McalGrid() or McalList() with M_DISPLACE_CAMERA_COORD. This determines and displaces the camera coordinate system to its new location. Note that besides the camera coordinate system, this also displaces the tool coordinate system (if it is not an M_STATIONARY_CAMERA type of M_3D_ROBOTICS); no other coordinate system is affected. M_3D_ROBOTICS calibration mode is more efficient and accurate than calibrating with M_TSAI_BASED mode and then using the results of McalCalculateHandEye() to transform coordinates between the robot base and the absolute coordinate system. 3D camera calibration modes Tsai-based mode Robotics mode Moving camera robotics mode Stationary camera robotics mode Steps to perform camera calibration in a 3D robotics mode ",
      "wordCount": 1495,
      "subEntries": []
    },
    {
      "id": "UG_calibration_Calibration_propagation",
      "version": null,
      "title": "Camera calibration propagation",
      "subTitles": [
        "Processing calibrated images",
        "Saving and reloading a calibrated image",
        "Saving the calibration with the image file",
        "Saving the associated camera calibration context in a separate file"
      ],
      "location": "MIL UG P04: 2D related information",
      "pageURL": "content\\UserGuide\\calibration\\Calibration_propagation.htm",
      "text": " Camera calibration propagation Camera calibration contexts store a lot of information. When you associate a camera calibration context with an image or a digitizer, some of this information is copied and some of it is just referenced. In addition, when an operation is done on a calibrated image, its camera calibration information is typically propagated to the destination image or result buffer. The three types of information stored in a camera calibration context are: The non-linear mapping between the world and pixel coordinate systems. Properties of the calibration setup, such as the type of grid used and its size. Camera calibration information, which represents the most functional part of the calibration, and consists primarily of a copy of all coordinate systems. When a digitizer is associated with a camera calibration context (McalAssociate()), the digitizer only retains a link to the camera calibration context. When you grab images with the digitizer, the grabbed images are automatically associated with the camera calibration context. A digitizer with an associated camera calibration context is known as a calibrated digitizer. To disassociate a camera calibration context from an image or digitizer, use McalAssociate() with M_NULL. When an image is associated with a camera calibration context, it receives a copy of the calibration's coordinate systems and a reference to the camera calibration context for all other settings, including the intrinsic attributes. This data is referred to as the camera calibration information. An image with an associated camera calibration context is known as a calibrated image. If you change the relative coordinate system or camera position of the camera calibration context after association, the change will not affect the image, because the image has its own camera calibration information. If you change any other setting of the camera calibration context after association, the change will affect the calibrated image because those settings are retrieved through the reference to the camera calibration context. A result buffer used by an analysis operation can also contain camera calibration information. If the MIL module supports returning results in real-world units, the camera calibration information stored with the source images will be copied to the result buffer. For more information on getting results with respect to real-world units, see the Working with real-world units section later in this chapter. When a child buffer is allocated in a calibrated image, the child buffer receives a copy of the camera calibration information stored in the parent, taking into account the different origin in the pixel coordinate system. Consequently, the absolute and relative coordinate systems of the child buffer are initially the same as the parent image, when the child is allocated. Since the child buffer has its own copy of the coordinate systems, you can displace its relative coordinate system to any new location. However, there exists a rigid link between the parent and child's relative coordinate systems, so if you move the parent's relative coordinate system, the child buffer's relative coordinate system will be displaced to maintain the same position and orientation that was previously established with respect to the parents relative coordinate system. For more information, see the Multiple relative coordinate systems subsection of the Calibration and one or many fixtures section of Chapter 29: Fixturing in MIL. You can also use McalAssociate() to copy the camera calibration information from an image or result buffer to another image or result buffer. MbufCopy() will also copy all the camera calibration information associated with a buffer to the specified destination buffer. Processing calibrated images When a camera calibration context is associated with an image, it has certain implications on processing operations applied to that image. Depending on the type of operation performed on the calibrated image, the destination image also receives a copy of the camera calibration information for the following circumstances: When performing point-to-point or neighborhood processing operations, the destination image receives a copy of the camera calibration information from the source image. If the operation uses more than one source image, the camera calibration information gets copied to the destination image only if all source images have the same camera calibration information; otherwise, the camera calibration information of the destination image is left unchanged. Geometric functions (MimFlip(), MimPolarTransform(), MimResize(), MimRotate(), MimTranslate(), and MimWarp()) always result in an uncalibrated image, even if the source image is calibrated. You can use McalWarp() to warp an existing calibration context and associate it with a warped uncalibrated image. For more information, see the Propagating camera calibration information after performing a geometric operation section later in this chapter. The function MbufClear() always results in an uncalibrated image. You can use MgraClear() to clear a buffer while preserving the camera calibration context associated with the empty image. Functions for which the source data is always considered uncalibrated always produce uncalibrated images. These functions include, for example, MbufImport...() and MbufLoad(). A result buffer will receive a copy of the camera calibration information from the source images used to generate the result if and only if all source images have the same camera calibration information and the module supports returning results in world units; otherwise, the result buffer is left uncalibrated. Saving and reloading a calibrated image When saving and reloading a calibrated image, you must account for its associated camera calibration context. You can either save it with the image file, or save it in a separate file. By default, the image's camera calibration information is not saved and, therefore, is not reloaded. To inquire whether an image is calibrated, use McalInquire() with M_ASSOCIATED_CALIBRATION. Saving the calibration with the image file To save the image's associated calibrated object with the image file, use MbufExport() with M_MIL_TIFF + M_WITH_CALIBRATION. To restore the associated camera calibration context, use McalRestore(). Typically, when restoring the camera calibration context, you will also restore the associated image, using MbufImport(), MbufLoad(), or MbufRestore(), and then associate the restored image buffer to the restored camera calibration, using McalAssociate(). In this case, the calibrated image will always be in the same state as it was when it was previously saved. The following is a general example of how to save/restore the calibration (and the image) using M_WITH_CALIBRATION. /* Save the image along with its associated calibration in a file. */ MbufExport(MIL_TEXT(\"Image.mim\"), M_MIL_TIFF+M_WITH_CALIBRATION, ImageId); /* Free the image. */ MbufFree(ImageId); /* ... */ /* The following code can be in another application. */ /* Restore the image from the file. */ MbufRestore(MIL_TEXT(\"Image.mim\"), SystemId, &amp;ImageId); /* Restore the calibration object from the file. */ McalRestore(MIL_TEXT(\"Image.mim\"), SystemId, M_DEFAULT, &amp;CalibrationContextId); /* Associate the restored calibration context to the restored image. */ McalAssociate(CalibrationContextId, ImageId, M_DEFAULT); When using M_WITH_CALIBRATION, the restored camera calibration context contains information relevant only to the restored image (of the same file); it is not recommended that you associate it with another image. For example, if you restore the camera calibration context (McalRestore()) from an image file that had been saved using MbufExport() with M_WITH_CALIBRATION, the restored camera calibration context and the camera calibration context that was originally associated with the saved image, can have different settings. This can occur because the calibration settings that are specific to the saved image (such as the position of the relative coordinate system) are also present in the restored camera calibration context. When restoring an image with a constant pixel size (including depth maps), use MbufImport() with M_MIL_TIFF + M_WITH_CALIBRATION. This imports the image along with its uniform camera calibration information. In this case, the camera calibration is associated with a default uniform camera calibration. Saving the associated camera calibration context in a separate file In certain cases, you might not want to save the associated camera calibration context in the same file as the image (MbufExport() with M_WITH_CALIBRATION). For example: You do not want to save the image in a MIL file format. M_WITH_CALIBRATION must be used in combination with M_MIL_TIFF. You cannot, for example, use an M_JPEG... format. You want to associate the same camera calibration context to multiple images, but you only want to save it once (for example, to conserve disk space). To save a calibrated image and its camera calibration context in a separate file, perform the following: Obtain the identifier of the image's camera calibration context, using McalInquire() with M_ASSOCIATED_CALIBRATION. Save the camera calibration context, using McalSave() or McalStream(). Save the image buffer, using MbufSave() or MbufExport(). To reload the image and associate it with its camera calibration context, perform the following: Restore the image buffer, using MbufRestore(). Restore the camera calibration context, using McalRestore(). Associate the restored image with the restored camera calibration context, using McalAssociate(). The following is an example of how to save two calibrated images and their common camera calibration context in separate files, and then reload the images and associate them with the restored camera calibration context: /* Save 2 images in JPEG files. Both images: - Are already associated to the same calibration contexts. - Are not child images. - Have not been corrected using McalTransformImage. - Have relative coordinate systems that have not been modified. */ McalInquire(Image1Id, M_ASSOCIATED_CALIBRATION+M_TYPE_MIL_ID, &amp;CalibrationContextId); McalSave(MIL_TEXT(\"Calibration.mca\"), CalibrationContextId, M_DEFAULT); MbufExport(MIL_TEXT(\"Image1.jpg\"), M_JPEG_LOSSY, Image1Id); MbufExport(MIL_TEXT(\"Image2.jpg\"), M_JPEG_LOSSY, Image2Id); /* Free the images and the calibration context. */ MbufFree(Image1Id); MbufFree(Image2Id); McalFree(CalibrationContextId); /* ... */ /* The following code can be in another application. */ /* Restore the images from the files. */ MbufRestore(MIL_TEXT(\"Image1.jpg\"), SystemId, &amp;Image1Id); MbufRestore(MIL_TEXT(\"Image2.jpg\"), SystemId, &amp;Image2Id); /* Restore the calibration context from the file. */ McalRestore(MIL_TEXT(\"Calibration.mca\"), SystemId, M_DEFAULT, &amp;CalibrationContextId); /* Associate the restored calibration context to the restored images. */ McalAssociate(CalibrationContextId, Image1Id, M_DEFAULT); McalAssociate(CalibrationContextId, Image2Id, M_DEFAULT); Note that if one or more of the following conditions are true, this save/reload procedure can result in a calibrated image that might not be in the same state as the previously saved image: The previously saved image was corrected, using McalTransformImage(). The previously saved image was calibrated, using McalUniform(). The previously saved image was a child image. The relative coordinate system of the previously saved image was moved. When you associate a camera calibration context with an image, its child images are also associated with the camera calibration context; their offset from the parent image is automatically taken into account. If you save a child image on its own into a file and restore it, it becomes an ordinary stand alone image; if you reassociate it with the original camera calibration context, the camera calibration context cannot automatically know that the image's pixel coordinate system should be offset from the original mapping. If the camera calibration context is restored from a separate file, you can restore the calibration of the image (that used to be a child image) by associating it with the restored camera calibration context, and then specifying its original offset from its original parent that was calibrated, using McalControl() with M_CALIBRATION_CHILD_OFFSET_X and M_CALIBRATION_CHILD_OFFSET_Y. The following is a general example of how to perform this procedure: /* Associate a calibration to an image and allocate a child of this image. */ McalAssociate(CalibrationContextId, ImageId, M_DEFAULT); MbufChild2d(ImageId, ChildOffsetX, ChildOffsetY, ChildSizeX, ChildSizeY, &amp;ChildId); /* Save the child images and the calibration context in separate files. */ MbufExport(MIL_TEXT(\"Child.mim\"), M_MIL_TIFF, ChildId); McalSave(MIL_TEXT(\"Calibration.mca\"), CalibrationContextId, M_DEFAULT); /* Free the image and the calibration context. */ MbufFree(ChildId); McalFree(CalibrationContextId); /* ... */ /* The following code can be in another application. */ /* Restore the image from the file. */ MbufRestore(MIL_TEXT(\"Child.mim\"), SystemId, &amp;ChildId); /* Restore the calibration context from the file. */ McalRestore(MIL_TEXT(\"Calibration.mca\"), SystemId, M_DEFAULT, &amp;CalibrationContextId); /* Associate the restored calibration context to the restored image. */ McalAssociate(CalibrationContextId, ChildId, M_DEFAULT); /* Specify the original offset of the restored image from its parent (at the time it was originally calibrated). */ McalControl(ChildId, M_CALIBRATION_CHILD_OFFSET_X, ChildOffsetX); McalControl(ChildId, M_CALIBRATION_CHILD_OFFSET_Y, ChildOffsetY); If you create a camera calibration context for a child image, associate it to the child image, and then save the image separately from its parent, you will not need to specify its offset from its parent. Similarly, if you save the camera calibration context and the child image in the same file, you will not need to specify the child offset from its parent. Camera calibration propagation Processing calibrated images Saving and reloading a calibrated image Saving the calibration with the image file Saving the associated camera calibration context in a separate file ",
      "wordCount": 2023,
      "subEntries": []
    },
    {
      "id": "UG_calibration_Working_with_realworld_units",
      "version": null,
      "title": "Working with real-world units",
      "subTitles": [
        "Getting results in world units",
        "Input settings in world units",
        "Angle convention in MIL"
      ],
      "location": "MIL UG P04: 2D related information",
      "pageURL": "content\\UserGuide\\calibration\\Working_with_realworld_units.htm",
      "text": " Working with real-world units One of the main advantages of calibration is the ability to work in real-world units, so that locations in your images correspond to real-world locations. The following table lists the modules that support input and output units in world units, and those that support regions of interest defined in world units, assuming that the image used is associated with a camera calibration context: Module 1 World native processing World input units World output units Region of interest M3dmap Y Y Y N Magm N N N N Mbead N Y Y N Mblob N Y 2 Y Y Mclass N N N Y Mcode N Y Y Y Mcol N N N/A Y Mdmr N N Y Y Medge Y N Y N Mgra N/A Y N/A N Mim N N Y N Mmeas N Y Y Y Mmet Y Y Y N Mmod Y N Y N Mocr N N Y Y Mpat N N Y Y Mreg N N N N Mstr N N Y Y 1 For the 3D modules that work with point cloud containers and/or 3D geometry objects, all 3D positional information (coordinates) are considered real-world (all source data is treated as if it is natively calibrated). 2 Some exceptions. Getting results in world units If an image is calibrated, most results obtained from it will be returned in world units by default. When a result is returned in world units, it is returned with respect to the relative coordinate system. If a result can be returned in either world or pixel units, it will be stated in the function description. You can use a module's M...Control() function with M_RESULT_OUTPUT_UNITS to specify that results should be returned in pixel units instead. Note that if you set this control type to M_WORLD but your results are not obtained from a calibrated image, the module's corresponding M...GetResult() function will generate an error when you try to retrieve results. You can use McalTransformCoordinate(), McalTransformCoordinateList(), or McalTransformCoordinate3dList() to convert coordinates from their pixel to their world values (or vice versa). The latter two functions allow you to convert an entire list of coordinates at once for better efficiency. McalTransformCoordinate3dList() also allows you to convert a coordinate in the relative coordinate system (or any other world coordinate system) to its corresponding value in any other world coordinate system. You can use McalTransformResult() to convert a specific non-positional result (a length, angle, or area) from its pixel to its world value (or vice versa). Note, however, that this function uses the average pixel size to perform the conversion; results will be more accurate if you first correct the image. You can use McalTransformResultAtPosition() to convert an angle from its pixel value to its world value or vice versa at a specified position. In the presence of distortion, some results are meaningless when converted from real-world to pixel units unless considered at a specific position in the image. For example, if a Model Finder model appears warped in a target image, but the camera calibration context of the image compensates for this during the model search, the resulting angle is meaningful in the real-world coordinate system, and meaningless in the pixel coordinate system, unless converted at a specific position in the target image. Since McalTransformResultAtPosition() operates on a position, it is not affected by distortion, and can be applied to uncorrected images. Input settings in world units The modules that support settings in world units require that you set the working unit to M_WORLD and you use a calibrated image, before they interpret their settings as being in world units. Otherwise, by default, they interpret their settings as being in pixel units, even if a module natively works in world units. The function and constant to set the input units depend on the module (see the table below). Some modules have multiple constants to set the input units, so that you can specify some settings in world units and others in pixel units. Note that if you set these constants to M_WORLD but you don't perform the module's operation on a calibrated image (for example, M...Calculate(), M...Read(), or M...Find()), the operation will generate an error. How to set the working units Settings that must respect the specified working units Module 3 Function and constant 3D Reconstruction The 3D Reconstruction module has some settings that are always expected in pixels and some that are always expected in world units. Depends on setting. Bead MbeadControl() with M_TEMPLATE_INPUT_UNITS Template points and settings (position and dimension). MbeadControl() with M_TRAINING_BOX_INPUT_UNITS Search box settings in the training phase. Blob MblobControl() with M_INPUT_SELECT_UNITS Condition low and high values passed to MblobSelect(). Code McodeControl() with M_SCANLINE_INPUT_UNITS M_SCANLINE_STEP and M_SCANLINE_HEIGHT. McodeControl() with M_ABSOLUTE_APERTURE_SIZE_INPUT_UNITS M_ABSOLUTE_APERTURE_SIZE. McodeControl() with M_SEARCH_ANGLE_INPUT_UNITS M_SEARCH_ANGLE. McodeControl() with M_CELL_SIZE_INPUT_UNITS M_CELL_SIZE_MIN and M_CELL_SIZE_MAX. McodeControl() with M_DOT_SPACING_INPUT_UNITS M_DOT_SPACING_MIN and M_DOT_SPACING_MAX. Graphics MgraControlList() with M_INPUT_UNITS Position and dimension settings when changing a graphic in a 2D graphics list. MgraControl() with M_INPUT_UNITS Position and dimension settings passed to Mgra...() functions. Measurement MmeasSetMarker() with M_SEARCH_REGION_INPUT_UNITS Position and dimension of the search region. MmeasSetMarker() with M_MARKER_REFERENCE_INPUT_UNITS Marker reference position. MmeasSetMarker() with M_POINT_INPUT_UNITS Position, spacing, and angle of a point marker. Metrology The Metrology module accepts input values in world units if the image is calibrated, and pixel units otherwise. When using a calibrated image, you cannot specify pixel units. Position and dimension settings. 3 For the 3D modules that work with point cloud containers and/or 3D geometry objects, all 3D positional information (coordinates) are considered real-world (all source data is treated as if it is natively calibrated). Angle convention in MIL When working in pixel units, you define angles with respect to the pixel coordinate system. In this case, positive angles are always interpreted to be counterclockwise with respect to the initial line. When working in world units, you define angles with respect to the relative coordinate system. In this case, the direction of rotation of the angles depends on the direction of the Y-axis. Note that since the Y-axis of an image is oriented downwards by default, the angles in MIL are inverted from mathematical convention. In certain cases, you might want to convert angles from MIL convention to mathematical convention: the negative value of an angle in MIL convention is the positive value of the same angle in mathematical convention. For example, 45° in MIL convention is the same as -45° in mathematical convention. The inverted nature of angles in MIL leads to complications when dealing with trigonometry, specifically the sine function. If you use the sine function with an input angle in the MIL convention, the result of the function will be in MIL convention, inverted from mathematical convention. It is for this reason that, when rotating a point (x, y) around the origin, the 2D rotation matrix that MIL uses is: Note that this matrix has already taken into account the inversion of sine functions: the -sin and sin functions are switched from their conventional positions in a standard 2D rotation matrix. Therefore, you don't need to worry about the inverted angles when working with this 2D rotation matrix within MIL. Working with real-world units Getting results in world units Input settings in world units Angle convention in MIL ",
      "wordCount": 1204,
      "subEntries": []
    },
    {
      "id": "UG_calibration_Calibrating_using_calibration_points_from_a_grid",
      "version": null,
      "title": "Calibrating using calibration points from a grid",
      "subTitles": [
        "Requirements for the image of the grid",
        "Requirements for the image of a circle grid",
        "Requirements for the image of a chessboard grid",
        "Defining the absolute coordinate system",
        "Determining the grid's reference calibration point",
        "Using the X- and Y-offsets",
        "Inverting the orientation of the Y-axis",
        "Calibrating with a partial chessboard grid",
        "Defining the relative coordinate system directly",
        "Calibrating a Tsai based camera calibration context when the camera is directly overhead"
      ],
      "location": "MIL UG P04: 2D related information",
      "pageURL": "content\\UserGuide\\calibration\\Calibrating_using_calibration_points_from_a_grid.htm",
      "text": " Calibrating using calibration points from a grid To calibrate your camera setup, you can specify points in the image and map them to real-world coordinates. These are known as calibration points. You can have MIL automatically determine the calibration points from an image of a user-defined grid and the world description of this grid. To do so, use McalGrid(). The world description includes the number of rows and columns, as well as the point-to-point distance between these rows and columns, in real-world units. The number of rows and columns in your grid are used to specify the number of calibration points that McalGrid() extracts. Real-world calibration points on the grid, with known spacing between points, are mapped to pixels in the grid's image to establish the image calibration points. The origin and axes of the absolute coordinate system are determined based on the position of the calibration points. McalGrid() can use a grid of circles (M_CIRCLE_GRID) or a chessboard grid (that is, grid of squares/rectangles - M_CHESSBOARD_GRID). McalGrid() can also use fiducial grid, which is a chessboard grid with a Data Matrix code that encodes information about the grid itself. Fiducial grids are especially useful when calibrating multiple camera setups to use the same absolute coordinate system. For information on fiducial grids, see the Calibrating using a fiducial grid section later in this chapter. MIL is distributed with five different camera calibration grids that you can print and use: ChessboardCalibrationGrid_15x16_Letter.pdf, ChessboardCalibrationGrid_18x22_Letter.pdf, CircleCalibrationGrid_15x16_Letter.pdf, CircleCalibrationGrid_18x22_Letter.pdf, and FiducialCalibrationGrid_Letter.pdf. These files are located in the Matrox Imaging\\Images directory. Each file includes the world description of the grid. For information on generating a chessboard grid with your own specifications, see the Generating a grid for calibration section later in this chapter. Requirements for the image of the grid To create an accurate (subpixel) pixel-to-world mapping, your grid image must have a certain minimum number of calibration points and it should meet a set of guidelines at the working resolution, depending on the type of grid. Requirements for the image of a circle grid In a circle grid, the center of each circle in the real-world grid is used as a calibration point. When using a circle grid, to perform a full camera calibration with a 2D camera calibration context, the grid image must have at least 2x2 calibration points; for a 3D camera calibration context, the grid image must have at least 2x3 or 3x2 calibration points. The image of the circle grid should meet the following guidelines: The radius of the grid's circles should range between 6 and 10 pixels. The center-to-center distance between the grid's circles should range from 18 to 32 pixels (22 pixels recommended). The minimum distance between the edges of the circles should be 6 pixels. The grid should be large enough to cover the area of the image from which you want real-world results (the working area). The grid image should have high contrast. Requirements for the image of a chessboard grid In a chessboard grid, the intersection of four squares/rectangles is used as a calibration point. When using a chessboard grid to perform a full camera calibration with a 2D or a 3D camera calibration context, the grid image must have at least 3x3 calibration points. Note that for the chessboard grid image to have 3x3 calibration points, it must have at least 4 columns and 4 rows. The image of the chessboard grid can be either the complete grid with 4 clearly defined border edges or some part of the grid, as in the image below. If you are using an image with a partial chessboard grid to calibrate your camera setup, you must call McalControl() with M_GRID_PARTIAL set to M_ENABLE. By default, camera calibration using partial grids is disabled (M_GRID_PARTIAL set to M_DISABLE). In this case, the complete grid should be visible, including the outermost boundary squares/rectangles. Any occlusion of the grid can result in problems. The number of rows and columns specified when calling McalGrid() must equal the number of rows and columns found in the image of the grid. When partial grids are enabled (M_GRID_PARTIAL set to M_ENABLE), the chessboard grid in your image can be occluded, either by the edge of the image or by an object within the image. For partial grids, you do not explicitly specify the number of rows and columns when calling McalGrid(), so the grid can have any number of rows and columns. For more information on partial grids, see the Calibrating with a partial chessboard grid subsection of this section. Note that only chessboards grids can be partial. Circle grids must always be complete. For both complete and partial grids, the image of the chessboard grid should meet the following guidelines: The squares/rectangles should each be at least 12 X 12 pixels. In the case of rectangles or squares with perspective distortion, the smallest dimension should be at least 12 pixels. The physical grid and the grid image should be clear of specks, dirt, and noise. This can be achieved by cleaning the physical grid and/or preprocessing the image, as much as possible. The grid should have little to no saturation. The grid image should have high contrast. Defining the absolute coordinate system Calibration defines the absolute coordinate system. McalGrid() takes a grid, finds the grid's reference calibration point, which typically becomes the origin of the absolute coordinate system, and finds the grid lines, two of which become the axes of the absolute coordinate system. Note that while McalGrid() typically defines the absolute coordinate system directly, it can be used to define the relative coordinate system directly and the absolute coordinate system indirectly. For more information on when and how you should define the relative coordinate system directly, see the Defining the relative coordinate system directly subsection of this section. Determining the grid's reference calibration point For circle grids and complete chessboard grids, the calibration point closest to the top-left corner of the grid image is the grid's reference calibration point. The reference calibration point, along with the offset parameters of McalGrid(), determine the origin (0, 0) of the absolute coordinate system. The X- and Y-axes of the absolute coordinate system are aligned with the top-most row and left-most column of the grid, respectively. Typically, the offset parameters are set to 0, which makes the grid's reference calibration point the origin of the absolute coordinate system. If the grid appears rotated in the image such that the grid's reference calibration point is not in the top-left corner of the image, you must specify where the grid's reference calibration point is in the image. The grid can appear rotated in the image for two different reasons: because the physical grid is rotated or because the camera is rotated. Regardless of the reason, the solution is the same: specify a hint pixel. Specify a hint pixel that is close to the grid's reference calibration point in the rotated image. To do so, use McalControl() with M_GRID_HINT_PIXEL_X and M_GRID_HINT_PIXEL_Y before calling McalGrid(). For instance in the following image, the image of the grid appears rotated 90º, so the grid's reference calibration point is roughly at the pixel coordinates (225, 25). In this case, you would set your hint pixel to any pixel close to (225, 25), and then call McalGrid(). There are at most 4 corners to the grid (or 2 valid corners, given a rectangular grid with a known number of rows and columns), so the rough estimate of the pixel coordinates of the reference calibration point do not have to be precise. The closest valid corner to the specified coordinates will be used as the grid's reference calibration point. Note that in this example, the real-world grid has 9 horizontal rows and 12 vertical columns. However, the grid appears rotated in the image; so, it seems to have 12 horizontal rows and 9 vertical columns. It is important to specify the real-world values of 9 rows and 12 columns when calling McalGrid(), regardless of how the grid looks in the rotated image. McalGrid() looks for the closest valid corner, given the hint pixel and the number of rows and columns. Also note that, in this example, if a hint pixel is specified near to the opposite corner, the absolute coordinate system's origin would be placed there, which is the only other possible valid corner for a non-square grid. Inverting the rows and columns will not cause an error, but might change the grid's reference calibration point and the orientation of the axes. Using the X- and Y-offsets Once McalGrid() has determined the grid's reference calibration point and orientation, it applies the specified X- and Y-offsets to determine the origin of the absolute coordinate system. Whatever values you specify for the X- and Y-offsets will be the coordinates of the grid's reference calibration point in the absolute coordinate system. Typically, you specify 0 for the X- and Y-offsets, which means that the grid's reference calibration point is at the origin of the absolute coordinate system. You can, however, specify any values for the offsets; the offsets are specified in real-world units. Note that the origin of the absolute coordinate system does not have to be within the field-of-view. Note that for 3D calibration modes, you can also offset along the Z-axis. If your grid is parallel to the surface that you want to use to define the absolute coordinate system, but not at the same height, you should compensate for the height difference using the Z-offset parameter when calling McalGrid(). This can be used even for a small height differential caused by the thickness of the grid itself. For more information, see the Moving the relative coordinate system to account for height section of Chapter 34: 3D analysis using planar views of an object. Inverting the orientation of the Y-axis By default, the Camera Calibration module assumes the Y-axis is oriented 90° clockwise with respect to the positive X-axis. You can have the positive Y-axis oriented 90° counter-clockwise with respect to the positive X-axis using McalGrid() with M_CIRCLE_GRID or M_CHESSBOARD_GRID and the combination constant M_Y_AXIS_COUNTER_CLOCKWISE. Note that the orientation of the absolute coordinate system in the image of the grid is affected by the location of the hint pixel specified using McalControl() with M_GRID_HINT_PIXEL_X and M_GRID_HINT_PIXEL_Y. In the following images, the bold X in the grid is the hint pixel. Note that in the case of 3D calibrations, there is also the Z-axis to consider. By default, the Z-axis is pointing downward, typically away from the camera. When the Y-axis is inverted using M_Y_AXIS_COUNTER_CLOCKWISE, the Z-axis also inverts, so that the 3D coordinate systems always remains right-handed. When inverted, the Z-axis points upward, typically toward the camera, as illustrated in the image below. Calibrating with a partial chessboard grid In some circumstances, such as when the camera placement necessitates that the grid be partially occluded, you can calibrate your camera with a partial grid. In this case, there are special considerations. You can calibrate your camera using a partial chessboard grid, but not a partial circle grid. Circle grids must be complete. You must explicitly enable camera calibration with partial grids, using McalControl() with M_GRID_PARTIAL, prior to calling McalGrid(). For a partial grid, the grid's default reference calibration point (used to determine the origin of the absolute coordinate system) is the calibration point closest to the center of the image. You can specify a non-default reference calibration point by specifying a grid hint pixel, using McalControl() with M_GRID_HINT_PIXEL_X and M_GRID_HINT_PIXEL_Y. The grid's reference calibration point will be the calibration point closest to the grid hint pixel. The grid's orientation is determined by the two grid lines intersecting at the reference calibration point. The X- and Y-axes are always aligned with the grid lines. By default, the X-axis of the absolute coordinate system is the grid line intersecting the reference calibration point and closest to the image's X-axis, with the positive X-axis pointing right. To specify the other grid line and/or direction for the positive X-axis, you must specify McalControl() with M_GRID_HINT_ANGLE_X. When you specify a hint angle, the positive X-axis will be the grid line intersecting the reference calibration point and closest in angle to the hint angle. The Y-axis is 90° clockwise from the X-axis, unless it is inverted using McalGrid() with M_CHESSBOARD_GRID + M_Y_AXIS_COUNTER_CLOCKWISE. You can specify how to handle potential invalid calibration points, using McalControl() with M_GRID_SHAPE. Choosing between setting M_GRID_SHAPE to M_RECTANGLE or M_ANY helps McalGrid() determine where the edge of the chessboard grid is. With the knowledge of the edge of the grid, it becomes easier to determine if a calibration point found near the edge is valid (from the grid) or invalid (from noise). By default, M_GRID_SHAPE is set to M_RECTANGLE. This assumes that the edges of the grid can be found. Once a grid edge is found, any potential calibration point found beyond the grid edge can be ignored. You can keep the default value (M_RECTANGLE) even when the grid is partially occluded by the image border, as long as the shape of the visible edges of the grid are rectangular (straight edges connected in 90° angles). Set M_GRID_SHAPE to M_ANY when the physical chessboard grid is not rectangular, for instance a circular or triangular grid that fits inside some enclosure, or when the grid is occluded by some object. In this case, all potential calibration points will be included in the camera calibration, possibly including false calibration points near the edge of the grid caused by noise. This has the effect of potentially reducing the quality of the camera calibration. Defining the relative coordinate system directly In most circumstances, calibrating your camera will define the absolute coordinate system. The grid's reference calibration point, the axes directions, and the specified X- and Y-offsets, define the origin and orientation of the absolute coordinate system. This is the default behavior. Note that when you define the absolute coordinate system, you indirectly define your relative coordinate system to be, by default, at the same place as the absolute. You can, however, define the relative coordinate system directly and the absolute coordinate system indirectly, by calling McalControl() with M_CALIBRATION_PLANE set to M_RELATIVE_COORDINATE_SYSTEM. This can be useful when calibrating a M_TSAI_BASED camera calibration context, or an M_STATIONARY_CAMERA type of M_3D_ROBOTICS camera calibration context. Note that, you cannot set M_CALIBRATION_PLANE to M_ABSOLUTE_COORDINATE_SYSTEM for an M_STATIONARY_CAMERA type of M_3D_ROBOTICS camera calibration context. By default, the relative and absolute coordinate system overlap when they are first created using McalGrid(), so defining the absolute coordinate system directly or the relative coordinate system directly is identical. However, you can specify a position and orientation for the relative coordinate system, with respect to the absolute coordinate system, before either are officially created. If the relative coordinate system is offset from the absolute coordinate system before calling McalGrid(), specifying whether the camera calibration grid represents the relative or the absolute coordinate system with M_CALIBRATION_PLANE make a difference. In the image below, before calling McalGrid(), the relative coordinate system was specified (using McalRelativeOrigin() or McalSetCoordinateSystem()) to be translated away from the absolute coordinate system by 4 units in the X-axis, 2 units in the Y-axis, and 0 in the Z-axis. The image on the left shows the placement of the two coordinate systems when M_CALIBRATION_PLANE is set to M_RELATIVE_COORDINATE_SYSTEM. The image on the right shows the placement when M_CALIBRATION_PLANE is set to M_ABSOLUTE_COORDINATE_SYSTEM. Note that in both images, the relative coordinate system has the same position relative the absolute coordinate system. Calibrating a Tsai based camera calibration context when the camera is directly overhead When calibrating a M_TSAI_BASED camera calibration context, typically, your camera must be positioned so that it has perspective distortion. In the case of a camera setup with a camera directly overhead the working area, there is no natural perspective distortion, presenting a challenge to camera calibration. This challenge can be addressed using McalControl() with M_CALIBRATION_PLANE. Lift one side of the grid to a known angle, for instance by placing the grid on an accurately manufactured wedge. Before grabbing the image of the grid, set the position of the relative coordinate system such that the relative coordinate system is offset from the absolute coordinate system (the working area) at the precise angle of the wedge the grid is resting on (using McalSetCoordinateSystem()). Now, change the calibration plane to the relative coordinate system (using McalControl() with M_CALIBRATION_PLANE set to M_RELATIVE_COORDINATE_SYSTEM), grab an image of the grid on the wedge, and calibrate the camera (using McalGrid()). The relative coordinate system will be at the angle of the grid on the wedge and the absolute coordinate system will be the working area. You can then realign the relative coordinate system so that it is on or parallel to the same surface as the absolute coordinate system. Calibrating using calibration points from a grid Requirements for the image of the grid Requirements for the image of a circle grid Requirements for the image of a chessboard grid Defining the absolute coordinate system Determining the grid's reference calibration point Using the X- and Y-offsets Inverting the orientation of the Y-axis Calibrating with a partial chessboard grid Defining the relative coordinate system directly Calibrating a Tsai based camera calibration context when the camera is directly overhead ",
      "wordCount": 2870,
      "subEntries": []
    },
    {
      "id": "UG_calibration_Calibrating_using_a_fiducial_grid",
      "version": null,
      "title": "Calibrating using a fiducial grid",
      "subTitles": [
        "Requirements when calibrating your camera setup using a fiducial grid",
        "Defining the absolute coordinate system with a fiducial grid",
        "Determining the grid's reference calibration point",
        "Orientation of the fiducial grid in the image",
        "Specifying the position and orientation of the absolute coordinate system when calling McalGrid()",
        "Inquiring camera calibration information after successful calibration",
        "Calibrating multiple cameras or camera positions using a fiducial grid",
        "Multi-fiducial grids"
      ],
      "location": "MIL UG P04: 2D related information",
      "pageURL": "content\\UserGuide\\calibration\\Calibrating_using_a_fiducial_grid.htm",
      "text": " Calibrating using a fiducial grid Another way to calibrate your camera setup and have MIL automatically establish the calibration points is to use a fiducial grid, as in the image below. A fiducial grid is a chessboard grid that contains a fiducial. The fiducial used in a fiducial grid is a Data Matrix code that encodes information about the grid itself. This encoded grid information includes the grid spacing, the units in which the spacing is measured, the position of the grid's reference calibration point, and the grid's orientation. Calibrating with a fiducial grid is especially useful when calibrating multiple cameras or multiple camera positions in a single coordinate system. It can be difficult to find a common reference calibration point shared by all the images of the same grid taken at different angles and positions. By using a fiducial grid that encodes a specific reference calibration point, any image of the grid, regardless of its orientation or position, will have the same known reference calibration point. The following image is a 6x6 fiducial grid. MIL is distributed with a fiducial grid that you can print and use: FiducialCalibrationGrid_Letter.pdf, located in the Matrox Imaging\\Images directory. However, you can also generate your own fiducial grid by running the CalGenChessGrid example, accessible from the Matrox Example Launcher. For information on how to modify the example to generate a fiducial grid specific to your setup, see the Generating a grid for calibration section later in this chapter. To calibrate your camera setup using a fiducial grid, you need to set a few control types, grab an image of the fiducial grid, and call McalGrid(). Requirements when calibrating your camera setup using a fiducial grid The Data Matrix code in the grid encodes real-world information about the grid. Calibrating your camera using a valid fiducial grid requires you to set the following control types using McalControl(): Enable the use of a Data Matrix code as a fiducial, using M_GRID_FIDUCIAL set to M_DATAMATRIX. Enable the use of partial grids, using M_GRID_PARTIAL set to M_ENABLE, since the Data Matrix code covers part of the grid. Ensure there is no hint pixel or hint angle by setting M_GRID_HINT_PIXEL_X, M_GRID_HINT_PIXEL_Y, and M_GRID_HINT_ANGLE_X to M_NONE. This is the default setting, so this is typically unnecessary. Once these control types are set, you can grab an image of the grid and call McalGrid() with the following parameter values: Set the row number and column number parameters to M_UNKNOWN. Set the row spacing and column spacing parameters to M_FROM_FIDUCIAL. Note that if you calibrate with a fiducial grid and set these parameters to specific values, the values that you specify will override the values encoded in the Data Matrix code. Set the grid type to M_CHESSBOARD_GRID. The image of the grid must meet the following requirements: The Data Matrix code in the image of your fiducial grid must have a sufficient buffer zone around it. The squares that the fiducial is placed upon are known as the fiducial zone. To recognize the fiducial in the grid, the camera must see at least 1.5 squares between the fiducial zone and the edge of the grid on all sides, as illustrated in the image below. If the fiducial is too close to the edge of the image, McalGrid() might not recognize the fiducial, which will cause the camera calibration to fail. Calibrating your camera setup using a fiducial grid works with all camera calibration modes, but it is not recommended for M_LINEAR_INTERPOLATION mode, which is the default calibration mode. This is because the fiducial rests on top of one or more calibration points, effectively removing the point(s) from the grid. The effect of the missing calibration points in M_LINEAR_INTERPOLATION mode is local inaccuracy; the camera calibration around the area in the image that has the missing calibration points will be less accurate. Note that the effect of the missing calibration points in the other camera calibration modes is still inaccuracy, but the inaccuracy is evenly distributed across the entire image, making it nearly irrelevant. Calibrating a low-resolution camera using a fiducial grid is not recommended. Low resolution images might have Data Matrix codes that are difficult to decode. Also, low-resolution images will mean bigger calibration squares and therefore have fewer calibration points, which leads to a less accurate calibration. At minimum, the image resolution and image size must allow the individual cells in the Data Matrix code to be at least 3x3 pixels. Defining the absolute coordinate system with a fiducial grid Calibrating a camera setup, regardless of the calibration mode or type of grid, defines the absolute coordinate system in the world. For a fiducial grid, like the chessboard grid and circle grid, the absolute coordinate system's origin and orientation are determined by the grid's features, such as the grid's reference calibration point and orientation, and the parameter values of McalGrid(). Note that while McalGrid() typically defines the absolute coordinate system directly, it can be used to define the relative coordinate system directly and the absolute coordinate system indirectly using McalControl() with M_CALIBRATION_PLANE. For more information, see the Defining the relative coordinate system directly subsection of the Calibrating using calibration points from a grid section earlier in this chapter. Determining the grid's reference calibration point The fiducial grid's reference calibration point is an important component of defining the absolute coordinate system, but it cannot be directly observed from the grid itself; the position of the grid's reference calibration point is encoded in the Data Matrix code. The grid's reference calibration point is typically the calibration point to the top-left of the fiducial in the grid. This is the default position when creating your fiducial grid using the CalGenChessGrid example. The reference calibration point can be anywhere on the grid and its position can only be determined after the Data Matrix code is read. With the default fiducial grid output from the CalGenChessGrid example, there are marks on the outside of the grid that signify where the reference point is. These marks are not, strictly speaking, part of the grid itself. In practice, McalGrid() finds the Data Matrix code, reads the code, and then sets the grid's reference calibration point accordingly. The following illustration shows a fiducial grid with the default reference calibration point and the absolute coordinate system that results from the grid. For more information about specifying the position of the grid's reference calibration point and the fiducials, see the Specifying the grid's fiducials subsection of the Generating a grid for calibration section later in this chapter. Orientation of the fiducial grid in the image The position (and offset, if any) of the fiducial in the grid determines where the grid's reference calibration point is, but the reference calibration point does not determine the orientation of the fiducial grid. The orientation of the fiducial grid is determined by the orientation of the fiducial. A Data Matrix code has a known orientation. It has a solid black L-shaped finder pattern on its bottom and left side, and a checkered pattern on its top and right side. Since the orientation of the Data Matrix code is always known, the direction of the X- and Y-axes are always known, even if the fiducial grid is rotated. In the following image, the fiducial grid is rotated 45° and is slightly askew, yet the grid's reference calibration point and the grid orientation are automatically known because of the features of the Data Matrix code. Note that it is not advisable to use a grid that occupies so little of the entire camera's field of view, as in the image above. Those areas of the image (the camera's field of view) that do not have calibration points will not be accurately calibrated. Specifying the position and orientation of the absolute coordinate system when calling McalGrid() A fiducial grid has a fixed reference calibration point and orientation, but these are only the starting points of determining the origin and orientation of the absolute coordinate system. Like with chessboard grids and circle grids, you can apply an offset and/or invert the orientation of the Y-axis of the absolute coordinate system when calling McalGrid(). Typically, when you call McalGrid(), you specify 0 for the X- and Y-offset parameters. This means that typically, the grid's reference calibration point is the origin of the absolute coordinate system. You can, however, specify any value for the offsets; the offsets are specified in real-world units. When you specify an X- or Y-offset, you move the origin of the absolute coordinate system away from the grid's reference calibration point. The reference calibration point will have the coordinates specified by the X- and Y-offsets. For example, when calling McalGrid(), if you set the X- and Y-offsets to 3 and 4, respectively, the grid's reference calibration point would have the coordinates (3, 4) in the absolute coordinate system. Even though the orientation of a fiducial grid is fixed, you are still able to invert the direction of the Y-axis in the absolute coordinate system, using McalGrid() with M_Y_AXIS_COUNTER_CLOCKWISE. In this case, the Y-axis of the absolute coordinate system will be 90° counter clockwise from the X-axis, instead of the default 90° clockwise from the X-axis. Note that for 3D camera calibration setups, the Z-axis also inverts when you invert the Y-axis. Typically, the Z-axis is facing down into the working area, but once the Y- axis is inverted, the Z-axis will point up, towards the camera. Inquiring camera calibration information after successful calibration After a successful calibration with a fiducial grid, you can inquire the grid spacings (McalInquire() with M_ROW_SPACING or M_COLUMN_SPACING). You can inquire the unit used to describe the spacings (which is also the unit used for all positions returned by the module) using McalInquire() with M_GRID_UNITS or M_GRID_UNIT_SHORT_NAME, to get a constant or a string, respectively. M_GRID_UNITS M_GRID_UNIT_SHORT_NAME M_UNKNOWN units Metric Units M_MICROMETERS um M_MILLIMETERS mm M_CENTIMETERS cm M_METERS m M_KILOMETERS km Imperial Units M_MILS mils M_INCHES in M_FEET ft M_MILES miles Note that MIL does not enforce unit consistency when mixing results from different calibrations, nor does it perform any unit conversion. Calibrating multiple cameras or camera positions using a fiducial grid One of the best uses for a fiducial grid is for calibrating multiple cameras or camera positions. If you have more than one camera whose images need to share the same absolute coordinate system, using a fiducial grid is recommended. Consider the following working area and camera setup, where two cameras will grab images of a conveyor. Looking from above, the fiducial grid covers most of the working area. Camera 1 can see the entire grid, but camera 2, which is rotated 90°, cannot see the entire grid, as in the image below. You grab an image of the fiducial grid with camera 1 and use it to calibrate camera 1. The orientation and position of the absolute coordinate system is established using the reference calibration point and the orientation of the fiducial grid. When you grab an image of the same unmoved fiducial grid with camera 2, the image appears to be rotated. Calibrating camera 2 with this image will produce the same absolute coordinate system, despite appearing differently. The animation below illustrates camera calibration using a fiducial grid. Once these cameras are calibrated and have the same absolute coordinate system, an unmoved object that both cameras can see will have the same coordinates for the same point on the object, despite appearing in very different positions in the image, as illustrated below. The example above is for two cameras, but could easily apply to one camera that is moved to different positions during camera calibration, as is the case when calibrating your camera in M_3D_ROBOTICS camera calibration mode. Note that it is essential that each camera be able to see a fiducial in the grid. If there is no way to position your cameras and/or fiducial grid so that at least one complete fiducial is in the field of view of every camera, you must create a new fiducial grid that has either more fiducials or better placed fiducials. Multi-fiducial grids Sometimes your working area is too large for your cameras' field of view and at least one camera cannot see the fiducial. In this case, you must create a new fiducial grid that has more than one fiducial. For example, in the image below, the overlap of the two cameras' field of view is too narrow for the fiducial zone to satisfy the requirement of being 1.5 chessboard squares away from the edge of the image. This means that there is no spot for the fiducial to satisfy this constraint for both cameras. A second fiducial is added so that both cameras can be calibrated using a fiducial grid. Each fiducial in the grid encodes where the grid's reference calibration point is with regards to itself. In the image below, fiducial 1 encodes an X-offset of +2 and a Y-offset of -2. This means that the grid's reference calibration point is two calibration points left and two calibration points down from fiducial 1. Fiducial 2 specifies the exact same reference calibration point (there can be only one), but encodes an X-offset of -3 and a Y-offset of +1. This means that the grid's reference calibration point is three calibration points right and one calibration point up from fiducial 2. If you have multiple fiducials and one of your cameras is able to see two or more of them, McalGrid() will only decode one of them. As long as your fiducial grid is valid, decoding any one will have the same result. The position of each fiducial perfectly matches its encoded offsets so that every fiducial on the grid points to the same calibration point as the grid's reference calibration point. If your fiducial grid is invalid, for whatever reason, no error will occur, but the results will be uncertain. Note that the grid's reference calibration point does not have to be in the image. In the above image, the grid's reference calibration point is not in camera 2's field of view. Calibrating using a fiducial grid Requirements when calibrating your camera setup using a fiducial grid Defining the absolute coordinate system with a fiducial grid Determining the grid's reference calibration point Orientation of the fiducial grid in the image Specifying the position and orientation of the absolute coordinate system when calling McalGrid() Inquiring camera calibration information after successful calibration Calibrating multiple cameras or camera positions using a fiducial grid Multi-fiducial grids ",
      "wordCount": 2415,
      "subEntries": []
    },
    {
      "id": "UG_calibration_Calibrating_using_calibration_points_from_a_list",
      "version": null,
      "title": "Calibrating using calibration points from a list",
      "subTitles": null,
      "location": "MIL UG P04: 2D related information",
      "pageURL": "content\\UserGuide\\calibration\\Calibrating_using_calibration_points_from_a_list.htm",
      "text": " Calibrating using calibration points from a list McalList() allows you to explicitly specify the calibration points as a list of pixel coordinates and their associated real-world coordinates. The more coordinates you specify, the more accurate the mapping. McalList() can be used when you explicitly know the real-world coordinates for a given set of pixel coordinates. The specified pixel coordinates should cover the area of the image from which you want real-world coordinates (the working area). Based on your camera calibration mode, McalList() requires a certain minimum number of points to calibrate correctly. The following table shows the minimum number of points that McalList() requires to perform a full calibration given a specific camera calibration mode. Camera calibration mode Minimum number of points required for a full calibration Uniform 3 Piecewise linear interpolation 3 Perspective transformation 4 Tsai-based (with no z-coordinate) 5 Tsai-based (with z-coordinate) 7 Robotics 5 In the case of perspective distortion, knowing the world coordinates of 4 points in the image gives sufficient information to create a mapping function. To create a good mapping for radial distortion, the Camera Calibration module requires a larger number of coordinates (for example, more than 30) distributed over the image. Unlike when using McalGrid(), McalList() does not use a default orientation for the Y-axis of the absolute coordinate system. It establishes the orientation based on the specified calibration points. It arbitrarily selects three of the specified points (for example, point A, B, and C). It then establishes the direction that a line between point A and B would rotate to meet a line between point A and C while using the smallest angle of rotation. It finally selects the Y-axis orientation for the absolute coordinate system so that the rotation direction in the pixel coordinate system and in the absolute coordinate system are the same. To inquire the orientation of the Y-axis, use McalInquire() with M_Y_AXIS_DIRECTION. Calibrating using calibration points from a list ",
      "wordCount": 323,
      "subEntries": []
    },
    {
      "id": "UG_calibration_Inquiring_about_your_calibration",
      "version": null,
      "title": "Inquiring about your camera calibration",
      "subTitles": [
        "Camera calibration status and errors",
        "Camera calibration accuracy",
        "Addressing calibration error due to problems finding calibration points",
        "Addressing calibration error due to problems creating the mapping function",
        "Inquiring pixel and world calibration points",
        "Position and orientation of coordinate systems",
        "Pinhole camera"
      ],
      "location": "MIL UG P04: 2D related information",
      "pageURL": "content\\UserGuide\\calibration\\Inquiring_about_your_calibration.htm",
      "text": " Inquiring about your camera calibration After camera calibration, you can inquire about the status and accuracy of your calibration, as well as the position and orientation of your coordinate systems. You can also inquire the intrinsic and extrinsic attributes of the pinhole camera used to model your camera when working with 3D-based camera calibration modes. Camera calibration status and errors After calibrating with McalGrid() or McalList(), you can check the success of your camera calibration using McalInquire() with M_CALIBRATION_STATUS. If calibration was successful, it will return M_CALIBRATED, otherwise an error code is returned. For example, if you calibrate using McalGrid() and the grid does not meet the required guidelines, M_CALIBRATION_STATUS returns M_GRID_NOT_FOUND. If you try to perform a full calibration in M_TSAI_BASED mode, and the camera is placed perpendicular to the grid, M_PLANE_ANGLE_TOO_SMALL is returned. M_NOT_INITIALIZED is returned if M_CALIBRATION_STATUS is inquired before calling McalGrid() or McalList(). Camera calibration accuracy After a successful camera calibration, you can inquire about the accuracy of your calibration. From the pixel coordinates and corresponding world coordinates of the calibration points, McalGrid() and McalList() establishes a mapping function that can transform any pair of pixel coordinates to their corresponding world coordinates, and vice versa. Depending on several factors, such as the calibration mode, noise in the image, and camera distortion, the mapping function might not be perfectly accurate. After calibration, this slight inaccuracy can even apply to the original calibration points. For instance, the original pixel coordinates of the calibration points, when transformed into world coordinates, might not equal the original world coordinates of the calibration points. The difference between the transformed coordinates and the original coordinates of the calibration points is called camera calibration error. In the default M_LINEAR_INTERPOLATION calibration mode, the mapping function is created such that the pixel coordinates, when transformed into world coordinates, are nearly identical to the original world coordinates, and vice versa, for all calibration points. This results in a camera calibration that is nearly perfectly accurate for the calibration points. When calibrating using a grid, this implies a very high accuracy in the area of the image with the grid, and a lower accuracy for the rest of the image. In every other calibration mode, the mapping function is created, such that it is accurate more evenly across the entire image. Effectively, this means that in M_LINEAR_INTERPOLATION calibration mode, real-world measurements will be more accurate the closer they are to the area of the image that had the grid; while in all other calibration modes, any inaccuracy of real-world measurements will be felt equally throughout the image. You can inquire about the camera calibration error using McalInquire() with M_AVERAGE_PIXEL_ERROR, M_MAXIMUM_PIXEL_ERROR, M_AVERAGE_WORLD_ERROR, or M_MAXIMUM_WORLD_ERROR. Note that for robotics camera calibration mode, you can use McalInquireSingle() to inquire about the calibration accuracy of each call to McalGrid() or McalList() made with M_ACCUMULATE. There are two main causes of calibration error: problems finding calibration points and problems creating the mapping function. Addressing calibration error due to problems finding calibration points McalGrid() takes an image of a grid and determines the pixel coordinates of the calibration points using feature extraction algorithms. You can assess the accuracy of the feature extraction using McalDraw() with M_DRAW_IMAGE_POINTS, which draws the extracted calibration points. You can overlay the extracted calibration points on the original image of the grid to ensure that there are no false calibration points or missing calibration points. It is also important that the pixel coordinates of the calibration points are directly in the middle of each circle, for a circle grid, or at the intersection of the grid squares, for a chessboard grid or fiducial grid. Any extra points, missing points, or imprecisely positioned points will result in calibration error. You can typically improve the accuracy of the found calibration points by physically cleaning your grid or cleaning up the image of the grid. Cleaning up the image of the grid can include adjusting the focus of the camera, the saturation of the image, or the lighting in the setup. The contrast between the foreground and the background of the grid must be sharp. Addressing calibration error due to problems creating the mapping function Camera calibration creates a mapping function that can transform pixel coordinates to world coordinates, and vice versa. This mapping function makes certain assumptions, based on the calibration mode. Any violation of the assumptions can result in a mapping function that imprecisely maps pixel coordinates to world coordinates. For instance, camera calibrations calculated in M_PERSPECTIVE_TRANSFORMATION mode cannot be used with cameras that have lens distortion. If you calibrated your camera setup in this mode and your camera has lens distortion, there would likely be mapping problems. Often the violation of assumptions is a matter of degree. For instance, most cameras have at least a small amount of lens distortion, especially around the edge of the lens. This means that most calibrations calculated using M_PERSPECTIVE_TRANSFORMATION mode (which doesn't compensate for lens distortion) will have some degree of calibration error. You can determine if the error is within tolerance using McalInquire(). There are two types of calibration error measured: pixel error (M_AVERAGE_PIXEL_ERROR or M_MAXIMUM_PIXEL_ERROR) and world error (M_AVERAGE_WORLD_ERROR and M_MAXIMUM_WORLD_ERROR). The pixel error is the pixel difference between the original world coordinates of the calibration points transformed into pixel coordinates, and the original pixel coordinates of the calibration points. The world error is the world difference between the original pixel coordinates of the calibration points transformed into world coordinates, and the original world coordinates of the calibration points. In both cases, the calibration error is a measure of the quality of the mapping function as applied to the calibration points. You can visually inspect the location and severity of the calibration error using McalDraw(). You can draw the original pixel coordinates of the calibration points using M_DRAW_IMAGE_POINTS, and you can draw the original world coordinates of the calibration points, transformed into the pixel coordinates with the mapping function, using M_DRAW_WORLD_POINTS. By drawing the original and transformed coordinates together, you can see where the points differ. This difference is calibration error. Alternatively, you could draw just the original world coordinates (transformed into pixel coordinates with the mapping function), directly on the image of the original grid, as in the image below. This way you can see exactly where on the grid are the biggest differences. With this information, you can adjust the setup as needed. To improve the accuracy of your calibration (reduce the calibration error caused by mapping problems), you can specify a calibration mode that better represents the assumptions of your camera setup. Generally speaking, you can reduce camera calibration error by calibrating again using a new camera calibration context that encompasses more assumptions. If your first calibration mode is M_UNIFORM_TRANSFORMATION and it produces a calibration with more calibration error than you can tolerate, try using a new calibration context in M_PERSPECTIVE_TRANSFORMATION mode. If this still produces a calibration with more error than is tolerable, try using a new calibration context in M_TSAI_BASED mode. Note that M_TSAI_BASED mode supports 3D calibration and has additional setup considerations. In the default calibration mode, M_LINEAR_INTERPOLATION mode, the mapping function is created so that comparing transformed coordinates (either pixel-to-world or world-to-pixel) to the original coordinates of the calibration points results in almost no measured calibration error. This produces increased calibration accuracy for areas of the image inside the grid and reduced accuracy for areas outside the grid. Because calibration error is measured using calibration points, there is no way to measure the inaccuracy of the areas outside of the grid. Also, if the pixel coordinates or world coordinates of any calibration point are incorrectly specified, the mapping will be significantly inaccurate in the area around the incorrectly specified calibration point. This inaccuracy also cannot measured. For information on each calibration mode, including a list of supported features, see the Camera calibration modes section earlier in this chapter. Another way to improve the accuracy of the mapping function is to increase the number of calibration points used to calibrate your camera setup. When calibrating using a grid, this means you could use a grid with more columns or rows, possibly with smaller spacings between calibration points. The number of calibration points and the size of the spacings has limitations, which are discussed in the Calibrating using calibration points from a grid section earlier in this chapter. To maximize grid coverage in your image, you can use a chessboard or fiducial grid that extends outside the image borders, using McalControl() with M_GRID_PARTIAL set to M_ENABLE. Inquiring pixel and world calibration points You can inquire the pixel coordinates and world coordinates of the calibration points that were used by McalGrid() or McalList() to create the camera calibration. If you have calibrated using McalGrid(), the pixel coordinates of the calibration points are those automatically extracted from the image of the grid, and the world coordinates of the calibration points are those calculated from the world description of the grid (number and spacings of the rows and columns of the grid). If you have calibrated using McalList(), you have explicitly specified the pixel coordinates and world coordinates of the calibration points. You can inquire the pixel coordinates of the calibration points, using McalInquire() with M_CALIBRATION_IMAGE_POINTS_X and M_CALIBRATION_IMAGE_POINTS_Y. When inquiring the pixel coordinates of calibration points from a grid, the coordinates correspond to the extracted center of the circles in a circle grid or to the extracted intersections of four corners in a chessboard grid or fiducial grid. You can inquire the world coordinates of the calibration points, using McalInquire() with M_CALIBRATION_WORLD_POINTS_X and M_CALIBRATION_WORLD_POINTS_Y. You can use these coordinates to independently calculate calibration error. To calculate the calibration error in world units, perform the following: Inquire the original pixel coordinates of the calibration points using McalInquire() with M_CALIBRATION_IMAGE_POINTS_X and M_CALIBRATION_IMAGE_POINTS_Y. Transform the original pixel coordinates to world coordinates using McalTransformCoordinate() or McalTransformCoordinateList() with M_PIXEL_TO_WORLD. Inquire the original world coordinates of the calibration points using McalInquire() with M_CALIBRATION_WORLD_POINTS_X and M_CALIBRATION_WORLD_POINTS_Y. Compare the transformed world coordinates to the original world coordinates to calculate your own world calibration error metrics. Calibrations in M_LINEAR_INTERPOLATION mode should have two nearly identical sets of coordinates. Note that to calculate the calibration error in pixel units, you must perform the same steps but in a different order. First you must inquire the original world coordinates, then transform them to pixel coordinates with M_WORLD_TO_PIXEL, then inquire the original pixel coordinates, and finally compare the transformed pixel coordinates with the original pixel coordinates to calculate the pixel calibration error. Position and orientation of coordinate systems You might need to inquire about the position and orientation of one coordinate system with respect to another. You can do so using McalInquire() for two-dimensional camera calibration modes or McalGetCoordinateSystem() for three-dimensional camera calibration modes. For two dimensional camera calibration modes, you can inquire about the position and orientation of the relative coordinate system and the position of the tool coordinate system: To retrieve the position of the relative coordinate system, use McalInquire() with M_RELATIVE_ORIGIN_X, M_RELATIVE_ORIGIN_Y, and M_RELATIVE_ORIGIN_Z. To inquire about the rotation of the relative coordinate system, use McalInquire() with M_RELATIVE_ORIGIN_ANGLE; this will return the counter-clockwise angle of rotation about the Z-axis as measured with respect to the absolute coordinate system. To retrieve the position of the tool coordinate system, use McalInquire() with M_TOOL_POSITION_X, M_TOOL_POSITION_Y, M_TOOL_POSITION_Z, and M_TOOL_ROTATION_Z. For 3D-based camera calibration modes, use McalGetCoordinateSystem() to inquire about the position and orientation of the absolute, relative, tool, or camera coordinate systems. For robotics camera calibration mode, you can also inquire about the position and orientation of the robot base coordinate system. McalGetCoordinateSystem() can return the relationship between these coordinate systems in three-dimensional space, in terms of a specified type of transformation. For example, after a successful Tsai-based camera calibration, you might need to know the calculated position and orientation of your camera with respect to the absolute coordinate system. To obtain this information as a translation and rotation of the camera coordinate system from the absolute coordinate system, you can use McalGetCoordinateSystem() with M_CAMERA_COORDINATE_SYSTEM as the target coordinate system and M_ABSOLUTE_COORDINATE_SYSTEM as the reference coordinate system. The following code snippet shows how to retrieve this information using two consecutive calls to McalGetCoordinateSystem(). The first call returns the X-, Y-, and Z-coordinates of the camera coordinate system's origin, and the second call returns the three rotation angles of the camera coordinate system's axes around the X-, Y-, and Z-axes of the absolute coordinate system. /* Get the position and orientation of the camera with respect to the absolute coordinate system. */ MIL_DOUBLE CameraPosX, CameraPosY, CameraPosZ; MIL_DOUBLE AngleY, AngleX, AngleZ; McalGetCoordinateSystem(CalibrationID, M_CAMERA_COORDINATE_SYSTEM, M_ABSOLUTE_COORDINATE_SYSTEM, M_TRANSLATION, M_NULL, &amp;CameraPosX, &amp;CameraPosY, &amp;CameraPosZ, M_NULL); McalGetCoordinateSystem(CalibrationID, M_CAMERA_COORDINATE_SYSTEM, M_ABSOLUTE_COORDINATE_SYSTEM, M_ROTATION_YXZ, M_NULL, &amp;AngleY, &amp;AngleX, &amp;AngleZ, M_NULL); For robotics camera calibration mode, you can retrieve the position and orientation of any coordinate system with respect to the robot base coordinate system using McalGetCoordinateSystem(). The values returned can then be provided to a robot controller software to move the robot. Note that the pixel coordinate system cannot be used with McalGetCoordinateSystem(). Refer to the Working with real-world units section earlier in this chapter for information on transforming values from world to pixel units. Refer to the Moving coordinate systems to reflect camera setup changes section later in this chapter for more information on coordinate system transformations. Pinhole camera You can retrieve the values of several intrinsic and extrinsic attributes of the pinhole camera used to model your camera when working in Tsai-based or robotics camera calibration mode: To retrieve the calculated effective focal length of the modeled pinhole camera, use McalInquire() with M_FOCAL_LENGTH. The returned value is expressed in horizontal pixel units. You can use the following relation to convert the focal length from pixel units into real-world units: Where specifies the distance between the centers of two horizontally adjacent CCD elements of your camera. Note that this is the focal length of the modeled pinhole camera; it will not necessarily match the focal length given by the lens manufacturer. You can override the value determined by the previous call to McalGrid() or McalList() if you want to use calibration values from another source (for example, the lens manufacturer) using McalControl() with M_FOCAL_LENGTH. To retrieve the second order radial distortion coefficient, use McalInquire() with M_DISTORTION_RADIAL_1. Radial distortion refers to image distortions caused by the camera's lens, namely, pin cushion and barrel distortions. It is calculated by measuring the distance from the principal point to any other point in the image plane. The second order radial distortion coefficient is used in calculations to remove lens distortion, as described below. Let represent the distorted (acquired) pixel coordinates. Coordinates are normalized and centered using and the principal point : Let represent the second order radial distortion coefficient. Where represent the corrected, undistorted coordinates. You can override the value determined by the previous call to McalGrid() or McalList() if you want to use calibration values from another source (for example, the lens manufacturer) using McalControl() with M_DISTORTION_RADIAL_1. To locate the camera's position in space, use McalGetCoordinateSystem() with M_CAMERA_COORDINATE_SYSTEM as a target coordinate system. Inquiring about your camera calibration Camera calibration status and errors Camera calibration accuracy Addressing calibration error due to problems finding calibration points Addressing calibration error due to problems creating the mapping function Inquiring pixel and world calibration points Position and orientation of coordinate systems Pinhole camera ",
      "wordCount": 2553,
      "subEntries": []
    },
    {
      "id": "UG_calibration_Physically_correcting_an_image",
      "version": null,
      "title": "Physically correcting an image",
      "subTitles": [
        "Generating lookup tables to correct images",
        "Scale and position of the corrected image",
        "Transformation cache"
      ],
      "location": "MIL UG P04: 2D related information",
      "pageURL": "content\\UserGuide\\calibration\\Physically_correcting_an_image.htm",
      "text": " Physically correcting an image A calibrated image still appears distorted because it has not been physically corrected. You can use McalTransformImage() to physically correct and remove distortions from your images. An image that has no distortions and appears exactly as it would if looking straight down onto it is known as a corrected image. When a corrected image is used within a MIL module, pixels have the same, uniform size in every direction, and results can be returned in real-world units. As is expected, the image features in the corrected image will have the same world coordinates as they had in the source image, despite the fact their pixel coordinates have changed. For example, after calibrating the source image below, the world coordinates of the bottom-left circle are (5,6). After correcting your image, the world coordinates of the bottom-left circle in the corrected image are also (5,6), even though it is evident that the pixel coordinates are different for the bottom-left circle in the source and corrected images. When working in Tsai-based camera calibration mode or robotics camera calibration mode, it is possible to physically correct lens distortions of an image (that is, barrel distortion and pin cushion distortion) without removing other types of distortions. To correct lens distortions only, use McalTransformImage() with M_CORRECT_LENS_DISTORTION_ONLY. Note that images are physically corrected using a geometric warping. Generating lookup tables to correct images Instead of generating a corrected image, it is possible to generate lookup tables (LUTs), using McalTransformImage() with M_EXTRACT_LUT_X and M_EXTRACT_LUT_Y, and then use these LUTs to correct images using MimWarp(). It is recommended to use this method when you are using hardware that yields faster processing with LUT inputs. Scale and position of the corrected image When calling McalTransformImage(), you can specify the fill mode. This essentially allows you to specify how the transformed image should be positioned and scaled in the destination image. There are three types of fill mode: M_FIT, M_CLIP, and M_USE_DESTINATION_CALIBRATION. An M_FIT fill mode scales and positions the transformed image such that every source pixel maps to a valid destination pixel. An M_CLIP fill mode scales and positions the transformed image so that every destination pixel maps to a valid source pixel. Whereas, an M_USE_DESTINATION_CALIBRATION fill mode scales and positions the transformed image using the camera calibration information of the destination image. When using an M_USE_DESTINATION_CALIBRATION fill mode, the source image is positioned such that its relative coordinate system is placed at the same location as the current relative coordinate system of the destination image. In addition, the source image is scaled to have the same pixel-to-world mapping as the destination image. To use this fill mode, the destination image must be a calibrated image with a uniform pixel size. To apply a calibration to the destination image that just scales and offsets the world coordinate system from the pixel coordinate system, use McalUniform() on the destination buffer prior to calling McalTransformImage(). Note that this fill mode only affects how the image is positioned and scaled in the destination image; the source image is always transformed according to the calibration setting of the CalibrationId parameter. This fill mode cannot be used with M_EXTRACT_LUT_X or M_EXTRACT_LUT_Y or performing an M_CORRECT_LENS_DISTORTION_ONLY operation. If you want to preserve the average pixel size of the source image when using an M_FIT or M_CLIP fill mode, you need to allocate the destination image buffer with an appropriate width and height. If you are performing an M_FIT type operation, you can use McalInquire() with M_TRANSFORM_FIT_SIZE_X_PRESERVE_PIXEL_SIZE and M_TRANSFORM_FIT_SIZE_Y_PRESERVE_PIXEL_SIZE to determine the width and height of your destination image buffer, in pixels, that will best preserve the source image's average pixel size. Likewise, if you are performing an M_CLIP type operation, you can use McalInquire() with M_TRANSFORM_CLIP_SIZE_X_PRESERVE_PIXEL_SIZE and M_TRANSFORM_CLIP_SIZE_Y_PRESERVE_PIXEL_SIZE to determine the width and height of your destination image buffer, in pixels, that will best preserve the source image's average pixel size. Transformation cache By default, a cache is used to physically correct an image. The first time a camera calibration context is used to transform an image, this cache fills up with information relevant to the transformation. On subsequent transformations with the camera calibration context, the information in the cache can significantly accelerate the transform. However, if you need to save memory, you can disable this cache, using McalControl() with M_TRANSFORM_CACHE. The cache consists of two 32-bit buffers that have the same size as the destination buffer of McalTransformImage(). The information in the cache is flushed whenever you change the size of the source or destination buffers of McalTransformImage(), the angle of the relative coordinate system in the camera calibration context, or the size and position of the pixels in the corrected image. Physically correcting an image Generating lookup tables to correct images Scale and position of the corrected image Transformation cache ",
      "wordCount": 802,
      "subEntries": []
    },
    {
      "id": "UG_calibration_Moving_coordinate_systems_to_reflect_camera_setup_changes",
      "version": null,
      "title": "Moving coordinate systems to reflect camera setup changes",
      "subTitles": [
        "Types of transformation",
        "Translation",
        "Rotation",
        "Transforming coordinate systems",
        "Moving the camera after calibrating with a 3D-based camera calibration context",
        "Special considerations concerning the tool and camera coordinate systems"
      ],
      "location": "MIL UG P04: 2D related information",
      "pageURL": "content\\UserGuide\\calibration\\Moving_coordinate_systems_to_reflect_camera_setup_changes.htm",
      "text": " Moving coordinate systems to reflect camera setup changes Once your camera setup is calibrated, you might need to reposition the world coordinate systems, established during calibration, for different reasons. For example, you might need to reposition the tool and the camera coordinate system because the tool holding your camera or grid might have moved, or you might need to reposition the relative coordinate system to measure, in real-world units, an object located at a different position in an image (fixturing). There are two general ways to reposition a coordinate system: Specify an exact transformation using McalSetCoordinateSystem() for 3D-based camera calibration contexts (M_TSAI_BASED or M_3D_ROBOTICS) or using McalRelativeOrigin() or McalControl() for other camera calibration contexts. Automatically recalculate the camera coordinate system's new position using McalGrid() or McalList() for 3D-based camera calibration contexts (M_TSAI_BASED or M_3D_ROBOTICS). All results are returned with respect to the relative coordinate system, so you must ensure it is placed at an appropriate location for your measurements. If you are using 3D-based camera calibration modes, the location of the relative coordinate system along the Z-axis of the absolute coordinate system also affects measurements. For more information, see the Moving the relative coordinate system to account for height section of Chapter 34: 3D analysis using planar views of an object. Types of transformation MIL can reposition a coordinate system (target) with respect to another coordinate system (reference), using two main types of transformations: translation and rotation. Translation A translation of a coordinate system is equivalent to the displacement of all points along the reference coordinate axes and is specified using a translation vector. For camera calibration contexts using a perspective-transformation mode or linear-interpolation mode (two-dimensional camera calibration modes), you can move the relative coordinate system using McalRelativeOrigin(). For 3D-based camera calibration contexts, you can apply a translation along the X, Y, and Z-axes using McalSetCoordinateSystem() with M_TRANSLATION. Rotation A rotation of a coordinate system is equivalent to the movement of all points in a circular motion around some axis in a reference coordinate system. To rotate the relative coordinate system of a camera calibration context that uses a two-dimensional camera calibration mode, use McalRelativeOrigin() with the AngularOffset parameter set to the rotation angle, in degrees. To rotate a coordinate system of a 3D-based camera calibration context, use McalSetCoordinateSystem(). Rotations in three-dimensional space can be specified in multiple ways using this function: Axis and angle rotation. Expresses the rotation of the target coordinate system as a rotation of all its points by a certain angle of rotation ( ), around an arbitrary axis of rotation defined by a unit vector in the reference coordinate system. The animation below illustrates rotation using McalSetCoordinateSystem() with M_ROTATION_AXIS_ANGLE and M_ASSIGN. Quaternion rotation. Expresses the rotation of the target coordinate system as a quaternion from the angle of rotation ( ) and the normalized axis of rotation ( ), as defined in the following equation. Matrix rotation. Expresses the rotation of the target coordinate system as a 3x3 square matrix transformation. X-Y-Z rotation. Expresses the rotation of the target coordinate system as a rotation of all points along the three axes of the reference coordinate system, with all possible X-, Y- and Z-component combinations. It is also known as Roll-Pitch-Yaw rotation. The animation below illustrates the rotation using McalSetCoordinateSystem() with M_ROTATION_XYZ and M_ASSIGN. Homogeneous matrix rotation. Expresses the rotation of the target coordinate system as a homogeneous matrix transformation. Homogeneous matrices can express both a translation and a rotation of a coordinate system. It is a 4x4 matrix made up of a 3x3 rotation matrix and a translation vector. If the rotation matrix is an identity matrix, only a translation takes effect. Transforming coordinate systems For two-dimensional camera calibration modes, you can only transform the relative and tool coordinate systems. To define, move, or rotate the relative coordinate system, use McalRelativeOrigin(). To specify a new position for the tool coordinate system, you can use McalControl() with M_TOOL_POSITION_X, M_TOOL_POSITION_Y, M_TOOL_POSITION_Z, and M_TOOL_ROTATION_Z. For three-dimensional camera calibration modes, use McalSetCoordinateSystem() to transform a three-dimensional coordinate system in terms of another. This function can apply the transformation of a specified target coordinate system in two distinct ways: From the origin and orientation of the reference coordinate system, using McalSetCoordinateSystem() with M_ASSIGN. This method is useful to explicitly define the origin of the relative coordinate system or the tool coordinate system when they have not been previously defined. It is also useful when, for example, all movements of the target coordinate system are only known from the origin of the reference coordinate system. From its current position in a reference coordinate system using M_COMPOSE_WITH_CURRENT. The transformation is still defined in terms of the reference coordinate system. Essentially, the specified transformation is composed with the current position and orientation of the target coordinate system. This method is useful, for example, to translate the tool coordinate system, when you know the precise movement of a robotic arm in the absolute coordinate system. Note that the pixel coordinate system cannot be used with McalSetCoordinateSystem(). The following code snippet shows how to use McalSetCoordinateSystem() to update your camera calibration context after rotating a robotic arm by 30 degrees. In this example, the robotic arm is the tool holding the camera; this means that the tool coordinate system should be rotated. Note that this will also rotate the camera if M_LINK_TOOL_AND_HEAD is set to M_ENABLE, and it is not an M_STATIONARY_CAMERA type of M_3D_ROBOTICS. /* * A robotic arm is holding the camera. * The arm rolls 30 degrees around its own axis (the Z axis) */ McalSetCoordinateSystem(CalibrationId, M_TOOL_COORDINATE_SYSTEM, M_TOOL_COORDINATE_SYSTEM, M_ROTATION_Z + M_COMPOSE_WITH_CURRENT, M_NULL, 30.0, M_DEFAULT, M_DEFAULT, M_DEFAULT); Moving the camera after calibrating with a 3D-based camera calibration context After calibrating your 3D-based camera calibration context, you can move your camera to a new location and automatically reposition the camera coordinate system, assuming that you are not calibrating an M_STATIONARY_CAMERA type of M_3D_ROBOTICS. To automatically reposition the coordinate system, you can use McalGrid() or McalList() with M_DISPLACE_CAMERA_COORD. This determines and displaces the camera coordinate system to its new location. Note that besides the camera coordinate system, this also displaces the tool coordinate system (if still linked -discussed later); no other coordinate system is affected. The operation requires a minimum of 4 calibration points and only calculates the position and orientation between the camera and camera calibration plane. It does not recompute the corrections for non-linear distortions; this allows for faster processing. When determining the new location of the camera coordinate system, McalGrid() and McalList() compute this position based on the provided calibration points. Depending on the feature extraction used to extract the calibration points, there could be extracted points which are outliers that incorrectly skew results. If you have some knowledge about how many calibration points could be outliers, you can specify this number using McalControl() with M_LOCALIZATION_NB_OUTLIERS_MAX. The computation will then attempt to compute a solution using a subset of points. This creates an increased number of possible combinations of points that could form a solution and can lengthen the computation time. However, by considering a subset of points, you can increase the likelihood of finding an accurate solution when outliers are present. An iterative method is used to determine which subset of points best determines the new location of the coordinate system when the possibility of outliers has been specified. By specifying a maximum number of iterations using McalControl() with M_LOCALIZATION_NB_ITERATIONS_MAX, you can adjust the robustness of the algorithm. By reducing the value of M_LOCALIZATION_NB_ITERATIONS_MAX, you can speed up the computation but possibly have a less accurate result. M_DISPLACE_CAMERA_COORD is only supported for 3D-based camera calibration contexts that are calibrated using McalGrid() or McalList() with M_FULL_CALIBRATION. In addition, if a rigid link exists between the camera coordinate system and the tool coordinate system, both the camera coordinate system and tool coordinate systems are displaced. The other coordinate systems are left as is. Special considerations concerning the tool and camera coordinate systems Camera calibration contexts allocated in three-dimensional modes automatically define the camera coordinate system after a successful call to McalGrid() or McalList() with M_FULL_CALIBRATION, and creates a rigid link with the tool coordinate system such that moving one will move both (unless it is an M_STATIONARY_CAMERA type of M_3D_ROBOTICS). To move the camera coordinate system by assigning the tool coordinate system to known positions in another coordinate system, it is preferable to specify the actual real-world starting position and orientation of the tool coordinate system before calibrating (before calling McalGrid() or McalList(), rather than leaving them both at the same position). If you have a camera mounted on the last joint of a robotic arm, you can set the arm's position as the origin of the tool coordinate system. After a successful M_TSAI_BASED or M_3D_ROBOTICS camera calibration, you can move the tool coordinate system according to the movements of the arm and be assured that the camera coordinate system will move accordingly. You can disable the link using McalControl() with M_LINK_TOOL_AND_HEAD set to M_DISABLE. In this case, any change applied to the camera position will affect only the camera coordinate system and not the tool coordinate system and vice versa. When working in robotics mode, you can specify the position and orientation of the robot tool, returned by a robot controller software, to the camera calibration context using McalSetCoordinateSystem(). When the camera and robot tool are linked together, the camera is automatically positioned and oriented accordingly. The images grabbed by the camera at the new position and orientation are therefore correctly calibrated. The following code snippet shows how to provide data to the camera calibration context using McalSetCoordinateSystem(): /* * Set the position and orientation of the tool coordinate system according * to the robot encoders. */ /* First, obtain the tool's position and orientation using the robot's software.*/ /* Second, call McalSetCoordinateSystem() twice.*/ McalSetCoordinateSystem(CalibrationId, M_TOOL_COORDINATE_SYSTEM, M_ROBOT_BASE_COORDINATE_SYSTEM, M_TRANSLATION + M_ASSIGN, M_NULL, ToolPosX, ToolPosY, ToolPosZ, M_DEFAULT); McalSetCoordinateSystem(CalibrationId, M_TOOL_COORDINATE_SYSTEM, M_TOOL_COORDINATE_SYSTEM, M_ROTATION_XYZ + M_ASSIGN, M_NULL, AngleX, AngleY, AngleZ, M_DEFAULT); Moving coordinate systems to reflect camera setup changes Types of transformation Translation Rotation Transforming coordinate systems Moving the camera after calibrating with a 3D-based camera calibration context Special considerations concerning the tool and camera coordinate systems ",
      "wordCount": 1692,
      "subEntries": []
    },
    {
      "id": "UG_calibration_Calibrating_a_camera_setup_that_analyzes_large_objects",
      "version": null,
      "title": "Calibrating a camera setup that analyzes large objects",
      "subTitles": [
        "Single camera fixed on a movable tool (manipulator): tool coordinate system example",
        "Single camera and movable object: relative coordinate system example",
        "Several fixed cameras and fixed object: grid offset example"
      ],
      "location": "MIL UG P04: 2D related information",
      "pageURL": "content\\UserGuide\\calibration\\Calibrating_a_camera_setup_that_analyzes_large_objects.htm",
      "text": " Calibrating a camera setup that analyzes large objects The Camera Calibration module makes it possible to measure the length between various points on an object, even when the object is not entirely within the camera's field-of-view. The camera's field-of-view refers to the largest world region visible in an image at a given resolution. The approach to analyzing a large object involves acquiring images of the various parts of the object, getting real-world coordinates from each image, and then calculating the distance between the coordinates. Three types of applications are considered: A single camera is fixed on a manipulator and the manipulator is moved to different positions to acquire the different images. A single camera is fixed to a location and the object is moved to different positions to acquire the different images. Several cameras are used to acquire the different images. Single camera fixed on a movable tool (manipulator): tool coordinate system example When a single camera is fixed on a manipulator, part of the object is grabbed, the camera is moved to a different position, a different part of the object is grabbed, and the process repeats until the entire object has been grabbed. For the coordinates from each image to be in the same absolute coordinate system, the tool coordinate system has to be updated each time the tool is moved and before associating the camera calibration context with each image. To change the tool coordinate system, use McalControl() with M_TOOL_POSITION_X, M_TOOL_POSITION_Y, M_TOOL_POSITION_Z, and M_TOOL_ROTATION_Z for camera calibration contexts using a two-dimensional camera calibration mode. For M_TSAI_BASED camera calibration contexts, use McalSetCoordinateSystem() with M_TOOL_COORDINATE_SYSTEM as the target coordinate system. Single camera and movable object: relative coordinate system example When a single camera is fixed to a location, part of the object is grabbed, the object is moved to a different position, another part of the object is grabbed, and the process repeats until the entire object has been grabbed. For the coordinates from each image to be in the same relative coordinate system, the relative coordinate system must be moved each time the object is moved and before associating the camera calibration context with each image. To move the relative coordinate system, use McalRelativeOrigin() for camera calibration contexts using a two-dimensional camera calibration mode. For M_TSAI_BASED camera calibration contexts, use McalSetCoordinateSystem() with M_RELATIVE_COORDINATE_SYSTEM as the target coordinate system. Several fixed cameras and fixed object: grid offset example For the coordinates from each image to be in the same absolute coordinate system when several cameras are used, the camera calibration context used to calibrate each camera must use the same absolute coordinate system. When using McalGrid(), you must use an offset to relate the origin of each grid to the same absolute coordinate system. When using McalList(), all real-world coordinates used in each mapping must be coordinates from the same absolute coordinate system. Calibrating a camera setup that analyzes large objects Single camera fixed on a movable tool (manipulator): tool coordinate system example Single camera and movable object: relative coordinate system example Several fixed cameras and fixed object: grid offset example ",
      "wordCount": 514,
      "subEntries": []
    },
    {
      "id": "UG_calibration_Propagating_calibration_information_after_performing_a_geometric_operation",
      "version": null,
      "title": "Propagating camera calibration information after performing a geometric operation",
      "subTitles": null,
      "location": "MIL UG P04: 2D related information",
      "pageURL": "content\\UserGuide\\calibration\\Propagating_calibration_information_after_performing_a_geometric_operation.htm",
      "text": " Propagating camera calibration information after performing a geometric operation When you have a calibrated image and perform a geometric operation, the resulting image does not retain its camera calibration information. However, you can create an appropriately warped version of the camera calibration context and associate it with the uncalibrated geometrically transformed image. McalWarp() allows you to apply a warping to the pixel-to-world mapping of a camera calibration context and use it to configure a specified camera calibration context. The newly configured context can then be associated with a similarly warped image. McalWarp() is meant to be used in conjunction with MimWarp(). As such, it takes the same warping parameter values used to transform the image. Therefore, McalWarp() can perform first-order polynomial warpings, perspective polynomial warpings, and custom warpings using LUTs. If you want to apply a flip, resize, rotate, or translate operation on an image and wanted the destination image to be appropriately calibrated, you must perform the transformation of the image using MimWarp() instead of MimFlip(), MimResize(), MimRotate(), and MimTranslate(); you can then use McalWarp() followed by McalAssociate() to appropriately calibrate the transformed image. Note that, MimWarp() and McalWarp() use a matrix of coefficients (or LUTs) to describe its transformations. To generate the coefficients that represent the required transform, you can use MgenWarpParameter() to first generate the required transformation matrix (or LUTs) and subsequently call MimWarp() and McalWarp(). To perform a geometric operation on an image and preserve the camera calibration information, perform the following: Call MimWarp() on the calibrated image to warp your image. Allocate a new camera calibration context using McalAlloc() and specify the camera calibration mode best suited for the geometric transform. Source camera calibration mode Destination's camera calibration mode after a linear geometric transform (translation, rotation, resize) Destination's camera calibration mode after a non-linear geometric transform (perspective, LUTs) Uniform Uniform Piecewise linear interpolation Piecewise linear interpolation Piecewise linear interpolation Piecewise linear interpolation Perspective transformation Perspective transformation Piecewise linear interpolation Tsai-based/Robotics Piecewise linear interpolation Piecewise linear interpolation Note that, the piecewise linear interpolation mode can accurately represent all geometric transforms and McalWarp() does not generate 3D-based camera calibration contexts. Call McalWarp() as follows: Set the original calibrated image as the source image for McalWarp(), and set the newly allocated camera calibration context as the destination. Use the same matrix coefficients or LUTs used by MimWarp() for McalWarp(), and set the transformation type to M_WARP_LUT or M_WARP_POLYNOMIAL based on the warping applied to the image. Associate the newly configured camera calibration context with the warped image of MimWarp(). When warping the pixel-to-world mapping of a camera calibration context, the destination camera calibration context need not be in the same camera calibration mode as the source context. McalWarp() approximates the equivalent calibration when converting from one mode to the other. The following code snippet shows how to perform a rotation using MimWarp(). It generates the required transformation matrices for the rotation using MgenWarpParameter(). It then shows how to warp the pixel-to-world mapping of the existing camera calibration context and propagate the new camera calibration information to the warped image using McalWarp() and then McalAssociate() respectively. // Generate the warping matrix to rotate the source image +90 degrees around its center. // This is the composition of a translation to the source's center, a rotation, and then a // translation from the destination's center. MIL_DOUBLE SrcCenterX = 0.5*(SrcSizeX-1); MIL_DOUBLE SrcCenterY = 0.5*(SrcSizeY-1); MIL_DOUBLE DstCenterX = 0.5*(DstSizeX-1); MIL_DOUBLE DstCenterY = 0.5*(DstSizeY-1); MIL_ID WarpMatrixArrayBufId = MbufAlloc2d(SysId, 3, 3, 32+M_FLOAT, M_ARRAY, M_NULL); MgenWarpParameter(M_NULL, WarpMatrixArrayBufId, M_NULL, M_WARP_POLYNOMIAL, M_TRANSLATE, -SrcCenterX, -SrcCenterY); MgenWarpParameter(WarpMatrixArrayBufId, WarpMatrixArrayBufId, M_NULL, M_WARP_POLYNOMIAL, M_ROTATE, 90.0, M_NULL); MgenWarpParameter(WarpMatrixArrayBufId, WarpMatrixArrayBufId, M_NULL, M_WARP_POLYNOMIAL, M_TRANSLATE, DstCenterX, DstCenterY); // Warp the image. MimWarp(SrcImageBufId, DstImageBufId, WarpMatrixArrayBufId, M_NULL, M_WARP_POLYNOMIAL, M_BILINEAR+M_OVERSCAN_CLEAR); // Same as: // MimRotate(SrcImageBufId, DstImageBufId, 90.0, M_DEFAULT, M_DEFAULT, M_DEFAULT, // M_DEFAULT, M_BILINEAR+M_OVERSCAN_CLEAR); // Warp the pixel-to-world mapping of the calibration context // and associate the context to the warped image. MIL_ID DstContextCalId = McalAlloc(SysId, M_LINEAR_INTERPOLATION, M_DEFAULT, M_NULL); McalWarp(SrcImageBufId, DstContextCalId, WarpMatrixArrayBufId, M_NULL, 0.0, 0.0, (MIL_DOUBLE)DstSizeX, (MIL_DOUBLE)DstSizeY, M_DEFAULT, M_DEFAULT, M_WARP_POLYNOMIAL, M_DEFAULT); if (McalInquire(DstContextCalId, M_CALIBRATION_STATUS, M_NULL) == M_CALIBRATED) { McalAssociate(DstContextCalId, DstImageBufId, M_DEFAULT); } else { MosPrintf(MIL_TEXT(\"Calibration warping has failed.\\n\")); } Propagating camera calibration information after performing a geometric operation ",
      "wordCount": 690,
      "subEntries": []
    },
    {
      "id": "UG_calibration_How_coordinates_and_nonpositional_results_are_transformed",
      "version": null,
      "title": " How coordinates and non-positional results are transformed",
      "subTitles": [
        "Transforming from the pixel to a specified world coordinate system",
        "Transforming from the world to the pixel coordinate system",
        "Transforming from one world coordinate system to another",
        "Generating unit vectors from the pixel coordinate system (or vice versa)",
        "Transforming coordinates from a depth map to a world coordinate system (or vice versa) ",
        "Using piecewise linear camera calibrations",
        "Transforming Results"
      ],
      "location": "MIL UG P04: 2D related information",
      "pageURL": "content\\UserGuide\\calibration\\How_coordinates_and_nonpositional_results_are_transformed.htm",
      "text": " How coordinates and non-positional results are transformed If you have a calibrated image or camera calibration context, you can perform coordinate transformations and transform non-positional results from pixel units to world units (or vice versa). Transforming from the pixel to a specified world coordinate system If you have a pair of coordinates, or a list of coordinates, in the pixel coordinate system, you can determine their position in a specified world coordinate system. For a pair of coordinates, use McalTransformCoordinate() to perform the transformation. However, if you have a list of coordinates, use McalTransformCoordinateList() or McalTransformCoordinate3dList(), which have better performance than performing multiple calls to McalTransformCoordinate(). When transforming from pixel to world coordinate systems, McalTransformCoordinate(), McalTransformCoordinateList(), and McalTransformCoordinate3dList() trace a line (simulating a light ray) from the effective pinhole of the camera through the specified point in the image plane. Since all world points along a given light ray project onto the same point in the image plane, every world point along the ray is theoretically a solution. Therefore, to return a unique solution, the line is intersected with the XY-plane (Z=0) of the relative coordinate system, and then the point of intersection is transformed to the specified world coordinate system. The following image depicts the typical case where the camera is placed above a setup. Since the relative coordinate system is parallel to the image plane, any point in the image can be transformed to its real-world equivalent. Since coordinates are transformed with respect to the relative coordinate system, if the relative coordinate system is displaced between calls to McalTransformCoordinate(), McalTransformCoordinateList(), and McalTransformCoordinate3dList(), the returned positions will not necessarily be comparable. If the image plane is not parallel to the relative coordinate system, due to the camera setup or a displacement of the relative coordinate system, not every point in the image plane will have a valid real-world equivalent. Therefore, three types of intersections can occur when transforming from the image plane to a world coordinate system. If the specified point in the image plane corresponds to a point in front of the camera in the relative coordinate system, that point in the relative coordinate system is transformed to the destination world coordinate system. However, if the line traced through the specified point in the image plane does not intersect the XY (Z=0) plane of the relative coordinate system, M_INVALID_POINT is returned. If the line's intersection with the XY-plane of the relative coordinate system is behind the camera, then the mathematically computed value is transformed to the destination world coordinate system, even though it is not the correct world location of the point. However, using McalTransformCoordinate(), McalTransformCoordinateList(), or McalTransformCoordinate3dList() with M_NO_POINTS_BEHIND_CAMERA, returns M_INVALID_POINT if the computed point is behind the camera. If you are certain that all specified pixel coordinates being transformed will be in the camera's field of view, do not use M_NO_POINTS_BEHIND_CAMERA, since it adds computation time to the transformation. Note that, for the perspective based camera calibration mode, the effective pinhole of the camera is implicitly defined, so the conversion of coordinates is the same as explained above. Uniform and linear interpolation camera calibration modes do not model an effective pinhole, and instead use a linear and piecewise linear mapping to transform a pair of coordinates, respectively. Transforming from the world to the pixel coordinate system To convert a point specified in a world coordinate system to its corresponding point in the pixel coordinate system, McalTransformCoordinate(), McalTransformCoordinateList(), and McalTransformCoordinate3dList() transform the specified point to the relative coordinate system, and then form a line (simulating a light ray) from the point in the XY (Z=0) plane of the relative coordinate system to the effective pinhole of the camera. The functions then return the intersection of this line with the image plane. The following image depicts the typical case where the camera is placed above a setup. Since the relative coordinate system is parallel to the image plane, any point in the world coordinate system can be transformed to its pixels equivalent. If the relative coordinate system is not parallel to the image plane, due to the camera setup or a displacement of the relative coordinate system, not every point specified in a world coordinate system will have a valid pixel equivalent. Three types of intersections can occur when transforming from a world coordinate system to the image plane. If the point in the XY-plane of the relative coordinate system corresponds to a point in front of the camera, the intersection point in the image plane is returned. However, if the line formed through the specified point in the XY-plane of the relative coordinate system does not intersect the image plane, M_INVALID_POINT is returned since there is no intersection. If the point that forms the line from the XY-plane of the relative coordinate system is behind the camera, then the mathematically computed pixel value is returned, even though it does not correspond to the world location of the pixel in the image. However, using McalTransformCoordinate(), McalTransformCoordinateList(), or McalTransformCoordinate3dList() with M_NO_POINTS_BEHIND_CAMERA, returns M_INVALID_POINT if the calculated point does not have a correct real-world equivalent. If you are certain that all specified world points being transformed will be in the camera's field of view, do not use M_NO_POINTS_BEHIND_CAMERA, since it adds computation time to the transformation. Note that, for the perspective based camera calibration mode, the effective pinhole of the camera is implicitly defined, so the conversion of coordinates is the same as explained above. Uniform and linear interpolation camera calibration modes, do not model an effective pinhole, and instead use a linear or piecewise linear mapping to transform a pair of coordinates, respectively. Transforming from one world coordinate system to another McalTransformCoordinate3dList() can be used to transform any specified list of points from a source world coordinate system to a destination world coordinate system. The returned position is the same physical point, but is expressed with respect to the target coordinate system. The following image depicts two coordinate systems, where a specified point has been transformed from one coordinate system to another. Generating unit vectors from the pixel coordinate system (or vice versa) You can transform a list of coordinates from the pixel coordinate system to a series of unit vectors using McalTransformCoordinate3dList() with M_UNIT_DIRECTION_VECTOR. This generates unit vectors for each specified point in the image plane. The unit direction vector is generated by determining the direction vector between the effective pinhole of the camera and the point specified in the image plane. Since it is a unit vector, it has a magnitude of 1, and only gives the direction along which a world point could be found. Similarly, you can specify a unit direction vector and determine the corresponding point in the pixel coordinate system. Transforming coordinates from a depth map to a world coordinate system (or vice versa) You can use McalTransformCoordinate3dList() to transform any specified list of points from a source depth map to a destination world coordinate system. By specifying a point's pixel coordinates and intensity value, McalTransformCoordinate3dList() determines the location of the specified point in the target world coordinate system. Similarly, you can specify a point in the world coordinate system and determine its location and intensity in the depth map. McalTransformCoordinate3dList() only transforms coordinates from a fully corrected depth map. For more information, see Chapter 46: 3D reconstruction using laser line profiling. Using piecewise linear camera calibrations When transforming coordinates from an image that has been calibrated using a piecewise linear camera calibration mode (allocated using McalAlloc() with M_LINEAR_INTERPOLATION), the transformation could be inaccurate if the coordinate being transformed is outside the calibrated area. The calibrated area is the space that was defined by the calibration points during calibration. Since an extrapolation is performed for points outside the calibration area, the accuracy of the transformation decreases. Using McalTransformCoordinate(), McalTransformCoordinateList(), or McalTransformCoordinate3dList() with M_NO_EXTRAPOLATED_POINTS, all points outside the calibration area will return M_INVALID_POINT. Transforming Results If you have a calibrated image or a camera calibration context, you can use McalTransformResult() to transform several different measures from pixel to world units (or vice versa). You can transform an area specified in pixel units, and determine its value in world units, using McalTransformResult() with M_AREA. Similarly, you can convert a value in world units to its pixel unit equivalent. If you have a constant pixel size in X and Y, the transformation will be exact. You can transform a length in the X or Y direction specified in the pixel coordinate system, and determine its real-world length, using McalTransformResult() with M_LENGTH_X or M_LENGTH_Y. Similarly, you can convert a real-world length to its pixel length. If you have a constant pixel size in X and Y, the transformation will be exact. If you want to transform an arbitrary length that lies in any direction, use McalTransformResult() with M_LENGTH. If you have a constant pixel size in X and Y and no perspective distortion, such as a uniform camera calibration, the transformation will be exact. However, if you do not have an identical scaling in the X and Y directions, an approximation will be used to determine the best value to give the specified length in real-world units. If the difference between the X and Y scales is large, the approximation will be less accurate. The following image shows the area and length results that can be transformed. If you want to transform a specified angle at a particular position from the pixel coordinate system to the world coordinate system (or vice versa), you can use McalTransformResultAtPosition() with M_ANGLE. You must also specify the position at which you want to transform the angle. The following is an image of a rail road track, which has significant perspective distortion. An angle measurement is taken between the horizontal and the tracks rail. The angle between the horizontal and the rail in the image is 55°, but after applying McalTransformResultAtPosition() with M_ANGLE, the actual angle of 90 degrees is returned. If you do not have any positional information and you want to convert an angle from pixel units to world units, you can use McalTransformResult() with M_ANGLE. However, if you do not have a constant pixel size in both X and Y, McalTransformResult() will return an approximate value. How coordinates and non-positional results are transformed Transforming from the pixel to a specified world coordinate system Transforming from the world to the pixel coordinate system Transforming from one world coordinate system to another Generating unit vectors from the pixel coordinate system (or vice versa) Transforming coordinates from a depth map to a world coordinate system (or vice versa) Using piecewise linear camera calibrations Transforming Results ",
      "wordCount": 1765,
      "subEntries": []
    },
    {
      "id": "UG_calibration_Generating_a_grid_for_calibration",
      "version": null,
      "title": "Generating a grid for calibration",
      "subTitles": [
        "Generating a grid using CalGenChessGrid",
        "Specifying the physical setup",
        "Specifying the grid's fiducials",
        "Printing the grid",
        "Adding printed fiducials to an existing chessboard grid"
      ],
      "location": "MIL UG P04: 2D related information",
      "pageURL": "content\\UserGuide\\calibration\\Generating_a_grid_for_calibration.htm",
      "text": " Generating a grid for calibration MIL is distributed with grids that you can print and use: FiducialCalibrationGrid_Letter.pdf ChessboardCalibrationGrid_15x16_Letter.pdf, ChessboardCalibrationGrid_18x22_Letter.pdf, CircleCalibrationGrid_15x16_Letter.pdf, CircleCalibrationGrid_18x22_Letter.pdf. These files are located in the Matrox Imaging\\Images directory. However, you might need to create a grid that better suits your setup. To generate a custom fiducial or chessboard grid of squares/rectangles, MIL provides an example, CalGenChessGrid, accessible from the Matrox Example Launcher. Before running CalGenChessGrid.cpp to generate the required fiducial or chessboard grid, you must set constants in gridconfig.h, according to your grid requirements. Once you have set the constants, run the example to generate an image of the grid that you can then print. Generating a grid using CalGenChessGrid There are many values that you can configure before using CalGenChessGrid, but typically you will focus on two categories: the physical setup and the grid's fiducials. Keep in mind that a chessboard grid is simply a fiducial grid where the number of fiducials is set to 0. Specifying the physical setup When generating fiducial grids or chessboard grids, you must describe the physical setup in terms of the grid's dimensions, such as its size in world units, and the camera's attributes, such as its field of view. The following should be considered for your setup: Be consistent with your world units. All dimensions specified in world units must be in the same units. For example, if you specify your grid size in millimeters, you must specify your camera's field of view in millimeters. In addition, for a fiducial grid, you must specify the world unit that you are using. In the example above, you must specify millimeters as your unit of measurement. Note that your unit of measurement is not checked in any way. What is encoded in the Data Matrix code is only the name that you give to your unit of measurement. There is no explicit or implicit unit conversions. The following is a list of the available world units: Metric units. M_MICROMETERS. M_MILLIMETERS. M_CENTIMETERS. M_METERS. M_KILOMETERS. Imperial units. M_MILS. M_INCHES. M_FEET. M_MILES. Miscellaneous. M_UNKNOWN. Set the grid's X- and Y-size to the required dimensions, in world units. For maximum calibration accuracy, your grid's size should encompass the entire field of view of all cameras, or the size should be at least as large as the working area of all cameras. To automatically determine the number of rows and columns and the size of the squares/rectangles in the grid, you must set the size of the field of view and the resolution of the cameras. When automatically determined, the number and size of rows and columns will be set to maximize the total number of calibration points, while maintaining pixel and size restrictions for the chessboard squares/rectangles. Set the camera's field of view by specifying the length of the X-axis in world units. Set the camera's resolution by specifying the length of the X-axis in pixels. If you have more than one camera, calculate the ratio of each camera's field of view/ resolution. Specify the field of view and resolution of the camera with the highest ratio. Note that the values you specify for the field of view and resolution are used to heuristically determine the number of rows/column. When a camera has perspective distortion, you might have to increase the MIN_CAMERA_PIXELS_PER_SQUARE constant to compensate for chessboard rows or columns that are too small. To manually specify the number of rows and columns, you must first disable the automatic determination of rows and columns, and then enter the number of required rows and columns. The size of the chessboard squares/rectangles are automatically determined. Note that unless the ratio of rows and columns equals the ratio of the X and Y dimensions of the grid, it is possible that either the number of rows or the number of columns in your grid will be slightly lower than the specified number. The dimensions of the grid takes precedence over the number of rows or columns. Specifying the grid's fiducials The grid's fiducials are Data Matrix codes that encode the grid's physical information discussed above and also the position of the grid's reference calibration point. The fiducial grid, regardless of its total number of fiducials, has a single reference calibration point, which you must specify before running the example. The grid can have zero, one, or many fiducials. If you specify a grid with zero fiducials, this is equivalent to a chessboard grid. The following fiducial settings should be considered for your setup: Specify a calibration point on the grid as the reference calibration point. The reference calibration point is the calibration point typically used as the origin of the absolute coordinate system. By default, the reference calibration point is the calibration point closest to the center of the grid. When specifying a non-default position, you must provide explicit coordinates for the reference calibration point. The X-coordinate is the number of calibration points between the left-most column of calibration points and the required reference calibration point. The Y-coordinate is the number of calibration points between the top-most row of calibration points and the required reference calibration point. This implies that to specify the top-left calibration point as the reference calibration point, you must specify (0, 0) for the X- and Y-coordinates. In the following image, to specify the illustrated reference calibration point, you must specify 7 as the X-coordinate and 3 as the Y-coordinate. Specify the number of fiducials that you need for your grid. For most setups, a fiducial grid with a single fiducial is ideal. For setups where you have multiple cameras that cannot all see the entire grid, you might need to create multiple fiducials at strategic places on the grid so that each camera sees at least one fiducial on the grid. Note that each Data Matrix code encodes the same grid information and the offsets that correspond to the same reference calibration point. If a camera sees more than one fiducial, only one is read because they each have the necessary information to set up the same absolute coordinate system. Specify the position of your fiducial(s) in the grid. The position of the fiducial in your grid is specified as an X-and Y-coordinate, with respect to the current position of the reference calibration point. The X- and Y-coordinate is applied to the calibration point to the top-left of the Data Matrix code. When the coordinates of the fiducial are (0, 0), as illustrated in the top-left image below, a 2x2 Data Matrix code is placed over the calibration point to the bottom-right of the reference calibration point. Add 1 to the X-coordinate to move the Data Matrix code right 1 calibration point and subtract 1 to move it left. Add 1 to the Y-coordinate to move it down 1 calibration point and subtract 1 to move it up. In the top-right image below, the fiducial is placed at (1, 1) from the unchanged default reference calibration point. If you move the reference calibration point, for instance to the top-left calibration point, as in the image to the bottom-left, but keep the X- and Y-position of the fiducial (the position of the fiducial is [1, 1] in this example), the position of the fiducial on the grid will follow the new reference calibration point. To keep the fiducial in place on the grid and change the reference calibration point, as in the image below-right, you must specify a new position for the fiducial that considers the new position of the reference calibration point. Note that the fiducial must not be too close to the edge of the grid. The fiducial zone of your fiducial must be at least 1.5 squares away from the edge of the grid. When specifying more than one fiducial, you must specify each fiducial's position with respect to the same reference calibration point, as in the image below. For each fiducial, specify whether you need a 2x2 fiducial zone or a 3x3 fiducial zone; this affects the size of the fiducial. Typically, use a 2x2 fiducial zone. The 3x3 fiducial zone is usually used when the resolution of the camera produces a Data Matrix code that is too small to read. To read a Data Matrix code, the pixel size of the individual cells of the code in your image must be at least 3 pixels wide. If you have a low resolution camera or if the generated Data Matrix code has many cells, the cells might be too small to read. In this case, specify to create a larger Data Matrix code that takes up 9 grid squares/rectangles (3x3) instead of the typical 4 grid squares/rectangles (2x2). This produces a larger fiducial zone, as in the following image. The maximum size for a fiducial zone is 3x3. Note that the additional size of the fiducial covers up more calibration points, which lowers the total number of calibration points used for calibration. This can lower the overall accuracy of the calibration, especially when calibrating in M_LINEAR_INTERPOLATION mode. Printing the grid Once you have a calibration grid, either by generating it using the example or by choosing one of the grids provided with MIL, you must print the grid. The grid that the example produces is a png named ChessGrid.png and can be found in the \\Documents\\Matrox Imaging\\MIL\\Examples\\Processing\\2dCalibration\\CalGenChessGrid\\C++ folder. An in-depth explanation of printing options is beyond the scope of this section. Typically, you must print the fiducial grid at as high a resolution as you can. It is recommended that your print resolution be at least 600 DPI. You should not attempt to scale or fit the image; the printer must print the fiducial grid exactly as is. Whichever way you print the grids, you must physically measure the grid spacings afterward so they are accurate. The more accurate your physical grid is, the better the calibration and all subsequent MIL measurements will be. Consider that even a 0.1 mm deviation per grid square is 2% of a 5 mm row or column spacing. This can result in calibration imprecision. Note that the fiducial grid that is distributed with MIL is encoded to have a row and column spacing of exactly 10 mm. Adding printed fiducials to an existing chessboard grid If you already have a highly accurate chessboard grid, you can still take advantage of calibrating your camera(s) with a fiducial grid, by affixing one or more valid Data Matrix codes to your existing grid. You must configure gridconfig.h and run the CalGenChessGrid.cpp example, print the Data Matrix codes the example outputs, and affix the printed codes to you existing chessboard grid at the exact spot where they should go, based on how you configured the example. The CalGenChessGrid.cpp example outputs two or more images, one image of the complete fiducial grid and one image for each fiducial in the fiducial grid. Note that the fiducials do not need to be printed with the same level of accuracy as the grid squares/rectangles themselves because they are not used as calibration points; the Data Matrix code only needs to be accurate enough to be easily read. To affix fiducials to an existing grid, perform the following: Configure gridconfig.h and run the CalGenChessGrid.cpp example. Specify that you will manually set the number of rows and columns. By default, the number of rows and columns are automatically established. Specify the exact dimensions of your existing chessboard grid. To ensure this, set the exact length and width of your existing chessboard grid and the exact number of rows and columns it has. Specify the grid's reference calibration point, the number of fiducials, and their positions, according to your requirements. Print the fiducial(s). The individual images of the fiducial(s) are in the same folder as the image of the fiducial grid. Print the fiducial as large as you can, given the constraints discussed below. This will make the Data Matrix code easier to read. Use this image of a 2x2 fiducial zone code to understand how large you will be able to print the Data Matrix code. The space requirements are the same for the 3x3 fiducial zones. The Data Matrix code must have a white zone at least 2 Data Matrix cells wide around it. If the white space is too thin, the Data Matrix code might not be read, resulting in a failed calibration. The fiducial(s) output by CalGenChessGrid.cpp already have sufficient white space. Do not crop the white space. Note that while the image of the Data Matrix includes sufficient white space, if you print the code on white paper, you might not be able to see where the white space ends. When you cut out the fiducial, consider the necessary white space around the Data Matrix code. The fiducial, including the white space, must have a cushion between it and the edge of the fiducial zone. The cushion must be at least 0.4 chessboard grid squares wide all around the fiducial. You might need to shrink your fiducial to meet this minimum. The pixel size of the Data Matrix cells in your fiducial grid image must be at least 3 pixels wide. This is not a physical constraint of the printed fiducial, but if the image of your fiducial grid does not have enough resolution to satisfy this constraint and the constraints above, you might have to increase the size of the fiducial and place it in a larger fiducial zone. You can specify to create a larger Data Matrix code by configuring gridconfig.h before running the CalGenChessGrid.cpp example. This larger code is placed in a fiducial zone that has 9 grid squares/rectangles (3x3) instead of the typical 4 grid squares/rectangles (2x2). Affix the fiducial(s) to your existing chessboard grid. Place the fiducials on your existing grid in the exact spot and in the same orientation that they appear in the generated version of the fiducial grid. The position and orientation of the fiducial is important. A Data Matrix code with no offset encodes the grid's reference calibration point to be the closest calibration point to the top-left corner of the Data Matrix code, considering its proper orientation. Illustrated on the left below is the original fiducial grid that the example generates. If the Data Matrix code from the example is printed and affixed to your existing chessboard grid at a different location than it was generated for, the reference calibration point moves, as in the image on the right. Note that if you affix the Data Matrix code in a different position than was generated, you must still ensure that the fiducial zone is at least 1.5 grid squares away from the edge of the grid for both the 2x2 and 3x3 Data Matrix codes. If the Data Matrix code is rotated, the grid's reference calibration point also changes, as does the orientation of the absolute coordinate system, as in the image below. Pay close attention to position and orientation of each separate Data Matrix code when using a multi-fiducial grid. Moving a single Data Matrix code is not necessarily a problem; it will simply move the resulting absolute coordinate system. If you have more than one fiducial and you place one of them incorrectly, they will each specify a different reference calibration point for the grid. This will not necessarily generate an error, but will result in unpredictable behavior. You cannot use the same Data Matrix code twice on the same grid. If you need to affix more than one fiducial to your existing chessboard grid, you must use CalGenChessGrid.cpp to generate all the fiducials and you must place them in the exact spot that they appear in the generated fiducial grid image. The fiducials are numbered in the order specified in CalGenChessGrid.cpp. Generating a grid for calibration Generating a grid using CalGenChessGrid Specifying the physical setup Specifying the grid's fiducials Printing the grid Adding printed fiducials to an existing chessboard grid ",
      "wordCount": 2645,
      "subEntries": []
    }
  ]
}]
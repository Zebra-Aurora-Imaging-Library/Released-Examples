[{
  "id": "Readme_milMorphis",
  "version": "2023100322",
  "title": "milMorphis",
  "wordCount": 0,
  "subEntries": [
    {
      "id": "Readme_milMorphis_milmorphis",
      "title": "milmorphis",
      "location": "MIL Release Notes",
      "pageURL": "\\milMorphis\\milmorphis.htm",
      "text": " ------------------------------------------------------------------------------- Matrox Imaging Library (MIL) 10.0 Release Notes (milmorphis) December, 2013 (c) Copyright Matrox Electronic Systems Ltd., 1992-2013. ------------------------------------------------------------------------------- This document outlines what is new with MIL for Matrox Morphis and explains the current limitations and particularities when using MIL with Matrox Morphis. It also presents last minute hardware-specific information that did not make it into the manuals or on-line help. Note that this text file serves to complement your manual. The information found in this file overrides your formally documented material. Contents: 1. Matrox Morphis with MIL. 1.1 What’s new. 1.1.1 Differences between MIL 10.0 and MIL 9.0 Update 37. 1.1.2 Differences between MIL 9.0 Update 37 and MIL 9.0.Update 26. 1.1.3 Differences between MIL 9.0 Update 26 and MIL 9.0.Update 17. 1.1.4 Differences between MIL 9.0 Update 17 and MIL 9.0. 1.1.5 Differences between MIL 9.0 and MIL 8.0 Update 7b. 2. Location of examples (in the help file) ------------------------------------------------------------------------------- 1. Matrox Morphis with MIL. 1.1 What’s new. 1.1.1 Differences between MIL 10.0 and MIL 9.0 Update 37. - Support for Microsoft® Windows® 8. - Hardware JPEG2000 compression is no longer supported. - MIL 10 has a new mechanism to control and inquire IO signals. It has unified some concepts under the M_IO_... constants of MsysControl/MsysInquire. For the correlation between old and new MIL constants, refer to the MilMorphisIOConversionTable release note. 1.1.2 Differences between MIL 9.0 Update 37 and MIL 9.0 Update 26. - Addition to MdigControl() and MdigInquire(): - M_DECODER_MODE: Controls the contrast/brightness mode of the ADV7184 video decoder. When an ADV7184-equipped board is set to operate in ADV7183 mode, it cannot be set back to ADV7184 mode unless the PC is rebooted. - Values: M_ADV7184 Default behavior on ADV7184 boards. Setting this value on an ADV7183-equipped board will generate an error. M_ADV7183 Makes the contrast/brightness on a ADV7184-equipped board behave like that of an ADV7183-equipped board. M_DEFAULT Same as M_ADV7184. 1.1.3 Differences between MIL 9.0 Update 26 and MIL 9.0.Update 17. - Support of the ADV7184 video decoder. The ADV7184 video decoder is present on the following Matrox Morphis part numbers: - MOR/4VD/84* - MOR4VDE/84* - MOR/2VD/84* - MOR2VDE/84* - MOR/2VD/HD/84* - MOR/2VD/J2K/84* - MOR2VDCME/84* - MOR+/2VD/84* *** IMPORTANT NOTICE REGARDING MATROX MORPHIS ../84* PART NUMBERS *** Channel switching with the ADV7184 video decoder is performed differently than with the ADV7183A video decoder. All applications that require any channel switching (i.e. use the MIL function MdigChannel() ) will need to use a different DCF, available as part of this Update 26. In cases of channel switching, the correct DCF filename to load will have the suffix &quot;_FAST.DCF&quot; appended to the video format name (for instance, NTSC_FAST.DCF for the NTSC video format). These &quot;_FAST&quot; DCF files will work on both the original Matrox Morphis boards and the Matrox Morphis /84* boards. All DCF files are located in the following folder: \\Matrox Imaging\\Drivers\\Morphis\\dcf 1.1.4 Differences between MIL 9.0 Update 17 and MIL 9.0. - Fixed an issue when grabbing from multiple cameras. When a camera on one of the channels is unplugged, it can cause an error on one of the other channels. - Fixed an issue when a camera is repeatedly disconnected and reconnected. It could cause a grab error that could only be recovered by rebooting the PC. 1.1.5 Differences between MIL 9.0 and MIL 8.0 Update 7b. - Support for MIL 9.0. 2. Location of examples (in the help file) - In the help file, the location information written at the top of examples might not be up-to-date. Use MIL Example Launcher to find an example on disk. ",
      "wordCount": 595,
      "subEntries": []
    },
    {
      "id": "Readme_milMorphis_MilMorphisIOConversionTable",
      "title": "MilMorphisIOConversionTable",
      "location": "MIL Release Notes",
      "pageURL": "\\milMorphis\\MilMorphisIOConversionTable.htm",
      "text": " ------------------------------------------------------------------------------- Matrox Imaging Library (MIL) 10.0 MIL 9 to MIL 10 IO conversion table for the Matrox Morphis December, 2013 (c) Copyright Matrox Electronic Systems Ltd., 1992-2013. ------------------------------------------------------------------------------- MIL 10 has a new mechanism to control and inquire IO signals. It has unified some concepts under the M_IO_... constants of MsysControl/MsysInquire. Although the old mechanism still works, the old mechanism is deprecated. To port your code to the new mechanism, use the equivalence tables below. Note that the concept of user-defined signals is now treated differently. To output a user-defined signal, you set a bit in a static user output register (M_USER_BIT_STATE). To inquire the state of an auxiliary input signal so that you can act upon it (user input), you inquire the status of the auxiliary signal directly (M_IO_STATUS); you don’t inquire a bit. The following conversion table applies to the Matrox Morphis. Contents 1. MIL 9 to MIL 10 conversion table. 2. MIL 9 to MIL 10 conversion examples. 2.1 Setting a user-bit. 2.2 Inquiring a user-bit. 2.3 Hooking a callback function on a user-bit. 2.4 Setting a grab trigger source. =============================================================================== 1. MIL 9 to MIL 10 conversion table. For M_GRAB_TRIGGER_SOURCE: M_HARDWARE_PORT0 now becomes M_AUX_IO16 Note that the following table includes only equivalences for inquiring whether a signal is an input or an output. MsysInquire M_USER_BIT_MODE + n becomes M_IO_MODE + M_AUX_IOn where n is from 0 to 16 Note that the following table includes only equivalences for setting up output user-defined signals; see the subsequent table for inquiring user input signals (no corresponding register bit). MsysControl M_USER_BIT_VALUE_OUT + n becomes M_USER_BIT_STATE + M_USER_BITn where n is from 0 to 15 Note that the following table includes only equivalences for reading the status of a user input signal. MsysInquire M_USER_BIT_VALUE_IN + n becomes M_IO_STATUS + M_AUX_IOn where n is from 0 to 16 MsysHookFunction M_USER_BIT_CHANGE becomes M_IO_CHANGE Note that the following table includes only equivalences for inquiring which input signal caused the interrupt event. MsysGetHookInfo M_USER_BIT returns n becomes M_IO_INTERRUPT_SOURCE returns M_AUX_IOn where n is from 0 to 15 Note that the following table includes only equivalences for controlling/inquiring whether an input signal should cause an interrupt. MsysControl/Inquire M_USER_BIT_INTERRUPT_STATE + n becomes M_IO_INTERRUPT_STATE + M_AUX_IOn where n is from 0 to 15 Note that the following table includes only equivalences for controlling/inquiring input signals that cause an interrupt. MsysControl/Inquire M_USER_BIT_INTERRUPT_MODE + n becomes M_IO_INTERRUPT_ACTIVATION + M_AUX_IOn where n is from 0 to 15 2. MIL 9 to MIL 10 conversion examples. 2.1 Setting a user-bit. Using Mil 9 IO API: MsysControl(MilSystem, M_USER_BIT_VALUE_OUT + 1, M_ON); MsysControl(MilSystem, M_USER_BIT_MODE + 1, M_OUTPUT); Using Mil 10 IO API: MsysControl(MilSystem, M_USER_BIT_STATE + M_USER_BIT1, M_ON); MsysControl(MilSystem, M_IO_MODE + M_AUX_IO1, M_OUTPUT); 2.2 Inquiring a user-bit. Using Mil 9 IO API: MsysControl(MilSystem, M_USER_BIT_MODE + 1, M_INPUT); MsysInquire(MilSystem, M_USER_BIT_VALUE_IN + 1, &amp;Value); Using Mil 10 IO API: MsysControl(MilSystem, M_IO_MODE + M_AUX_IO1, M_INPUT); MsysInquire(MilSystem, M_IO_STATUS + M_AUX_IO1, &amp;Value); 2.3 Hooking a callback function on a user-bit. Using Mil 9 IO API: MsysControl(MilSystem, M_USER_BIT_MODE + 1, M_INPUT); MsysControl(MilSystem, M_USER_BIT_INTERRUPT_MODE + 1, M_EDGE_RISING); MsysHookFunction(MilSystem, M_USER_BIT_CHANGE, HookHandlerFnc, &amp;HookData); MsysControl(MilSystem, M_USER_BIT_INTERRUPT_STATE + 1, M_ENABLE); MIL_INT HookHandlerFnc(MIL_INT HookType, MIL_ID EventId, void *UserDataPtr) { MIL_INT UserBit = 0; MsysGetHookInfo(EventId, M_USER_BIT, &amp;UserBit); // UserBit will be 1 when interrupt is fired. } Using Mil 10 IO API: MsysControl(MilSystem, M_IO_MODE + M_AUX_IO1, M_INPUT); MsysControl(MilSystem, M_IO_INTERRUPT_ACTIVATION + M_AUX_IO1, M_EDGE_RISING); MsysHookFunction(MilSystem, M_IO_CHANGE, HookHandlerFnc, &amp;HookData); MsysControl(MilSystem, M_IO_INTERRUPT_STATE + M_AUX_IO1, M_ENABLE); MIL_INT HookHandlerFnc(MIL_INT HookType, MIL_ID EventId, void *UserDataPtr) { MIL_INT IOSource = 0; MsysGetHookInfo(EventId, M_IO_INTERRUPT_SOURCE, &amp;IOSource); // IOSource will be M_AUX_IO1 when interrupt is fired. } 2.4 Setting a grab trigger source. Using Mil 9 IO API: MdigControl(MilDigitizer, M_GRAB_TRIGGER_SOURCE, M_HARDWARE_PORT0); Using Mil 10 IO API: MdigControl(MilDigitizer, M_GRAB_TRIGGER_SOURCE, M_AUX_IO16); ",
      "wordCount": 612,
      "subEntries": []
    }
  ]
}]
[{
  "id": "Example_PlaceHolder_ID",
  "version": "2024020714",
  "title": "Example_PlaceHolder_Title",
  "wordCount": 0,
  "subEntries": [
    {
      "id": "Examples_Processing_DifferenceAnalysis_FlexAlignment_CPP_finderitem_cpp",
      "version": "2024020714",
      "title": "finderitem.cpp",
      "location": "Sample Code from MIL Examples",
      "text": " Top /*************************************************************************************/ /* * File name: FinderItem.cpp * Location: See Matrox Example Launcher in the MIL Control Center * * * Synopsis: Implementation of the CFinderItem class * * Copyright (C) Matrox Electronic Systems Ltd., 1992-2024. * All Rights Reserved */ #include \"FinderItem.h\" #include \"Rect.h\" /*************************************************************************************/ /* * Class : CFinderItem * * Name : CFinderItem() * * Access : Public * * Synopsis : Constructor * */ CFinderItem::CFinderItem() : m_PatternMatchingId(M_NULL), m_ResultId(M_NULL), m_Rect(0L, 0L, 0L, 0L), m_Center(0.0, 0.0) { /* Init();. */ } /*************************************************************************************/ /* * Class : CFinderItem * * Name : Init() * * Access : Public * * Synopsis : Initialize the class * */ void CFinderItem::Init() { m_PatternMatchingId = M_NULL; m_ResultId = M_NULL; SetRect(0L, 0L, 0L, 0L); SetCenter(0.0, 0.0); } /*************************************************************************************/ /* * Class : CFinderItem * * Name : ~CFinderItem() * * Access : Public * * Synopsis : Destructor * */ CFinderItem::~CFinderItem() { Init(); } /*************************************************************************************/ /* * Class : CFinderItem * * Name : SetCenter() * * Access : Public * * Synopsis : Set the center position of the finder item * */ void CFinderItem::SetCenter() { /* Set the center of the rect (MbufControlNeighor style). */ m_Center.x = MIL_DOUBLE(m_Rect.OffX + ((m_Rect.SizeX - 1) / 2)); m_Center.y = MIL_DOUBLE(m_Rect.OffY + ((m_Rect.SizeY - 1) / 2)); if (M_NULL != m_PatternMatchingId) { MpatControl(m_PatternMatchingId, 0, M_REFERENCE_X, m_Center.x); MpatControl(m_PatternMatchingId, 0, M_REFERENCE_Y, m_Center.y); } } ",
      "wordCount": 229
    },
    {
      "id": "Examples_Processing_DifferenceAnalysis_FlexAlignment_CPP_flexalignment_cpp",
      "version": "2024020714",
      "title": "flexalignment.cpp",
      "location": "Sample Code from MIL Examples",
      "text": " Top /*************************************************************************************/ /* * File name: FlexAlignment.cpp * Location: See Matrox Example Launcher in the MIL Control Center * * * Synopsis: This example shows how to perform flexible alignment using the Pattern Matching and the Calibration module. * The first part of the example shows how to perform rigid alignment. * The second part of the example shows how to perform flexible alignment. * * Copyright (C) Matrox Electronic Systems Ltd., 1992-2024. * All Rights Reserved */ #include &lt;mil.h&gt; #include &lt;memory&gt; #include \"CAUtil.h\" #include \"FlexRegistration.h\" /* Path to the template and target image. */ MIL_CONST_TEXT_PTR TEMPLATE_PATH = M_IMAGE_PATH MIL_TEXT(\"FlexAlignment//template.mim\"); MIL_CONST_TEXT_PTR TARGET_PATH = M_IMAGE_PATH MIL_TEXT(\"FlexAlignment//target.mim\"); /* Constants. */ const MIL_INT DELTA_SEARCH = 20; /* Size of the search area for Pattern Matching. */ const MIL_INT GRID_SIZE_X = 8; /* Number of cells in x axis. */ const MIL_INT GRID_SIZE_Y = 8; /* Number of cells in y axis. */ const MIL_INT GRID_MARGIN = 4; /* Margin of the grid. Setting a margin ensures that the content of the cells is present in the target image. */ const MIL_DOUBLE MODEL_MIN_SEPARATION = 10.0; /* Minimum distance in pixels between two models to be considered distinct. Must be smaller than DELTA_SEARCH. */ const MIL_DOUBLE DIFF_THRESH_SCORE = 8.0; /* If two pattern matching occurrences are found for a cell, their score difference must be larger than this */ /* value in order to use the best occurrence. Otherwise, both occurrences are rejected and the cell is not used */ /* for the calibration. */ const MIL_DOUBLE ACCEPTANCE_SCORE = 80.0; /* Specifies the acceptance level. If the match score is less than this level, it is not considered a match. */ const MIL_DOUBLE CERTAINTY_SCORE = 98.0; /* Specifies the certainty level. If the match score is greater than or equal to this level, a match is assumed */ /* without looking elsewhere in the image for a better match. */ /* Namespace. */ using std::auto_ptr; /* Function declaration. */ bool RigidAlignment(MIL_ID TemplateBufferId, MIL_ID TargetBufferId, MIL_ID DstBufferId); /*****************************************************************************/ /* Example description. /*****************************************************************************/ void PrintHeader() { MosPrintf(MIL_TEXT(\"[EXAMPLE NAME]\\n\")); MosPrintf(MIL_TEXT(\"FlexAlignment\\n\\n\")); MosPrintf(MIL_TEXT(\"[SYNOPSIS]\\n\")); MosPrintf(MIL_TEXT(\"This example shows how to perform flexible alignment using\\n\")); MosPrintf(MIL_TEXT(\"the Pattern Matching and the Calibration modules.\\n\\n\")); MosPrintf(MIL_TEXT(\"[MODULES USED]\\n\")); MosPrintf(MIL_TEXT(\"Modules used: Display, Graphics, Pattern Matching, Calibration\\n\")); MosPrintf(MIL_TEXT(\"and Registration.\\n\\n\")); MosPrintf(MIL_TEXT(\"Press any key to continue.\\n\\n\")); MosGetch(); } int main(void) { /* Print example information in console. */ PrintHeader(); MIL_ID MilApplication = M_NULL, /* Application identifier. */ MilSystem = M_NULL, /* System Identifier. */ MilDisplay1 = M_NULL, /* Display identifier 1. */ MilDisplay2 = M_NULL, /* Display identifier 2. */ MilDisplay3 = M_NULL, /* Display identifier 3. */ MilGraList1 = M_NULL, /* Graphic List identifier for Display 1.*/ MilGraList2 = M_NULL, /* Graphic List identifier for Display 2.*/ TemplateBufferId = M_NULL; /* Template buffer identifier. */ /* Structure with minimal buffer information. */ SBuffer TargetBufferId, /* Target buffer identifier. */ RigidAlignedBuffer, /* Rigid aligned buffer result identifier. */ FlexAlignedBuffer, /* Flexible aligned buffer result identifier. */ Diff, /* Difference between the original target and the original template. */ RigidDiff, /* Difference between the rigid alignment result and the original template. */ FlexDiff; /* Difference between the flexible alignment result and the original template. */ MIL_BOOL RigidAlignmentStatus; /* Allocate defaults. */ MappAlloc(M_NULL, M_DEFAULT, &amp;MilApplication); MsysAlloc(MilApplication, M_SYSTEM_HOST, M_DEFAULT, M_DEFAULT, &amp;MilSystem); /* Allocate and prepare displays. */ MdispAlloc(MilSystem, M_DEFAULT, MIL_TEXT(\"M_DEFAULT\"), M_DEFAULT, &amp;MilDisplay1); MdispAlloc(MilSystem, M_DEFAULT, MIL_TEXT(\"M_DEFAULT\"), M_DEFAULT, &amp;MilDisplay2); MdispAlloc(MilSystem, M_DEFAULT, MIL_TEXT(\"M_DEFAULT\"), M_DEFAULT, &amp;MilDisplay3); MIL_STRING DisplayTitle1 = MIL_TEXT(\"Template Image\"); MIL_STRING DisplayTitle2 = MIL_TEXT(\"Target Image\"); MIL_STRING DisplayTitle3 = MIL_TEXT(\"Difference Result\"); MIL_STRING DisplayTitle4 = MIL_TEXT(\"Rigidly Aligned Target Image\"); MIL_STRING DisplayTitle5 = MIL_TEXT(\"Rigid Alignment Difference Result\"); MIL_STRING DisplayTitle6 = MIL_TEXT(\"Flexibly Aligned Target Image\"); MIL_STRING DisplayTitle7 = MIL_TEXT(\"Flexible Alignment Difference Result\"); MdispControl(MilDisplay1, M_TITLE, DisplayTitle1); MdispControl(MilDisplay2, M_TITLE, DisplayTitle2); MdispControl(MilDisplay3, M_TITLE, DisplayTitle3); MdispZoom(MilDisplay1, 0.5, 0.5); MdispControl(MilDisplay1, M_WINDOW_INITIAL_POSITION_X, 0L); MdispZoom(MilDisplay2, 0.5, 0.5); MdispControl(MilDisplay2, M_WINDOW_INITIAL_POSITION_X, 600L); MdispZoom(MilDisplay3, 0.5, 0.5); MdispControl(MilDisplay3, M_WINDOW_INITIAL_POSITION_X, 1200L); MgraAllocList(MilSystem, M_DEFAULT, &amp;MilGraList1); MgraAllocList(MilSystem, M_DEFAULT, &amp;MilGraList2); MdispControl(MilDisplay1, M_ASSOCIATED_GRAPHIC_LIST_ID, MilGraList1); MdispControl(MilDisplay2, M_ASSOCIATED_GRAPHIC_LIST_ID, MilGraList2); /* Restore the template and target image. */ TemplateBufferId = MbufRestore(TEMPLATE_PATH, MilSystem, M_NULL); RestoreAndConvert(MilSystem, TARGET_PATH, TargetBufferId, 8 + M_UNSIGNED); /* Compute the difference between the template image and the target image. */ CloneBuffer(TemplateBufferId, Diff); MimArith(TargetBufferId.Id, TemplateBufferId, Diff.Id, M_SUB_ABS); MdispSelect(MilDisplay1, TemplateBufferId); MdispSelect(MilDisplay2, TargetBufferId.Id); MdispSelect(MilDisplay3, Diff.Id); /* Pause to show the template and target image. */ MosPrintf(MIL_TEXT(\"The graphic patterns displayed are printed on a flexible material.\\n\")); MosPrintf(MIL_TEXT(\"The flexibility of the material causes local deformations in the design.\\n\")); MosPrintf(MIL_TEXT(\"A subtraction operation shows that the images are not aligned.\\n\\n\")); MosPrintf(MIL_TEXT(\"Press any key to perform rigid alignment.\\n\\n\")); MosGetch(); /* Clone to allocate memory for rigid alignment result buffer. */ CloneBuffer(TargetBufferId, RigidAlignedBuffer); /* Perform rigid aligment. */ RigidAlignmentStatus = RigidAlignment(TemplateBufferId, TargetBufferId.Id, RigidAlignedBuffer.Id); /* Compute the difference between the template image and the rigidly aligned target result. */ CloneBuffer(TemplateBufferId, RigidDiff); MimArith(RigidAlignedBuffer.Id, TemplateBufferId, RigidDiff.Id, M_SUB_ABS); MdispControl(MilDisplay2, M_TITLE, DisplayTitle4); MdispSelect(MilDisplay2, RigidAlignedBuffer.Id); MdispControl(MilDisplay3, M_TITLE, DisplayTitle5); MdispSelect(MilDisplay3, RigidDiff.Id); /* Pause to show the rigid alignment results. */ MosPrintf(MIL_TEXT(\"1- Rigid Alignment:\\n\")); MosPrintf(MIL_TEXT(\"-------------------\\n\")); MosPrintf(MIL_TEXT(\"The target image is aligned to the template image by performing\\n\")); MosPrintf(MIL_TEXT(\"rotation and translation operations on the target image.\\n\")); MosPrintf(MIL_TEXT(\"This method does not provide a good alignment due to the local deformations.\\n\\n\")); MosPrintf(MIL_TEXT(\"Press any key to perform flexible alignment.\\n\\n\")); MosGetch(); if (RigidAlignmentStatus) { /* Allocate and set the flex registration object. We define a GRID_SIZE_X x GRID_SIZE_Y grid, a search region of size DELTA_SEARCH x DELTA_SEARCH pixels. */ CFlexRegistration FlexRegistration(GRID_SIZE_X, GRID_SIZE_Y, GRID_MARGIN); FlexRegistration.SetDeltaSearch(DELTA_SEARCH); /* DEFAULT = 5. */ FlexRegistration.SetModelMinSeparation(MODEL_MIN_SEPARATION); /* DEFAULT = 20. */ FlexRegistration.SetAcceptanceAndCertaintyScore(ACCEPTANCE_SCORE, CERTAINTY_SCORE); /* DEFAULT = 75 and 90 respectively. */ FlexRegistration.SetScoreDifferenceThresh(DIFF_THRESH_SCORE); /* DEFAULT = 8. */ FlexRegistration.SetTemplateBufferId(TemplateBufferId); /* Match every cell position in the rigidly aligned target image to a cell in the template image and using these position to define a calibration context. */ MbufCopy(RigidAlignedBuffer.Id, TargetBufferId.Id); FlexRegistration.Calculate(TargetBufferId.Id); /* Clone to allocate memory for flexible alignment result buffer. */ CloneBuffer(TargetBufferId, FlexAlignedBuffer); /* Perform flexible aligment transforming the target image using the previously defined calibration context. */ FlexRegistration.Transform(TargetBufferId.Id, FlexAlignedBuffer.Id); /* Compute the difference between the target image and the flexibly aligned result. */ CloneBuffer(TemplateBufferId, FlexDiff); MimArith(FlexAlignedBuffer.Id, TemplateBufferId, FlexDiff.Id, M_SUB_ABS); /* Draw the grid on template image. */ MdispControl(MilDisplay1, M_UPDATE, M_DISABLE); MgraControl(M_DEFAULT, M_COLOR, M_COLOR_GREEN); FlexRegistration.Draw(MilGraList1, DRAW_MODEL); MdispControl(MilDisplay1, M_UPDATE, M_ENABLE); /* Draw the result. */ MdispControl(MilDisplay2, M_UPDATE, M_DISABLE); MgraControl(M_DEFAULT, M_COLOR, M_COLOR_BLUE); FlexRegistration.Draw(MilGraList2, DRAW_SEARCH_REGION); MgraControl(M_DEFAULT, M_COLOR, M_COLOR_GREEN); FlexRegistration.Draw(MilGraList2, DRAW_RESULT_BOX); MdispControl(MilDisplay2, M_UPDATE, M_ENABLE); MdispSelect(MilDisplay3, M_NULL); /* Pause to show the template, rigidly aligned target image, and the grids. */ MosPrintf(MIL_TEXT(\"2- Flexible Alignment:\\n\")); MosPrintf(MIL_TEXT(\"----------------------\\n\")); MosPrintf(MIL_TEXT(\"The template image is first partitioned into child images.\\n\")); MosPrintf(MIL_TEXT(\"Each child is then matched in the rigidly aligned target image\\n\")); MosPrintf(MIL_TEXT(\"using the Pattern Matching module.\\n\")); MosPrintf(MIL_TEXT(\"This establishes a list of corresponding position between the two images.\\n\\n\")); MosPrintf(MIL_TEXT(\"Press any key to see the flexible alignment result.\\n\\n\")); MosGetch(); /* Change title, remove graphics, and select the result difference of the flexible alignment. */ MgraControlList(MilGraList1, M_ALL, M_DEFAULT, M_DELETE, M_DEFAULT); MgraControlList(MilGraList2, M_ALL, M_DEFAULT, M_DELETE, M_DEFAULT); MdispControl(MilDisplay2, M_TITLE, DisplayTitle6); MdispSelect(MilDisplay2, FlexAlignedBuffer.Id); MdispControl(MilDisplay3, M_TITLE, DisplayTitle7); MdispSelect(MilDisplay3, FlexDiff.Id); /* Pause to show the flexible alignment results. */ MosPrintf(MIL_TEXT(\"These positions are then used to locally align the target image\\n\")); MosPrintf(MIL_TEXT(\"with the template image using a calibration context.\\n\")); MosPrintf(MIL_TEXT(\"The alignment between the target and template image is improved.\\n\\n\")); MosPrintf(MIL_TEXT(\"Press any key to end.\\n\\n\")); MosGetch(); } /* Rigid alignement fail. */ else { MosPrintf(MIL_TEXT(\"Rigid alignment failed.\\n\")); } /* Free all allocations. */ MgraFree(MilGraList1); MgraFree(MilGraList2); MdispFree(MilDisplay2); MdispFree(MilDisplay3); MbufFree(Diff.Id); MbufFree(RigidDiff.Id); MbufFree(TargetBufferId.Id); MbufFree(FlexAlignedBuffer.Id); MbufFree(RigidAlignedBuffer.Id); MbufFree(TemplateBufferId); MbufFree(FlexDiff.Id); /* Free defaults. */ MappFreeDefault(MilApplication, MilSystem, MilDisplay1, M_NULL, M_NULL); return 0; } /* Function to perform rigid aligment. */ bool RigidAlignment(MIL_ID TemplateBufferId, MIL_ID TargetBufferId, MIL_ID DstBufferId) { bool AlignSucceed = false; /* Allocate registration context and result context. */ MIL_ID RegContextId = MregAlloc(M_DEFAULT_HOST, M_CORRELATION, M_DEFAULT, M_NULL); MIL_ID RegResultId = MregAllocResult(M_DEFAULT_HOST, M_DEFAULT, M_NULL); /* Allow rotation and translation. */ MregControl(RegContextId, M_CONTEXT, M_TRANSFORMATION_TYPE, M_TRANSLATION_ROTATION); /* Temporary array of input ID. */ MIL_ID ImageArray[2] = { TemplateBufferId, TargetBufferId }; /* Perform the registration. */ MregCalculate(RegContextId, ImageArray, RegResultId, 2, M_DEFAULT); MIL_INT Result; MregGetResult(RegResultId, M_GENERAL, M_RESULT + M_TYPE_MIL_INT, &amp;Result); if (M_SUCCESS == Result) { AlignSucceed = true; /* Retrieve the transformation matrix. */ MIL_ID TransMatrixId; MregGetResult(RegResultId, 1, M_TRANSFORMATION_MATRIX_ID + M_TYPE_MIL_ID, &amp;TransMatrixId); MimWarp(TargetBufferId, DstBufferId, TransMatrixId, M_NULL, M_WARP_POLYNOMIAL, M_BILINEAR + M_OVERSCAN_CLEAR); } MregFree(RegResultId); MregFree(RegContextId); return AlignSucceed; } ",
      "wordCount": 1327
    },
    {
      "id": "Examples_Processing_DifferenceAnalysis_FlexAlignment_CPP_flexregistration_cpp",
      "version": "2024020714",
      "title": "flexregistration.cpp",
      "location": "Sample Code from MIL Examples",
      "text": " Top /*************************************************************************************/ /* * File name: FlexRegistration.cpp * Location: See Matrox Example Launcher in the MIL Control Center * * * Synopsis: Implementation of the FlexRegistration class * * * Copyright (C) Matrox Electronic Systems Ltd., 1992-2024. * All Rights Reserved */ #include \"FlexRegistration.h\" /*************************************************************************************/ /* * Class : CFlexRegistration * * Name : CFlexRegistration() * * Access : Public * * Synopsis : Constructor * * Parameters : SizeX, SizeY and Margin of the grid * */ CFlexRegistration::CFlexRegistration(MIL_INT SizeX /*= DEFAULT_SIZE_X*/, MIL_INT SizeY /*= DEFAULT_SIZE_X*/, MIL_INT Margin /*= DEFAULT_MARGIN*/) : m_FlexRegistrationGrid(SizeX, SizeY, Margin) { /* Allocate the calibration context. */ m_CalId = McalAlloc(M_DEFAULT_HOST, M_LINEAR_INTERPOLATION, M_DEFAULT, M_NULL); } /*************************************************************************************/ /* * Class : CFlexRegistration * * Name : Calculate() * * Access : Public * * Synopsis : Calculate the flex * * Parameters : Target buffer on which to compute the * : flex transformation relative to the template * */ void CFlexRegistration::Calculate(MIL_ID TargetBufferId) { m_FlexRegistrationGrid.Calculate(TargetBufferId, m_CalId); } /*************************************************************************************/ /* * Class : CFlexRegistration * * Name : Draw() * * Access : Public * * Synopsis : Draw flex registration information * * Parameters : Destination buffer and draw operation to perform * */ void CFlexRegistration::Draw(MIL_ID DstBufferId, EFlexDrawOperation FlexDrawOperation) { m_FlexRegistrationGrid.Draw(DstBufferId, FlexDrawOperation); } /*************************************************************************************/ /* * Class : CFlexRegistration * * Name : UpdateGrid() * * Access : Public * * Synopsis : Update the flex grid when the template buffer changed * */ void CFlexRegistration::UpdateGrid() { if (M_NULL != m_TemplateId) { /* Flush the previous grid and update. */ m_FlexRegistrationGrid.ClearGrid(); m_FlexRegistrationGrid.UpdateGrid(m_TemplateId); } } /*************************************************************************************/ /* * Class : CFlexRegistration * * Name : Transform() * * Access : Public * * Synopsis : Align the src buffer on the template buffer * */ void CFlexRegistration::Transform(MIL_ID SrcBufferId, MIL_ID DstBufferId) { McalUniform(DstBufferId, 0, 0, 1, 1, 0, M_DEFAULT); McalTransformImage(SrcBufferId, DstBufferId, m_CalId, M_BILINEAR+M_OVERSCAN_CLEAR, M_DEFAULT, M_WARP_IMAGE + M_USE_DESTINATION_CALIBRATION); } ",
      "wordCount": 310
    },
    {
      "id": "Examples_Processing_DifferenceAnalysis_FlexAlignment_CPP_flexregistrationgrid_cpp",
      "version": "2024020714",
      "title": "flexregistrationgrid.cpp",
      "location": "Sample Code from MIL Examples",
      "text": " Top /*************************************************************************************/ /* * File name: FlexRegistrationGrid.cpp * Location: See Matrox Example Launcher in the MIL Control Center * * * Synopsis: Implementation of the FlexRegistrationGrid class * * * Copyright (C) Matrox Electronic Systems Ltd., 1992-2024. * All Rights Reserved */ #include \"FlexRegistrationGrid.h\" #include \"Rect.h\" #include \"MathUtil.h\" /*************************************************************************************/ /* * Class : CFlexRegistrationGrid * * Name : ~CFlexRegistrationGrid() * * Access : Public * * Synopsis : Destructor * */ CFlexRegistrationGrid::~CFlexRegistrationGrid() { ClearGrid(); } /*************************************************************************************/ /* * Class : CFlexRegistrationGrid * * Name : UpdateGrid() * * Access : Public * * Synopsis : Update the grid * * Parameters : TemplateBufferId * * Comments : Divide and template buffer in a SizeX*SizeY grid * : and create a pattern matching context (FinderItem) for each grid element * */ void CFlexRegistrationGrid::UpdateGrid(MIL_ID TemplateBufferId) { /* Inquire the grid size. */ MIL_INT GridSizeX = GetSizeX(); MIL_INT GridSizeY = GetSizeY(); MIL_INT Margin = GetMargin(); /* Inquire buffer size. */ MIL_INT TemplateBufferSizeX = MbufInquire(TemplateBufferId, M_SIZE_X, M_NULL); MIL_INT TemplateBufferSizeY = MbufInquire(TemplateBufferId, M_SIZE_Y, M_NULL); m_CellSizeX = (TemplateBufferSizeX - (2 * Margin)) / GridSizeX; /* omit extra pixels. */ m_CellSizeY = (TemplateBufferSizeY - (2 * Margin)) / GridSizeY; MIL_INT OffX, OffY; MIL_ID PatternId, ResultId; for(MIL_INT Row = 0; Row &lt; GridSizeY; Row++) { for(MIL_INT Col = 0; Col &lt; GridSizeX; Col++) { /* Get a reference to the item. */ CFinderItem &amp;UpdatedItem = m_FlexRegistrationGrid.GetElement(Row, Col); /* Compute offsets. We add a margin to define models far from the border to ensure their content is also present in the target image. */ OffX = (Col * m_CellSizeX)+ Margin; OffY = (Row * m_CellSizeY)+ Margin; UpdatedItem.SetRect(OffX, OffY, m_CellSizeX, m_CellSizeY); UpdatedItem.SetCenter(); /* Allocate the pattern matching context of the FinderItem . */ PatternId = MpatAlloc(M_DEFAULT_HOST, M_DEFAULT, M_DEFAULT, M_NULL); MpatDefine(PatternId, M_REGULAR_MODEL, TemplateBufferId, OffX, OffY, m_CellSizeX, m_CellSizeY, M_DEFAULT); UpdatedItem.SetPatternMatchingId(PatternId); /* Allocate the result buffer of the FinderItem. */ ResultId = MpatAllocResult(M_DEFAULT_HOST, M_DEFAULT, M_NULL); UpdatedItem.SetResultId(ResultId); /* Update the search region of the FinderIdem. */ MpatControl(PatternId, 0, M_SEARCH_OFFSET_X, M_Round(UpdatedItem.GetCenter().x - m_DeltaSearch / 2)); MpatControl(PatternId, 0, M_SEARCH_OFFSET_Y, M_Round(UpdatedItem.GetCenter().y - m_DeltaSearch / 2)); MpatControl(PatternId, 0, M_SEARCH_SIZE_X, m_DeltaSearch); MpatControl(PatternId, 0, M_SEARCH_SIZE_Y, m_DeltaSearch); /* Other controls. */ MpatControl(PatternId, M_ALL, M_ACCURACY, M_MEDIUM); MpatControl(PatternId, M_ALL, M_SPEED, M_MEDIUM); MpatControl(PatternId, M_ALL, M_ACCEPTANCE, m_AcceptanceScore); MpatControl(PatternId, M_ALL, M_CERTAINTY, m_CertaintyScore); MpatControl(PatternId, M_ALL, M_FIRST_LEVEL, M_AUTO_CONTENT_BASED); /* We set the maximum number of target occurences to 2. If the context finds 2 occurences with close scores values the model will */ /* not be included in the calibration process (see Calculate() for more details). */ MpatControl(PatternId, M_ALL, M_NUMBER, 2); /* We set the minimum separation in percentage between two occurences to be considered distinct. */ MpatControl(PatternId, M_ALL, M_MIN_SEPARATION_X, m_ModelMinSeparation / MIL_DOUBLE(m_CellSizeX) * 100.0); MpatControl(PatternId, M_ALL, M_MIN_SEPARATION_Y, m_ModelMinSeparation / MIL_DOUBLE(m_CellSizeY) * 100.0); } } } /*************************************************************************************/ /* * Class : CFlexRegistrationGrid * * Name : SetSizeX() * * Access : Public * * Synopsis : Set the X size of the grid * * Parameters : NewSizeX * */ void CFlexRegistrationGrid::SetSizeX( MIL_INT NewSizeX ) { /* Update the cell size. */ MIL_INT OldGridSizeX = GetSizeX(); /* Old size. */ m_CellSizeX = m_CellSizeX * OldGridSizeX / NewSizeX; m_FlexRegistrationGrid.SetSizeX(NewSizeX); } /*************************************************************************************/ /* * Class : CFlexRegistrationGrid * * Name : SetSizeY() * * Access : Public * * Synopsis : Set the Y size of the grid * * Parameters : NewSizeY * */ void CFlexRegistrationGrid::SetSizeY( MIL_INT NewSizeY ) { /* Update the cell size. */ MIL_INT OldGridSizeY = GetSizeY(); /* Old size. */ m_CellSizeY = m_CellSizeY * OldGridSizeY / NewSizeY; m_FlexRegistrationGrid.SetSizeY(NewSizeY); } /*************************************************************************************/ /* * Class : CFlexRegistrationGrid * * Name : SetMargin() * * Access : Public * * Synopsis : Set the margin of the grid * * Parameters : Margin * */ void CFlexRegistrationGrid::SetMargin(MIL_INT Margin) { m_FlexRegistrationGrid.SetMargin(Margin); } /*************************************************************************************/ /* * Class : CFlexRegistrationGrid * * Name : SetSize() * * Access : Public * * Synopsis : Set the X , Y size of the grid * * Parameters : NewSizeX, NewSizeY * */ void CFlexRegistrationGrid::SetSize( MIL_INT NewSizeX, MIL_INT NewSizeY ) { MIL_INT OldGridSizeX = GetSizeX(); /* Old size. */ MIL_INT OldGridSizeY = GetSizeY(); m_CellSizeX = m_CellSizeX * OldGridSizeX / NewSizeX; m_CellSizeY = m_CellSizeY * OldGridSizeY / NewSizeY; m_FlexRegistrationGrid.SetSizeX(NewSizeX); m_FlexRegistrationGrid.SetSizeY(NewSizeY); } /*************************************************************************************/ /* * Class : CFlexRegistrationGrid * * Name : Draw() * * Access : Public * * Synopsis : Draw flex grid information in the DstGraList * * Parameters : DstGraList, DrawOperation * */ void CFlexRegistrationGrid::Draw(MIL_ID DstGraList, EFlexDrawOperation FlexDrawOperation) { /* Retrieve the size of the grid. */ MIL_INT SizeX = GetSizeX(); MIL_INT SizeY = GetSizeY(); MIL_INT CurrentPatternMatchingId = M_NULL; MIL_INT CurrentResultId = M_NULL; switch(FlexDrawOperation) { case DRAW_MODEL: { for(MIL_INT Row = 0; Row &lt; SizeY; Row++) for(MIL_INT Col = 0; Col &lt; SizeX; Col++) { CFinderItem &amp;CurrentFinderItem = GetElement(Row, Col); MIL_INT OffX = CurrentFinderItem.GetRect().OffX; MIL_INT OffY = CurrentFinderItem.GetRect().OffY; MIL_INT SizeX = CurrentFinderItem.GetRect().SizeX; MIL_INT SizeY = CurrentFinderItem.GetRect().SizeY; MIL_DOUBLE CenterX = CurrentFinderItem.GetCenter().x; MIL_DOUBLE CenterY = CurrentFinderItem.GetCenter().y; /* Draw the rect. */ MgraRect(M_DEFAULT, DstGraList, OffX, OffY, OffX+SizeX-1, OffY+SizeY-1); /* Draw the center. */ MgraDot(M_DEFAULT, DstGraList, M_Round(CenterX), M_Round(CenterY)); } break; } case DRAW_SEARCH_REGION: { for(MIL_INT Row = 0; Row &lt; SizeY; Row++) for(MIL_INT Col = 0; Col &lt; SizeX; Col++) { CFinderItem &amp;CurrentFinderItem = GetElement(Row, Col); MIL_DOUBLE CenterX = CurrentFinderItem.GetCenter().x; MIL_DOUBLE CenterY = CurrentFinderItem.GetCenter().y; /* Draw the rect. */ MgraRect(M_DEFAULT, DstGraList, M_Round(CenterX - m_DeltaSearch / 2), M_Round(CenterY - m_DeltaSearch / 2), M_Round(CenterX + m_DeltaSearch / 2), M_Round(CenterY + m_DeltaSearch / 2)); /* Draw the center. */ MgraDot(M_DEFAULT, DstGraList, M_Round(CenterX), M_Round(CenterY)); } break; } case DRAW_RESULT_BOX: { for(MIL_INT Row = 0; Row &lt; SizeY; Row++) for(MIL_INT Col = 0; Col &lt; SizeX; Col++) { CFinderItem &amp;CurrentFinderItem = GetElement(Row, Col); CurrentPatternMatchingId = CurrentFinderItem.GetPatternMatchingId(); CurrentResultId = CurrentFinderItem.GetResultId(); MIL_DOUBLE Num; MIL_DOUBLE Scores[2] = {}; MpatGetResult(CurrentResultId, M_DEFAULT, M_NUMBER, &amp;Num); MpatGetResult(CurrentResultId, M_DEFAULT, M_SCORE, Scores); MIL_DOUBLE Diff = Scores[0] - Scores[1]; if (Num == 1 || (Num == 2 &amp;&amp; Diff &gt; m_ScoreDifferenceThresh)) { MpatDraw(M_DEFAULT, CurrentResultId, DstGraList, M_DRAW_BOX, 0, M_DEFAULT); MpatDraw(M_DEFAULT, CurrentResultId, DstGraList, M_DRAW_POSITION, 0, M_DEFAULT); } else { /* Retrieve the position and size of the model box. */ MIL_INT OffX = CurrentFinderItem.GetRect().OffX; MIL_INT OffY = CurrentFinderItem.GetRect().OffY; MIL_INT SizeX = CurrentFinderItem.GetRect().SizeX; MIL_INT SizeY = CurrentFinderItem.GetRect().SizeY; MIL_DOUBLE CenterX = CurrentFinderItem.GetCenter().x; MIL_DOUBLE CenterY = CurrentFinderItem.GetCenter().y; /* Force the draw of not found model to red. */ MIL_INT CurrentColor = MgraInquire(M_DEFAULT, M_COLOR, M_NULL); if(Num == 0) MgraControl(M_DEFAULT, M_COLOR, M_COLOR_RED); else MgraControl(M_DEFAULT, M_COLOR, M_COLOR_MAGENTA); /* Draw the rect. */ MgraRect(M_DEFAULT, DstGraList, OffX, OffY, OffX+SizeX-1, OffY+SizeY-1); /* Draw the center. */ MgraDot(M_DEFAULT, DstGraList, M_Round(CenterX), M_Round(CenterY)); /* Reset to previous color. */ MgraControl(M_DEFAULT, M_COLOR, MIL_DOUBLE(CurrentColor)); } } break; } case DRAW_INDEX: { for(MIL_INT Row = 0; Row &lt; SizeY; Row++) for(MIL_INT Col = 0; Col &lt; SizeX; Col++) { CFinderItem &amp;CurrentFinderItem = GetElement(Row, Col); CurrentResultId = CurrentFinderItem.GetResultId(); MIL_TEXT_CHAR TmpBuffer[50]; MosSprintf(TmpBuffer, 50, MIL_TEXT(\"%d\"), Row*GetSizeX()+Col); MIL_DOUBLE Num; MpatGetResult(CurrentResultId, M_DEFAULT, M_NUMBER, &amp;Num); if ( Num &gt; 0) { /* Get the position of the result. */ MIL_DOUBLE PosX = 0.0, PosY = 0.0; MpatGetResult(CurrentResultId, 0, M_POSITION_X, &amp;PosX); MpatGetResult(CurrentResultId, 0, M_POSITION_Y, &amp;PosY); MgraText(M_DEFAULT, DstGraList, M_Round(PosX), M_Round(PosY), TmpBuffer); } else { /* Retrieve the center of the model box. */ MIL_DOUBLE CenterX = CurrentFinderItem.GetCenter().x; MIL_DOUBLE CenterY = CurrentFinderItem.GetCenter().y; MgraText(M_DEFAULT, DstGraList, M_Round(CenterX), M_Round(CenterY), TmpBuffer); } } } break; case DRAW_SCORE: { for(MIL_INT Row = 0; Row &lt; SizeY; Row++) for(MIL_INT Col = 0; Col &lt; SizeX; Col++) { CFinderItem &amp;CurrentFinderItem = GetElement(Row, Col); CurrentResultId = CurrentFinderItem.GetResultId(); MIL_TEXT_CHAR TmpBuffer[50]; MIL_DOUBLE Num; MpatGetResult(CurrentResultId, M_DEFAULT, M_NUMBER, &amp;Num); if (Num &gt; 0) { for(int i = 0; i &lt; Num; i++) { /* Get the position of the result. */ MIL_DOUBLE Score = 0.0, PosX = 0.0, PosY = 0.0; MpatGetResult(CurrentResultId, i, M_POSITION_X, &amp;PosX); MpatGetResult(CurrentResultId, i, M_POSITION_Y, &amp;PosY); MpatGetResult(CurrentResultId, i, M_SCORE, &amp;Score); MosSprintf(TmpBuffer, 50, MIL_TEXT(\"%.2f\"), Score); MgraText(M_DEFAULT, DstGraList, M_Round(PosX), M_Round(PosY), TmpBuffer); } } else { /* Retrieve the center of the model box. */ MIL_DOUBLE CenterX = CurrentFinderItem.GetCenter().x; MIL_DOUBLE CenterY = CurrentFinderItem.GetCenter().y; MosSprintf(TmpBuffer, 50, MIL_TEXT(\"NF\")); /* Not found. */ MgraText(M_DEFAULT, DstGraList, M_Round(CenterX), M_Round(CenterY), TmpBuffer); } } } break; default: break; } } /*************************************************************************************/ /* * Class : CFlexRegistrationGrid * * Name : ClearGrid() * * Access : Public * * Synopsis : Clear the flex grid * * Comments : Remove all the finder item from the grid * */ void CFlexRegistrationGrid::ClearGrid() { /* Inquire the grid size. */ MIL_INT GridSizeX = GetSizeX(); MIL_INT GridSizeY = GetSizeY(); MIL_ID CurPatternMatchingId = M_NULL; MIL_ID CurResultId = M_NULL; for(MIL_INT Row = 0; Row &lt; GridSizeY; Row++) { for(MIL_INT Col = 0; Col &lt; GridSizeX; Col++) { /* Reinitialized the finder item. */ CFinderItem &amp;CurClearedItem = m_FlexRegistrationGrid.GetElement(Row, Col); CurPatternMatchingId = CurClearedItem.GetPatternMatchingId(); CurResultId = CurClearedItem.GetResultId(); if(M_NULL != CurPatternMatchingId) MpatFree(CurPatternMatchingId); if(M_NULL != CurResultId) MpatFree(CurResultId); /* Reinitialized. */ CurClearedItem.Init(); } } } /*************************************************************************************/ /* * Class : CFlexRegistrationGrid * * Name : UpdateSearchRegion() * * Access : Public * * Synopsis : Update the search region of each finder item * : in the grid */ void CFlexRegistrationGrid::UpdateSearchRegion() { /* Inquire the grid size. */ MIL_INT GridSizeX = GetSizeX(); MIL_INT GridSizeY = GetSizeY(); /* Retrieve the PatternMatchingId of the first element to test if a context is already associated. */ if (M_NULL != m_FlexRegistrationGrid.GetElement(0, 0).GetPatternMatchingId()) { for(MIL_INT Row = 0; Row &lt; GridSizeY; Row++) for(MIL_INT Col = 0; Col &lt; GridSizeX; Col++) { /* Get a reference to the item. */ CFinderItem &amp;UpdatedItem = m_FlexRegistrationGrid.GetElement(Row, Col); /* Update the search region of the FinderIdem. */ MpatControl(UpdatedItem.GetPatternMatchingId(), 0, M_SEARCH_OFFSET_X, M_Round(UpdatedItem.GetCenter().x - m_DeltaSearch / 2)); MpatControl(UpdatedItem.GetPatternMatchingId(), 0, M_SEARCH_OFFSET_Y, M_Round(UpdatedItem.GetCenter().y - m_DeltaSearch / 2)); MpatControl(UpdatedItem.GetPatternMatchingId(), 0, M_SEARCH_SIZE_X, m_DeltaSearch); MpatControl(UpdatedItem.GetPatternMatchingId(), 0, M_SEARCH_SIZE_Y, m_DeltaSearch); } } } /*************************************************************************************/ /* * Class : CFlexRegistrationGrid * * Name : UpdateModelMinSeparation() * * Access : Public * * Synopsis : Update the minimum sepration parameter of each finder item * : in the grid * */ void CFlexRegistrationGrid::UpdateModelMinSeparation() { /* Inquire the grid size. */ MIL_INT GridSizeX = GetSizeX(); MIL_INT GridSizeY = GetSizeY(); /* Retrieve the PatternMatchingId of the first element to test if a context is already associated. */ if(M_NULL != m_FlexRegistrationGrid.GetElement(0, 0).GetPatternMatchingId()) { for(MIL_INT Row = 0; Row &lt; GridSizeY; Row++) for(MIL_INT Col = 0; Col &lt; GridSizeX; Col++) { /* Get a reference to the item. */ CFinderItem &amp;UpdatedItem = m_FlexRegistrationGrid.GetElement(Row, Col); /* Update the model minimum separation of the FinderIdem. */ MpatControl(UpdatedItem.GetPatternMatchingId(), M_ALL, M_MIN_SEPARATION_X, m_ModelMinSeparation / MIL_DOUBLE(m_CellSizeX) * 100.0); MpatControl(UpdatedItem.GetPatternMatchingId(), M_ALL, M_MIN_SEPARATION_Y, m_ModelMinSeparation / MIL_DOUBLE(m_CellSizeY) * 100.0); } } } /*************************************************************************************/ /* * Class : CFlexRegistrationGrid * * Name : UpdateAcceptanceAndCertaintyScore() * * Access : Public * * Synopsis : Update the acceptance and certainty score of each finder item * : in the grid * */ void CFlexRegistrationGrid::UpdateAcceptanceAndCertaintyScore() { /* Inquire the grid size. */ MIL_INT GridSizeX = GetSizeX(); MIL_INT GridSizeY = GetSizeY(); /* Retrieve the PatternMatchingId of the first element to test if a context is already associated. */ if(M_NULL != m_FlexRegistrationGrid.GetElement(0, 0).GetPatternMatchingId()) { for(MIL_INT Row = 0; Row &lt; GridSizeY; Row++) for(MIL_INT Col = 0; Col &lt; GridSizeX; Col++) { /* Get a reference to the item. */ CFinderItem &amp;UpdatedItem = m_FlexRegistrationGrid.GetElement(Row, Col); /* Update the model minimum separation of the FinderIdem. */ MpatControl(UpdatedItem.GetPatternMatchingId(), M_ALL, M_ACCEPTANCE, m_AcceptanceScore); MpatControl(UpdatedItem.GetPatternMatchingId(), M_ALL, M_CERTAINTY, m_CertaintyScore); } } } /*************************************************************************************/ /* * Class : CFlexRegistrationGrid * * Name : Calculate() * * Access : Public * * Synopsis : Associate every finder item with a target position in the target buffer * : and prepare a calibration context. * * Parameters : TargetBufferId, DstCalId * */ void CFlexRegistrationGrid::Calculate(MIL_ID TargetBufferId, MIL_ID DstCalId) { /* Count found point in the target. */ MIL_INT FoundCounter = 0; /* Inquire the grid size. */ MIL_INT GridSizeX = m_FlexRegistrationGrid.GetSizeX(); MIL_INT GridSizeY = m_FlexRegistrationGrid.GetSizeY(); /* Allocate array for the McalList call. */ MIL_INT ArraySize = GridSizeX * GridSizeY; /* Those arrays have the maximum possible size. */ MIL_DOUBLE *XTemplateArray = new MIL_DOUBLE[ArraySize]; MIL_DOUBLE *YTemplateArray = new MIL_DOUBLE[ArraySize]; MIL_DOUBLE *XTargetArray = new MIL_DOUBLE[ArraySize]; MIL_DOUBLE *YTargetArray = new MIL_DOUBLE[ArraySize]; /* For each element in the grid, search for occurrence of the model in the search region. */ for(MIL_INT Row = 0; Row &lt; GridSizeY; Row++) for(MIL_INT Col = 0; Col &lt; GridSizeX; Col++) { CFinderItem &amp;CurFinderItem = m_FlexRegistrationGrid.GetElement(Row, Col); MIL_ID ResultId = CurFinderItem.GetResultId(); MIL_INT PatternMatchingId = CurFinderItem.GetPatternMatchingId(); /* Fill target array. */ MpatPreprocess(PatternMatchingId, M_DEFAULT, M_NULL); MpatFind(PatternMatchingId, TargetBufferId, ResultId); MIL_DOUBLE Num; MIL_DOUBLE Scores[2] = {}; MpatGetResult(ResultId, M_DEFAULT, M_NUMBER, &amp;Num); MpatGetResult(ResultId, M_DEFAULT, M_SCORE, Scores); MIL_DOUBLE Diff = Scores[0] - Scores[1]; /* If one occurrence is found, retrieve the position. Or, if two occurrences are found and the score difference */ /* is higher than the threshold, retrieve the position of the first occurence (higher score). */ if (Num == 1 || (Num == 2 &amp;&amp; Diff &gt; m_ScoreDifferenceThresh)) { /* Fill template array. */ XTemplateArray[FoundCounter] = CurFinderItem.GetCenter().x; YTemplateArray[FoundCounter] = CurFinderItem.GetCenter().y; /* Fill target array. */ MpatGetResult(ResultId, 0, M_POSITION_X, &amp;(XTargetArray[FoundCounter])); MpatGetResult(ResultId, 0, M_POSITION_Y, &amp;(YTargetArray[FoundCounter])); FoundCounter++; } } /* Perform the linear interpolation calibration using the positions found. */ McalList(DstCalId, XTargetArray, YTargetArray, XTemplateArray, YTemplateArray, M_NULL, FoundCounter, M_LINEAR_INTERPOLATION, M_DEFAULT); /* Free previously allocated array. */ delete [] XTemplateArray; delete [] YTemplateArray; delete [] XTargetArray; delete [] YTargetArray; } ",
      "wordCount": 2137
    },
    {
      "id": "Examples_Processing_DifferenceAnalysis_FlexAlignment_CPP_uniformgrid_cpp",
      "version": "2024020714",
      "title": "uniformgrid.cpp",
      "location": "Sample Code from MIL Examples",
      "text": " Top /*************************************************************************************/ /* * File name: UniformGrid.cpp * Location: See Matrox Example Launcher in the MIL Control Center * * * Synopsis: * * * Copyright (C) Matrox Electronic Systems Ltd., 1992-2024. * All Rights Reserved */ #include \"UniformGrid.h\" ",
      "wordCount": 41
    }
  ]
}]
[{
  "id": "UG_SureDotOCR",
  "version": "2024020714",
  "title": "SureDotOCR",
  "subTitles": null,
  "location": "MIL UG P03: 2D processing and analysis",
  "pageURL": "content\\UserGuide\\SureDotOCR\\ChapterInformation.htm",
  "text": " Chapter 15: SureDotOCR This chapter explains how to perform optical character recognition (OCR) on dot matrix text with the MIL SureDotOCR module. This module contains MIL functions prefixed with Mdmr. MIL SureDotOCR module Steps to read dot-matrix strings from an image Basic concepts for the MIL SureDotOCR module Fonts Importing and exporting dot-matrix fonts Content of SureDotOCR font files Console-based font utilities Dot-matrices in fonts and strings to read should be the same Delete, control, and inquire about fonts and characters Programmatically managing fonts and characters String models Required settings Dot diameter Text block dimensions Maximum and minimum number of characters Optional settings Foreground Intensity and contrast Acceptance and certainty Rank Number of strings to read Space String angle Italic angle Constraining string model positions with permitted characters Reading space Default permitted characters, and overriding them General controls for the different positions in the string model Managing the different string model positions (implicit or explicitly constrained) Recommended conditions for optimal string reading Reading a partial string Reading only one line of a string with multiple lines Reading strings with dissimilar qualities Character names in ASCII and Unicode environments Results and annotations Results Strings and formatted strings Reading substrings and skipped positions Typical results to retrieve Size of string results Positional and dimensional results Recommendations to improve results Annotations Timeout or stop SureDotOCR example ",
  "wordCount": 225,
  "subEntries": [
    {
      "id": "UG_SureDotOCR_MIL_SureDotOCR_module",
      "version": null,
      "title": "MIL SureDotOCR module",
      "subTitles": null,
      "location": "MIL UG P03: 2D processing and analysis",
      "pageURL": "content\\UserGuide\\SureDotOCR\\MIL_SureDotOCR_module.htm",
      "text": " MIL SureDotOCR module The MIL SureDotOCR module is an innovative set of functions, prefixed with Mdmr, that allow you to perform OCR directly on dot-matrix text (no previous preparations needed). Dot-matrix text refers to characters represented by a two-dimensional grid of dots. This grid is a dot-matrix. A common dot-matrix has 5 columns and 7 rows. To form dot-matrix characters, machines can print the required dots using drops of ink. To represent a virtual equivalent of dot-matrix characters, you can specify the printed dots as foreground values (FF) in a font file, or even an array. Numerous industries, like packaging, use dot-matrix text to print product information, such as manufacturing date, expiry date, lot number, and product number. With SureDotOCR, you can design a vision inspection system that directly ensures the validity of this information. For example, to validate an expiration date printed with dot-matrix text, you can use SureDotOCR to read the text and verify that the first printed string is \"Exp.\" and the second printed string is the expected month, day, and year. You can quickly create a SureDotOCR context that holds the required fonts, string models, and constraints necessary to perform robust read operations on target images. With minimal tuning of defaults, SureDotOCR successfully reads strings in 8-bit grayscale images and provides numerous results, such as the string's score and the character's value. SureDotOCR is invariant to changes in contrast, and offers full rotational tolerance. The module can also adapt to some variations in scale, aspect ratio, non-uniform dot spacing, uneven backgrounds, deformed or skewed characters, and perspective. SureDotOCR supports multiple grammar-like rules, offering a high degree of flexibility to constrain the characters to read at each position in a string. Multiple font definitions are supported in a single context, and you have access to SureDotOCR's console-based font utilities, as well as numerous fonts using SureDotOCR's own font file format, allowing you to easily manage your fonts. You can quickly create your own, and you can make use of the ones that SureDotOCR provides. You can program with SureDotOCR in both a Unicode or ASCII environment, though the module internally handles characters in Unicode. Numerous types of characters are supported, including international character sets, punctuation marks, and, of course, the smiley face. SureDotOCR uses feature-based technologies specifically designed to accurately interpret and robustly read the unique qualities of dot-matrix strings. For example, the spaces between the dots that make up characters can prove difficult to manage for traditional character recognition solutions, which typically require preparing case-specific images with solid-stroked text. SureDotOCR requires no such preparation. You just need to specify some settings, such as the expected size of the dots and the dimensions of a box framing the dot-matrix text in your image. Reading dot-matrix text has never been simpler, or more effective, than with SureDotOCR. MIL SureDotOCR module ",
      "wordCount": 474,
      "subEntries": []
    },
    {
      "id": "UG_SureDotOCR_Steps_to_reading_a_dot_matrix_string_in_an_image",
      "version": null,
      "title": "Steps to read dot-matrix strings from an image",
      "subTitles": null,
      "location": "MIL UG P03: 2D processing and analysis",
      "pageURL": "content\\UserGuide\\SureDotOCR\\Steps_to_reading_a_dot_matrix_string_in_an_image.htm",
      "text": " Steps to read dot-matrix strings from an image The following steps provide a basic methodology for using the MIL SureDotOCR module: Allocate a SureDotOCR context, using MdmrAlloc(). Allocate a SureDotOCR result buffer to hold the results of the read operation, using MdmrAllocResult(). Import one or more fonts into the context, using MdmrImportFont(). Typically, you should use the SureDotOCR console-based font utilities with the predefined SureDotOCR font files that MIL installs to interactively create your fonts. You can also add an empty font to the context, using MdmrControl() with M_FONT_ADD to which you can then add characters. If necessary, add or replace characters in a font, using MdmrImportFont(). Alternatively, you can add characters to a font using MdmrControlFont() with M_CHAR_ADD and an array containing the dot-matrix of the character. MdmrControlFont() provides additional functionality, such as allowing you to delete characters, or rename them. Set general read settings: Set the diameter of the dots that make up the characters in the strings to read, using MdmrControl() with M_DOT_DIAMETER. Optionally, you can also specify a tolerance for the size of the dot diameter using MdmrControl() with M_DOT_DIAMETER_SPREAD. Set the dimensions of the area (text block) that encompasses all dot-matrix text, using MdmrControl() with M_TEXT_BLOCK_HEIGHT and M_TEXT_BLOCK_WIDTH. If necessary, modify other context settings, using MdmrControl(). For example, you can modify the foreground with which to read strings. Add one or more string models to the context, using MdmrControl() with M_STRING_ADD. Set model-specific settings for each model: Set the minimum and maximum number of characters in the string model, using MdmrControlStringModel() with M_STRING_SIZE_MIN and M_STRING_SIZE_MAX. If necessary, modify other string model settings, using MdmrControlStringModel(). For example, you can apply grammar-like constraints, such as specifying that a position in a string must contain a specific character from a specific font. Preprocess the SureDotOCR context, using MdmrPreprocess(). Perform the read operation on the specified target image, using MdmrRead(). Retrieve the required results from the SureDotOCR result buffer, using MdmrGetResult(). If necessary, draw the results, using MdmrDraw(). For example, you can specify M_DRAW_STRING_BOX to draw a bounding box around the string; then, specify M_DRAW_MIL_FONT_STRING to draw an annotation of the string under the bounding box. For more information on annotation, see the Annotations subsection of the Results and annotations section later in this chapter. If necessary, save your SureDotOCR context, using MdmrSave() or MdmrStream(). Free all your allocated objects, using MdmrFree(), unless M_UNIQUE_ID was specified during allocation. Steps to read dot-matrix strings from an image ",
      "wordCount": 409,
      "subEntries": []
    },
    {
      "id": "UG_SureDotOCR_Basic_concepts",
      "version": null,
      "title": "Basic concepts for the MIL SureDotOCR module",
      "subTitles": null,
      "location": "MIL UG P03: 2D processing and analysis",
      "pageURL": "content\\UserGuide\\SureDotOCR\\Basic_concepts.htm",
      "text": " Basic concepts for the MIL SureDotOCR module The basic concepts and vocabulary conventions for the MIL SureDotOCR module are: Character. A symbol, such as a digit, letter, or punctuation mark, represented by a dot-matrix. Constraint. A restriction that limits the strings to read. Constraints typically refer to permitted character constraints. If you override the constraints for a specific position, the position is said to be explicitly constrained; otherwise, it is said to be implicitly constrained. Dot-matrix. A two-dimensional grid of dots that represents a character. Dot-matrix template. The dot-matrix with which every character in a font must be represented. If a font's dot-matrix template is 5 columns by 7 rows, the dot-matrix that represents the number 1 can contain a dot in every cell of its center column. Empty font. A font with no characters. Font. A data structure, within a SureDotOCR context, that stores a list of characters, with each character's name and corresponding dot-matrix representation. Permitted character constraint. A restriction that limits the characters to read at a string model position according to a font and character type. Punctuation character. Typically categorized as characters that are not letters or digits, such as the hyphen ('-'). Rank. The order in which to read strings. SureDotOCR uses rank to establish the total number of strings to read. Regular character. A character that is either a letter or a digit. Space. An area within which character information is absent. Spaces occur between dots in the same character, between characters in the same string, and between strings on the same line. Strings on separate lines are always separate strings. String. A linear sequence of generally aligned characters. If the distance between two successive characters is greater than the maximum space allowed, the characters are considered part of two strings. Characters on separate lines are always in separate strings. String model. A data structure, within a SureDotOCR context, that stores a string to read in the target image. String model positions. Subdivisions of a string model representing the characters to read. String results. Dot-matrix strings, read from the target image, that respect the specifications of a SureDotOCR context, including string model and font settings therein. SureDotOCR context. A MIL object that stores all settings, fonts, and string models with which to read dot-matrix text. Use the SureDotOCR console-based utility, DmrContextViewer (accessible from the Matrox Example Launcher), to view the settings of a context, and the settings of the fonts and string models therein. SureDotOCR font definition file. A text file, with an MDMRF extension, that represents a font and its dot matrix characters. Use this file to import a font into, and to export a font out of, a SureDotOCR context. Target image. The image in which to read dot-matrix strings. Text block. The area in the image buffer (or in the buffer's associated region of interest) that includes all dot-matrix text. Basic concepts for the MIL SureDotOCR module ",
      "wordCount": 488,
      "subEntries": []
    },
    {
      "id": "UG_SureDotOCR_Fonts",
      "version": null,
      "title": "Fonts",
      "subTitles": [
        "Importing and exporting dot-matrix fonts",
        "Content of SureDotOCR font files",
        "Console-based font utilities",
        "Dot-matrices in fonts and strings to read should be the same",
        "Delete, control, and inquire about fonts and characters",
        "Programmatically managing fonts and characters"
      ],
      "location": "MIL UG P03: 2D processing and analysis",
      "pageURL": "content\\UserGuide\\SureDotOCR\\Fonts.htm",
      "text": " Fonts A font is a data structure, within a SureDotOCR context, that stores a list of characters, with each character's name and corresponding dot-matrix representation. A context must contain one or more fonts. A font must contain one or more characters. Only strings with characters represented by a font in the context can be read. For example, if you want to read a string with the number \"1\", the number \"1\" must be a character in a font. Each character must be unique within a font. However the same character can be in multiple fonts. This typically means the fonts represent the characters differently. For example, in FontBig, the number \"1\" can be defined by a column of 10 dots, while in FontEvenBigger the number \"1\" can be defined by a column of 15 dots. You can choose either of these fonts with which to read the number \"1\" that you want. The following lists the most common operations performed on fonts and characters. Import characters from a font file into a new or existing font of a SureDotOCR context (MdmrImportFont()). In general, you should use MIL CoPilot to create and update your own fonts. However, you can also use the console-based font utilities with the predefined SureDotOCR font files that MIL installs; for more information, see the Console-based font utilities subsection of this section. Export fonts to a file (MdmrExportFont()). Delete fonts and characters (MdmrControl() and MdmrControlFont()), and perform general control and inquire type operations on fonts and characters (MdmrControlFont(), MdmrInquireFont(), and MdmrName()). Fonts should only contain characters that you want to read. Delete all unnecessary characters. Add and update fonts by programmatically defining character representations in an array (MdmrControl() and MdmrControlFont()). For font modifications to take effect, you must preprocess the context by calling MdmrPreprocess(). Importing and exporting dot-matrix fonts You can import characters from a font file into a new or existing font of a SureDotOCR context, using MdmrImportFont(). You can import all characters (M_IMPORT_ALL_CHARS) or an explicit list (for example, \"123GO!\"). You can, for example, call MdmrImportFont() multiple times to import, into one font, different characters from different fonts. If you try to import a character that already exists, you can choose to overwrite the existing character (M_OVERWRITE), or you can keep the original (M_NO_OVERWRITE). You can also export a font with all its characters from a SureDotOCR context to a font file, using MdmrExportFont(). Exported fonts can be imported into any SureDotOCR context. For easier use with other Matrox Imaging software products (for example, Matrox Design Assistant or MIL CoPilot), import and export characters using a SureDotOCR font file. This is essentially a text file with the SureDotOCR font file extension, MDMRF. To create and update these files, you should use the console-based font utilities with the predefined SureDotOCR font files that were installed with MIL. You can also create and update font files with a text editor and using the MDMRF extension when saving. Ensure the file is in UTF-16 (little-endian order) and starts with a byte order mark (BOM) that indicates this; the BOM value is U+FEFF. Although often supported, editors might not use the standard terminology, UTF-16. For example, you might have to save the file as Unicode or UCS-2 little-endian. Content of SureDotOCR font files The content of all SureDotOCR font files must adhere to expected specifications. If all the characters in all the strings will be in italic (skewed), you should not add the italic version of the characters to the font. Instead, set the italic angle (skew) as described in the Italic angle subsection of the String models section later in this chapter. Below is an example of how SureDotOCR expects the character 'A' to appear in a font: The following is a line-by-line description of what SureDotOCR files should contain. Line Description 1 This line contains the text, \"File Representation\". 2 This line contains the text, \"MIL_DOT_FONT\". 3 This line is blank. 4 and above These lines specify the entry of every character in the font. Each entry begins with the word \"CharValue\", a space, and the character name. The character's dot-matrix representation is on the next line. \"FF\" is for dots that represent the character; the rest use \"00\". Every dot-matrix of every character must contain at least one \"FF\", and have the same number of columns and rows. Lines beginning with the hash character ('#') are comments. They should not be within a character's dot-matrix and are typically used sparingly (only when they provide true value). Blank lines separate multiple characters in a font. A character's \"CharValue\" name should properly identify its dot-matrix representation. For example, if the \"CharValue\" name is '1', its dot-matrix should not represent the letter 'A'. \"CharValue\" names should be unique within a font. Character names can be in UTF-16 hexadecimal; these begin with \"\\x\". Alternatively, you can enter the UTF-16 character directly (for example, the capital Greek letter PSI) if using Windows API functions with the UTF-16 macro, and your source code is saved as unicode. Expressing characters in UTF-16 hexadecimal allows you to specify them directly in C++ string literals. This notation can also be useful if you are in an ASCII environment and you want to have Unicode characters beyond the Basic Latin range. When specifying the characters to read, you can seamlessly mix notations. For example, to read the characters \"ABC\", where just 'A' is represented in hexadecimal, you can call MdmrControlStringModel() with M_CHAR_LIST and specify the character list as MIL_TEXT(\"\\x0041\") MIL_TEXT(\"BC\"). Names for special surrogate pairs in UTF-16 hexadecimal are listed successively. For example, \"CharValue \\xD83D\\xDE0A\" specifies a smiley face character. Dot-matrix fonts cannot represent certain characters, such as null or the standard space (0x0020). To establish the distance between characters in a target string that represents a space, call MdmrControl() with M_SPACE_SIZE_MAX and M_SPACE_SIZE_MIN. When you call MdmrImportFont() to add a new font to a context, the dimensions of the characters' dot-matrix represent the dimensions of the dot-matrix template of the font. The dot-matrix of every subsequent character that you add to the font must use these dimensions. To inquire about them, call MdmrInquireFont() with M_FONT_SIZE_COLUMNS and M_FONT_SIZE_ROWS. If you delete all characters in a font, the dimensions of the new characters' dot-matrix re-sets the dimensions of the dot-matrix template of the font. If you imported a font from a SureDotOCR font file, you can modify one of the imported font's character representations using an array with the character representation to modify, provided it adheres to the font's dot-matrix template. For more information, see the Programmatically managing fonts and characters subsection of this section. Console-based font utilities You can interactively create and edit fonts, using MIL CoPilot. Additionally, MIL installs SureDotOCR console-based font utilities, such as DmrEditFontFile (accessible from the Matrox Example Launcher), and predefined SureDotOCR font files (for example, *.mdmrf in C:\\Program Files\\Matrox Imaging\\Contexts). You can alternatively use these utilities and files to interactively create and update your fonts. In this case, file and content requirements are automatically respected; ensure that you maintain these requirements as you develop your fonts. Console-based font utility Why should I use this utility? DmrShowFontFile To display the characters in a SureDotOCR font file. DmrEditFontFile To interactively add or modify characters in a SureDotOCR font file that already exists. DmrGenFontFile To interactively create a new SureDotOCR font file and add characters to that file. To create you own fonts, you would typically: Use DmrShowFontFile to view the predefined MDMRFs (font files). Make a copy of the predefined MDMRFs that most resemble the fonts that you want to have in your SureDotOCR context. Be sure to rename the predefined MDMRFs before modifying them, so you do not overwrite the originals. Use DmrEditFontFile to interactively modify or add characters to the renamed MDMRFs. Call MdmrImportFont() to import characters from a font file into a new or existing font of a SureDotOCR context. Call MdmrControlFont() with M_CHAR_DELETE to remove unneeded characters from your fonts. If necessary, you can open a renamed MDMRF file and modify it manually using a text-based editor that supports the required format (UTF-16), as previously discussed. This can be particularly convenient if you want to delete numerous characters from a renamed font. In this case, delete the characters before importing them with MdmrImportFont(). Dot-matrices in fonts and strings to read should be the same The dot-matrix of each character in a font should be, dot for dot, the same as the dot-matrix of each character in the string to read. Even subtle discrepancies in dot-matrices can impact the read operation. Before reading, adjust the characters in your fonts accordingly. To do so interactively, use the console-based font utility, DmrEditFontFile. As previously discussed, you will not typically create a font from scratch. For example, you can choose a predefined MDMRF file that is similar to the font you need, and then modify it as you require. When choosing a font, be aware that differences between characters are not necessarily consistent. Some dot-matrices might be very different, some might be barely different, and some might not be different at all. The following is an example of digits defined in 2 different fonts. Can you spot the differences? The characters with different dot-matrices are zero, three, and five. Delete, control, and inquire about fonts and characters To delete one or all fonts from a context, call MdmrControl() with M_FONT_DELETE. To delete one or all characters from a font, call MdmrControlFont() with M_CHAR_DELETE. You can also delete characters from a font file (MDMRF) using a text based editor. To perform general controls and inquires on fonts and characters, call MdmrControlFont() and MdmrInquireFont()), respectively. For example, you can modify a font's label (M_FONT_LABEL_VALUE), change a character's name (M_CHAR_NAME), or inquire the total number of dots possible in the font's dot-matrix template (M_FONT_SIZE_TEMPLATE). You can also call MdmrName() to perform specialized name-type operations on fonts. For example, you can set the name of a font, or use a font's name to retrieve either its label or index. By referring to fonts with meaningful names, you can more easily manage them. All font names in a context must be unique. MdmrName() operations do not impact how strings are processed and read. Programmatically managing fonts and characters You can specify an array containing the dot-matrix of a character, using MdmrControlFont() with either M_CHAR_ADD, to add a new character to a font, or M_CHAR_TEMPLATE, to modify a character already in a font. You must populate the array, one row contiguously after the other, with 255 (0xFF) to represent a dot in the character's dot-matrix and 0 to represent a blank. You must organize the character data in the specified array according to the dimensions of the font's dot-matrix template. For example, if the template is 5x7 and you want to programmatically add the number \"1\", your array must contain 5 entries repeated 7 times, for a total of 35 entries. You would typically add such characters to a font that already had its template established by the SureDotOCR font file that first created and populated the font. To inquire the template's dimensions, use M_FONT_SIZE_COLUMNS and M_FONT_SIZE_ROWS. You can also add such characters to an empty font. To do so, you must first create an empty font by calling MdmrControl() with M_FONT_ADD, and then explicitly set the size of the font's dot-matrix template by calling MdmrControlFont() with M_FONT_SIZE_COLUMNS and M_FONT_SIZE_ROWS. Fonts Importing and exporting dot-matrix fonts Content of SureDotOCR font files Console-based font utilities Dot-matrices in fonts and strings to read should be the same Delete, control, and inquire about fonts and characters Programmatically managing fonts and characters ",
      "wordCount": 1931,
      "subEntries": []
    },
    {
      "id": "UG_SureDotOCR_String_models",
      "version": null,
      "title": "String models",
      "subTitles": [
        "Required settings",
        "Dot diameter",
        "Text block dimensions",
        "Maximum and minimum number of characters",
        "Optional settings",
        "Foreground",
        "Intensity and contrast",
        "Acceptance and certainty",
        "Rank",
        "Number of strings to read",
        "Space",
        "String angle",
        "Italic angle",
        "Constraining string model positions with permitted characters",
        "Reading space",
        "Default permitted characters, and overriding them",
        "General controls for the different positions in the string model",
        "Managing the different string model positions (implicit or explicitly constrained)",
        "Recommended conditions for optimal string reading",
        "Reading a partial string",
        "Reading only one line of a string with multiple lines",
        "Reading strings with dissimilar qualities"
      ],
      "location": "MIL UG P03: 2D processing and analysis",
      "pageURL": "content\\UserGuide\\SureDotOCR\\String_models.htm",
      "text": " String models A string model is a data structure, within a SureDotOCR context, that stores the requirements that a dot-matrix string in a target image must meet, for the string to be read. These requirements can range from general to specific; they can apply to the string models themselves, or to the different string model positions. For example, you can create a string model to read any string from a target image that contains any two characters from any font in a context, or you can create a string model to read a string that contains the numbers '4' and '2' from the Galaxy font. A SureDotOCR context must contain one or more string models. To add a string model to a context, call MdmrControl() with M_STRING_ADD. To delete a string model from a context, use M_STRING_DELETE. You can also call MdmrControl() to control context settings related to string models. To inquire about such settings, call MdmrInquire(). To control and inquire about string models themselves, call MdmrControlStringModel() and MdmrInquireStringModel(), respectively. Context settings related to string models apply to all string models in that context. For string model modifications to take effect, you must preprocess the context by calling MdmrPreprocess(). Required settings Before reading dot-matrix text from a target image with MdmrRead(), you must specify the following settings related to string models: Dot diameter. Text block dimensions. Minimum and maximum number of characters. Ideally, the string in the target image should adhere to each of these settings. If it doesn't, the string might still be read, although possibly with a lower resulting score. For more information, see the Acceptance and certainty subsection of this section. Dot diameter The dot diameter refers to the size of the dots that represent the characters of the strings in the target. To set the diameter, call MdmrControl() with M_DOT_DIAMETER. The diameter is set for a context and applies to every dot in all strings read for each string model in that context. The dots that make up the characters in the image must be visually distinguishable, both vertically and horizontally. If dots are merged into a solid bar, as seen in the following image, there can be difficulties reading. When dots are merged (that is, you cannot perceive the bump of each dot) due to low resolution or poor focus, improve the image's quality. If a string's characters are printed such that their center to center spacing is less than the dot diameter, it might not be feasible to read such strings reliably. SureDotOCR can tolerate a specified amount of spread of the dots. To enable a tolerance for spread, enable MdmrControl() with M_DOT_DIAMETER_SPREAD_MODE. Then, specify the tolerance for the size of the dot diameter using M_DOT_DIAMETER_SPREAD. Specify the tolerance as a value centered at the M_DOT_DIAMETER. In the image below, M_DOT_DIAMETER is set to 4.0 and M_DOT_DIAMETER_SPREAD is set to 2.0. This will allow dots with a diameter between 3.0 and 5.0. When M_DOT_DIAMETER_SPREAD_MODE is enabled, it is recommended that you also set the dot diameter step using MdmrControl() with M_DOT_DIAMETER_STEP. The diameter step is the increment between steps SureDotOCR will use when checking the range of diameters set by M_DOT_DIAMETER_SPREAD. For example, if M_DOT_DIAMETER is set to 4.0, M_DOT_DIAMETER_SPREAD is set to 2.0, and M_DOT_DIAMETER_SPREAD to 0.2, SureDotOCR will check 3.0, 3.2, 3.4, 3.6,... 4.6, 4.8, 5.0 until it finds. Text block dimensions The text block refers to a rectangle that encloses all dot-matrix text in the target image buffer (or in the buffer's associated region of interest). To set the text block dimensions, call MdmrControl() with M_TEXT_BLOCK_WIDTH and M_TEXT_BLOCK_HEIGHT. Set the width and height according to the orientation of the string(s) to read in the text block. The width is oriented along the axis that represents the string's base; while the height is oriented along the vertical axis that is perpendicular to the string's base. The text block dimensions are set for a context and must enclose all dot-matrix text in the image or region of interest, if one exists. SureDotOCR establishes the center of the text block automatically. The text block should be smaller than the rectangular region of interest (MbufSetRegion()), if the target image specified with MdmrRead() has one. Maximum and minimum number of characters The number of characters refers to the size of the string to read in the target. To set the number of characters, call MdmrControlStringModel() with M_STRING_SIZE_MIN_MAX. Each character in a string that you expect to read represents a position in the string model. For information about how to constrain the different positions to limit the characters permitted, see the Constraining string model positions with permitted characters subsection of this section. Optional settings To fine tune how SureDotOCR reads dot-matrix text from a target image, you can specify the following settings related to string models: Foreground. Intensity and contrast. Acceptance and certainty. Rank. Number of strings to read. String angle. Italic angle. Foreground Foreground refers to whether the dots that represent the characters of the strings in the target are darker or lighter than the background. By default, SureDotOCR assumes characters are darker than the backgrounds (for example, black dots on a white surface). To modify this, call MdmrControl() with M_FOREGROUND_VALUE. The foreground is set for a context and applies to all strings read for each string model in that context. Intensity and contrast Intensity refers to the average grayscale value of the pixels that make up the character's dots (foreground) in the strings. Since target images must be 8-bit, the highest possible intensity of a dot is 255 (white). The lowest possible intensity is 0 (black). Contrast refers to the difference in pixel intensity between a character and its background. The greater the difference, the higher the contrast. The following dot-matrix strings, from left to right, show a decrease in contrast. If a valid character exists in the target image, it can typically be read with the default intensity and contrast settings. However, if the read operation is proving problematic, or you want to try and speed up the read time, you can adjust these settings. To modify the intensity requirements, set M_MIN_INTENSITY_MODE or M_MAX_INTENSITY_MODE to M_USER_DEFINED. You can then specify a minimum or maximum intensity value with M_MIN_INTENSITY or M_MAX_INTENSITY, respectively. Valid values are between 0 and 255, inclusive. The default minimum is 0; the default maximum is 255. To modify the contrast requirements, set M_MIN_CONTRAST_MODE to M_USER_DEFINED, and specify a minimum contrast value with M_MIN_CONTRAST. Valid values are between 0 and 255, inclusive. The default value is 15. The default contrast mode is M_AUTO, which automatically establishes the minimum contrast. Note that with M_AUTO, SureDotOCR will not read characters with a contrast less than 15. SureDotOCR ignores potential character data in the target image that does not have an intensity that falls within the specified min and max range or that does not have a contrast greater than or equal to the specified minimum value. Although this can be useful to fine tune your results and potentially decrease read time, particularly in the presence of noise and in unusually contrasted images, be aware that improperly ignoring image data can cause SureDotOCR to ignore actual characters. Intensity and contrast are set for a context and apply to all strings read for each string model in that context. Acceptance and certainty Acceptance and certainty refer to string model settings that regulate when a target string can be read (acceptance) and when a target string must be read (certainty), based on the resulting score of the string and its characters. When you call MdmrRead(), SureDotOCR analyzes the target image and localizes potential character candidates for each string model. The best candidates that meet the minimum definition of a string (a linear sequence of generally aligned characters) and all user-specified settings will be read. Every character candidate is given a score between 0 and 100. The higher the score, the better the candidate. This score quantifies, as a percentage, the similarity between the character in the target string and the corresponding character in the font that the string model uses. The string score is the average score of all the characters in the string. To retrieve these scores, call MdmrGetResult() with M_CHAR_SCORE and M_STRING_SCORE. By default, the acceptance level for the score of both the string and its characters is 50%. To modify these levels, call MdmrControlStringModel() with M_STRING_ACCEPTANCE or M_CHAR_ACCEPTANCE. Strings can only be read if the string score, and the score of every character, is greater than or equal to their respective acceptance level. For example, if a string has three characters, and the first two have a score of 55%, and the last has a score of 40%, the string's score is 50%, which meets the string's default acceptance level. However, since one character does not meet the default character acceptance level, this string will not be read. To read this string, you can lower the character's acceptance level to 40%, without having to lower the acceptance level of the string. By default, the certainty level is 70%. If a string's score is equal to or above this level, the string is immediately read as a valid string result, without processing the rest of the target image for strings with higher scores (provided the specified number of strings to read has been read). To modify the certainty level, call MdmrControlStringModel() with M_STRING_CERTAINTY. Acceptance and certainty are set for string models; each one can have their own levels. You should typically set the acceptance to represent a threshold for a score that is adequate, though you would like to check the rest of the image for strings with better scores. The certainty level represents a threshold for a score that is so amazingly good, you need not even consider the possibility that there is a better string out there. Since lowering the certainty usually results in less image analysis, it can speed up the read operation. Remember to set the certainty carefully, since a low level can cause a premature termination of the read operation, and allow the best candidates to remain unread. The default acceptance and certainty settings are generally fine. However if you are not getting the results you want, try experimenting with them. For example, changing the acceptance might be necessary for images with poorly printed characters. When used in concert, these settings offer a simple, fast, and versatile way of accepting and rejecting strings. Rank Rank refers to the order to read for a string model, relative to the other string models in a context. SureDotOCR reads strings from left to right, and from top to bottom, with respect to the angle of the target. Following this order, the strings read in the illustrations below are \"JOHN\", \"PAUL\", \"GEORGE\", and \"RINGO\". Rank 0 (the default) indicates that the string for that string model should be read first; accounting for angle, it will be the top left-most string. In this example, that first string is \"JOHN\". Rank is only relevant when there are multiple string models in a context. To specify a string model's rank, call MdmrControlStringModel() with M_STRING_RANK. String models with lower ranks are read before those with higher ones. Specifying a rank order can make the read operation faster and more accurate. Ranks are set for string models; each one can have its own value. Strings with different ranks must be on separate lines. If multiple string models have identical ranks, SureDotOCR reads just one string, depending on which is more similar to its string model. For example, if a context has string models with ranks set to [0, 0, 0, 1], only one of the three string models with rank 0 can have a string read for it. When specifying ranks, you must include rank 0, and you must not skip successive values. For example, if you have four string models with their respective ranks set to [1, 2, 3, 4], you will get an error, because you did not include rank 0. You will also get an error if you set their ranks to [0, 1, 2, 4], because you included ranks 2 and 4 but skipped rank 3. Examples of acceptable rank settings are [0, 1, 2, 3], [0, 0, 0, 0], [2, 2, 1, 0], and [2, 1, 0, 1]. Number of strings to read SureDotOCR establishes the required number of strings to read for a context according to the rank of its string models (M_STRING_RANK). That is: TotalNumberOfStringsToRead = HighestRankValue + 1. For example, if you have four string models with ranks set to [0, 0, 1, 2], SureDotOCR must read 3 strings. If 3 strings cannot be read, no results are returned. Since the default rank for every string model is 0, SureDotOCR tries to read 1 string, regardless of how many string models are in a context, unless you modify rank. In all cases, a maximum of 1 string can be read for each string model. Space Space generally refers to the distance between characters. To help deal with spaces in target strings, SureDotOCR allows you to control space settings for string models in a context, by calling MdmrControl() with M_SPACE_SIZE_MIN and M_SPACE_SIZE_MAX. Establishing these settings properly can help differentiate characters in the same word, characters in different words but the same string, and characters in different strings. By default, the minimum width of a space character is equivalent to the maximum character width in the target string. The default maximum width of a space character is equivalent to three times the maximum character width in the string. The following table shows how SureDotOCR interprets the actual space in the target between one character and another. Distance between characters Interpretation of characters on either side of the space MinimumSpaceWidth &lt;= CharacterDistance &lt;= MaximumSpaceWidth SureDotOCR considers the characters to be part of separate words in a string, and can insert a space character between them. The width of this space is a value between MinimumSpaceWidth and MaximumSpaceWidth, depending on the actual distance between the characters in the target. CharacterDistance &lt; MinimumSpaceWidth SureDotOCR considers the characters to be part of the same word, and will not insert a space character. CharacterDistance &gt; MaximumSpaceWidth SureDotOCR considers the characters to be part of separate strings. Space values are set for a context, so they apply to all strings read for all string models in that context. To disable space settings, set M_SPACE_SIZE_MIN_MODE and M_SPACE_SIZE_MAX_MODE to M_DISABLE. If you disable the maximum space width, no amount of space between aligned characters can cause them to be part of separate strings. This does not apply to characters on separate lines or severely misaligned characters. If you disable the minimum space width, no amount of space between characters in the same string can cause SureDotOCR to recognize the characters as part of separate words; that is, SureDotOCR will not recognize an actual space character. If necessary, SureDotOCR allows you to specify a space character as a permitted character constraint. For more information, see the Reading space subsection of this section. String angle By default, the angle of a string is detected automatically (MdmrControl() with M_STRING_ANGLE_MODE set to M_AUTO). However, you can explicitly specify the nominal angle at which to read a string. To do so, you must first set the angle mode (M_STRING_ANGLE_MODE) to M_ANGLE; you can then specify the angle using MdmrControl() with M_STRING_ANGLE. Valid values for the angle are specified in degrees, and can range from 0 to 360. The string angle can be set relative to the X-axis of the pixel coordinate system or relative coordinate system; to specify which one, set M_STRING_ANGLE_INPUT_UNITS to M_PIXEL or M_WORLD, respectively. You can also set the angle to the same angle as the target image's region of interest by setting the angle to M_ACCORDING_TO_REGION. A benefit of setting the string angle explicitly is that inspection speed increases if a string angle is chosen and the fixture angle is known. Alternatively, you can set that the string can be read from left to right with the characters facing upward, or from right to left with the characters facing downward, by setting M_STRING_ANGLE_MODE to M_ORIENTATION. This is useful if the product can be rotated 180 degrees, and this rotation does not affect the acceptability of a product ( for example, if the product is placed backwards at an inspection point but is still a good part). Italic angle SureDotOCR can also read characters at a specified angle (skew). To do so, you must first set the character angle mode, using MdmrControl() with M_ITALIC_ANGLE_MODE, to M_ANGLE; then, set M_ITALIC_ANGLE to the required angle in degrees. Valid values range from -90 to 90 degrees, relative to a line perpendicular to the angle of the string. The Y-axis is the zero reference (instead of the X-axis), and a positive angle searches for the characters leaning counter-clockwise at a specified angle (left-leaning); whereas, a negative angle searches for the characters leaning clockwise at the specified angle (right-leaning). If M_ITALIC_ANGLE is set to 0, SureDotOCR searches for non-italic characters. A benefit of setting an italic angle explicitly is that inspection speed increases if italic angle is chosen and the fixture angle is known. When M_STRING_ANGLE_MODE is set to M_DEFAULT, M_ITALIC_ANGLE_MODE must also be set to M_DEFAULT. Constraining string model positions with permitted characters As previously discussed, any character from any font can, by default, be read at any string model position. For example, if you have two string models (StringGood and StringBetter), each with a maximum and minimum number of characters of two, and you have two fonts (FontNice and FontNicer), each with the characters '2' and '4', the strings '24', '42', '22', or '44' can be read from the target image, where each '2' and '4' can correspond to how they are represented in either font. To restrict the characters that can be read, according to a specified character type and font, call MdmrControlStringModel() with M_ADD_PERMITTED_CHARS_ENTRY. This can be considered defining the string's grammar. For example, you can specify that for StringGood, a target string can only be read if the character at position 0 is a '4' from FontNice, and the character at position 1 is a '2' from FontNice. Similarly, for StringBetter, you can specify that a string can only be read if the character at position 0 is a '4' from FontNicer and the character at position 1 is a '2' from FontNicer. When permitting explicit characters to be read, use M_ADD_PERMITTED_CHARS_ENTRY with M_CHAR_LIST and specify the list of character names, such as \"42\". If you are using Windows API functions with the Unicode macro, and your source code is also Unicode, you can specify the characters directly in Unicode. Be aware that each character in the list must exist in the specified font. You can also specify character names in hexadecimal format beginning with \"\\\\x\", such as \"\\\\x34\\\\x32\" instead of \"42\". Hexadecimal notation is necessary if you are in an ASCII environment and you want to have Unicode characters beyond the Basic Latin range. For example, Basic Latin does not include the smiley face character; to specify it, use \"\\\\x263A\". To list a string of character names with mixed notation, you should also use \"\\\\x\" (for example, \"ADAMS\\\\x34\\\\x32\\\\x263A\"). In addition to permitting one or more specific characters to be read at the different string model positions, you can permit a group of characters to be read. For example, you can permit all digits (M_DIGITS), letters (M_LETTERS), lowercase letters (M_LETTERS_LOWERCASE), and uppercase letters (M_LETTERS_UPPERCASE) that exist in the specified font to be read. You can also permit all characters present in the font to be read (M_ANY). The specified font must contain at least one instance of the characters you are permitting to be read. For example, if you use M_DIGITS, the specified font must have at least one character between '0' and '9'. All permitted characters in the target, whether you identify them explicitly or as a group, must adhere to their corresponding character definition in either a specific font or in any font in the context. To specify one or any font, use M_ADD_PERMITTED_CHARS_ENTRY with M_FONT_INDEX() or M_FONT_LABEL(). For example, you can permit SureDotOCR to read all digits (M_DIGITS) represented by a specific font (M_FONT_INDEX(n)), or all digits (M_DIGITS) represented by any font (M_FONT_INDEX() set to M_ANY). M_ADD_PERMITTED_CHARS_ENTRY is cumulative. Each time you specify permitted characters, they are added to the previously specified permitted characters, if they exist. For example, in one call to MdmrControlStringModel(), you can specify the number '1' (with M_CHAR_LIST) as a permitted character constraint at position 0, and in another call to MdmrControlStringModel(), you can specify M_LETTERS as a permitted character constraint at position 0. These two entries allow the number '1' and any letter in the font to be read at position 0. To inquire the number of permitted character entries, call MdmrInquireStringModel() with M_NUMBER_OF_PERMITTED_CHARS_ENTRIES. If this inquire returns 0, it indicates that you have not added any permitted character entries, which means SureDotOCR reads any character from any font (initial default behavior). You can also delete a character constraint at a specific index by calling MdmrControlStringModel() with M_DELETE_PERMITTED_CHARS_ENTRY. You can select to delete a restriction at a specific index, or delete all restrictions. Reading space SureDotOCR also allows you to read a space character as a permitted character constraint, using M_ADD_PERMITTED_CHARS_ENTRY with M_SPACE. Unlike other permitted characters, M_SPACE has the following restrictions (not following them can cause an error). You cannot represent a space character in a font. As discussed, you establish a space character with the M_SPACE_SIZE_... context controls. A space constraint is exclusive at a given string model position. For example, if you specify M_SPACE for a position, you cannot add another character constraint, such as M_DIGITS, at that same position. You cannot have a space constraint at consecutive positions in a string model. The first or last position of a string model cannot have a space constraint. Reading an M_SPACE character does not necessarily mean that the corresponding space position in the target string is blank. SureDotOCR attempts to read the best string possible, and can use the space constraint as an area to ignore, even if that area is not empty. For example, if you have an icon at a specific position within a target string, you can specify a space character at that position. Below is a list of examples illustrating how SureDotOCR manages and reads permitted space characters. For simplicity, 'S' refers to space and 'L' refers to letter. Any permitted character other than space could have been used instead of a letter. Target string Permitted character constraints Will it read? AB CD LLSLL Yes AB CD EF LLSLLSLL Yes ABCD LLSLL No ABCDEF LLSLLSLL No AB CD LLLL Yes AB CD EF LLLLLL Yes AB CD EF LLSLLLL Yes M M LSL Yes MWM LSL Yes In the target string MWM, the letter 'W' can represent numerous types of data, such as another character, an icon, or noise. If an M_SPACE character was read, its resulting character score will be 100% and it will not influence the score of the string. For more information, see the Results and annotations section later in this chapter. Default permitted characters, and overriding them If necessary, you can specify permitted characters to read for every string model position. This can prove tedious, as in cases where you want to permit the same characters for the majority of positions in the string model. To handle such cases, and others like it, you can set default constraints for all the positions in the string model by passing M_DEFAULT to the Position parameter, and override the constraints for specific positions by passing M_POSITION_IN_STRING(n) instead, where n is the position for which to specify an explicit (overriding) constraint. As an example, consider reading the following product lot number: Here, the dot-matrix string contains 11 characters. With the exception of one character, which is a hyphen, each character can be a digit between 0 and 9. To handle this, you can specify M_DIGITS as the default constraint for all positions in the string model. You can then explicitly specify that at position 5, you want to read a hyphen. This requires calling MdmrControlStringModel() twice, which is a lot more convenient than calling it eleven times. If you override the default constraints for a specific position, the position is said to be explicitly constrained; otherwise, it is said to be implicitly constrained. In the lot number example above, there is one explicitly constrained position (at position 5). General controls for the different positions in the string model SureDotOCR provides general controls for the different positions in the string model. Specifically, you can: Clone the explicit constraints from one position to the next, using M_CLONE_CONSTRAINTS_FROM. Reset the default constraints for the positions in the string model back to their initial value, using M_RESET_IMPLICIT_CONSTRAINTS. Reset the explicitly constrained position to be implicitly constrained, using M_RESET_POSITION_TO_IMPLICIT_CONSTRAINTS. Once you have explicitly constrained a position, it is considered to be explicitly constrained until you use this operational control, even if you manually set the position's constraints back to the defaults of the string model. Managing the different string model positions (implicit or explicitly constrained) The way in which to manage the different string model positions depends on the Position parameter. Specifying M_DEFAULT indicates that you are working with the default constraints for all the positions in the string model (positions that are implicitly constrained). Specifying M_POSITION_IN_STRING(n) indicates that you are overriding the default constraints for the n string model position (that position will then be considered explicitly constrained). You can also specify M_POSITION_IN_STRING(n) to modify a position (n) that has already been explicitly constrained. Alternatively, you can modify such a position with M_POSITION_CONSTRAINED_ORDER(n), where n indicates the order in which the position was explicitly constrained. For example, if you explicitly constrained positions 19, 5, and 24, their respective constrained order values are 0, 1, and 2. To control all positions that have been explicitly constrained, use M_ALL_CONSTRAINED_POSITIONS. This can be useful to, for example, add a permitted character constraint to all existing explicitly constrained positions or to reset all explicitly constrained positions to be implicitly constrained (M_RESET_POSITION_TO_IMPLICIT_CONSTRAINTS). Except for M_ALL_CONSTRAINED_POSITIONS, all Position parameter settings are available for both controlling and inquiring about string models. If you want to loop through all explicitly constrained positions, call MdmrInquireStringModel() with the Position parameter set to M_POSITION_CONSTRAINED_ORDER(n), where n is the order in which the position was explicitly constrained. Note that the constrained order of a position changes if you reset previously constrained positions to be implicitly constrained (M_RESET_POSITION_TO_IMPLICIT_CONSTRAINTS). To inquire the number of explicitly constrained positions, use M_NUMBER_OF_CONSTRAINED_POSITIONS. Recommended conditions for optimal string reading Sometimes strings you want to read are less than optimal: they could be only part of a string, close to other strings, or dissimilar in dot spacing. To avoid false readings, there are some methods you can use to ensure you are reading the intended strings. Reading a partial string If you are only interested in part of a string, the defined text block should be large enough to read all dot-matrix text in the image (or associated region of interest), including the parts you don't want. After reading the entire string, use string related functions to separate the parts of the string you want to read (for example, using a strncpy or std::substr function in C). This avoids problematic results when the module centers the text block in an unexpected place in your target image. Reading only one line of a string with multiple lines If you are only interested in one line of a string that has multiple lines, you should still read all of the lines in one search region, even the ones you don't want, and then extract the required string line. This helps avoid problematic results. Reading strings with dissimilar qualities Multiple strings in an image can sometimes have characters with dissimilar qualities, such as variations in skew angle or spacing between dots. This can occur when, for example, the strings were printed with different ink jets. To prevent inaccurate reading of such strings, use one SureDotOCR context per string model you are looking for, each called to read a different child buffer. If the string can move locations, you can create two child buffers (or more) the size of the entire image, and use a different ROI with each. The following example, illustrates the latter. Two child buffers are set to the size of the whole image; an ROI is set for each such that each encompasses a different part of the string. A different context (with different string constraint) is then used to read each set of strings separately. String models Required settings Dot diameter Text block dimensions Maximum and minimum number of characters Optional settings Foreground Intensity and contrast Acceptance and certainty Rank Number of strings to read Space String angle Italic angle Constraining string model positions with permitted characters Reading space Default permitted characters, and overriding them General controls for the different positions in the string model Managing the different string model positions (implicit or explicitly constrained) Recommended conditions for optimal string reading Reading a partial string Reading only one line of a string with multiple lines Reading strings with dissimilar qualities ",
      "wordCount": 4871,
      "subEntries": []
    },
    {
      "id": "UG_SureDotOCR_Character_names_in_ASCII_and_Unicode_environments",
      "version": null,
      "title": "Character names in ASCII and Unicode environments",
      "subTitles": null,
      "location": "MIL UG P03: 2D processing and analysis",
      "pageURL": "content\\UserGuide\\SureDotOCR\\Character_names_in_ASCII_and_Unicode_environments.htm",
      "text": " Character names in ASCII and Unicode environments SureDotOCR supports ASCII and Unicode environments. You can specify character names using their native representation or in hexadecimal format beginning with \"\\x\". For example, you can specify the character name of the letter A as \"A\" (its native name) or you can specify it as \"\\x0041\". Characters between 0 and 127 are considered Basic Latin. They are common in both ASCII and Unicode. If you are in an ASCII environment and you are getting results about a Basic Latin character, SureDotOCR does not consider the Unicode name, by default. For example, if SureDotOCR reads the character \"A\" which is a Basic Latin character, and you use M_CHAR_NAME to get the name of that character, SureDotOCR returns \"A\", even if you explicitly named it \"\\x0041\" in the font. To return information about the character's UTF-16 (Unicode) name (that is, \"\\x0041\"), use the combination value M_HEX_UTF16_FOR_ALL. If you are in an ASCII environment and you are getting results about Unicode character names beyond the Basic Latin range (0 to 127), you can only retrieve information about the character name in hexadecimal format. For example, Basic Latin does not include the smiley face character; it must be named hexadecimal format (\"\\x263A\"). When retrieving results about such characters in an ASCII environment, their name in hexadecimal is returned (M_HEX_UTF16_FOR_NON_BASIC_LATIN by default). In a Unicode environment, the character representations are returned (for example, ?). You can, however, explicitly specify that the character name in hexadecimal format is returned instead using M_HEX_UTF16_FOR_NON_BASIC_LATIN or M_HEX_UTF16_FOR_ALL (for example, to obtain \"\\x263A\" instead of the actual smile face). This is not typically done since characters beyond the Basic Latin range can exit natively in a Unicode string. Note that the character name representations affect the string size. For example, the string \"abc?\" nominally consists of four characters plus the null terminating character. However in an ASCII environment, getting a string size result (retrieved with, for example, M_STRING + M_STRING_SIZE) will return 10 as the string size, because the string is read as \"abc\\x263A\". For the same string mentioned above (\"abc?\"), when M_HEX_UTF16_FOR_ALL is specified, you will obtain \"\\x0061\\x0062\\x0063\\x263A\" and a string size of 25. Character names in ASCII and Unicode environments ",
      "wordCount": 371,
      "subEntries": []
    },
    {
      "id": "UG_SureDotOCR_Retrieving_results_and_annotation",
      "version": null,
      "title": "Results and annotations",
      "subTitles": [
        "Results",
        "Strings and formatted strings",
        "Reading substrings and skipped positions",
        "Typical results to retrieve",
        "Size of string results",
        "Positional and dimensional results",
        "Recommendations to improve results",
        "Annotations",
        "Timeout or stop"
      ],
      "location": "MIL UG P03: 2D processing and analysis",
      "pageURL": "content\\UserGuide\\SureDotOCR\\Retrieving_results_and_annotation.htm",
      "text": " Results and annotations MIL stores the results of a read operation (MdmrRead()) in a SureDotOCR result buffer. Most applications typically retrieve and draw various features of these results, using MdmrGetResult() and MdmrDraw(). For example, you can retrieve and draw the resulting string that was read. Some results depend on if you are in an ASCII or Unicode environment; see the Character names in ASCII and Unicode environments section earlier in this chapter for details. Results With MdmrGetResult(), you can retrieve global results, string results, or character results. Global results refer to information about the SureDotOCR result buffer itself, while string and character results refer to information about the strings and characters in the result buffer. You can remove all results from a result buffer by calling MdmrControl() with M_RESET. This does not delete the buffer identifier, as is the case with MdmrFree(). M_RESET can be a convenient and optimal way of saving memory resources. In some cases, unrecognized characters can cause either an unexpected string or no string to be returned; to determine which characters are not recognized, you can set MdmrControl() with M_STRING_PARTIAL_MODE to M_ENABLE. M_STRING_PARTIAL_CHAR_INVALID can be used to set the single character string that replaces invalid characters; the default is \"?\". Strings and formatted strings To retrieve the string that was read, use M_STRING or M_FORMATTED_STRING. With M_STRING, you will retrieve the string that was read, according to the string model definition. This result includes the name (symbol) of all the characters in the string and the terminating null character. It also include spaces, if they correspond to a space permitted character constraint in the string model (MdmrControlStringModel() with M_SPACE). With M_FORMATTED_STRING, you will retrieve the string that was read, according to the target string format. This result includes the name (symbol) of all the characters in the string and the terminating null character. It also includes spaces, if the target string has any that are greater than the minimum spacing (MdmrControl() with M_SPACE_SIZE_MIN) and less than the maximum spacing (M_SPACE_SIZE_MAX). The following table shows the difference between M_STRING and M_FORMATTED_STRING, given the target string read for the string model. For simplicity, 'S' refers to space and 'L' refers to letter. Any permitted character other than space could have been used instead of a letter. Target string String model M_STRING M_FORMATTED_STRING ABCD LLLL \"ABCD\" \"ABCD\" AB CD LLLL \"ABCD\" \"AB CD\" AB CD LLSLL \"AB CD\" \"AB CD\" AB CD EF LLLLLL \"ABCDEF\" \"AB CD EF\" AB CD EF LLSLLLL \"AB CDEF\" \"AB CD EF\" AB CD EF LLSLLSLL \"AB CD EF\" \"AB CD EF\" ABWCD LLSLL \"AB CD\" \"AB CD\" SureDotOCR attempts to read the best string possible, and can use the space constraint as an area to ignore, even if that area is not empty. This is the case for the target string ABWCD. For more information, see the Reading space subsection of the String models section earlier in this chapter. When retrieving the results of characters in strings, you must use M_INDEX_IN_STRING(n) or M_INDEX_IN_FORMATTED_STRING(n), to specify the character (one or all). The difference between these two settings is similar to the difference between M_STRING and M_FORMATTED_STRING. For M_INDEX_IN_STRING(n), spaces read in the target string are indexed as character results if they correspond to a space permitted character constraint in the string model. For M_INDEX_IN_FORMATTED_STRING(n), spaces read in the target are always indexed as character results. For example, if the string model definition specifies to read 4 capital letters (\"LLLL\"), and the target string read is \"AB CD\", M_INDEX_IN_FORMATTED_STRING(3) refers to 'C', while M_INDEX_IN_STRING(3) refers to 'D'. If the string model definition specifies to read 4 capital letters and 1 space (\"LLSLL\"), and the target string read is \"AB CD\", M_INDEX_IN_FORMATTED_STRING(3) and M_INDEX_IN_STRING(3) both refer to 'C'. When retrieving results with M_STRING_PARTIAL_MODE enabled, you can retrieve the position of the unrecognized characters with M_STRING_CHAR_INVALID_INDICES and M_FORMATTED_STRING_CHAR_INVALID_INDICES, for M_STRING and M_FORMATTED_STRING respectively. Reading substrings and skipped positions If M_STRING_SIZE_MIN is less than M_STRING_SIZE_MAX and the image does not contain a complete string, MIL SureDotOCR will return a substring. The substring must be at least as long as M_STRING_SIZE_MIN and match the string constraints without a break in the middle. If a substring is read, you can use MdmrGetResult() with M_SKIPPED_POSITIONS to see which positions in the string constraint model were skipped. For example, if there was the following constraints: String size min: 2. String size max: 6. Position 0 1 2 3 4 5 Constraint DIGIT LETTER DIGIT LETTER LETTER LETTER. The table below shows the input, success, and skipped positions, using the string constraints listed above. String in image String read successful Skipped Positions 2A1 Yes 3,4,5 ABC Yes 0,1,2 A1B Yes 0,4,5 11ABC No N/A 1A2CDE Yes N/A If a substring cannot be read, you can only retrieve the position of unrecognized characters if M_STRING_PARTIAL_MODE was enabled prior to the read operation. In this case, you can retrieve the position of the unrecognized characters with M_STRING_CHAR_INVALID_INDICES and M_FORMATTED_STRING_CHAR_INVALID_INDICES, for M_STRING and M_FORMATTED_STRING respectively. Typical results to retrieve In addition to retrieving the actual strings and characters read, you will also typically want to retrieve: The total number of strings read (M_STRING_NUMBER). The number of characters read for a string (M_STRING_CHAR_NUMBER). The name of individual characters in the strings read (M_CHAR_NAME). If a space was read, the name returned is an actual space (and the terminating null character). The score of the strings read (M_STRING_SCORE). The string score quantifies, as a percentage, how closely the target string resembles its corresponding string model in the SureDotOCR context. The string score is the average score of the individual characters in the string, which you can also retrieve (M_CHAR_SCORE). If an M_SPACE permitted character was read (MdmrControlStringModel()), its resulting character score will be 100%. SureDotOCR does not use such scores when calculating the string score. Information about the bounding box of the strings read, such as height (M_STRING_HEIGHT), width (M_STRING_WIDTH), angle (M_STRING_ANGLE), center (M_STRING_POSITION...), and corners (M_STRING_BOX_...). You can also retrieve similar results for each character in the string read (M_CHAR_...). For example, you can retrieve the width of character's bounding box (M_CHAR_WIDTH). Information regarding the state of the read operation (M_STATUS). Size of string results SureDotOCR returns the M_STRING, M_FORMATTED_STRING, and M_CHAR_NAME results as a string. To determine the size of the string returned, add M_STRING_SIZE to the requested result. That is, M_STRING + M_STRING_SIZE, M_FORMATTED_STRING + M_STRING_SIZE, and M_CHAR_NAME + M_STRING_SIZE. You need this size information to establish the size of the array in which to write the results. You must specify the address of this array with the ResultArrayPtr parameter. When retrieving multiple string results, M_STRING_SIZE returns the size of each string. To establish the total required array size, you must know the number of strings you're getting, and you must perform a summation. For example, if you read \"SYLVAIN\", \"STEVE\", and \"DOMINIQUE\", the content for all three strings is \"SYLVAIN\\0STEVE\\0DOMINIQUE\\0\", and the string size returned (M_STRING + M_STRING_SIZE) is [8, 6, 10]. You must sum these values to get the total required array size, which is 24. M_FORMATTED_STRING requires the same summation. Differences in the resulting string size can come from how each result type manages spaces, as previously discussed. For M_CHAR_NAME, the name of each letter at each position in the string is itself a string, with its own terminating null character. To perform the proper summations, you must get the number of strings, and the number of characters per string. For example, if the string \"SYLVAIN\" was read, and you retrieve the M_CHAR_NAME result type for all positions in that string, SureDotOCR returns \"S\\0Y\\0L\\0V\\0A\\0I\\0N\\0\", which has a string size (M_CHAR_NAME + M_STRING_SIZE) of [2,2,2,2,2,2,2]. You must sum these values to get the required array size, which is 14. To get the required array size for all strings read, you must perform this summation for each string, and then you must sum all those values. The following is an example of how to retrieve the character name result, with the proper array size, for all characters in all strings. //Number of strings. MdmrGetResult(MilDmrResult, M_GENERAL, M_DEFAULT, M_STRING_NUMBER + M_TYPE_MIL_INT, &amp;NumberOfStringRead); //Number of characters for each string. MIL_INT* NbChar = new MIL_INT[NumberOfStringRead]; MdmrGetResult(MilDmrResult, M_ALL, M_GENERAL, M_FORMATTED_STRING_CHAR_NUMBER + M_TYPE_MIL_INT, NbChar); //Total number of characters (summation). MIL_INT TotalNbChar = 0; for(MIL_INT k = 0; k &lt; NumberOfStringRead; k++) { TotalNbChar += NbChar[k]; } //Size of each character name. MIL_INT* CharNameSize = new MIL_INT[TotalNbChar]; MdmrGetResult(MilDmrResult, M_ALL, M_INDEX_IN_FORMATTED_STRING(M_ALL), M_CHAR_NAME + M_STRING_SIZE + M_TYPE_MIL_INT, CharNameSize); //Size of all character names (summation). MIL_INT SizoForAllName = 0; for(MIL_INT k = 0; k &lt; TotalNbChar; k++) SizoForAllName += CharNameSize[k]; //Total required array size for all character names for all strings. MIL_TEXT_CHAR* AllName = new MIL_TEXT_CHAR[SizoForAllName]; MdmrGetResult(MilDmrResult, M_ALL, M_INDEX_IN_FORMATTED_STRING(M_ALL), M_CHAR_NAME, AllName); Positional and dimensional results If your target image (MdmrRead()) was associated with a camera calibration context, positional and dimensional results are, by default, returned with respect to the relative coordinate system of the image. Otherwise, these results are returned in pixels, relative to the center of top-left pixel in the target image. To specify this, call MdmrControl() with M_RESULT_OUTPUT_UNITS. For more information, see the Working with real-world units section of Chapter 28: Calibrating your camera setup. Positional and dimensional results take into account the angle at which the result was found. This example shows how the result for the bottom-left corner of the string box (M_STRING_BOX_BL_X and M_STRING_BOX_BL_Y) depends on the location and angle at which the string was read. Recommendations to improve results After performing the read operation, you might not always get the most optimal results. Typical issues include: Unread strings. Incorrectly read strings (misidentified characters). Low string or character scores. The following are recommendations to improve reading and get the best results possible. Don't have characters touching or cut off at image borders. Ensure a contrast level of at least 15 gray levels. Ensure the rank of each string model is properly set. For example, strings with different ranks must be on separate lines. For more information, see the Rank subsection of the String models section earlier in this chapter. Ensure the string length is at least 4 characters to prevent the string from being read upside down. Ensure that the diameter of the dots is between 4-7 pixels wide. If they are too small, there can be trouble reading the dots; if they are too large, it will take more processing time. Ensure the variation between the smallest and largest dot spacing within a string is less than half of the average dot space. Ensure the distance between two consecutive dots along a character axis is larger than the dot size. Ensure the distance between consecutive characters is 2x the dot spacing of dots found in individual characters. Ensure the minimum vertical spacing between stacked strings is the dot height. Fonts should only contain the characters to read; delete all others. For more information, see the Delete, control, and inquire about fonts and characters subsection of the Fonts section earlier in this chapter. Set constraints at each character position to ensure the correct character is read at the correct position, with the specified font. Set up the context to read all the strings in the target image, even if you are not interested in all strings. Once strings are read, get the results of the ones you want. Set up the string model to read the entire string, even if you are not interested in all of it. Once the string is read, parse out the characters that you don't want. Set up the string box so that it is only large enough to read all the characters to be read and exclude all other features of the image. Set minimum and maximum dot intensities to improve performance. The dot-matrix of each character in the fonts should be the same as the dot-matrix of each character in the strings to read. For more information, see the Dot-matrices in fonts and strings to read should be the same subsection of the Fonts section earlier in this chapter. Annotations With MdmrDraw(), you can draw specific features of a SureDotOCR result buffer in the destination image buffer or 2D graphics list. In general, the drawings that you will want to perform include: Drawing a bounding box around the string that was read (M_DRAW_STRING_BOX). Drawing a bounding box around the characters that were read (M_DRAW_STRING_CHAR_BOX). Drawing a circled dot at the center of the bounding box of each string's character (M_DRAW_STRING_CHAR_POSITION). Drawing the names of the characters that were read (M_DRAW_MIL_FONT_STRING). When applicable, the required information is drawn at the location that the string was read in the target, at the correct angle, scale, and aspect ratio. You can specify that the characters in the string appear according to how the target string is formatted (for example, with non-constrained spaces), by specifying M_DRAW_MIL_FONT_FORMATTED_STRING instead of M_DRAW_MIL_FONT_STRING. Timeout or stop The read operation can occasionally take an unexpectedly long time to calculate. To manage this, you can call MdmrControl() to specify a timeout value or to stop the read. Timeout refers to the maximum time that MdmrRead() has to read all strings for a context. By default, the maximum time is 2000.0 msec. To change this, use M_TIMEOUT. You can also explicitly halt the read operation, using M_STOP_READ. This call must be done from another thread of higher priority. No results are returned if the read operation times out or is stopped. Results and annotations Results Strings and formatted strings Reading substrings and skipped positions Typical results to retrieve Size of string results Positional and dimensional results Recommendations to improve results Annotations Timeout or stop ",
      "wordCount": 2263,
      "subEntries": []
    },
    {
      "id": "UG_SureDotOCR_SureDotOCR_example",
      "version": null,
      "title": "SureDotOCR example",
      "subTitles": null,
      "location": "MIL UG P03: 2D processing and analysis",
      "pageURL": "content\\UserGuide\\SureDotOCR\\SureDotOCR_example.htm",
      "text": " SureDotOCR example The SureDotOCR example Mdmr.cpp illustrates how to read dot-matrix text. Specifically, the example reads a product's expiry date and lot number. mdmr.cpp To run this example, use the Matrox Example Launcher in the MIL Control Center. SureDotOCR example ",
      "wordCount": 42,
      "subEntries": []
    }
  ]
}]
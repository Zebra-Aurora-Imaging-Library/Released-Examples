[{
  "id": "UG_metrology",
  "version": "2024020714",
  "title": "Metrology",
  "subTitles": null,
  "location": "MIL UG P03: 2D processing and analysis",
  "pageURL": "content\\UserGuide\\metrology\\ChapterInformation.htm",
  "text": " Chapter 21: Metrology This chapter explains how to use the MIL Metrology module to measure features and validate geometric tolerances in a target image. MIL Metrology module Steps to measure and validate expected features Basic concepts for the MIL Metrology module Features Reference frame Global frame Local frame Set position (Physically) measured features Metrology regions Best fit, inner fit, and outer fit operations (Physically measured) edgel features Constructed features Using metrology regions with constructed features Basic construction (using points) Cloning and copying Fit Operations for building point features Operations for building line features Parametrically constructed features Multiple features Geometric tolerances Adding a geometric tolerance Angularity Area and perimeter Concentricity Distance Length Parallelism Perpendicularity Position Radius Roundness Straightness Using multiple geometric tolerances Eliminating unwanted edgels Customizing the edge extraction algorithm Edgel and fit constraints Active edgels and fitted edgels Gradient angle Edgel selection rank Common fit constraints Standard fit constraints Robust fit constraints Copy feature edgels Denoising edgels Calculating and retrieving results Retrieving the results Status of features and geometric tolerances Output frame Annotating the results Template reference Using external edgels and points with constructed features Adding edge chains (chained edgels) Adding chained pixels (points) Metrology example ",
  "wordCount": 198,
  "subEntries": [
    {
      "id": "UG_metrology_MIL_metrology_module",
      "version": null,
      "title": "MIL Metrology module",
      "subTitles": null,
      "location": "MIL UG P03: 2D processing and analysis",
      "pageURL": "content\\UserGuide\\metrology\\MIL_metrology_module.htm",
      "text": " MIL Metrology module Many industries require the ability to measure and validate objects to, for example, assemble multiple parts. Historically, in such industries, manual quality control applications were created to verify the shape, size, and location of objects relative to one another. To accomplish this, a template was used. A template is a physical part, or mold, that typically contains holes and incisions at various positions. If the object being verified physically fit into the template, then that object had passed the quality inspection and could be used in assembly; otherwise, it had failed and would be discarded or reworked. The MIL Metrology module is a powerful set of functions that allows you to design such measurement and validation applications, using a virtual equivalent of a physical template. The MIL metrology template represents a precisely measured and reusable model from which objects can be verified and measured. To build a metrology template, you must have features (which are like the holes and incisions) and geometric tolerances (which are like the positions that features must have, relative to other features). You can add either physically measured or constructed features to your metrology template. Physically measured features are geometric primitives (such as a circle) that are physically measured using the edge information (edgels) in the target image. Physically measured features, and the metrology region (ROI) from which their edgels are established in the target image, must be placed at the appropriate location in the template. Note that Metrology's edgel extraction is based on Edge Finder technology; for more information, see the Extracting the edges section of Chapter 10: Edge Finder. Constructed features are geometric primitives that do not actually exist in the target image, they are mathematically defined (parametrically constructed features) or geometrically derived from a set of other features (either constructed or physically measured). For example, a constructed point feature can be derived at the center of a physically measured circle. Features alone do not typically provide enough information to establish the metrology template. For example, if you add two segment features, you might also want to verify their total length, or if they are perpendicular. To do this, you can specify the geometric tolerances that the features of the object in the target image must respect to be considered valid. The following example illustrates how you can use features and geometric tolerances in a metrology template to represent an appropriate object in a target image. To depict this object, the template has two ring-shaped metrology regions where two circles are expected to be physically measured, and one rectangular metrology region where one segment is expected to be physically measured. The template also contains the definition of a constructed segment, built from the center points of the two physically measured circles, and a perpendicularity tolerance between this constructed segment and the physically measured segment. The following example also shows the target image, which has been annotated to display the successfully measured features and the validated tolerance. The MIL Metrology module allows you to specify the coordinates of features and metrology regions relative to a reference frame, which can be set to either the global frame or a local frame. The global frame is a coordinate system whose origin is at the top-left corner of the metrology template (by default, aligned with the center of the top-left corner pixel of the target image); the global frame is created automatically. A local frame is a coordinate system that can be located anywhere within the metrology template; you can create a local frame at a specified position or based on the positions of other features in the template. During calculation, the reference frame can be repositioned. The MIL Metrology module provides complete support for camera calibration. If the target image is calibrated, calculations are performed in the calibrated real-world such that, without physically correcting your images, measurements and calculations are made even in the presence of distortion, and results calculated in real-world units. Note that, when complex distortions exist, some results are meaningless when converted from real-world to pixel units (for example, angle). You should therefore be cautious when using distorted images. If a camera calibration context has been associated with the target image, you must specify dimensions for features, geometric tolerances, metrology regions, and positions in real-world units. The MIL Metrology module also allows you to restore a metrology context from a file or memory stream, or save a metrology context to a file or memory stream. MIL Metrology module ",
      "wordCount": 749,
      "subEntries": []
    },
    {
      "id": "UG_metrology_Steps_to_measure_and_validate_expected_features",
      "version": null,
      "title": "Steps to measure and validate expected features",
      "subTitles": null,
      "location": "MIL UG P03: 2D processing and analysis",
      "pageURL": "content\\UserGuide\\metrology\\Steps_to_measure_and_validate_expected_features.htm",
      "text": " Steps to measure and validate expected features The following steps provide a basic methodology for using the MIL Metrology module: Allocate a metrology context to store the features and tolerances of your metrology template and to store global processing settings, using MmetAlloc(). When you allocate a metrology context, the global reference frame is automatically created. Allocate a metrology result buffer to hold the results of your calculations, using MmetAllocResult(). Define the features of your metrology template. For each feature: Add the feature to the template, using MmetAddFeature(). Typically, you should add physically measured features before constructed features. For a physically measured feature, you must set the feature's metrology region in the template, using MmetSetRegion(). The features with which to build constructed features can also have a delimited metrology region. If necessary, adjust feature settings using successive calls to MmetControl(). Define the geometric tolerances of your metrology template. For each tolerance: Add the tolerance to the template, using MmetAddTolerance(). If necessary, adjust tolerance settings using successive calls to MmetControl(). If necessary, specify your required global processing settings, using successive calls to MmetControl(). If necessary, reposition features (typically, a reference frame) in the template, depending on the location of the object in the target image, using MmetSetPosition(). Calculate features and validate geometric tolerances for the object in the target image, using MmetCalculate(). Retrieve the required results from the result buffer, using MmetGetResult(). If necessary, draw specific metrology result features and geometric tolerances in an image buffer, using MmetDraw(). If necessary, save your metrology context, using MmetSave() or MmetStream(). Free your metrology context and result buffer, using MmetFree(), unless M_UNIQUE_ID was specified during allocation. Steps to measure and validate expected features ",
      "wordCount": 280,
      "subEntries": []
    },
    {
      "id": "UG_metrology_Basic_concepts",
      "version": null,
      "title": "Basic concepts for the MIL Metrology module",
      "subTitles": null,
      "location": "MIL UG P03: 2D processing and analysis",
      "pageURL": "content\\UserGuide\\metrology\\Basic_concepts.htm",
      "text": " Basic concepts for the MIL Metrology module The basic concepts and vocabulary conventions for the MIL Metrology module are: Active edgels. The edgels within the metrology region that adhere to certain constraints. Constructed feature. A geometric primitive that has been mathematically defined or geometrically derived from a set of other features. Edge. A curve that delineates a boundary, which can be established from intensity transitions in an image. Edgel. Elementary points (or edge elements) within an edge. Each edgel represents an X- and Y-position, and the angular direction of the gradient. Fitted edgels. The active edgels that are used to build a fitted feature. Geometric tolerance. The acceptable deviation from the definition of a feature, or the acceptable relationship between multiple features. Global frame. The metrology template's default reference frame. Gradient angle. The angle between the target image's horizontal axis and the edge's perpendicular direction (from black to white) at each edgel location. Iterative fit. The calculated fit resulting from one of the iterations during the iteration process. Local frame. A constructed reference frame. (Physically) measured feature. A geometric primitive that can be physically measured using the edgels in the metrology region. Metrology context. A MIL object that stores all features and geometric tolerances of the metrology template, and global processing settings. Metrology region. The delimited area in the target image from which to select the edgels used to establish a physically measured feature. The features with which to build constructed features can also have a delimited metrology region. Metrology region orientation. The alignment of a metrology region, with respect to a reference frame. Metrology template. The set of all features and geometric tolerances. Output frame. The coordinate system in which feature results are returned. Parametrically constructed feature. A geometric primitive that has been mathematically defined, rather than geometrically derived from a set of other features. Reference frame. The coordinate system in which features are defined and to which they are relative. Target image. The image in which to extract physically measured features, build constructed features, and verify geometric tolerances. Template reference. An image (or result buffer) that represents an example of a target image, used to help build or modify a metrology template. Basic concepts for the MIL Metrology module ",
      "wordCount": 373,
      "subEntries": []
    },
    {
      "id": "UG_metrology_Features",
      "version": null,
      "title": "Features",
      "subTitles": [
        "Reference frame",
        "Global frame",
        "Local frame",
        "Set position",
        "(Physically) measured features",
        "Metrology regions",
        "Best fit, inner fit, and outer fit operations",
        "(Physically measured) edgel features",
        "Constructed features",
        "Using metrology regions with constructed features",
        "Basic construction (using points)",
        "Cloning and copying",
        "Fit",
        "Operations for building point features",
        "Operations for building line features",
        "Parametrically constructed features",
        "Multiple features"
      ],
      "location": "MIL UG P03: 2D processing and analysis",
      "pageURL": "content\\UserGuide\\metrology\\Features.htm",
      "text": " Features Once you have allocated your metrology context using MmetAlloc(), you must then add features to the metrology template, using MmetAddFeature(). You can add both physically measured and constructed features. The following table lists all available features, their definition, and whether they can be physically measured or constructed. Feature Definition Physically measured Constructed Arc A continuous portion of a circle. Yes Yes Circle A closed curve of points where each point is located at the same distance from one center point. Yes Yes Edgel Elementary points (or edge elements) within an edge. Each edgel represents an X- and Y-position, and the angular direction of the gradient. Yes Yes Line A one-dimensional geometric primitive that is straight and infinitely long. — Yes Local frame A constructed reference frame. — Yes Point A geometric primitive that represents an X- and Y-position. Yes Yes Segment Part of a geometric line that is defined by a start point and end point. Yes Yes If you associate a camera calibration context to the target image, you must use real-world units to define or position features in the template. If there is no camera calibration context, use pixel units. For more information, see the Camera calibration - overview section of Chapter 28: Calibrating your camera setup. Reference frame In a metrology template all positional information for physically measured features (including their metrology region) and constructed features is relative to a coordinate system. The coordinate system that you use as your reference is called the reference frame. Every feature and metrology region has a reference frame with which it is associated. The reference frame can either be the global frame (created by default) or a local frame (user-defined feature). You can reposition, rotate, or change reference frames, which can be useful when dealing with multiple parts in the same image. To reposition or rotate a reference frame, use MmetControl() with M_POSITION_X, M_POSITION_Y, and M_ANGLE. To change a feature's reference frame, use MmetControl() with M_FEATURE_INDEX() or M_FEATURE_LABEL() to specify the feature and M_REFERENCE_FRAME to set the label or index of its new reference frame. If you change a reference frame, move a reference frame, or alter its angle, all features and metrology regions associated with that reference frame are modified accordingly. Global frame By default, a feature's reference frame is set to the global frame. When you allocate a metrology context, MIL automatically creates the global frame, assigns it an index of 0, and labels it M_GLOBAL_FRAME. The global frame is the first coordinate system used to define the features to add to the metrology template of a metrology context. The global frame always exists and you cannot delete it. If the target image is not calibrated, the global frame's default origin (0,0) is aligned with the center of the top-left corner pixel of the target image. If the target image is calibrated, the global frame's default origin is aligned with the origin of the relative (world) coordinate system. To move the global frame, use MmetSetPosition(). In the following example, the position (center) of a ring-shaped metrology region is set according to the global frame. Local frame In addition to the default reference frame (global frame), you can add your own reference frame feature anywhere within the global frame. Each reference frame that you add is called a local frame. To add a local frame, use MmetAddFeature() with M_LOCAL_FRAME. You can add a local frame by cloning it from another local frame (M_CLONE_FEATURE), constructing it from two points or one point and an angle (M_CONSTRUCTION), or by providing specific position and angle values (M_PARAMETRIC). The following example illustrates the use of three reference frames: the global frame, a local frame constructed with position and angle values, and a local frame constructed with two points. The first illustration shows how the local frames are created. The second illustration shows how features can be added (a circle and a segment) according to each local frame. This is useful since the two parts of the phone swivel, though they are independently stable. Set position When you are setting the position of a reference frame within the metrology template, you are typically assuming that the corresponding position in the target image is at the same location. However, in real-world applications, the location of this position within the target image does not always correspond to the position in the template. To help solve this problem, you can change the position of your reference frame just before performing metrology calculations. To change the position of your reference frame, use MmetSetPosition() with explicit positional values (M_POSITION), translation and rotation values (M_GEOMETRIC), transformation coefficients (M_FORWARD_COEFFICIENTS), or the results of another MIL module (M_RESULT). For example, you can use the MIL Model Finder module to find the object, and then use that occurrence's found position to place the reference frame with which to perform metrology calculations. For more information on an occurrence's found position, see the Reference axis subsection of the Customizing search settings section of Chapter 8: Geometric Model Finder. Positions set with MmetSetPosition() are not saved with the metrology context. Note that you are not limited to repositioning the reference frame; you can move the expected location of any physically measured or parametrically constructed feature. To do so, use MmetSetPosition() and specify the label or index of the feature. Moving a feature other than the reference frame is typically useful only for very advanced applications. (Physically) measured features A physically measured feature is a geometric primitive (segment, arc, circle, point, and edgel) that can be physically measured, using contour edgels, within a specified metrology region in the target image. To add a physically measured feature to the template, use MmetAddFeature() with M_MEASURED. For more information about contour edgels, see the Extracting the edges section of Chapter 10: Edge Finder. All physically measured features are composed of edgels (edge elements). A physically measured segment, arc, circle, and point feature contains edgels that form its definitive geometric shape; conversely, an edgel feature is a group of edgels without a definitive geometry. For more information, see the (Physically measured) edgel features subsection of this section. Metrology regions A metrology region is an area in the target image that contains the edgels MIL uses to establish the physically measured feature. By default, MIL uses the entire target image as the metrology region of the measured feature. However, to reduce the likelihood of getting unwanted features, and to speed up the calculation, you should typically restrict this area, using MmetSetRegion(). For example, you can specify that the physically measured feature must not only be within the specified target image, but that it must also be within the specified ring, arc, segment, or rectangle metrology region. In general, good results come from well-defined metrology regions. Note that the features with which to build constructed features can also have a delimited metrology region. When you call MmetSetRegion(), you can define the metrology region in one of the following ways. Explicitly specify the shape and size of the region. This is referred to as an explicitly-defined metrology region. Most applications typically use this type of region. Set the region's shape and size using a graphic in a 2D graphics list. This is referred to as a 2D graphics list metrology region. When using a 2D graphics list metrology region, you must specify the geometry (shape) of the region using MmetSetRegion(), and then add the combination value M_FROM_GRAPHIC_LIST (for example, M_ARC + M_FROM_GRAPHIC_LIST). In this case, you must add the corresponding graphic to the 2D graphics list using an appropriate Mgra...() function; for example, when establishing a feature from an M_ARC metrology region, you can call MgraArc() to add an arc to the 2D graphics list. The 2D graphics list must contain only one graphic and it must have the same geometric-shape as specified using MmetSetRegion(). The advantage of defining a 2D graphics list metrology region is that you can set it with respect to the relative coordinate system as well as set it interactively. Define the metrology region based on other features by passing a derived metrology region object to MmetSetRegion(). This is referred to as a derived metrology region. When using a derived metrology region (MmetSetRegion() with M_FROM_DERIVED_GEOMETRY_REGION), you must allocate a derived metrology region object using MmetAlloc() with M_DERIVED_GEOMETRY_REGION, and then set it up using MmetControl() with M_REGION_.... Once you specify the geometry of the derived metrology region using the M_REGION_GEOMETRY control type, you can set most of the geometry's attributes either explicitly or derive them based on a feature. Use the corresponding M_REGION_..._TYPE control type to specify which. For example, instead of specifying explicit X- and Y-coordinates to set the position of a rectangular metrology region, you can derive its position according to the position of a point feature. Regardless of how you define the metrology region, the regions themselves behave similarly; that is, they restrict the area in the target image from which to establish your physically measured features. By default, when the target image is calibrated, the metrology region closely follows the image distortion. You can disable high accuracy for the metrology region of a feature and have the Metrology module approximate the distortion using MmetControl() with M_REGION_ACCURACY_HIGH set to M_DISABLE. This results in a quicker processing time. Each metrology region has an orientation, which refers to the alignment of a metrology region, with respect to a reference frame. The following example shows 4 metrology regions (ring, arc, segment, and rectangle) and their orientation, as depicted with an arrow. You can draw a metrology region (and its orientation) using MmetDraw() with M_DRAW_REGION. Note that for circular metrology regions (arc, ring, ring-sector), the metrology region's orientation is radial. For the features to be extracted, they must not only fall within the metrology region, but their edgels' gradient angle must also fall along the region's orientation. Various control types can be used to set a valid relationship between the metrology region's orientation, and the edgels' gradient angle. For more information, see the Gradient angle subsection of the Eliminating unwanted edgels section later in this chapter. The metrology region's position is set relative to the global frame by default. You can, however, use the coordinate system of any reference frame. The following table lists all available metrology regions, and the physically measured features that can be extracted from them. Metrology region Feature Arc Circle Edgel Point Segment Arc — — — Yes — Infinite (default) Yes Yes Yes Yes Yes Rectangle — — Yes — Yes Ring — Yes Yes — — Ring-sector Yes — Yes — Yes Segment — — — Yes — For an infinite metrology region (M_INFINITE), you must set the X- Y-position of the origin of the region. You must also explicitly set the angle of orientation (the default is the same as the reference frame). For a rectangular metrology region (M_RECTANGLE), you must set the X- Y-position of the origin of the region. You must also set the region's width, height, and angle. The orientation is determined by the origin's position and angle. For a segment-shaped metrology region (M_SEGMENT), you must set the X- Y-position of the segment's start point and end point; the orientation is from start point to end point. For an arc-shaped metrology region (M_ARC), you must set the X- Y-position of the origin of the region, as well as the region's radius, start angle and end angle; the orientation is from start angle to end angle. For a ring-shaped metrology region (M_RING), you must set the X- Y-position of the origin (center) of the region. You must also set the start radius and the end radius. To delimit only a sector of a ring (M_RING_SECTOR), you must set the start angle and end angle of the ring. The orientation is from the start radius to the end radius. Also, the region itself is set counter-clockwise, from the start angle to the end angle (for ring-sector). Note that M_INFINITE is similar to M_RECTANGLE, however an infinite metrology region does not have a width and a height (boundaries). The following examples illustrate rectangle, segment, arc, and ring-sector metrology regions. Note that, for ring-shaped metrology regions, switching the start radius and end radius reverses the orientation. Unlike other physically measured features, multiple measured points can be extracted from the metrology region. For more information, see the Multiple features subsection of this section. Best fit, inner fit, and outer fit operations To add a physically measured feature, you must typically set its fit operation, which establishes the feature from the feature's active edgels. Active edgels are those edgels in the metrology region that satisfy the edgel constraints (MmetControl() with M_EDGEL_ANGLE_RANGE, M_EDGEL_RELATIVE_ANGLE, and M_EDGEL_SELECTION_RANK). The active edgels that the fit operation actually uses are referred to as the fitted edgels. For more information, see the Edgel and fit constraints subsection of the Eliminating unwanted edgels section later in this chapter. The following table lists the fit operations and the features you can build with them. Build operation Feature to build Arc Circle Edgel Point Segment Best fit (default) Yes Yes — Yes Yes Inner fit — Yes — — Yes Outer fit — Yes — — Yes A feature built with the best fit operation (M_FIT) will pass as close to as many of the active edgels as possible. Note that the best fit segment separates the inner and outer fit regions, which are used to calculate the inner and outer fit segments. A feature built with the best fit operation (M_STANDARD_FIT) gives more importance to the edgels whose gradient's orientation follows the region's orientation. The starting point of the best fit segment is the extremity closest to the origin of the metrology region. By default, when specifying an M_FIT operation, MIL performs a standard best fit. However, when dealing with a lot of outliers (outlier edgels/points), you can change this to a robust best fit, by calling MmetControl() with M_FIT_TYPE set to M_ROBUST_FIT. A feature built with the inner fit operation (M_INNER_FIT) will represent the innermost boundary of the set of active edgels. For a circle feature, the inner fit is the largest possible circle that contains none of the active edgels. For a segment feature, the inner fit depends on the best fit segment. The active edgels used to build the inner fit segment are on the counter-clockwise side of the best fit segment, relative to its direction. The inner fit segment passes through the two farthest active edgels of the inner fit region such that all the active edgels of the inner fit region are located on the same side of the inner fit segment. A feature built with the outer fit operation (M_OUTER_FIT) will represent the outermost boundary of the set of active edgels. For a circle feature, the outer fit is the smallest possible circle that contains all of the active edgels. For a segment feature, the outer fit depends on the best fit segment. The active edgels used to build the outer fit segment are on the clockwise side of the best fit segment, relative to its direction. The outer fit segment passes through the two farthest active edgels of the outer fit region such that all the active edgels of the outer fit region are located on the same side of the outer fit segment. The following table illustrates an arc, circle, and segment feature added with the different fit operations; the operations are performed on the active edgels provided. Build operation Feature to build Arc Circle Segment Best fit Inner fit Not available Outer fit Not available When using a fit operation, you can fine-tune the fit process by calling MmetControl() and specifying fit constraints; for example, for greater precision, you can increase the maximum number of fit iterations that MIL can use to establish the feature (M_FIT_ITERATIONS_MAX). Such fit constraints can alter the precision of the edge that is ultimately fit; however, they might not reliably discard outliers (outlier edgels/points) when they significantly impact the initial fit (the first iteration of the fit). When dealing with a lot of outliers, use a robust best fit (M_ROBUST_FIT). For more information on fit constraints, see the Active edgels and fitted edgels subsection of the Eliminating unwanted edgels section later in this chapter. Note that a feature built with a fit operation will not necessarily touch the active edgels on which it is based. Also, to determine the length of a segment feature built using a fit operation, MIL projects the fitted edgels in the feature's metrology region onto the segment. (Physically measured) edgel features Edgel features do not have a definitive geometry; they are built using the raw information (edgels) extracted from the metrology region. Each edgel represents an X- and Y-position, and an angular direction (of the gradient). An edgel feature typically contains numerous edgels. To add an edgel feature, use MmetAddFeature() with M_MEASURED and M_EDGEL. By default, edgel features are built using all the edgels in the feature's metrology region. However, you can choose to eliminate unwanted edgels, based on their gradient angle; this can prove useful since it allows you to customize the extracted edgels to fit your needs. For more information, see the Gradient angle subsection of the Eliminating unwanted edgels section later in this chapter. An edgel feature is useful to add an atypical shape to the metrology template. That is, you can add features that do not represent a geometric primitive, such as an arc, circle, point, or segment. The edgel information of a feature might also prove useful in several types of advanced applications. For example, you might want to set a true minimum distance tolerance between the edgels that compose two segments, rather than having the minimum distance based on the fitted segments that are built from the edgels. Constructed features A constructed feature is a geometric primitive (point, arc, circle, segment, line, edgel, and local frame) that is either: Mathematically defined (M_PARAMETRIC). Geometrically derived from a set of other features (all build operations except M_PARAMETRIC). The features used to build a constructed feature are referred to as base features. To add a constructed feature, use MmetAddFeature() with M_CONSTRUCTED. For constructed features that are geometrically derived, you must also specify the label of the feature(s) to use for construction. These features are referred to as base features. The following example shows a constructed segment added from the constructed center points of 2 physically measured circles. To add a constructed feature, you must set the operation with which to build the feature. For a constructed feature that is geometrically derived, the operation selects how to use the specified base feature(s) to build the constructed feature. The following table lists all constructed features, and the operations to build them. Build operation Feature to build Arc Circle Edgel Line Local frame Point Segment Absolute angle — — — — — Yes — Absolute position — — — — — Yes — Angle — — — Yes — — — Basic construction Yes Yes — Yes Yes — Yes Best fit Yes Yes — Yes — — Yes Bisector — — — Yes — — — Center — — — — — Yes — Clone Yes Yes Yes Yes Yes Yes Yes Closest — — — — — Yes — Closest to infinity point — — — — — Yes — Copy feature edgels — — Yes — — — — End position — — — — — Yes — Extended intersection — — — — — Yes — External feature — — Yes — — — — Group edgels (default) — — Yes — — — — Inner fit — Yes — — — — Yes Intersection — — — — — Yes — Max distance point — — — — — Yes — Max of min distance point — — — — — Yes — Middle — — — — — Yes — Outer fit — Yes — — — — Yes Parallel — — — Yes — — — Parametric (default) Yes Yes — Yes Yes Yes Yes Perpendicular — — — Yes — — — Relative angle — — — — — Yes — Relative position — — — — — Yes — Relative sector — — — Yes — — — Start position — — — — — Yes — Using metrology regions with constructed features When using a fit operation to build a constructed feature, a metrology region delimits the region from which base features are built. You must call MmetSetRegion() to specify the metrology region for each base feature. The base feature of a constructed edgel feature built using a clone operation can also be delimited by a metrology region. MIL only uses the edgels or points within the delimited region of the base feature to build the constructed feature; edgels or points outside the region are clipped. Metrology regions for the base features of constructed features are the same as metrology regions for physically measured features. For more information, the Metrology regions subsection of this section. Basic construction (using points) The basic construction operation, M_CONSTRUCTION, creates a constructed feature based on points, which are considered a feature's most fundamental (basic) elements. The number of points MIL requires, and how MIL implements them, are dependent on the feature you are constructing. The following example shows how a local frame, line, segment, circle, and arc are built using 2 or 3 points. When using M_CONSTRUCTION, you can specify the following features with which to build the new feature: points, circles, arcs, or local frames. If you specify a non-point feature, MIL uses that feature's most significant point; that is, for a circle or arc, MIL takes its center point, and for a local frame, MIL takes its origin point. In the following example, a segment (M_CONSTRUCTED with M_SEGMENT) is built using M_CONSTRUCTION with two specified circle features (FeatureLabelArrayPtr). Cloning and copying The clone operation, M_CLONE_FEATURE, creates a constructed feature that is an exact duplicate, or modified replica, of the specified base feature, which can be constructed or physically measured. The clone operation is available for building any constructed feature. The base feature of a constructed edgel feature built using a clone operation can be delimited by a metrology region. Metrology allows you to modify certain aspects of a cloned feature, using MmetControl() with M_CLONE_.... For example, you can translate (M_CLONE_OFFSET_X, M_CLONE_OFFSET_Y), rotate (M_CLONE_ANGLE), and/or scale (M_CLONE_SCALE) a cloned feature. When modifying a cloned feature, values (position, scale, and angle) are relative to the reference frame of the clone's base feature. When cloning a reference frame, its associated features are not cloned. For constructed edgel features only, you can also use the operation M_COPY_FEATURE_EDGELS. This creates a new constructed edgel feature that contains the edgels of the specified base features, each of which can be physically measured or a constructed edgel feature. By default, the M_COPY_FEATURE_EDGELS operation copies all the edgels of the base features to the newly constructed edgel feature. However, for physically measured base features, you can restrict the operation to copy only the active edgels or only the fitted edgels of the base features. For constructed edgel base features, MIL always copies all edgels. For more information, see the Copy feature edgels subsection of the Eliminating unwanted edgels section later in this chapter. Fit The fit operations create a constructed feature that is the best fit (M_FIT), inner fit (M_INNER_FIT), or outer fit (M_OUTER_FIT), of the feature information (base features) that you provide. In most cases, the base features are points and/or edgels; the added feature will not necessarily touch these points/edgels. For example, you can add a constructed segment that is built using the best fit of a physically measured point feature (which contains multiple physically measured points). In this case, the constructed segment will pass as close to as many of the points as possible. When dealing with a lot of outliers (outlier edgels/points), try using a robust best fit, by calling MmetControl() with M_FIT_TYPE set to M_ROBUST_FIT. The base features of a constructed feature built using a fit operation can be delimited by a metrology region. In general, fit operations for constructed features and physically measured features behave similarly. For more information, see the Best fit, inner fit, and outer fit operations subsection of this section. Operations for building point features A point feature can be constructed using one of several specialized operations. For example, you can use the center operation (M_CENTER) to construct a point at the center of a segment. The following table illustrates some of the operations available to build a point based on the specified feature(s). Build operation Feature(s) used to build the point Circle or Arc Segment Several features Absolute angle Not available Not available Absolute position Not available Center Closest Not available Not available Closest to infinity point Not available Extended intersection Not available Not available Intersection Not available Not available Max distance point Not available Not available Max of min distance point Not available Not available Middle Not available Position end Not available Position start Not available Relative angle Not available Not available Relative position Not available Operations for building line features A line feature can be constructed using one of several specialized operations. For example, you can use the parallel operation (M_PARALLEL) to construct a line parallel to a specified segment. The following table illustrates some of the operations available to build a line based on the specified feature(s). Some operations also require an angle value. Build operation Feature(s) used to build the line A segment and a point Three points Two lines Angle Not available Not available Bisector Not available Parallel Not available Not available Perpendicular Not available Not available Relative sector Not available Not available Parametrically constructed features Most constructed features can be built mathematically (M_PARAMETRIC) by specifying explicit values, such as the feature's position and angle. You must use MmetControl() to specify the required values needed for the construction. For example, to build a line parametrically, you must use MmetControl() with M_LINE_A, M_LINE_B, and M_LINE_C to specify the coefficients A, B, and C of the line equation ( A x + B y + C = 0). Note that since a line is infinitely long, it has no position. The following illustration shows how a segment and arc are constructed by providing explicit positional values. For an arc, you must also provide its radius, start angle, and end angle. Multiple features A multiple feature is a feature that holds several instances of that same feature type; every instance of the feature type is considered a subfeature of the multiple feature. For example, a point feature can be a collection of several physically measured points, each of which is a subfeature (subpoint) of the point feature. Point and edgel features are considered multiple features. In certain cases, you can access subpoints; however, you can never access subedgels. A multiple point feature is created when the metrology region associated with a point feature contains more than one edgel. The subfeatures are numbered in ascending order along the orientation of the metrology region. You might need to specify the individual subfeatures (points) to use when adding a constructed feature based on a subfeature of a multiple physically measured point feature. To do so, use the FeatureLabelArrayPtr parameter to specify the label of the multiple point feature, and use the SubFeatureIndexArrayPtr parameter to specify the indices of the subpoints. The following table shows how a feature can be added using 8 points (specified from 5 features). FeatureLabelArrayPtr SubFeatureIndexArrayPtr MultiplePointFeature1 19 MultiplePointFeature2 1 MultiplePointFeature2 13 MultiplePointFeature3 1 MultiplePointFeature3 14 MultiplePointFeature3 20 MultiplePointFeature4 8 MultiplePointFeature5 1 Features Reference frame Global frame Local frame Set position (Physically) measured features Metrology regions Best fit, inner fit, and outer fit operations (Physically measured) edgel features Constructed features Using metrology regions with constructed features Basic construction (using points) Cloning and copying Fit Operations for building point features Operations for building line features Parametrically constructed features Multiple features ",
      "wordCount": 4655,
      "subEntries": []
    },
    {
      "id": "UG_metrology_Geometric_tolerances",
      "version": null,
      "title": "Geometric tolerances",
      "subTitles": [
        "Adding a geometric tolerance",
        "Angularity",
        "Area and perimeter",
        "Concentricity",
        "Distance",
        "Length",
        "Parallelism",
        "Perpendicularity",
        "Position",
        "Radius",
        "Roundness",
        "Straightness",
        "Using multiple geometric tolerances"
      ],
      "location": "MIL UG P03: 2D processing and analysis",
      "pageURL": "content\\UserGuide\\metrology\\Geometric_tolerances.htm",
      "text": " Geometric tolerances After adding features to the metrology template, you will typically add geometric tolerances, using MmetAddTolerance(). A geometric tolerance defines the acceptable deviation from the definition of a feature, or the acceptable geometric relationship between multiple features. When adding a geometric tolerance, you must set its minimum and maximum limit values. When defining the tolerance of one feature, these limits represent the acceptable deviation from the definition of the feature. For example, a segment's length tolerance can be between 90 and 100 pixels. For multiple features, these limits represent the valid range of acceptable values between the features. For example, the perpendicular tolerance between two segments can be +/- 0.05° (that is, 89.95° to 90.05°). To change the minimum and maximum limit values, use MmetControl() with M_VALUE_MIN and M_VALUE_MAX. You can also use MmetControl() with M_VALUE_WARNING_MIN and M_VALUE_WARNING_MAX to set warning values to alert you when the tolerance is close to its minimum and maximum limits. When you call MmetCalculate(), the tolerance is calculated (for example, 95 pixels) and a status is assigned (for example, M_PASS). To retrieve the tolerance value and status, use MmetGetResult() with M_TOLERANCE_VALUE and M_STATUS. The status of the geometric tolerance returns M_PASS or M_WARNING if the tolerance meets the specified requirements, and M_FAIL if it does not. M_FAIL is returned when a tolerance value falls outside the range defined by the minimum and maximum tolerance values and/or the minimum and maximum warning values. M_WARNING is returned when a tolerance value is less than or equal to the minimum tolerance value, but greater than the minimum warning value. A warning also occurs when a tolerance value is greater or equal to the maximum tolerance value, and less than the maximum warning value. M_PASS is returned when the value is between the minimum and maximum tolerance values. By default, the minimum and maximum tolerance and warning values are 0. The following is an example of (non-zero) minimum and maximum tolerance and warning values: Note that a warning will never be returned if the warning range is within the pass range. If a calibration context is associated with the target image, set values in real-world units. Otherwise use pixel units (for example, tolerance values and warning values, and positional values). For more information, see the Camera calibration - overview section of Chapter 28: Calibrating your camera setup. Adding a geometric tolerance With MmetAddTolerance(), you can add one of the following geometric tolerances: Angularity Area - simple Area - convex hull Area between curves Area under curve max Area under curve min Concentricity Distance Length (arc or circle) Length (segment or edgel) Parallelism Perimeter - simple Perimeter - convex hull Perpendicularity Position-X and Position-Y Radius Roundness Straightness This table illustrates the tolerance's icon, which you can draw by calling MmetDraw() with M_DRAW_TOLERANCE. For more information about drawing, see the Annotating the results subsection of the Calculating and retrieving results section later in this chapter. Angularity An angularity tolerance (M_ANGULARITY) validates that the angle between two features falls within the specified angular range (for example, that two lines intersect at an angle between 25° and 35°). An angularity tolerance can be applied between the following features. Two segment features. To validate the angularity between two segment features, MIL internally connects each segment at their start point and considers the angle between them to be, counter-clockwise, from the first segment to the second segment. This angle is valid if it falls within the angular range set by the minimum and maximum tolerance limits. To designate the valid angular range, the minimum and maximum tolerance limits are angles applied counter-clockwise around the start point of the first segment. Note that MIL does not physically rearrange the specified segments, it only orients them internally to measure the required angles. The following animation illustrates angularity. Each segment's start point, as well as the order you list the segments in the FeatureLabelArrayPtr parameter, can affect your results. For example, the angle between segment 1 and segment 2 is different than the angle between segment 2 and segment 1. Two line features. To validate the angularity between two line features, MIL considers the angle between them to be, counter-clockwise, from the first line to the second line. This angle is valid if it falls within the angular range set by the minimum and maximum tolerance limits. To designate the valid angular range, the minimum and maximum tolerance limits are angles applied counter-clockwise, from the first line to the second line, around the intersection point of the two lines. The order you list the lines in the FeatureLabelArrayPtr parameter can affect your results. For example, the angle between line 1 and line 2 is different than the angle between line 2 and line 1. Since lines are infinite, there are actually two ways to measure the angle between line 1 and line 2 (indicated as angle (a) in the following diagram) and between line 2 and line 1 (indicated as angle (b) in the following diagram). Note that this is inconsequential since each pair of angles is equivalent. A linear feature (segment or line) and an edgel feature. For one linear feature (segment or line) and one edgel feature, M_ANGULARITY validates the width of the projection of the edgel feature, along the nominal angle specified using MmetControl() with M_ANGLE. The angle is in the counter-clockwise direction relative to the linear feature. The minimum and maximum tolerance parameters set the valid projection width. Typically, you should set the minimum width value to 0. The width of the projection is in pixel or world units. The second feature specified in the FeatureLabelArrayPtr parameter must be edgel. Three point features. To validate the angularity between three point features, MIL considers the first point as the center of the angularity tolerance, the second point as the StartAngle (in the counter-clockwise direction relative to the first point), and the third point as the EndAngle (in the counter-clockwise direction relative to the first point). M_ANGULARITY validates the angle that results from EndAngle - StartAngle. Note that an angularity tolerance between a segment and a line produces too many ambiguities and therefore cannot be calculated. Area and perimeter You can add the following tolerances, based on area or perimeter. A tolerance for the typical area or perimeter of a feature's surface (M_AREA_SIMPLE or M_PERIMETER_SIMPLE). A tolerance, based on the convex hull, for the area or perimeter of a feature's surface (M_AREA_CONVEX_HULL or M_PERIMETER_CONVEX_HULL). Abstractly, you can consider the convex hull like placing a rubber band around the feature, and then calculating the area or perimeter. A tolerance for the area between two curves of edgels (M_AREA_BETWEEN_CURVES). You can control how MIL establishes curves from the edgel features using M_CURVE_INFO. MIL can automatically establish unbounded (open) or bounded (closed) curves. Alternatively, for unbounded curves, you can specify a reference frame to indicate the direction of the curve, which can make the tolerance faster to calculate and less sensitive to gaps between edgels. If the two specified curves intersect, then MIL will validate the areas on both sides of the curves by default. If you only want to validate areas on one side of the curves, enable M_AREA_BETWEEN_CURVES_ONE_SIDE_ONLY using MmetControl(). MIL must establish the side on which the areas are considered positive, and add them. Areas on the other side (which is considered the negative side) are ignored. The positive and negative sides are determined by the direction of the global reference frame's Y-axis, and whether it intersects with the first or second specified curve first. You can specify a different reference frame with M_AREA_BETWEEN_CURVES_DEFINE_SIDE. If the Y-axis initially intersects with the first specified curve, all the areas on the side of the first curve facing the direction of the Y-axis are considered positive and MIL adds them; all the areas on the other side of the first curve are considered negative and MIL ignores them. If the Y-axis initially intersects with the second specified curve, all the areas on the side of the second curve facing the direction of the Y-axis are considered negative and MIL ignores them; all the areas on the other side of the second curve are considered positive and MIL adds them. If neither curve intersects the Y-axis, or if only one curve intersects the Y-axis, the sign of the areas between the curves is computed based on the order in which the two curves are defined. If the points delimiting an area on the first specified curve appear in a clockwise order, then this area will be negative. If they appear in a counter-clockwise order, then this area will be positive. A tolerance for the maximum or minimum area under a curve of edgels or points (M_AREA_UNDER_CURVE_MAX or M_AREA_UNDER_CURVE_MIN) and a line. When a curve intersects with a segment or line feature, areas(s) can exist on both sides of the feature. The positive area(s) are those located on the side of the feature where the sum of the area(s) is the largest, and the negative area(s) are those located on the opposing side. Use M_DRAW_TOLERANCE_AREA... to draw the positive or negative area. Note that for an M_AREA_BETWEEN_CURVES, M_AREA_UNDER_CURVE_MAX, or M_AREA_UNDER_CURVE_MIN tolerance, you can set the maximum gap between edgels to consider them part of the same curve with M_CURVE_EDGEL_GAP_SIZE for an. M_CURVE_EDGEL_GAP_SIZE sets the look ahead distance used to identify which points to consider as the next point along the curve. For a small gap size, fewer points will be considered. For a large gap size, noisy and outlier points might be considered. The actual points chosen will vary depending both on their distances from the last chosen point and the type of tolerance that is being evaluated. Concentricity A concentricity tolerance (M_CONCENTRICITY) validates that two features have a common center. A concentricity tolerance can be applied to circle and arc features. The minimum and maximum tolerance parameters set the valid minimum and maximum distance allowed between the center of each feature. Typically, you should set the minimum distance value to 0. Distance A distance tolerance (M_DISTANCE_MAX and M_DISTANCE_MIN) validates that the distance between two features meets either the specified maximum or minimum distance values. You can use a maximum distance tolerance with any two features except lines (as lines are infinitely long); you can use a minimum distance tolerance with any two features. The maximum and minimum tolerance parameters set the valid maximum and minimum distances between features for either the maximum or minimum distance tolerance. By default, to validate the tolerance, MIL uses the distance at which the features are either the farthest (for M_DISTANCE_MAX) or the closest (for M_DISTANCE_MIN). You can however explicitly specify an angle at which to apply the distance tolerance between two features, by calling MmetControl() with M_DISTANCE_MODE. This can be seen as a type of caliper tolerance between the features. The following example shows how MIL applies the minimum distance tolerance between a circle and an edgel feature at a specific angle. Length A length tolerance (M_LENGTH) validates that the linear dimension of one feature meets the specified value. A length tolerance can be applied to one of the following features: segment, edgel, circle, or arc. For an edgel feature, you should only use M_LENGTH if the edgel represents one continuous curve (or path) that does not cross over itself. For circle and arc, length refers to the circumference. The minimum and maximum tolerance parameters set the valid minimum and maximum lengths of the feature. Parallelism A parallelism tolerance (M_PARALLELISM) validates the degree to which two features are parallel. A parallelism tolerance can be applied between the following: Two linear features (segments and lines). A linear feature (segment or line) and an edgel feature. For any combination of 2 linear features (segments and lines), M_PARALLELISM validates that the angle of the two features, relative to the global reference frame, is the same. The maximum tolerance parameter sets the valid angular range, from the nominal angle (0°). In this case, you should only set the maximum tolerance parameter, and set the minimum tolerance parameter to 0. The order of the features specified in the FeatureLabelArrayPtr parameter, as well as the start/end of the segments, is inconsequential. For parallelism tolerances between two linear features, angles are remapped to 0°; that is, the angle that is measured, and the angular range that you must provide, is the angle that is closest to 0°. For a linear feature and an edgel feature, M_PARALLELISM validates the width of the projection of the edgel feature on a theoretical line perpendicular to the segment or line feature. The minimum and maximum tolerance values set the valid projection width. The smaller the width, the more the edgel feature is parallel to the given segment or line feature. Typically, the minimum width value is 0. The width of the projection is in pixel or world units. The second feature specified in the FeatureLabelArrayPtr parameter must be edgel. Perpendicularity A perpendicularity tolerance (M_PERPENDICULARITY) validates the degree to which two features are perpendicular. A perpendicularity tolerance can be applied between the following features: Two linear features (segments and lines). A linear feature (segment or line) and an edgel feature. For any combination of 2 linear features (segments and lines), M_PERPENDICULARITY validates that the angle between the two features is 90°. The maximum tolerance parameter sets the valid angular range, from the nominal angle (90°). In this case, you should only set the maximum tolerance parameter, and set the minimum tolerance parameter to 0. The order of the features specified in the FeatureLabelArrayPtr parameter, as well as the start/end of the segments, is inconsequential. For perpendicularity tolerances between two linear features, angles are remapped to 90°; that is, the angle measured and the angular range you provide is the angle closest to 90°. For a linear feature and an edgel feature, M_PERPENDICULARITY validates the width of the projection of the edgel feature on a theoretical line parallel to the segment or line feature. The minimum and maximum tolerance values set the valid projection width. The smaller the width, the more the edgel feature is perpendicular to the given segment or line feature. Typically, the minimum width value is 0. The width of the projection is in pixel or world units. The second feature specified in the FeatureLabelArrayPtr parameter must be edgel. Position A position tolerance (M_POSITION_X and M_POSITION_Y) validates that a feature must be located at the specified position, along the X- or Y-direction of the specified reference frame. A position tolerance can be applied to a local frame feature, and one of the following features: local frame, point, circle. The minimum and maximum tolerance parameters set the valid minimum and maximum positions for either the X- or Y-position tolerance. If you only specify one feature, MIL validates the geometric relationship between that feature and its reference frame (every feature is associated to a reference frame). Radius A radius tolerance (M_RADIUS) validates that the linear length between the feature's center and perimeter falls within the specified values. A radius tolerance can be applied to one of the following features: arc or circle. The minimum and maximum tolerance parameters set the valid minimum and maximum radius of the feature. Roundness A roundness tolerance (M_ROUNDNESS) validates that a feature is round. This is done by calculating the distance between the inner and outer circular curves formed by the given feature, such as the circle feature shown below. Note that the inner and outer circular curves are concentric. A roundness tolerance can be applied to circle, arc, and edgel features. The minimum and maximum tolerance parameters set the valid minimum and maximum width between the two concentric curves (for non circle features, this can be seen as portions of a circle). Typically, you should set the minimum width value to 0. Straightness A straightness tolerance (M_STRAIGHTNESS) validates that a feature is straight. This is done by calculating the distance between the two parallel lines that are formed by the inner and outer boundaries of the feature. The angle of the two parallel lines is chosen such that the distance between them is the smallest. A straightness tolerance can be applied to segment and edgel features. The minimum and maximum tolerance parameters set the valid minimum and maximum width between the two parallel lines. Typically, you should set the minimum width value to 0. Using multiple geometric tolerances To accurately represent a relationship between features, the features might have to be validated by multiple geometric tolerances. For example, to verify the following result, you might set a 30° angularity tolerance between two segments. However, using only the angularity tolerance, each of the following results has a valid tolerance status. In this case, you need an additional tolerance to check the location of the segments. To do so, you would add two constructed point features at the start of each segment, using MmetAddFeature() with M_POINT and M_POSITION_START. You would then add a distance tolerance for these two points, ensuring they are at the same location. To satisfy the required feature relationship, both the angularity status of the segments and the distance status of the points must be valid. Geometric tolerances Adding a geometric tolerance Angularity Area and perimeter Concentricity Distance Length Parallelism Perpendicularity Position Radius Roundness Straightness Using multiple geometric tolerances ",
      "wordCount": 2874,
      "subEntries": []
    },
    {
      "id": "UG_metrology_Eliminating_unwanted_edgels",
      "version": null,
      "title": "Eliminating unwanted edgels",
      "subTitles": [
        "Customizing the edge extraction algorithm",
        "Edgel and fit constraints",
        "Active edgels and fitted edgels",
        "Gradient angle",
        "Edgel selection rank",
        "Common fit constraints",
        "Standard fit constraints",
        "Robust fit constraints",
        "Copy feature edgels",
        "Denoising edgels"
      ],
      "location": "MIL UG P03: 2D processing and analysis",
      "pageURL": "content\\UserGuide\\metrology\\Eliminating_unwanted_edgels.htm",
      "text": " Eliminating unwanted edgels The Metrology module has been configured, by default, to conduct a fast and robust calculation of physically measured features in the target image. This is done, in part, by typically using all edgels in the feature's metrology region. However, for unusually complex target images, or to fit your application's needs, you might want to restrict which edgels are used. Eliminating unwanted edgels can result in a more precise feature extraction, a more accurate fit, and a more robust calculation. Edgels within the metrology region that don't pass certain constraints are eliminated; the remainder can be considered active edgels. The following animation shows how edgels are selected within a region of interest. Customizing the edge extraction algorithm Before determining which edgels apply to a fit operation, you can modify the processing settings of the metrology context that affect how MIL extracts edges. For example, you can specify a smoothing operation to reduce image noise. To adjust the processing settings, use MmetControl(), and alter the: Edge extraction filter (M_CHAIN_ALL_NEIGHBORS, M_EXTRACTION_SCALE, M_FILTER_SMOOTHNESS, and M_FILTER_TYPE). Calculation precision (M_FLOAT_MODE). Magnitude type (M_MAGNITUDE_TYPE). Edge extraction threshold (M_THRESHOLD_MODE, M_THRESHOLD_TYPE, M_THRESHOLD_VALUE_HIGH, and M_THRESHOLD_VALUE_LOW). You can adjust these settings for each physically measured feature, or for the entire metrology context, which will affect all physically measured features. For more information on customizing the edge extraction algorithm, see the Customizing the edge extraction settings section of Chapter 10: Edge Finder. Edgel and fit constraints To control which edgels apply to a fit operation, you can adjust several criteria. You can specify which edgels are considered active, using gradient angle and edgel selection rank settings. You can further specify fit constraints that determine edgel selection for fitting a feature, and therefore establish which of the active edgels are considered fitted edgels. Active edgels and fitted edgels Active edgels are those edgels, in the metrology region, that satisfy the edgel constraints. Typically, they are used to build the feature. The edgel constraints include: The gradient angle restrictions (MmetControl() with M_EDGEL_ANGLE_RANGE and M_EDGEL_RELATIVE_ANGLE). The edgel selection rank restrictions (MmetControl() with M_EDGEL_SELECTION_RANK). Fitted edgels are those active edgels, in the metrology region, used by the fit operation to define a fitted feature. They satisfy both the edgel constraints mentioned above, and by default, the following: The fit operation (MmetAddFeature() with M_FIT, M_INNER_FIT, or M_OUTER_FIT). For information on fit operations, see the Best fit, inner fit, and outer fit operations subsection of the Features section earlier in this chapter. The common fit constraints (MmetControl() with M_FIT_COVERAGE_MIN and M_FIT_ITERATIONS_MAX). The standard fit constraints (MmetControl() with M_FIT_VARIATION_MAX and M_FIT_DISTANCE_MAX) or robust fit constraints (MmetControl() with M_FIT_DISTANCE_OUTLIERS, M_FIT_DISTANCE_OUTLIERS_VALUE, and M_FIT_INTERNAL_NUMBER_OF_POINTS). For fit operations, it is possible to have active edgels that are not used to construct a feature. This occurs when there are edgels that satisfy the edgel constraints (active edgels), but do not satisfy the fit constraints (fitted edgels). Therefore, the fitted edgels are the subset of active edgels used to construct the feature. For example, an inner fit and outer fit can produce two different features, and ultimately have two different sets of fitted edgels despite one common set of active edgels. Note that some active edgels are considered outliers because they are too far away from the expected feature fit. Outliers should not participate in the final fit. The standard fit constraints (applied when M_FIT_TYPE is set to M_STANDARD_FIT) can alter the precision of the edge that is ultimately fit; however, they might not reliably discard outliers (outlier edgels/points) when they significantly impact the initial fit (the first iteration of the fit). When dealing with a lot of outliers, use a robust best fit (M_FIT_TYPE set to M_ROBUST_FIT). Note that fit constraints apply when building either physically measured features or constructed features with a fit operation. Gradient angle The gradient angle (edgel direction) is the counter-clockwise angle between the target image's horizontal axis and the edge's gradient (the direction of the edgel's most sudden change from black to white) at each edgel location. The following example illustrates various edgels and their direction. You can filter out unwanted edgels by restricting the degrees of freedom applied to the edgel's gradient angle. To do so, use MmetControl() with M_EDGEL_ANGLE_RANGE. Only those edgels that have a gradient angle that falls within the angular range can be used to build the feature. You can set the angular range to any value between 0.0° and 360.0° (the default is 180.0°). By default, the angular range is set relative to the metrology region's orientation. To change the relative angle, use MmetControl() with M_EDGEL_RELATIVE_ANGLE. If the relative angle is set to M_SAME (the default), only those edgels that have the same gradient angle (from black to white) as the metrology region's orientation, and whose gradient angle falls within the angular range, will be used. If the relative angle is set to M_REVERSE, only those edgels that have the opposite gradient angle (from white to black) of the metrology region's orientation, and whose gradient angle falls within the angular range, will be used (+180°). You can also set the relative angle to same or reverse (M_SAME_OR_REVERSE). Note that for circular metrology regions (arc, ring, ring-sector), the metrology region's orientation is radial. For more information on metrology regions, see the Metrology regions subsection of the Features section earlier in this chapter. The following example shows how the gradient angle range (approximately 60°) and the relative angle (same and reverse) settings can be used with a rectangular metrology region and a ring-sector metrology region to select active edgels. The following example shows how the relative angle settings can be used with an arc-shaped metrology region to select different active edgel features in an object. Note that to get these results, a slight angular range must also be applied. Note that gradient angle restrictions apply when building either physically measured features, or constructed features that use physically measured edgels as a source. Edgel selection rank The edgel selection rank refers to the rank of the edgels to select when scanning the metrology region column by column from bottom to top. For example, if there are several possible edgels in a given column of the metrology region, the rank will determine whether the first edgel found, as opposed to the second or any subsequent edgel, is selected. To specify the rank, use MmetControl() with M_EDGEL_SELECTION_RANK. If the edgel selection rank is set to M_LAST, the last edgel found in the column will be used. Note that this control type takes effect after M_EDGEL_RELATIVE_ANGLE and M_EDGEL_ANGLE_RANGE are satisfied. In the following example, there are multiple edges in the metrology region. The solid gray line illustrates the edgels selected when M_EDGEL_SELECTION_RANK is set to 1; the dotted gray line illustrates the edgels selected when M_EDGEL_SELECTION_RANK is set to 2. Common fit constraints Metrology calculates the fit of a feature based on an iterative process, where each iteration results in a more accurate fit than its predecessor. This process results in a robust fit where unwanted edgels, such as noise, can be eliminated. To control the fit calculation, you can set specific constraints, depending on the type of fit. For both M_STANDARD_FIT and M_ROBUST_FIT, you can specify M_FIT_COVERAGE_MIN and M_FIT_ITERATIONS_MAX. The iteration process takes into account the minimum fit coverage (M_FIT_COVERAGE_MIN), which represents an estimation of how much the fitted feature must be covered by fitted edgels. The actual coverage that results from this setting depends on the scale of the image at which the feature edges were extracted, as specified with M_EXTRACTION_SCALE; a scale of 1 provides the best estimation. To set M_FIT_COVERAGE_MIN, you must specify a percentage based on the feature as a whole. For example, by specifying 80, you are indicating that approximately 80% of the entire fitted feature must be covered by fitted edgels, which also implies that the remaining parts of the feature can be gaps. As expected, the greater the minimum fit coverage, the more fitted edgels are needed to cover the feature. The default is 0%. For constructed features using a fit operation performed on multiple physically measured edgel features, the accuracy of the minimum fit coverage is based on the average of each feature's extraction scale. For physically measured or constructed arcs, circles, and segments, you can retrieve the actual coverage of the feature using MmetGetResult() with M_COVERAGE. The maximum fit iterations setting (M_FIT_ITERATIONS_MAX) allows you to set the maximum number of iterations used to compute a fitted feature. When this value is reached, the iteration process ends. A setting of one will consider all edgels/points in the fit. Settings higher than one will progressively eliminate outlying edgels (outlier edgels/points) in the fit. The more iterations, the better the fit, but the longer the calculation. By default, the number of iterations is determined automatically. Standard fit constraints When the number of outliers (outlier edgels/points) is not too significant, you should typically use standard fit mode (M_FIT_TYPE set to M_STANDARD_FIT). To control the fit calculation in this mode, you can specify M_FIT_VARIATION_MAX and M_FIT_DISTANCE_MAX, besides the common fit constraints discussed above. If the maximum fit variation setting (M_FIT_VARIATION_MAX) is reached, the iteration process can end. The maximum fit variation setting represents the maximum allowable difference in the value of the feature's underlying coefficients, from one fit iteration to the next. For example, a segment feature has 4 coefficients: the X-coordinate of its start point, the Y-coordinate of its start point, the X-coordinate of its end point, and the Y-coordinate of its end point. During each iteration, the segment's fit becomes more accurate and therefore, the values of its coefficients change and stabilize. If, for instance, the maximum fit variation setting is set to 0.05, then as soon as the difference of each coefficients' value between iterations is less than 0.05, the iteration process ends. During the iteration process with M_STANDARD_FIT, the maximum fit distance setting (M_FIT_DISTANCE_MAX) is applied. This setting limits the distance an active edgel can be from the current iterative fit for it to be considered in the next iterative fit. For example, if the first iterative fit of the iterative process includes all active edgels, one of which is farther away from the fit than the distance specified by M_FIT_DISTANCE_MAX, this edgel will not be taken into account during the next fit iteration. The higher the value of M_FIT_DISTANCE_MAX, the farther away an active edgel can be for it to be considered in the next iteration of the fit calculation. You must set this value in pixel units. The default is no maximum distance. If all the remaining edgels fall within the maximum allowable distance, they are considered as fitted edgels, provided they pass all other edgel constraints that have been set (for example, the gradient angle restrictions). Robust fit constraints When the number of outliers (outlier edgels/points) is significant and affecting the accuracy of the standard fit, you should typically use robust fit mode (M_FIT_TYPE set to M_ROBUST_FIT). To control the fit calculation in this mode, you can specify M_FIT_DISTANCE_OUTLIERS, M_FIT_DISTANCE_OUTLIERS_VALUE, and M_FIT_INTERNAL_NUMBER_OF_POINTS, besides the common fit constraints discussed above. When working in M_ROBUST_FIT mode, MIL uses the random sample consensus (RANSAC) algorithm during the fit operation. This approach repeats a two-step iteration to produce multiple candidates for the fit, from which the best is chosen. The algorithm proceeds as follows: A random subset of active edgels are selected for an initial fit. Set the number of elements in this subset with M_FIT_INTERNAL_NUMBER_OF_POINTS. The minimum number is 2 when fitting a segment and 3 when fitting a circle or an arc. These points are considered inliers (for this iteration) from the start. The remaining active edgels located within a certain distance from the fitted feature are also considered inliers and those located further away are considered outliers. To set how MIL determines the distance, use M_FIT_DISTANCE_OUTLIERS. If set to M_AUTO, the distance is automatically determined for you. If set to M_USER_DEFINED, use M_FIT_DISTANCE_OUTLIERS_VALUE to specify the distance in pixel units. MIL performs a second fit using all the inliers to improve the result. The RANSAC algorithm repeats, each time choosing a new subset for the initial fit and again performing a second fit based on inliers. Repeated random selection of initial points serves to eliminate outlier points because fits made with those points have larger errors than other fits that successfully use true inlier edgels. Note that a point can be an inlier for one iteration and an outlier for another. The robust fit process ends when the number of repeated two-step fits reaches the value set with M_FIT_ITERATIONS_MAX. The operation returns the best-fitted feature. The best-fit feature is the one with the smallest RMS error, which could be any of the fits obtained over all iterations. Note that, if the edge on which a fit is performed is somewhat indistinct or fuzzy, the default number of initial points and the default outlier distance value might not be high enough to provide a stable fit. For example, in applications where a static scene is grabbed multiple times, the result of the fit on an indistinct edge could vary slightly between each frame. Slightly increasing the M_FIT_INTERNAL_NUMBER_OF_POINTS and/or M_FIT_DISTANCE_OUTLIERS_VALUE and/or M_FIT_ITERATIONS_MAX settings could correct this instability. Copy feature edgels You can add a constructed edgel feature with the copy feature edgels operation (M_COPY_FEATURE_EDGELS) using MmetAddFeature(). When the base features are physically measured, you can build the new edgel feature using the active edgels (default), the fitted edgels, or all the edgels in the base feature's metrology region, regardless of any edgel constraints. For example, if you select the active edgels and use M_COPY_FEATURE_EDGELS with a base feature that was built using the best-fit operation for a segment, edgels that were not considered active when calculating the segment's best fit are not included in the new feature. Note that if the base features are constructed features, MIL copies all of the base feature's edgels. To select the active edgels, fitted edgels, or all edgels, use MmetControl() with M_EDGEL_TYPE set to M_ACTIVE_EDGELS, M_FITTED_EDGELS, or M_ALL_EDGELS, respectively. Note that these settings only affect the copy feature edgels build operation (M_COPY_FEATURE_EDGELS). For other build operations, each edgel constraint control must be adjusted according to your active edgel requirements. Denoising edgels To adjust edgels from rough edges and noise, you can specify a denoising mode with M_EDGEL_DENOISING_MODE. This will apply to all physically measured features and constructed edgel features. You must define a radius of neighborhood points in which the denoising is applied, with M_EDGEL_DENOISING_RADIUS. Larger radii provide stronger denoising, but can result in lost precision. The new coordinates of noisy edgels are calculated based on the specified denoising mode. There are three types of modes to select from. M_GAUSSIAN specifies to take the average point, with a weighting of all points based on the Gaussian function. The standard deviation of the Gaussian function is taken as half the neighborhood radius. M_MEAN specifies to take the mean of all provided points in the neighborhood. Finally, M_MEDIAN takes the median X and median Y of the neighborhood points. The found point is not necessarily an extracted point in the provided radius. You can draw edgels before the denoising operation was applied using M_DRAW_NOISY_EDGELS. Eliminating unwanted edgels Customizing the edge extraction algorithm Edgel and fit constraints Active edgels and fitted edgels Gradient angle Edgel selection rank Common fit constraints Standard fit constraints Robust fit constraints Copy feature edgels Denoising edgels ",
      "wordCount": 2558,
      "subEntries": []
    },
    {
      "id": "UG_metrology_Calculating_and_retrieving_results",
      "version": null,
      "title": "Calculating and retrieving results",
      "subTitles": [
        "Retrieving the results",
        "Status of features and geometric tolerances",
        "Output frame",
        "Annotating the results",
        "Template reference"
      ],
      "location": "MIL UG P03: 2D processing and analysis",
      "pageURL": "content\\UserGuide\\metrology\\Calculating_and_retrieving_results.htm",
      "text": " Calculating and retrieving results Once you have added features and geometric tolerances to the metrology template (MmetAddFeature() and MmetAddTolerance()), you can perform the Metrology operation (MmetCalculate()). If the features contained in your metrology template are purely constructed features (MmetAddFeature() with M_CONSTRUCTED), you can choose to not pass a target image to MmetCalculate() and perform calculations on the constructed features. To calculate correct results, it is important to note the calculation units (world or pixel), and the location of the reference frame (in the target image), before calling MmetCalculate(). If a camera calibration context has been associated with the target image, all tolerance and feature values (as well as metrology regions and positions) must have been set in the real-world. For more information, see the Camera calibration - overview section of Chapter 28: Calibrating your camera setup. If the position of a reference frame within the metrology template does not correspond to the same position in the target image, you must reposition the reference frame. For more information, see the Set position subsection of the Features section earlier in this chapter. By default, there is no limit set for the calculation time. However, the calculation can occasionally be unexpectedly long. To handle this, you can use MmetControl() with M_TIMEOUT to set a maximum calculation time. To check whether this limit has been reached, you can use MmetGetResult() with M_TIMEOUT_END. Once you have performed the Metrology operation, you can retrieve the results from your metrology result buffer, using MmetGetResult() with either the label of the feature or the label of the geometric tolerance. Retrieving the results Metrology offers several types of results that provide considerable feature and tolerance information. Typically, you retrieve results from your result buffer for one feature or one tolerance at a time. Examples of results that you can retrieve include: The calculation status of features and tolerances (M_STATUS). The feature's measurements (for example, M_LENGTH). The calculated tolerance value in the target image (M_TOLERANCE_VALUE). For example, the actual angle of intersection between two segments. To verify the availability of a metrology result (if it has been calculated), use MmetGetResult() and combine M_AVAILABLE to the specified result type. Status of features and geometric tolerances Two of the most critical results that you will typically retrieve are the calculation status of your features and geometric tolerances. To do so, use MmetGetResult() with M_STATUS. The status of the feature returns M_PASS if the feature was successfully validated and M_FAIL if it was not. There are many circumstances that can cause the feature to be invalid. For example, a feature is invalid if it does not exist in the specified metrology region of the target image; in this case, you might need to move the reference frame (MmetSetPosition()). A feature can also be invalid if the information provided is insufficient; this will occur, for example, if you try to construct a point of intersection between two physically measured segments that never actually cross one another. If a feature is guaranteed to fail, for example, due to its dependency on another process, you can disable the feature for calculation using MmetControl() with M_ACTIVE set to M_DISABLE. This might save you processing time. If you disable a feature, it is not calculated and the status of the feature (M_STATUS) will return M_FAIL. This is also the case for the status of all the derived features and tolerances, if any. You can re-enable the feature for calculation using MmetControl() with M_ACTIVE set to M_ENABLE. This is the default value. The status of the geometric tolerance returns M_PASS or M_WARNING if the tolerance was successfully validated and M_FAIL if it was not. Since the Metrology module provides highly sensitive measurement calculations, tolerances will fail unless they are strictly adhered. You can also use M_STATUS to retrieve a global status, which refers to the status of multiple statuses. For example, by calling MmetGetResult() with M_GENERAL and M_STATUS, you will get the global status of all the features and tolerances. This global status returns M_PASS if the status of each feature and tolerance is M_PASS. If any individual status is M_FAIL, you will get M_FAIL. If there is no individual status with M_FAIL, but one or more with M_WARNING, you will get M_WARNING. Output frame By default, feature results are returned according to the global frame, even if the feature is defined relative to a local frame. To change the frame used to return feature results (output frame), use MmetControl() with M_OUTPUT_FRAME. You can set the output frame to the feature's reference frame (M_REFERENCE_FRAME), any local frame (valid label of a local frame feature), the target image (M_IMAGE_FRAME), or the global frame (M_GLOBAL_FRAME). For example, the following image shows how the X- Y-position of a point feature can be (6,5), (3,3), or (1,1) depending on whether the output frame is set to the global frame, the local frame, or the image frame. For more information on global and local frames, see the Reference frame subsection of the Features section earlier in this chapter. Annotating the results MmetDraw() provides several operations for drawing in any specified image buffer. For example, you can draw the extracted edgels (M_DRAW_ALL_EDGELS), the active edgels (M_DRAW_ACTIVE_EDGELS), a successfully validated feature (M_DRAW_FEATURE), the features used to define a geometric tolerance (M_DRAW_TOLERANCE_FEATURES), the area used to define an area-based geometric tolerance (M_AREA_...), and the icon that represents the geometric tolerance (M_DRAW_TOLERANCE). To view the geometric tolerance icons, see the Geometric tolerances section earlier in this chapter. You can also choose to draw in the display's overlay buffer. By drawing into the display's overlay buffer, you can annotate an image non-destructively (see the Annotating the displayed image non-destructively section of Chapter 25: Displaying an image). If you are using a calibrated target image, the camera calibration is taken into account when drawing your results; that is, drawings might be distorted, according to the camera calibration. For example, a straight line in the world might be drawn as a curve in the image. MmetDraw() also allows you to draw features measured and validated in a zoomed region (of the target image from which results were obtained) by specifying the appropriate values for MgraControl() with M_DRAW_OFFSET_X, M_DRAW_OFFSET_Y, M_DRAW_ZOOM_X, and M_DRAW_ZOOM_Y control types. The relative origin values specify, in pixels, the coordinates of the center of the top-left pixel of the region in the target image, while the scale values specify the X- and Y-scaling factors used to fill the destination image buffer. When zooming, MmetDraw() will draw in the destination image buffer even if the buffer is not large enough to contain all of the zoomed image from the specified starting point. If necessary, the image will be clipped. When drawing all features or tolerances of a context, it can be difficult to visually differentiate between them if there are many. For example, some metrology contexts can have hundreds of features and tolerances, some of which you do not need to see, such as intermediate features that are only needed to build your final set of required features. To specify that a feature or tolerance in the context should not be drawn, use MmetControl() with M_DRAWABLE set to M_DISABLE. When features or tolerances are not drawn, you cannot affect them in an interactive display. Template reference A template reference is an image or result buffer that you can use as an example of a target image. Since it provides a visual sample, a template reference can help you build or modify a metrology template. To set a template reference, use MmetControl() with M_TEMPLATE_REFERENCE_ID. In this case, you can draw the results of features and tolerances extracted from that template reference. To do so, you will need to: Inquire M_TEMPLATE_REFERENCE_SIZE_X and M_TEMPLATE_REFERENCE_SIZE_Y to allocate an appropriate destination buffer. Pass the metrology context identifier to MmetDraw(). Draw the template reference (M_DRAW_TEMPLATE_REFERENCE). Draw the results. Note that the template reference does not in any way affect metrology calculations. Calculating and retrieving results Retrieving the results Status of features and geometric tolerances Output frame Annotating the results Template reference ",
      "wordCount": 1337,
      "subEntries": []
    },
    {
      "id": "UG_metrology_Using_external_edgels_and_points",
      "version": null,
      "title": "Using external edgels and points with constructed features",
      "subTitles": [
        "Adding edge chains (chained edgels)",
        "Adding chained pixels (points)"
      ],
      "location": "MIL UG P03: 2D processing and analysis",
      "pageURL": "content\\UserGuide\\metrology\\Using_external_edgels_and_points.htm",
      "text": " Using external edgels and points with constructed features It can be useful to use the Metrology module to measure features and validate tolerances based on edgels and points established using other MIL modules (or third-party applications). To do so, you can add to an M_EXTERNAL_FEATURE constructed edgel feature to a Metrology context, using MmetAddFeature() with M_EDGEL and M_EXTERNAL_FEATURE. Then, you can add a set of related edgels/points (typically chains of edgels or pixels) to the constructed feature using MmetPut(). You can perform multiple calls to MmetPut() to add multiple sets of edgels/points (edgel/pixel chains). Each call to MmetPut() maintains the information and positions of previously-added edgel/pixel chains. You can add both edgels and points to an M_EXTERNAL_FEATURE constructed edgel feature; however, to do so you must use separate calls. Use MmetInquire() to retrieve information about an external edgel feature, such as inquiring the total number of external edgels/points that were added (M_NUMBER). Adding edge chains (chained edgels) You can use MmetPut() to add edge chains to an M_EXTERNAL_FEATURE constructed edgel feature in a Metrology context. The edge chains could be established, for example, using the Edge Finder module or Model Finder module. The Edge Finder module allows you to identify and extract sets of connected edgels that make up the edges (edge chains) from a source image. Whereas, the Model Finder module allows you to retrieve the set of edgels at the occurrence of a model. You can use the Metrology module to ensure that the specified edgels comply with a required tolerance. For more information on these modules, see Chapter 8: Geometric Model Finder and Chapter 10: Edge Finder, respectively. To add edgels using MmetPut(), specify the total number of edgels you are passing, arrays containing both the X and Y-positions of your edgels, an array containing the gradient angles for each edgel, and optionally an array of chain indices that specifies to which chain the edgels belong. Information for one edgel should be at the same index position in the different arrays. Edgel Array of edge indices Array of X-coordinates Array of Y-coordinates Array of gradient angles (in degrees) 1 1 1 2 45 2 1 2 3 45 3 1 2 4 90 4 1 3 3 315 5 2 1 9 90 6 2 2 9 90 7 2 2 8 35 8 3 4 6 90 9 3 5 6 90 Adding chained pixels (points) Even if you don't know the gradient angle of a point, you can use MmetPut() to add points that fall upon an edge (chained pixels) to an M_EXTERNAL_FEATURE constructed edgel feature in a Metrology context. The chained pixels could be established, for example, using the Blob Analysis module. The Blob Analysis module allows you to identify the coordinates of all pixels bordering a blob or delimiting holes within a blob in a counterclockwise or clockwise direction. You can then analyze the shape of the blobs using the Metrology module. For more information on establishing the chained pixels on the border of blobs and their holes, see the Chained pixels subsection of the Finding the blob location and its bounding box section of Chapter 6: Blob analysis. To add chained pixels using MmetPut(), specify the total number of points you are passing, arrays containing both the X and Y-positions of your points, and optionally, an array of chain indices that specify to which chain the points belong. When adding points that lie along an edge, as is the case when using the Blob Analysis module, there is no gradient angle information to consider. In this case, you can set the control flag in MmetPut() to M_DEFAULT instead of specifying a gradient angle array. When calculating the gradient angle at different points, MmetPut() assumes that points in the arrays are consecutive, and lie along an edge. Furthermore, when calculating the gradient angle of chained pixels, M_EDGEL_RELATIVE_ANGLE must be set to M_SAME_OR_REVERSE. Information for one pixel should be at the same index position in the different arrays. An example of using the Metrology module to analyze chained pixels derived from blob contours can be found in the following example: metrologyonblobs.cpp It might also be useful to add points that are not along an edge to a Metrology context for analysis. For example, you can create a 3D profile from a depth map or point cloud and then add the resulting points using MmetPut(). For more information, see the Analyzing the profile of a 3D cross-section section of Chapter 35: 3D image processing. Using external edgels and points with constructed features Adding edge chains (chained edgels) Adding chained pixels (points) ",
      "wordCount": 768,
      "subEntries": []
    },
    {
      "id": "UG_metrology_Metrology_example",
      "version": null,
      "title": "Metrology example",
      "subTitles": null,
      "location": "MIL UG P03: 2D processing and analysis",
      "pageURL": "content\\UserGuide\\metrology\\Metrology_example.htm",
      "text": " Metrology example The metrology example Mmet.cpp defines the features and geometric tolerances of a metrology template. The template is used to calculate the features and verify the geometric tolerances on the following parts. The example also reports the status of the geometric tolerances and retrieves precise feature measurements. mmet.cpp To run this example, use the Matrox Example Launcher in the MIL Control Center. Metrology example ",
      "wordCount": 67,
      "subEntries": []
    }
  ]
}]
[{
  "id": "UG_3D_Containers",
  "version": "2024020714",
  "title": "3D Containers",
  "subTitles": null,
  "location": "MIL UG P06: 3D related information",
  "pageURL": "content\\UserGuide\\3D_Containers\\ChapterInformation.htm",
  "text": " Chapter 41: 3D Containers This chapter describes how to use 3D containers. 3D containers overview Basic concepts for 3D containers Components Component type Group, region, and source ID Component criterion Preparing a container for display or processing 3D settings for the range or disparity component Compensating for missing or ambiguous information Validating and fixing a container Requirements for a 3D-processable container Requirements for a 3D-displayable container Child containers Hooking to containers Using components individually Safe practices for working with components directly Child buffers Created components Ensuring that components are not reallocated ",
  "wordCount": 93,
  "subEntries": [
    {
      "id": "UG_3D_Containers_3D_containers_overview",
      "version": null,
      "title": "3D containers overview",
      "subTitles": null,
      "location": "MIL UG P06: 3D related information",
      "pageURL": "content\\UserGuide\\3D_Containers\\3D_containers_overview.htm",
      "text": " 3D containers overview A container is a MIL object that can contain buffers, called its components. Containers are used in MIL to hold information for a single 3D scene, whereby each component stores a different piece of information of that 3D scene. In this case it is called a 3D container. For example, a 3D-processable point cloud container contains a range component (which stores the XYZ-coordinates of each point), a confidence component (which stores the validity of each point), and might also contain an intensity component (which stores the intensity or color of each point). Containers should be used as a destination when grabbing from 3D sensors or importing 3D data, and containers with the appropriate components can be displayed and processed using MIL's 3D functions. You can allocate a container using MbufAllocContainer(). Typically, you will not need to manually allocate or free components for a container; they will be allocated and freed automatically when the container is used as a destination for a grabbing or 3D processing function. If necessary, you can allocate a component using MbufAllocComponent(), copy a buffer to an existing or new (automatically allocated) component using MbufCopyComponent(), or create a component mapped onto previously allocated memory using MbufCreateComponent(). When allocating a container, you must specify the MIL system on which to allocate it and the attributes it should have (such as M_GRAB). All image buffer components of the container will be allocated with the same attributes. When a container is no longer required, you should release it using MbufFree(). If a container has components that prevent it from being used as a source for a 3D processing function (for example, because a 3D sensor transmitted multiple range and confidence components during a grab into the container), you can create a child container with only the required components using MbufChildContainer(). The components in a child container are in the same memory as those in its parent container, so any changes made to those components will appear in both containers. You cannot directly allocate or free components of a child container. A child container therefore cannot be passed as a destination for a grab, copy, or processing function; it can, however, be passed as a source to relevant functions. 3D containers overview ",
      "wordCount": 376,
      "subEntries": []
    },
    {
      "id": "UG_3D_Containers_Basic_concepts_for_3D_containers",
      "version": null,
      "title": "Basic concepts for 3D containers",
      "subTitles": null,
      "location": "MIL UG P06: 3D related information",
      "pageURL": "content\\UserGuide\\3D_Containers\\Basic_concepts_for_3D_containers.htm",
      "text": " Basic concepts for 3D containers The basic concepts and vocabulary conventions when dealing with 3D containers are: Container. A MIL object that contains one or more buffers, called its components. 3D Container. A container that stores 3D data in a format supported by MIL. Component. A buffer that has been allocated in a container. Child container. A container that references a subset of the components of a parent container. The contents of a child container are determined dynamically when the parent container changes by applying a filter to its components based on a list of criteria, specified when the child container is allocated. 3D settings. The component settings that affect how 3D data in a range or disparity component is interpreted during conversion to a 3D-processable or 3D-displayable container. These settings are listed in For inquiring about settings that apply only to components. Component type. The component setting which indicates what type of information the component stores. Point cloud container. A container that stores a point cloud in a format supported by MIL (either for 3D-processing, 3D-display, or conversion). 3D-processable container. A 3D container that can be passed as a source to MIL 3D processing functions. You can inquire if a container is 3D-processable using MbufInquireContainer() with M_3D_PROCESSABLE. 3D-displayable container. A 3D container that can be selected to a MIL 3D display. You can inquire if a container is 3D-displayable using MbufInquireContainer() with M_3D_DISPLAYABLE. Range Component. A component with the component type M_COMPONENT_RANGE. A range component stores the coordinates of the points of a point cloud, or the depths of the pixels of a depth map. Disparity Component. A component with the component type M_COMPONENT_DISPARITY. A disparity component stores the apparent distance (typically measured in pixel units) between where an object appears in the left and right images captured by a stereoscopic camera. Intensity Component. A component with the component type M_COMPONENT_INTENSITY. An intensity component stores a standard image. Reflectance Component. A component with the component type M_COMPONENT_REFLECTANCE. A reflectance component stores the intensity of reflected light for each point or pixel of the range or disparity component. Basic concepts for 3D containers ",
      "wordCount": 355,
      "subEntries": []
    },
    {
      "id": "UG_3D_Containers_Components",
      "version": null,
      "title": "Components",
      "subTitles": [
        "Component type",
        "Group, region, and source ID",
        "Component criterion"
      ],
      "location": "MIL UG P06: 3D related information",
      "pageURL": "content\\UserGuide\\3D_Containers\\Components.htm",
      "text": " Components The buffers in a container are called its components. In most respects, components are no different from other buffers allocated using the MbufAlloc...() functions. Components have their own MIL buffer identifier and can be used with MIL functions that take a buffer. However, components are allocated and freed differently from other buffers. Typically, when a container is used as a destination for a grabbing or 3D processing function, that function will allocate and free the components automatically as required. You can allocate components manually using MbufAllocComponent(), MbufCopyComponent(), or MbufCreateComponent(). If you need to free components manually, use MbufFreeComponent() or free the container using MbufFree(). Component type Each component has a component type, which indicates the type of information stored in the component. For example, a component with the component type M_COMPONENT_RANGE stores 3D coordinates when the container stores a point cloud. MIL uses the component type to determine what type of information a component stores about the points in a point cloud container. Typically, a component's component type is set automatically during acquisition. You can set a component's component type manually using MbufControlContainer() with M_COMPONENT_TYPE. Group, region, and source ID If you grab data from a 3D sensor that transmits data in a format suitable for grabbing into a container, it might assign each component a group, region, and/or source ID number. Typically, components which have the same group, region, or source ID are associated in some way; for example, if your 3D sensor transmits the range and confidence components for multiple 3D scenes in a single grab, each set of components might have a different group ID. These component ID numbers can be inquired using MbufInquireContainer() with M_COMPONENT_GROUP_ID, M_COMPONENT_REGION_ID and M_COMPONENT_SOURCE_ID respectively. You can create a child container that contains only the components of a single group, using MbufChildContainer() with M_COMPONENT_BY_GROUP_ID(). You can then call MbufConvert3d() with the child container to convert the 3D data to a 3D-processable point cloud container. Your 3D sensor might transmit group, region, and source IDs that are not sequential. Refer to your 3D sensor manual to determine what ID numbers it will assign to components. Component criterion Some functions, such as MbufFreeComponent(), allow you to perform operations on the components of a specified container (such as freeing those components) by specifying a criterion. In some cases, these criteria (such as M_COMPONENT_BY_INDEX()) can only refer to a single component in the container. In other cases they can potentially refer to several components in the container (such as M_COMPONENT_INTENSITY, which specifies all intensity components in the container). By default, 3D functions only apply the operation to core components of a 3D-processable container. These components include the range, confidence, reflectance, normals, intensity, and mesh; for more information, see MbufInquireContainer() with M_3D_PROCESSABLE. Some functions (such as M3dimMerge()) allow you to apply the operation to all components, including custom components (M_COMPONENT_CUSTOM + n), if you specify M_APPLY_TO_ALL_COMPONENTS. The components must have the same dimensions as M_COMPONENT_RANGE; otherwise, they will be copied to the destination container unmodified. Note that if a custom component has an associated calibration context, the component's information is modified/copied, but its calibration context is discarded. Some functions, such as MbufInquireContainer(), require that you specify a criterion that identifies only a single component in the container. For these functions, an error will be generated if there is more than one component in the container that meets the specified criterion. Components Component type Group, region, and source ID Component criterion ",
      "wordCount": 576,
      "subEntries": []
    },
    {
      "id": "UG_3D_Containers_Preparing_a_container_for_display_or_processing",
      "version": null,
      "title": "Preparing a container for display or processing",
      "subTitles": [
        "3D settings for the range or disparity component",
        "Compensating for missing or ambiguous information",
        "Validating and fixing a container",
        "Requirements for a 3D-processable container",
        "Requirements for a 3D-displayable container"
      ],
      "location": "MIL UG P06: 3D related information",
      "pageURL": "content\\UserGuide\\3D_Containers\\Preparing_a_container_for_display_or_processing.htm",
      "text": " Preparing a container for display or processing Your 3D sensor might transmit 3D information in a format that is not natively displayable or processable by MIL. For example, MIL can only process containers that have a range component with a particular structure, but your 3D sensor might be a stereoscopic camera that transmits a disparity component. You can use MbufConvert3d() to convert grabbed 3D data to a 3D-processable and/or 3D-displayable point cloud container. This function also applies some modifications to the coordinates transmitted by your 3D sensor, such as scaling or offsetting all coordinates by a specified value to convert the 3D data to natively calibrated coordinates. Typically, if your 3D sensor is compliant (transmits data suitable for grabbing into a container), you do not need to modify grabbed data before making it 3D-processable or 3D-displayable using MbufConvert3d(). If your 3D sensor transmits several sets of 3D components, you might need to create a child container that contains only a single set of 3D components before converting the data (for more information, see the Child containers section later in this chapter). If your 3D sensor does not transmit required 3D settings for the range or disparity component, you must set those before converting the data. 3D settings for the range or disparity component When you pass a 3D container as a source to MbufConvert3d(), 3D settings in the range or disparity component are applied to the 3D data. For example, the X-coordinates of all points in the destination point cloud container are offset by the value specified by the M_3D_OFFSET_X setting. Additionally, some settings (such as M_3D_REPRESENTATION) must be set to convert the data. The 3D settings are listed in For specifying settings useful with components that store 3D data. If the M_3D_REPRESENTATION setting of your range or disparity component indicates a uniform distribution of X and/or Y values (for example, M_CALIBRATED_Z_UNIFORM_XY), you should specify M_3D_SCALE_X and/or M_3D_SCALE_Y to produce natively calibrated coordinates. Scale settings are not exclusively used with uniform 3D representations; coordinates are always scaled using these settings during conversion, regardless of how those coordinates are stored. If you are grabbing 3D data from a 3D profile sensor or linescan device that is not perpendicular to the conveyor belt, you can compensate for the angle using the M_3D_SHEAR_X and M_3D_SHEAR_Z settings. For example, if your conveyor belt slopes downward relative to your 3D sensor, you can specify an M_3D_SHEAR_Z to offset the Z values in each slice from those in the previous slice by a set amount. Note that the resulting point cloud will be slanted; for more information, see the Pitch subsection of the Correcting for 3D profile sensor placement section of Chapter 42: Grabbing from 3D sensors. For a disparity component, the disparity-specific 3D settings must be set (using MbufControlContainer() with M_3D_DISPARITY_...). Refer to your camera manual for the correct values. Note that MbufConvert3d() does not perform unit conversions; the source value for M_3D_DISTANCE_UNIT is always propagated to the destination without changes to the underlying data. Compensating for missing or ambiguous information In some cases, you might grab 3D data that is missing required information. For example, you might grab a range component with M_3D_REPRESENTATION set to M_CALIBRATED_Z. This 3D representation means that the underlying data has no specified X or Y-coordinates. By default, you cannot convert this container using MbufConvert3d() because the container is missing information. You can set the ControlFlag parameter to M_COMPENSATE flag to specify that you want MIL to convert the data by making assumptions. In the example above, the range component will be treated as though it has the 3D representation M_CALIBRATED_Z_UNIFORM_XY. You can use M_COMPENSATE to compensate for the following ambiguities in the source container: The M_3D_REPRESENTATION of the range or disparity component indicates that the coordinates for at least one axis are unspecified. There is no confidence information. Confidence information can be stored in a confidence component, or in the Z-axis values of the range or disparity component when M_3D_INVALID_DATA_FLAG is set to M_TRUE. There is more than one confidence, intensity/reflectance, mesh, or normals component. Note that you cannot compensate for having a container with more than one range or disparity component. You can free the extraneous components using MbufFreeComponent(), or allocate a child container to filter out the extraneous components using MbufChildContainer(). At least one component is incorrectly formatted. To learn the correct formatting for each component, see the Layout of data in a component subsection of the Working with non-compliant cameras section of Chapter 42: Grabbing from 3D sensors. Validating and fixing a container For successful processing and analysis of a point cloud container, some of its components must meet specific conditions. You can use M3dimFix() to validate whether a container satisfies certain conditions and optionally fix them if they are not met. If you pass a destination container to the function, you can obtain a modified copy of the source container that satisfies the specified conditions. Available conditions to verify and fix include: That each edge in a mesh is shared between at most two triangular faces, and that no triangular face is degenerate (M_MESH_VALID_NEIGHBORS). That each point in a mesh is valid (M_MESH_VALID_POINTS); valid points have a non-zero confidence score. That each point with a non-zero confidence has a normal vector value of exactly one or zero (M_NORMALS_NORMALIZED). That each point has a finite normal vector (M_NORMALS_FINITE). That each point in a range component is finite (M_RANGE_FINITE). That each point with a non-zero confidence is unreplicated (M_UNREPLICATED_POINTS). Note that, depending on your 3D sensor software, infinite values are sometimes assigned to invalid points. For example, an infinite value might be assigned to an invalid point's Z-coordinate in its range component, or to its normal vector in the normals component. Such values can cause errors with other 3D image processing functions. You can use M3dimFix() to replace infinite values with the value used to indicate missing data (M_3D_INVALID_DATA_VALUE). Note that you can combine values to validate multiple conditions in a single call to M3dimFix(), or you can specify to verify all conditions (M_ALL). Any specified condition is available only if the related component is present in the source container. Requirements for a 3D-processable container For a container to be 3D-processable, it must have the attribute M_PROC in addition to one (at most) of each of the following components: Component type Required Bands Data type Other Settings M_COMPONENT_RANGE Yes 3 Floating point M_3D_REPRESENTATION set to M_CALIBRATED_XYZ or M_CALIBRATED_XYZ_UNORGANIZED. All 3D settings (from the table For specifying settings useful with components that store 3D data) set to their default, except for M_3D_DISTANCE_UNIT which can have any setting. M_COMPONENT_CONFIDENCE Yes 1 8-bit unsigned The same M_SIZE_X and M_SIZE_Y as the range component. M_COMPONENT_INTENSITY or M_COMPONENT_REFLECTANCE (not both) No 1 or 3 8-bit unsigned or 16-bit unsigned The same M_SIZE_X and M_SIZE_Y as the range component. M_COMPONENT_NORMALS_MIL No 3 Floating point The same M_SIZE_X and M_SIZE_Y as the range component. M_COMPONENT_MESH_MIL No 1 32-bit unsigned If the range component has M_3D_REPRESENTATION set to M_CALIBRATED_XYZ, M_SIZE_Y must be 6. If the range component has M_3D_REPRESENTATION set to M_CALIBRATED_XYZ_UNORGANIZED, M_SIZE_Y must be 3 or 6. By default, any components with a component type not included in the table above will be propagated, but not used, by 3D processing functions and MbufConvert3d(). Some functions (such as M3dimMerge()) allow you to apply the operation to all components, including custom components, if you specify M_APPLY_TO_ALL_COMPONENTS. The components must have the same dimensions as M_COMPONENT_RANGE; otherwise, they will be copied to the destination container unmodified. You can determine whether a container is 3D-processable using MbufInquireContainer() with M_3D_PROCESSABLE. Requirements for a 3D-displayable container Any container with the M_DISP attribute that can be passed as a source to MbufConvert3d() (with M_COMPENSATE) is 3D-displayable. A conversion will occur each time the container is modified, unless you convert the container to a format that is natively 3D-displayable. Automatic conversion is primarily useful for displaying 3D data as it is being grabbed. The requirements for a container to be natively 3D-displayable are the same as the requirements for a container to be 3D-processable, except that the M_DISP attribute is required. You can determine whether a container is 3D-displayable using MbufInquireContainer() with M_3D_DISPLAYABLE. Preparing a container for display or processing 3D settings for the range or disparity component Compensating for missing or ambiguous information Validating and fixing a container Requirements for a 3D-processable container Requirements for a 3D-displayable container ",
      "wordCount": 1399,
      "subEntries": []
    },
    {
      "id": "UG_3D_Containers_Child_containers",
      "version": null,
      "title": "Child containers",
      "subTitles": null,
      "location": "MIL UG P06: 3D related information",
      "pageURL": "content\\UserGuide\\3D_Containers\\Child_containers.htm",
      "text": " Child containers A child container is a MIL object that behaves similarly to a normal container, but refers to components in another container. Child containers are useful when you need a container that has a subset of another container's components (for example, when your 3D sensor transmits multiple sets of 3D components in a single grab). A child container is not allocated in its own memory space; its components remain part of the parent container. Any modifications to data or settings of the components in the child container affect the components in the parent and vice versa. A child container inherits its attributes (such as M_PROC) from the parent container. Depending on your application, instead of using a child container you can free the components you don't need from a container using MbufFreeComponent(), or copy the components you do need to another container using MbufCopyComponent(). When you allocate a child container (using MbufChildContainer()), you must specify one or more criteria to determine the child container's contents. The contents of the child container are dynamically updated any time the parent container is modified, using the specified criteria as a filter. For example, if you allocate a child container with the criteria M_COMPONENT_BY_GROUP_ID() of a parent container that has no components, the child container will also have no components. If you subsequently grab into the parent container, MIL will include any grabbed components with the specified group ID in the child container. When a child container is no longer required, it can be released using MbufFree(). Before a container can be freed, all of its child containers must also be freed. A container can have any number of child containers. Additionally, a child container can itself have child containers. The latter might be useful for filtering the parent container multiple times. For example, you can first allocate a child container that contains all components (of the ultimate parent container) in group 2, then allocate a child of that container which contains only the range and intensity components. Because the first child container only contains the components from group 2, the second child container. You can determine a child container's direct parent using MbufInquireContainer() with M_PARENT_ID, and its ultimate parent using M_ANCESTOR_ID. You cannot directly allocate or free components of a child container. A child container therefore cannot be passed as a destination for a grab, copy, or processing function; it can, however, be passed as a source to relevant functions. For example, you can pass a child container as a source to MbufConvert3d(), but you cannot pass it as a destination (because MbufConvert3d() might allocate or free components in the destination container to make it 3D-processable). Child containers ",
      "wordCount": 448,
      "subEntries": []
    },
    {
      "id": "UG_3D_Containers_Hooking_to_containers",
      "version": null,
      "title": "Hooking to containers",
      "subTitles": null,
      "location": "MIL UG P06: 3D related information",
      "pageURL": "content\\UserGuide\\3D_Containers\\Hooking_to_containers.htm",
      "text": " Hooking to containers You can hook a callback function to changes in a container using MbufHookFunction(). You can choose to hook to either the container itself, or to all components of the container individually (including components allocated in the future). For more information about hook-handler functions in general, see the Event handling in MIL with hook-handler functions section of Chapter 2: Building an application. If you hook to the container itself, the callback function will be called after any MIL function that modifies at least one of its components, adds or removes a component, or uses the container as a destination (even if the container is not modified). Using MbufGetHookInfo() with M_MODIFIED_BUFFER within the callback function will return the identifier of the container. The callback function will never be called more than once for a single MIL function call. If you hook to all components of the container (by specifying M_ON_COMPONENT), the callback function will be called after any MIL function that modifies one of those components (including allocating or freeing the component). Using MbufHookFunction() with M_MODIFIED_BUFFER within the callback function will return the identifier of the component. If a single function modifies multiple components of the container (for example, if the container is a destination for a 3D processing function that modifies or frees multiple components), the callback function will be called once for each modified component. If you manually specify that a container has been modified (using MbufControlContainer() with M_MODIFIED), MIL will also call functions hooked to the container's components. If you do this for a child container, MIL will also call functions hooked to the parent container(s). Hooking to containers ",
      "wordCount": 275,
      "subEntries": []
    },
    {
      "id": "UG_3D_Containers_Using_components_individually",
      "version": null,
      "title": "Using components individually",
      "subTitles": [
        "Safe practices for working with components directly",
        "Child buffers",
        "Created components",
        "Ensuring that components are not reallocated"
      ],
      "location": "MIL UG P06: 3D related information",
      "pageURL": "content\\UserGuide\\3D_Containers\\Using_components_individually.htm",
      "text": " Using components individually Typically, you will not need to access the components of a 3D-processable point cloud container directly. Most 3D processing and analysis functionality that your application will require can be achieved using MIL 3D processing functions to perform operations on the container as a whole. There are advanced use-cases for accessing components directly, such as altering the confidence component to limit a processing operation to a particular set of points, or displaying grabbed 3D data as an image in a 2D display. Because a component is a MIL buffer, you can inquire its MIL identifier (using MbufInquireContainer() with M_COMPONENT_ID). You can then use the component with any MIL function that takes a buffer. This feature can be a powerful tool, for example allowing you to process 3D data using 2D processing functions (such as thresholding the Z-coordinates stored in the range component using MimClip()), or analyze 3D data using 2D analysis functions (such as performing blob analysis on the Z-coordinates stored in the range component using MblobCalculate()). Manipulating components directly also means taking on additional responsibility in your application, because MIL can no longer guarantee that 3D-processable containers will remain 3D-processable. To learn the required layout of data in a buffer depending on its component type, see the Working with non-compliant cameras section of Chapter 42: Grabbing from 3D sensors. Safe practices for working with components directly MIL functions that work with a container might free and reallocate components. You should therefore not depend on the MIL identifier of a component remaining static in your application. Typically, you should re-inquire a component's MIL identifier after calling any MIL function that uses the container as a destination. You should also assume that any changes you have made to the buffer (such as controlling settings or assigning an ROI) will not be retained. The following will not be kept if a component is freed and reallocated: Calibration. Hooked functions. LUT associations. Regions of interest. Settings (including 3D settings). Memory address. If a component that has been selected to a 2D display is freed and reallocated, by default MIL will automatically select the newly allocated component to the 2D display. You can disable this behavior using MappControl() with M_COMPONENT_AUTO_RESELECT and M_COMPONENT_AUTO_RESELECT_DISABLE. Child buffers Typically, you should not create child buffers of components. Doing so can lead to undefined behavior. If you need to create a child buffer of a component, you should free the child buffer before calling any MIL function that might free or reallocate components in the container. Created components If you created a component mapped to user-allocated memory using MbufCreateComponent(), and that component is reallocated because the container is used as a destination for a MIL function, the newly allocated component is no longer mapped to the specified memory. You are responsible for freeing the underlying memory after the mapped component is freed or reallocated by MIL. Ensuring that components are not reallocated In some cases, you might need to ensure that a component of a container is not reallocated. For example, when grabbing images from a non-compliant 3D sensor that transmits 3D data in a standard image stream, you might grab directly into a component (as opposed to grabbing into its container), or grab into a non-component image buffer and use MbufCreateComponent() to create components mapped onto that buffer. In these cases, typically you need the components to keep the same MIL identifier, attributes, and other settings. MIL will only automatically free or reallocate components when required to store the output of a MIL function. Therefore, the best way to ensure that components are not freed or reallocated is to avoid using the container as a destination for any MIL function. If you need to use the container as a destination (for example, to perform in-place processing), you should copy the components into another container using MbufCopyComponent(). If you need to convert the data to be 3D-processable, you can perform both operations at the same time using MbufConvert3d(). When grabbing into a container (as opposed to grabbing into an individual component), MIL grab functions (such as MdigGrab()) free all components of the container, even if those components are the correct size and type to hold the transmitted components. In some cases, components automatically allocated by a MIL grab function will be reused for subsequent grabs. Using components individually Safe practices for working with components directly Child buffers Created components Ensuring that components are not reallocated ",
      "wordCount": 740,
      "subEntries": []
    }
  ]
}]
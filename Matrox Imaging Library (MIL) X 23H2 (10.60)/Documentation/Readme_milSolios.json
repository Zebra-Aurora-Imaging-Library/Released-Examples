[{
  "id": "Readme_milSolios",
  "version": "2023100322",
  "title": "milSolios",
  "wordCount": 0,
  "subEntries": [
    {
      "id": "Readme_milSolios_milSolios",
      "title": "milSolios",
      "location": "MIL Release Notes",
      "pageURL": "\\milSolios\\milSolios.htm",
      "text": " Matrox Imaging Library (MIL) 10 Update 78 Matrox Solios release notes March 2018 ?(c) Copyright Matrox Electronic Systems Ltd., 1992-2018. &nbsp; This document outlines what is new with MIL for Matrox Solios and explains the current limitations and particularities when using MIL with Matrox Solios. It also presents last minute information that did not make it into the manual or on-line help. Note that this text file serves to complement your manual. The information found in this file overrides your formally documented material. Contents 1.???? MIL 10 Driver for Matrox Solios 1.1.1????? Differences between MIL 10 Update 78 and MIL 10 1.1.2????? Differences between MIL 10 and MIL 9 Update 43 1.1.3????? Differences between MIL 9 Update 43 and MIL 9 Update 5 1.1.4????? Differences between MIL 9 Update 5 and MIL 9 Update 4 1.1.5????? Differences between MIL 9 Update 4 and MIL 9 1.1.6????? Differences between MIL 9 and MIL 8 Update 16 1.2???????? What?s new in MIL 10 Update 78 1.2.1????? Standards compliance for Matrox Solios Camera Link family 1.2.2????? New features summary 1.2.3????? Additions to the command reference 1.2.4????? Behavior changes 1.2.5????? Bug fixes 1.2.6????? Known limitations and particularities 2.???? Location of examples (in the help file) &nbsp; 1.&nbsp;&nbsp; MIL 10 Driver for Matrox Solios 1.1.1&nbsp;&nbsp;&nbsp; Differences between MIL 10 Update 78 and MIL 10 Removed Windows? XP support. Improvements in the feature browser?s interface. New set of inquires for GenICam feature enumeration. Various bug fixes and improvements. 1.1.2&nbsp;&nbsp;&nbsp; Differences between MIL 10 and MIL 9 Update 43 ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Support for Microsoft? Windows? 8. ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MIL 10 has a new mechanism to control and inquire IO signals. It has unified some concepts under the M_IO_... constants of MdigControl/MdigInquire and generalized others that were being used for more than their original purpose (for example, M_GRAB_EXPOSURE_... to M_TIMER_...). For the correlation between old and new MIL constants, refer to the MilSoliosCameraLinkIOConversionTable and MilSoliosAnalogIOConversionTable release notes. 1.1.3&nbsp;&nbsp;&nbsp; Differences between MIL 9 Update 43 and MIL 9 Update 5 ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Updated the MilConfig tool to support selection for the amount of memory mapped on-board the Solios. This is useful to reduce the amount of memory mapped on the PCI/PCIe bus. The unmapped memory is still available for acquisition. ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Added support for GenICam? for Camera Link? (CLProtocol). Requires third party CLProtocol communication DLL supplied by the camera vendor. ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Updated the Intellicam tool to support a Feature Browser for Camera-Link?. ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Updated the MilConfig tool to support GenICam? for Camera Link? default parameters. ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Added clprotocol.cpp Solios specific example. Demonstrates the use of GenICam? for Camera Link? CLProtocol. Enables the use of MdigControlFeature() and MdigInquireFeature() to control camera features (parameters) as well as the feature browser dialog window. ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Added support for MdigControlFeature() and MdigInquireFeature(). See the MIL documentation for details. ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Added support for the new Solios eV-CL with MDR26 Camera Link? connectors (SOL2MEVCLBL* and SOL2MEVCLFL*). ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Fixed error: &quot;Error MdigProcess(): the command was aborted.&quot; This error could have occurred after calling MdigProcess and M_STOP without M_WAIT. ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Fixed a glitch that could have occurred when timers were used in continuous mode. ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Updated the analog firmware to fix an acquisition problem. &nbsp; Additions to MdigControl(): ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; M_GC_CLPROTOCOL: Controls the activation of GenICam? for Camera? Link? CLProtocol. Values: -&nbsp;&nbsp;&nbsp; M_ENABLE: Enables GenICam? for Camera Link? (CLProtocol). A Device ID template must be specified prior to enabling CLProtocol. See M_GC_CLPROTOCOL_DEVICEID. &nbsp; ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; M_GC_CLPROTOCOL_DEVICEID: Specifies the GenICam? for Camera Link? (CLProtocol) device ID template, which must match the camera connected to the Solios card. The installed device IDs can be inquired by calling MdigInquire() with M_GC_CLPROTOCOL_DEVICEID+n. See clprotocol Solios-specific example for more details. Values: -&nbsp;&nbsp;&nbsp; A MIL_TEXT_PTR string representing the GenICam? for Camera Link? (CLProtocol) device ID template. &nbsp; ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; M_GC_FEATURE_BROWSER: Opens the device feature browser dialog from a MIL console application. Supported control values are: Values: -&nbsp;&nbsp;&nbsp; M_DEFAULT: Opens the feature browser dialog. The calling thread is blocked. -&nbsp;&nbsp;&nbsp; M_OPEN+M_SYNCHRONOUS: same as M_DEFAULT. -&nbsp;&nbsp;&nbsp; M_OPEN+M_ASYNCHRONOUS: Opens the feature browser dialog. The calling thread returns as soon as the feature browser is created. -&nbsp;&nbsp;&nbsp; M_CLOSE: Closes the feature browser dialog. &nbsp; Additions to MdigInquire(): ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; M_GC_CLPROTOCOL: Returns information regarding activation of GenICam? for Camera Link? CLProtocol. Values: -&nbsp;&nbsp;&nbsp; M_ENABLE: GenICam? for Camera Link? CLProtocol is active. -&nbsp;&nbsp;&nbsp; M_DISABLE: GenICam? for Camera Link? CLProtocol is not active. ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; M_GC_CLPROTOCOL_DEVICEID_NUM: Returns a MIL_INT, representing the number of installed GenICam? for Camera Link? device ID templates. ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; M_GC_CLPROTOCOL_DEVICEID_SIZE_MAX: Returns a MIL_INT, representing the maximum string length required to store the device ID templates. ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; M_GC_CLPROTOCOL_DEVICEID+n: Returns a MIL_TEXT_PTR string, representing the nth GenICam? for Camera Link? device ID template installed. &nbsp; 1.1.4&nbsp;&nbsp;&nbsp; Differences between MIL 9 Update 5 and MIL 9 Update 4 ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Added a setting in MilConfig-&gt;Boards-&gt;Solios to control the amount of on-board physical memory visible on the PCI bus. ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Improved speed when calculating Bayer white balance coefficients on the Matrox Solios eV/eM-CLB. ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Improved transfer speed of color images to an M_PLANAR host destination with the Matrox Solios eV/eM-CLB. ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Added support of host M_RGB24 planar buffers when grabbing from a Bayer camera on the Matrox Solios eV/eM-CLB. ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Added support for 6 taps 8-bit acquisition modes. ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Added support for 4 taps 8-bit time multiplex cameras. &nbsp; Additions to MsysInquire(): &nbsp; ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; M_FIRMWARE_BUILDDATE: Returns the date when the grab firmware was built. ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; M_FIRMWARE_REVISION_GRAB: Returns the revision number of the grab firmware. ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; M_FIRMWARE_BUILDDATE_PROCESSING: Returns the date when the processing firmware was built. ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; M_FIRMWARE_REVISION_PROCESSING: Returns the revision number of the processing firmware. &nbsp; Additions to MdigControl() and MdigInquire(): &nbsp; ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; M_CAMERA_POWER: Controls the power sent to PoCL (Power over Camera-Link) cameras. Values: -&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; M_ON: Enable PoCL mechanism. -&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; M_OFF: Disable PoCL mechanism. -&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; M_DEFAULT: Same as M_ON. &nbsp; Various bug fixes: ?????? ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Fixed issue where MdigControl commands could have been executed immediately instead of being queued (REF: 116199). ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Fixed MdigGetHookInfo state for user bits. M_ON is always returned since it is the only possible value (REF: 113694). ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Fixed memory leak with MdigLut() (REF: 108109). ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Fixed Bayer support when grabbing in RGB24 packed host buffers (REF: 107972). ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Added more detailed error messages when setting invalid exposure values (REF: 107659). ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Fixed issue when grabbing simultaneously from 2 independent acquisition paths. Using MdigFree on one of the paths could have affected the other path (REF: 107410). ?????????? Updated firmwares: &nbsp; ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Matrox Solios eV-CLB ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Firmware file name: Soliosclem.firmware. ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Updated to build id: A90D0C0B, Snap version: 4_94. ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Improved performance of DMA operations. ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Fixed issues with hardware Bayer when grabbing at high bandwidth. ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Fixed issues when grabbing from multi-tap Bayer cameras. ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Added support of 3 DMA contexts to support RGB planar buffers. &nbsp; ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Matrox Solios eV-CLF ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Firmware file name: Soliosclemf.firmware. ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Updated to BuildId: A90A0C0F, Snap version: 4_94. ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mproved performance of DMA operations.?? 1.1.5&nbsp;&nbsp;&nbsp; Differences between MIL 9 Update 4 and MIL 9 ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Added support of Matrox Solios eM-CL and Matrox Solios eV-CL. ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Matrox Solios eV-CLB and Matrox Solios eM-CLB supports automatic Bayer conversion when grabbing from a camera that has a Bayer color filter (as specified by the DCF). &nbsp; -&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; To make use of this feature, use MdigControl() with M_BAYER_CONVERSION enabled. During conversion, the image can be white balanced if white balancing is enabled using MdigControl() with M_WHITE_BALANCE. &nbsp; -&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; The white balance coefficients can be set explicitly using MdigControl() with M_BAYER_COEFFICIENTS_ID or calculated automatically using MdigControl() with M_WHITE_BALANCE set to M_CALCULATE. &nbsp; -&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; The M_BAYER_... control types can only be used when grabbing from a camera that has a Bayer color filter (as specified by the DCF), otherwise an error will be generated. &nbsp; ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Reduced internal non-paged memory utilization.??????? 1.1.6&nbsp;&nbsp;&nbsp; Differences between MIL 9 and MIL 8 Update 16 ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Added support for MIL 9. ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MbufCopy(): The DMA transfer line count is not limited to 4095 lines anymore. 1.2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; What?s new in MIL 10 Update 78 Note that MIL 10 Update 78 is a cumulative update, including all content from MIL 10. 1.2.1&nbsp;&nbsp;&nbsp; Standards compliance for Matrox Solios Camera Link family ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Camera Link? version 2.0. ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GenICam? standard version 3.0.2. ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GenICam? for Camera Link? (CLProtocol). Note that this requires a third-party CLProtocol communication library (DLL) which is supplied by the camera vendor. ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GenICam? GenCP Camera Link Module version 1.0. 1.2.2&nbsp;&nbsp;&nbsp; New features summary ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Many bug fixes and improvements in the feature browser?s interface. ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Added support or IO redirection on CC bits. ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [Solios eA/XA only] New firmware which adds: o&nbsp;&nbsp;&nbsp; A second pre-scaler on the timer trigger. o&nbsp;&nbsp;&nbsp; The possibility to trigger the grab or a timer of any acquisition path using the rotary encoder of acquisition path 0. o&nbsp;&nbsp;&nbsp; The possibility to trigger the grab or a timer on acquisition path 0 using the rotary encoder of acquisition path 1. o&nbsp;&nbsp;&nbsp; Slow scan acquisition. ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [Solios eA/XA only] Added MsysInquire(M_COUPLING_MODE) which returns M_AC or M_DC. 1.2.3&nbsp;&nbsp;&nbsp; Additions to the command reference Added MdigInquire (M_COUPLING_MODE) which returns M_AC or M_DC. Additions to MdigControlFeature()/MdigInquireFeature() Support for M_FEATURE_ENUM_ENTRY_TOOLTIP + N MdigInquireFeature(). Returns the nth enum entry?s tooltip string. The string size can be inquired by adding the M_STRING_SIZE combination constant. Support for M_FEATURE_ENUM_ENTRY_DESCRIPTION + N MdigInquireFeature(). Returns the nth enum entry?s description string. The string size can be inquired by adding the M_STRING_SIZE combination constant. Support for M_FEATURE_ENUM_ENTRY_ACCESS_MODE + N MdigInquireFeature(). Returns the nth enum entry?s access mode. See M_FEATURE_ACCESS_MODE in the MIL documentation for details. Support for M_FEATURE_ENUM_ENTRY_VISIBILITY + N MdigInquireFeature(). Returns the nth enum entry?s visibility value. See M_FEATURE_VISIBILLITY in the MIL documentation for details. Support for M_FEATURE_ENUM_ENTRY_CACHING_MODE + N MdigInquireFeature(). Returns the nth enum entry?s caching mode. See M_FEATURE_CACHING_MODE in the MIL documentation for details. Support for M_FEATURE_ENUM_ENTRY_STREAMABLE + N MdigInquireFeature(). Returns the nth enum entry?s streamable value. See M_FEATURE_STREAMABLE in the MIL documentation for details. Support for M_FEATURE_SELECTOR_COUNT MdigInquireFeature(). Returns the number of features selected by the specified FeatureName parameter. Note that the FeatureName parameter must specify a selector type feature. Support for M_FEATURE_SELECTOR_NAME + N MdigInquireFeature(). Returns the nth feature name, as a string, selected by the specified feature. Note that the FeatureName parameter must specify a selector type feature. Support for M_FEATURE_VALID_VALUE_COUNT MdigInquireFeature(). Integer and floating point type features can support a fixed list of valid values instead of the traditional minimum, maximum and increment values. M_FEATURE_VALID_VALUE_COUNT returns the number of valid values supported. A value of 0 returned indicates the feature does not support a list of valid values; minimum, maximum and increment values must be used instead. Support for M_FEATURE_VALID_VALUE + N MdigInquireFeature(). Returns the nth valid value for an integer of floating point type feature. 1.2.4&nbsp;&nbsp;&nbsp; Behavior changes ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; When dealing with a DCF for a multi-tap camera that divides its image into multiple regions, and the camera sends multiple adjacent pixels per region along the Y-axis, the ordering behavior of the regions and adjacent pixels has changed. Instead of enumerating the regions along the X-axis before the adjacent pixels along the Y-axis, the adjacent pixels along the Y-axis are enumerated before regions along the X-axis. To use the previous ordering behaviour, load the DCF in Matrox Intellicam and adjust the enumeration of regions and adjacent pixels on the Tap Configuration tab of the DCF dialog. When dealing with a DCF that does not fit the above-mentioned requirement, the order has not changed. The following is an example of dealing with the ordering behavior for a 4-tap DCF: 1.2.5&nbsp;&nbsp;&nbsp; Bug fixes ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Fixed issue when setting M_ROTARY_ENCODER_POSITION_TRIGGER to a value higher then 0x8000000 on a 32bit OS. ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Fixed parameter checking error with M_GRAB_TRIGGER_SOURCE. ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Fixed possible blue-screen when allocating a 4 tap DCF on a camera link single base board. ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Fixed issue with MdigHookFunction(M_GRAB_START) when grabbing with MdigGrabContinuous. ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [Solios eA/XA only] Fixed issue when using a slow scan camera. ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [Solios eA/XA only] Fixed issue with MdigControl(M_CHANNEL) set to M_DEFAULT to use the value set in the DCF. &nbsp; 1.2.6&nbsp;&nbsp;&nbsp; Known limitations and particularities Windows? automatic 8.3 file name creation needs to be enabled in order for the MIL installer to access the temp folder when the user name contains a space. This option allows Windows to create short file/folder name aliases for ones with long names for programs, such as the MIL installer, that don't support spaces in the file/folder names. Alternatively, the MIL installer needs to run from a user account that belongs to the administrators group and has no spaces in it. Note that the same applies for uninstalling MIL. The required Visual C++ 2017 Redistributable needs the presence of KB2919442 and KB2919355. These will need to be obtained and applied before restarting this update. The MIL update requires a Windows installation that supports device drivers with SHA-2 digital certificates. Consequently, some Windows 7 installations will require that a Windows Monthly Rollup be applied before the MIL update can be installed. ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Processing FPGA: The Solios eA/XA's processing FPGA option is no longer supported. ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MdigGrab(): ?????? When grabbing in on-board buffers, the following limitations apply: -&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; The buffer Size-X and Size- Y must match the limitations set in the DCF. -&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; The buffer type must match the limitations set in the DCF. -&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; When grabbing with a 10- or 12-bit camera in an on-board 8-bit buffer, some image data might be missing or improperly shifted depending on the DCF tap configuration. &nbsp; ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MdigControl(M_CHANNEL): ????? Changing the synchronization channel with M_CHn+M_SYNC is not supported. ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MdigAlloc(): &nbsp; The mode of Matrox Solios eCL/XCL can be changed through MILConfig (Solios tab) from its factory-default setting of single-Medium to dual-Base. Follow all on-screen procedures. Once changed, the PC must be shut-down and then turned back on (perform a cold-boot) for changes to take effect. Note that simply restarting your computer (using the Start Shut Down Windows Restart command) will not allow the changes to take affect. If you change the mode of Matrox Solios, make certain you also change your DCF. Using the wrong DCF when performing a digitizer allocation (using MdigAlloc()) will result in an error. &nbsp; ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; On Matrox Solios eA/XA: When porting an application from MIL 9 to MIL 10 and using M_USER_BIT2, you might receive this error message: &quot;Invalid Aux IO usage: The user-defined output signal is already in use by the exposure&quot;. In this case, you must set the IO signal to be used as a user bit: MdigControl(MilDigitizer, M_IO_SOURCE + M_AUX_IO12, M_USER_BIT2); 2.&nbsp;&nbsp; Location of examples (in the help file) In the help file, the location information written at the top of examples might not be up-to-date. Use MIL Example Launcher to find an example on disk. &nbsp; ",
      "wordCount": 2432,
      "subEntries": []
    },
    {
      "id": "Readme_milSolios_MilSoliosAnalogIOConversionTable",
      "title": "MilSoliosAnalogIOConversionTable",
      "location": "MIL Release Notes",
      "pageURL": "\\milSolios\\MilSoliosAnalogIOConversionTable.htm",
      "text": " ------------------------------------------------------------------------------- Matrox Imaging Library (MIL) 10.0 MIL 9 to MIL 10 IO conversion table for the Matrox Solios eA/XA December, 2013 (c) Copyright Matrox Electronic Systems Ltd., 1992-2013. ------------------------------------------------------------------------------- MIL 10 has a new mechanism to control and inquire IO signals. It has unified some concepts under the M_IO_... constants of MdigControl/MdigInquire and generalized others that were being used for more than their original purpose (for example, M_GRAB_EXPOSURE_... to M_TIMER_...). Although the old mechanism still works, the old mechanism is deprecated. To port your code to the new mechanism, use the equivalence tables below. Note that the concept of user-defined signals is now treated differently. To output a user-defined signal, you set a bit in a static user output register (M_USER_BIT_STATE). If you associate that bit with an output signal (M_IO_SOURCE), the state of the bit is routed onto the specified signal. To inquire the state of an auxiliary input signal so that you can act upon it (user input), you inquire the status of the auxiliary signal directly (M_IO_STATUS); you don’t inquire a bit. The following conversion table applies to the Matrox Solios eA/XA. Contents 1. MIL 9 to MIL 10 conversion table. 2. MIL 9 to MIL 10 conversion examples. 2.1 Setting a user-bit. 2.2 Inquiring a user-bit. 2.3 Hooking a callback function on a user-bit. 2.4 Setting a grab trigger source. 2.5 Setting a timer trigger source. =============================================================================== 1. MIL 9 to MIL 10 conversion table. M_HARDWARE_PORT0 is replaced by M_AUX_IO0 M_HARDWARE_PORT1 is replaced by M_AUX_IO1 M_HARDWARE_PORT2 is replaced by M_AUX_IO2 M_HARDWARE_PORT3 is replaced by M_AUX_IO3 M_HARDWARE_PORT4 is replaced by M_AUX_IO4 M_HARDWARE_PORT5 is replaced by M_AUX_IO5 M_HARDWARE_PORT6 is replaced by M_AUX_IO6 M_HARDWARE_PORT7 is replaced by M_AUX_IO7 M_HARDWARE_PORT8 is replaced by M_AUX_IO8 M_HARDWARE_PORT9 is replaced by M_AUX_IO9 Note that the following table includes only equivalences for setting up output user-defined signals; see the subsequent table for inquiring user input signals (no corresponding register bit). MdigControl M_USER_BIT_VALUE + 0 becomes M_USER_BIT_STATE + M_USER_BIT0 MdigControl M_USER_BIT_VALUE + 1 becomes M_USER_BIT_STATE + M_USER_BIT1 MdigControl M_USER_BIT_VALUE + 2 becomes M_USER_BIT_STATE + M_USER_BIT2 Note that the following table includes only equivalences for reading the status of a user input signal. MdigInquire M_USER_BIT_VALUE + 3 becomes M_IO_STATUS + M_AUX_IO1 MdigInquire M_USER_BIT_VALUE + 4 becomes M_IO_STATUS + M_AUX_IO0 MdigInquire M_USER_BIT_VALUE + 5 becomes M_IO_STATUS + M_AUX_IO2 MdigInquire M_USER_BIT_VALUE + 6 becomes M_IO_STATUS + M_AUX_IO3 MdigInquire M_USER_BIT_VALUE + 7 becomes M_IO_STATUS + M_AUX_IO4 MdigInquire M_USER_BIT_VALUE + 8 becomes M_IO_STATUS + M_AUX_IO5 MdigInquire M_USER_BIT_VALUE + 9 becomes M_IO_STATUS + M_AUX_IO6 MdigInquire M_USER_BIT_VALUE + 10 becomes M_IO_STATUS + M_AUX_IO7 MdigInquire M_USER_BIT_VALUE + 11 becomes M_IO_STATUS + M_AUX_IO8 MdigInquire M_USER_BIT_VALUE + 12 becomes M_IO_STATUS + M_AUX_IO9 MdigHookFunction M_USER_BIT_CHANGE becomes M_IO_CHANGE Note that the following table includes only equivalences for inquiring which input signal caused the interrupt event. MdigGetHookInfo M_USER_BIT returns 3 becomes M_IO_INTERRUPT_SOURCE returns M_AUX_IO1 MdigGetHookInfo M_USER_BIT returns 4 becomes M_IO_INTERRUPT_SOURCE returns M_AUX_IO0 MdigGetHookInfo M_USER_BIT returns 5 becomes M_IO_INTERRUPT_SOURCE returns M_AUX_IO2 MdigGetHookInfo M_USER_BIT returns 6 becomes M_IO_INTERRUPT_SOURCE returns M_AUX_IO3 MdigGetHookInfo M_USER_BIT returns 7 becomes M_IO_INTERRUPT_SOURCE returns M_AUX_IO4 MdigGetHookInfo M_USER_BIT returns 8 becomes M_IO_INTERRUPT_SOURCE returns M_AUX_IO5 MdigGetHookInfo M_USER_BIT returns 9 becomes M_IO_INTERRUPT_SOURCE returns M_AUX_IO6 MdigGetHookInfo M_USER_BIT returns 10 becomes M_IO_INTERRUPT_SOURCE returns M_AUX_IO7 MdigGetHookInfo M_USER_BIT returns 11 becomes M_IO_INTERRUPT_SOURCE returns M_AUX_IO8 MdigGetHookInfo M_USER_BIT returns 12 becomes M_IO_INTERRUPT_SOURCE returns M_AUX_IO9 Note that the following table includes only equivalences for signals whose format can be changed (e.g. TTL to LVDS). MdigControl/Inquire M_USER_BIT_FORMAT + 0 becomes M_IO_FORMAT + M_AUX_IO10 MdigControl/Inquire M_USER_BIT_FORMAT + 1 becomes M_IO_FORMAT + M_AUX_IO11 MdigControl/Inquire M_USER_BIT_FORMAT + 5 becomes M_IO_FORMAT + M_AUX_IO2 MdigControl/Inquire M_USER_BIT_FORMAT + 6 becomes M_IO_FORMAT + M_AUX_IO3 MdigControl/Inquire M_USER_BIT_FORMAT + 7 becomes M_IO_FORMAT + M_AUX_IO4 MdigControl/Inquire M_USER_BIT_FORMAT + 8 becomes M_IO_FORMAT + M_AUX_IO5 MdigControl/Inquire M_USER_BIT_FORMAT + 9 becomes M_IO_FORMAT + M_AUX_IO6 MdigControl/Inquire M_USER_BIT_FORMAT + 10 becomes M_IO_FORMAT + M_AUX_IO7 MdigControl/Inquire M_USER_BIT_FORMAT + 11 becomes M_IO_FORMAT + M_AUX_IO8 MdigControl/Inquire M_USER_BIT_FORMAT + 12 becomes M_IO_FORMAT + M_AUX_IO9 Note that the following table includes only equivalences for controlling/ inquiring whether an input signal should cause an interrupt. MdigControl/Inquire M_USER_BIT_INTERRUPT_STATE + 3 becomes M_IO_INTERRUPT_STATE + M_AUX_IO1 MdigControl/Inquire M_USER_BIT_INTERRUPT_STATE + 4 becomes M_IO_INTERRUPT_STATE + M_AUX_IO0 MdigControl/Inquire M_USER_BIT_INTERRUPT_STATE + 5 becomes M_IO_INTERRUPT_STATE + M_AUX_IO2 MdigControl/Inquire M_USER_BIT_INTERRUPT_STATE + 6 becomes M_IO_INTERRUPT_STATE + M_AUX_IO3 MdigControl/Inquire M_USER_BIT_INTERRUPT_STATE + 7 becomes M_IO_INTERRUPT_STATE + M_AUX_IO4 MdigControl/Inquire M_USER_BIT_INTERRUPT_STATE + 8 becomes M_IO_INTERRUPT_STATE + M_AUX_IO5 MdigControl/Inquire M_USER_BIT_INTERRUPT_STATE + 9 becomes M_IO_INTERRUPT_STATE + M_AUX_IO6 MdigControl/Inquire M_USER_BIT_INTERRUPT_STATE + 10 becomes M_IO_INTERRUPT_STATE + M_AUX_IO7 MdigControl/Inquire M_USER_BIT_INTERRUPT_STATE + 11 becomes M_IO_INTERRUPT_STATE + M_AUX_IO8 MdigControl/Inquire M_USER_BIT_INTERRUPT_STATE + 12 becomes M_IO_INTERRUPT_STATE + M_AUX_IO9 Note that the following table includes only equivalences for controlling/ inquiring input signals that cause an interrupt. MdigControl/Inquire M_USER_BIT_INTERRUPT_MODE + 3 becomes M_IO_INTERRUPT_ACTIVATION + M_AUX_IO1 MdigControl/Inquire M_USER_BIT_INTERRUPT_MODE + 4 becomes M_IO_INTERRUPT_ACTIVATION + M_AUX_IO0 MdigControl/Inquire M_USER_BIT_INTERRUPT_MODE + 5 becomes M_IO_INTERRUPT_ACTIVATION + M_AUX_IO2 MdigControl/Inquire M_USER_BIT_INTERRUPT_MODE + 6 becomes M_IO_INTERRUPT_ACTIVATION + M_AUX_IO3 MdigControl/Inquire M_USER_BIT_INTERRUPT_MODE + 7 becomes M_IO_INTERRUPT_ACTIVATION + M_AUX_IO4 MdigControl/Inquire M_USER_BIT_INTERRUPT_MODE + 8 becomes M_IO_INTERRUPT_ACTIVATION + M_AUX_IO5 MdigControl/Inquire M_USER_BIT_INTERRUPT_MODE + 9 becomes M_IO_INTERRUPT_ACTIVATION + M_AUX_IO6 MdigControl/Inquire M_USER_BIT_INTERRUPT_MODE + 10 becomes M_IO_INTERRUPT_ACTIVATION + M_AUX_IO7 MdigControl/Inquire M_USER_BIT_INTERRUPT_MODE + 11 becomes M_IO_INTERRUPT_ACTIVATION + M_AUX_IO8 MdigControl/Inquire M_USER_BIT_INTERRUPT_MODE + 12 becomes M_IO_INTERRUPT_ACTIVATION + M_AUX_IO9 MdigControl M_GRAB_TRIGGER with M_ACTIVATE becomes M_GRAB_TRIGGER_SOFTWARE with M_ACTIVATE MdigGetHookInfo M_GRAB_EXPOSURE_TRIGGER_MISSED becomes M_TIMER_TRIGGER_MISSED MdigControl/Inquire M_GRAB_EXPOSURE + M_TIMERn becomes M_TIMER_STATE + M_TIMERn MdigControl M_GRAB_EXPOSURE + M_TIMERn with M_ACTIVATE becomes M_TIMER_TRIGGER_SOFTWARE + M_TIMERn with M_ACTIVATE MdigControl/Inquire M_GRAB_EXPOSURE_SOURCE + M_TIMERn becomes M_TIMER_TRIGGER_SOURCE + M_TIMERn MdigControl/Inquire M_GRAB_EXPOSURE_MODE + M_TIMERn becomes M_TIMER_OUTPUT_INVERTER + M_TIMERn MdigControl/Inquire M_GRAB_EXPOSURE_DELAY_CLOCK_MODE + M_TIMERn becomes M_TIMER_DELAY_CLOCK_ACTIVATION + M_TIMERn MdigControl/Inquire M_GRAB_EXPOSURE_DELAY_CLOCK_SOURCE + M_TIMERn becomes M_TIMER_DELAY_CLOCK_SOURCE + M_TIMERn MdigControl/Inquire M_GRAB_EXPOSURE_TRIGGER_MODE + M_TIMERn becomes M_TIMER_TRIGGER_ACTIVATION + M_TIMERn MdigControl/Inquire M_GRAB_EXPOSURE_CLOCK_SOURCE + M_TIMERn becomes M_TIMER_CLOCK_SOURCE + M_TIMERn MdigControl/Inquire M_GRAB_EXPOSURE_USAGE + M_TIMERn becomes M_TIMER_USAGE + M_TIMERn MdigControl/Inquire M_GRAB_EXPOSURE_TRIGGER_MISSED + M_TIMERn becomes M_TIMER_TRIGGER_MISSED + M_TIMERn MdigControl/Inquire M_GRAB_EXPOSURE_TRIGGER_MISSED_STATUS + M_TIMERn becomes M_TIMER_TRIGGER_MISSED_STATUS + M_TIMERn MdigControl/Inquire M_GRAB_EXPOSURE_TRIGGER_DIVIDER + M_TIMERn becomes M_TIMER_TRIGGER_RATE_DIVIDER + M_TIMERn MdigControl/Inquire M_GRAB_EXPOSURE_ARM + M_TIMERn becomes M_TIMER_ARM + M_TIMERn MdigControl/Inquire M_GRAB_EXPOSURE_ARM + M_TIMERn with M_ACTIVATE becomes M_TIMER_ARM_SOFTWARE + M_TIMERn with M_ACTIVATE MdigControl/Inquire M_GRAB_EXPOSURE_ARM_SOURCE + M_TIMERn becomes M_TIMER_ARM_SOURCE + M_TIMERn MdigControl/Inquire M_GRAB_EXPOSURE_ARM_MODE + M_TIMERn becomes M_TIMER_ARM_ACTIVATION + M_TIMERn MdigControl/Inquire M_GRAB_EXPOSURE_TIME_MAX + M_TIMERn becomes M_TIMER_DURATION_MAX + M_TIMERn MdigControl/Inquire M_GRAB_EXPOSURE_TIME + M_TIMERn becomes M_TIMER_DURATION + M_TIMERn MdigControl/Inquire M_GRAB_EXPOSURE_TIME_DELAY + M_TIMERn becomes M_TIMER_DELAY + M_TIMERn MdigControl/Inquire M_GRAB_EXPOSURE_CLOCK_FREQUENCY + M_TIMERn becomes M_TIMER_CLOCK_FREQUENCY + M_TIMERn MdigControl/Inquire M_GRAB_EXPOSURE_TIMEOUT + M_TIMERn becomes M_TIMER_TIMEOUT + M_TIMERn MdigControl/Inquire M_GRAB_EXPOSURE_MEASURED + M_TIMERn becomes M_TIMER_VALUE + M_TIMERn 2. MIL 9 to MIL 10 conversion examples. 2.1 Setting a user-bit. Using Mil 9 IO API: MdigControl(MilDigitizer, M_USER_BIT_VALUE + 0, M_ON); Using Mil 10 IO API: MdigControl(MilDigitizer, M_USER_BIT_STATE + M_USER_BIT0, M_ON); MdigControl(MilDigitizer, M_IO_SOURCE + M_AUX_IO10, M_USER_BIT0); 2.2 Inquiring a user-bit. Using Mil 9 IO API: MdigInquire(MilDigitizer, M_USER_BIT_VALUE + 3, &amp;Value); Using Mil 10 IO API: MdigInquire(MilDigitizer, M_IO_STATUS + M_AUX_IO1, &amp;Value); 2.3 Hooking a callback function on a user-bit. Using Mil 9 IO API: MdigControl(MilDigitizer, M_USER_BIT_INTERRUPT_MODE + 3, M_EDGE_RISING); MdigHookFunction(MilDigitizer, M_USER_BIT_CHANGE, HookHandlerFnc, &amp;HookData); MdigControl(MilDigitizer, M_USER_BIT_INTERRUPT_STATE + 3, M_ENABLE); MIL_INT HookHandlerFnc(MIL_INT HookType, MIL_ID EventId, void *UserDataPtr) { MIL_INT UserBit = 0; MdigGetHookInfo(EventId, M_USER_BIT, &amp;UserBit); // UserBit will be 3 when interrupt is fired. } Using Mil 10 IO API: MdigControl(MilDigitizer, M_IO_INTERRUPT_ACTIVATION + M_AUX_IO1, M_EDGE_RISING); MdigHookFunction(MilDigitizer, M_IO_CHANGE, HookHandlerFnc, &amp;HookData); MdigControl(MilDigitizer, M_IO_INTERRUPT_STATE + M_AUX_IO1, M_ENABLE); MIL_INT HookHandlerFnc(MIL_INT HookType, MIL_ID EventId, void *UserDataPtr) { MIL_INT IOSource = 0; MdigGetHookInfo(EventId, M_IO_INTERRUPT_SOURCE , &amp;IOSource); // IOSource will be M_AUX_IO1 when interrupt is fired. } 2.4 Setting a grab trigger source. Using Mil 9 IO API: MdigControl(MilDigitizer, M_GRAB_TRIGGER_SOURCE, M_HARDWARE_PORT0); Using Mil 10 IO API: MdigControl(MilDigitizer, M_GRAB_TRIGGER_SOURCE, M_AUX_IO0); 2.5 Setting a timer trigger source. Using Mil 9 IO API: MdigControl(MilDigitizer, M_GRAB_EXPOSURE_SOURCE, M_HARDWARE_PORT0); Using Mil 10 IO API: MdigControl(MilDigitizer, M_TIMER_TRIGGER_SOURCE, M_AUX_IO0); ",
      "wordCount": 1233,
      "subEntries": []
    },
    {
      "id": "Readme_milSolios_MILSoliosCameraLinkIOConversionTable",
      "title": "MILSoliosCameraLinkIOConversionTable",
      "location": "MIL Release Notes",
      "pageURL": "\\milSolios\\MILSoliosCameraLinkIOConversionTable.htm",
      "text": " ------------------------------------------------------------------------------- Matrox Imaging Library (MIL) 10.0 MIL 9 to MIL 10 IO conversion table for the Matrox Solios ecl/xcl/ev-cl December, 2013 (c) Copyright Matrox Electronic Systems Ltd., 1992-2013. ------------------------------------------------------------------------------- MIL 10 has a new mechanism to control and inquire IO signals. It has unified some concepts under the M_IO_... constants of MdigControl/MdigInquire and generalized others that were being used for more than their original purpose (for example, M_GRAB_EXPOSURE_... to M_TIMER_...). Although the old mechanism still works, the old mechanism is deprecated. To port your code to the new mechanism, use the equivalence tables below. Note that the concept of user-defined signals is now treated differently. To output a user-defined signal, you set a bit in a static user output register (M_USER_BIT_STATE). If you associate that bit with an output signal (M_IO_SOURCE), the state of the bit is routed onto the specified signal. To inquire the state of an auxiliary input signal so that you can act upon it (user input), you inquire the status of the auxiliary signal directly (M_IO_STATUS); you don’t inquire a bit. The following conversion table applies to the following Matrox boards: - Matrox Solios eCL/XCL - Matrox Solios eV-CL Contents 1. MIL 9 to MIL 10 conversion table. 2. MIL 9 to MIL 10 conversion examples. 2.1 Setting a user-bit. 2.2 Inquiring a user-bit. 2.3 Hooking a callback function on a user-bit. 2.4 Setting a grab trigger source. 2.5 Setting a timer trigger source. =============================================================================== 1. MIL 9 to MIL 10 conversion table. M_HARDWARE_PORT0 is replaced by M_AUX_IO0 M_HARDWARE_PORT1 is replaced by M_AUX_IO1 M_HARDWARE_PORT2 is replaced by M_AUX_IO2 M_HARDWARE_PORT3 is replaced by M_AUX_IO3 M_HARDWARE_PORT4 is replaced by M_AUX_IO4 M_HARDWARE_PORT5 is replaced by M_AUX_IO5 M_HARDWARE_PORT6 is replaced by M_AUX_IO6 M_HARDWARE_PORT7 is replaced by M_AUX_IO7 M_HARDWARE_PORT8 is replaced by M_AUX_IO8 M_HARDWARE_PORT9 is replaced by M_AUX_IO9 M_HARDWARE_PORT10 is replaced by M_AUX_IO10 M_HARDWARE_PORT11 is replaced by M_AUX_IO11 M_HARDWARE_PORT12 is replaced by M_AUX_IO12 M_HARDWARE_PORT13 is replaced by M_AUX_IO13 Note that the following table includes only equivalences for setting up output user-defined signals (or bidirectional signals set to output); see the subsequent table for inquiring user input signals (no corresponding register bit). MdigControl M_USER_BIT_VALUE + 0 becomes M_USER_BIT_STATE + M_USER_BIT0 MdigControl M_USER_BIT_VALUE + 1 becomes M_USER_BIT_STATE + M_USER_BIT1 MdigControl M_USER_BIT_VALUE + 2 becomes M_USER_BIT_STATE + M_USER_BIT2 MdigControl M_USER_BIT_VALUE + 3 becomes M_USER_BIT_STATE + M_USER_BIT3 MdigControl M_USER_BIT_VALUE + 4 becomes M_USER_BIT_STATE + M_USER_BIT4 MdigControl M_USER_BIT_VALUE + 5 becomes M_USER_BIT_STATE + M_USER_BIT5 MdigControl M_USER_BIT_VALUE + M_CCn becomes M_USER_BIT_STATE + M_USER_BIT_CC_IOm Note that the following table includes only equivalences for reading the status of a user input signal (or a bidirectional signal set to input). MdigInquire M_USER_BIT_VALUE + 2 becomes M_IO_STATUS + M_AUX_IO8 MdigInquire M_USER_BIT_VALUE + 3 becomes M_IO_STATUS + M_AUX_IO9 MdigInquire M_USER_BIT_VALUE + 4 becomes M_IO_STATUS + M_AUX_IO2 MdigInquire M_USER_BIT_VALUE + 5 becomes M_IO_STATUS + M_AUX_IO3 MdigInquire M_USER_BIT_VALUE + 6 becomes M_IO_STATUS + M_AUX_IO4 MdigInquire M_USER_BIT_VALUE + 7 becomes M_IO_STATUS + M_AUX_IO5 MdigInquire M_USER_BIT_VALUE + 8 becomes M_IO_STATUS + M_AUX_IO0 MdigInquire M_USER_BIT_VALUE + 9 becomes M_IO_STATUS + M_AUX_IO1 MdigInquire M_USER_BIT_VALUE + 10 becomes M_IO_STATUS + M_AUX_IO10 MdigInquire M_USER_BIT_VALUE + 11 becomes M_IO_STATUS + M_AUX_IO11 MdigInquire M_USER_BIT_VALUE + 12 becomes M_IO_STATUS + M_AUX_IO6 MdigInquire M_USER_BIT_VALUE + 13 becomes M_IO_STATUS + M_AUX_IO7 MdigControl/Inquire M_CAMERALINK_CCn_SOURCE with M_GRAB_EXPOSURE + M_TIMERm becomes M_IO_SOURCE + M_CC_IOn with M_TIMERm MdigControl/Inquire M_CAMERALINK_CCn_SOURCE with M_USER_BIT_CC_A becomes M_IO_SOURCE + M_CC_IOn with M_USER_BIT_CC_IO0 MdigControl/Inquire M_CAMERALINK_CCn_SOURCE with M_USER_BIT_CC_B becomes M_IO_SOURCE + M_CC_IOn with M_USER_BIT_CC_IO1 MdigControl/Inquire M_CAMERALINK_CCn_SOURCE with M_HSYNC becomes M_IO_SOURCE + M_CC_IOn with M_HSYNC MdigControl/Inquire M_CAMERALINK_CCn_SOURCE with M_VSYNC becomes M_IO_SOURCE + M_CC_IOn with M_VSYNC MdigControl/Inquire M_CAMERALINK_CCn_SOURCE with M_PIXCLK becomes M_IO_SOURCE + M_CC_IOn with M_PIXCLK MdigHookFunction M_USER_BIT_CHANGE becomes M_IO_CHANGE Note that the following table includes only equivalences for inquiring which input signal (or bidirectional signal set to input) caused the interrupt event. MdigGetHookInfo M_USER_BIT returns 2 becomes M_IO_INTERRUPT_SOURCE returns M_AUX_IO8 MdigGetHookInfo M_USER_BIT returns 3 becomes M_IO_INTERRUPT_SOURCE returns M_AUX_IO9 MdigGetHookInfo M_USER_BIT returns 4 becomes M_IO_INTERRUPT_SOURCE returns M_AUX_IO2 MdigGetHookInfo M_USER_BIT returns 5 becomes M_IO_INTERRUPT_SOURCE returns M_AUX_IO3 MdigGetHookInfo M_USER_BIT returns 6 becomes M_IO_INTERRUPT_SOURCE returns M_AUX_IO4 MdigGetHookInfo M_USER_BIT returns 7 becomes M_IO_INTERRUPT_SOURCE returns M_AUX_IO5 MdigGetHookInfo M_USER_BIT returns 8 becomes M_IO_INTERRUPT_SOURCE returns M_AUX_IO0 MdigGetHookInfo M_USER_BIT returns 9 becomes M_IO_INTERRUPT_SOURCE returns M_AUX_IO1 MdigGetHookInfo M_USER_BIT returns 10 becomes M_IO_INTERRUPT_SOURCE returns M_AUX_IO10 MdigGetHookInfo M_USER_BIT returns 11 becomes M_IO_INTERRUPT_SOURCE returns M_AUX_IO11 MdigGetHookInfo M_USER_BIT returns 12 becomes M_IO_INTERRUPT_SOURCE returns M_AUX_IO6 MdigGetHookInfo M_USER_BIT returns 13 becomes M_IO_INTERRUPT_SOURCE returns M_AUX_IO7 Note that the following table includes only equivalences for signals whose format can be inquired. MdigInquire M_USER_BIT_FORMAT + 0 becomes M_IO_FORMAT + M_AUX_IO12 MdigInquire M_USER_BIT_FORMAT + 1 becomes M_IO_FORMAT + M_AUX_IO13 MdigInquire M_USER_BIT_FORMAT + 2 becomes M_IO_FORMAT + M_AUX_IO8 MdigInquire M_USER_BIT_FORMAT + 3 becomes M_IO_FORMAT + M_AUX_IO9 MdigInquire M_USER_BIT_FORMAT + 4 becomes M_IO_FORMAT + M_AUX_IO2 MdigInquire M_USER_BIT_FORMAT + 5 becomes M_IO_FORMAT + M_AUX_IO3 MdigInquire M_USER_BIT_FORMAT + 6 becomes M_IO_FORMAT + M_AUX_IO4 MdigInquire M_USER_BIT_FORMAT + 7 becomes M_IO_FORMAT + M_AUX_IO5 MdigInquire M_USER_BIT_FORMAT + 8 becomes M_IO_FORMAT + M_AUX_IO0 MdigInquire M_USER_BIT_FORMAT + 9 becomes M_IO_FORMAT + M_AUX_IO1 MdigInquire M_USER_BIT_FORMAT + 10 becomes M_IO_FORMAT + M_AUX_IO10 MdigInquire M_USER_BIT_FORMAT + 11 becomes M_IO_FORMAT + M_AUX_IO11 MdigInquire M_USER_BIT_FORMAT + 12 becomes M_IO_FORMAT + M_AUX_IO6 MdigInquire M_USER_BIT_FORMAT + 13 becomes M_IO_FORMAT + M_AUX_IO7 Note that the following table includes only equivalences for controlling/inquiring whether an input signal (or bidirectional signal set to input) should cause an interrupt. MdigControl/Inquire M_USER_BIT_INTERRUPT_STATE + 2 becomes M_IO_INTERRUPT_STATE + M_AUX_IO8 MdigControl/Inquire M_USER_BIT_INTERRUPT_STATE + 3 becomes M_IO_INTERRUPT_STATE + M_AUX_IO9 MdigControl/Inquire M_USER_BIT_INTERRUPT_STATE + 4 becomes M_IO_INTERRUPT_STATE + M_AUX_IO2 MdigControl/Inquire M_USER_BIT_INTERRUPT_STATE + 5 becomes M_IO_INTERRUPT_STATE + M_AUX_IO3 MdigControl/Inquire M_USER_BIT_INTERRUPT_STATE + 6 becomes M_IO_INTERRUPT_STATE + M_AUX_IO4 MdigControl/Inquire M_USER_BIT_INTERRUPT_STATE + 7 becomes M_IO_INTERRUPT_STATE + M_AUX_IO5 MdigControl/Inquire M_USER_BIT_INTERRUPT_STATE + 8 becomes M_IO_INTERRUPT_STATE + M_AUX_IO0 MdigControl/Inquire M_USER_BIT_INTERRUPT_STATE + 9 becomes M_IO_INTERRUPT_STATE + M_AUX_IO1 MdigControl/Inquire M_USER_BIT_INTERRUPT_STATE + 10 becomes M_IO_INTERRUPT_STATE + M_AUX_IO10 MdigControl/Inquire M_USER_BIT_INTERRUPT_STATE + 11 becomes M_IO_INTERRUPT_STATE + M_AUX_IO11 MdigControl/Inquire M_USER_BIT_INTERRUPT_STATE + 12 becomes M_IO_INTERRUPT_STATE + M_AUX_IO6 MdigControl/Inquire M_USER_BIT_INTERRUPT_STATE + 13 becomes M_IO_INTERRUPT_STATE + M_AUX_IO7 Note that the following table includes only equivalences for controlling/inquiring whether a bidirectional signal should be set to input or to output. MdigControl/Inquire M_USER_BIT_MODE + 2 becomes M_IO_MODE + M_AUX_IO8 MdigControl/Inquire M_USER_BIT_MODE + 3 becomes M_IO_MODE + M_AUX_IO9 MdigControl/Inquire M_USER_BIT_MODE + 4 becomes M_IO_MODE + M_AUX_IO2 MdigControl/Inquire M_USER_BIT_MODE + 5 becomes M_IO_MODE + M_AUX_IO3 Note that the following table includes only equivalences for controlling/inquiring input signals (or bidirectional signal set to input) that cause an interrupt. MdigControl/Inquire M_USER_BIT_INTERRUPT_MODE + 2 becomes M_IO_INTERRUPT_ACTIVATION + M_AUX_IO8 MdigControl/Inquire M_USER_BIT_INTERRUPT_MODE + 3 becomes M_IO_INTERRUPT_ACTIVATION + M_AUX_IO9 MdigControl/Inquire M_USER_BIT_INTERRUPT_MODE + 4 becomes M_IO_INTERRUPT_ACTIVATION + M_AUX_IO2 MdigControl/Inquire M_USER_BIT_INTERRUPT_MODE + 5 becomes M_IO_INTERRUPT_ACTIVATION + M_AUX_IO3 MdigControl/Inquire M_USER_BIT_INTERRUPT_MODE + 6 becomes M_IO_INTERRUPT_ACTIVATION + M_AUX_IO4 MdigControl/Inquire M_USER_BIT_INTERRUPT_MODE + 7 becomes M_IO_INTERRUPT_ACTIVATION + M_AUX_IO5 MdigControl/Inquire M_USER_BIT_INTERRUPT_MODE + 8 becomes M_IO_INTERRUPT_ACTIVATION + M_AUX_IO0 MdigControl/Inquire M_USER_BIT_INTERRUPT_MODE + 9 becomes M_IO_INTERRUPT_ACTIVATION + M_AUX_IO1 MdigControl/Inquire M_USER_BIT_INTERRUPT_MODE + 10 becomes M_IO_INTERRUPT_ACTIVATION + M_AUX_IO10 MdigControl/Inquire M_USER_BIT_INTERRUPT_MODE + 11 becomes M_IO_INTERRUPT_ACTIVATION + M_AUX_IO11 MdigControl/Inquire M_USER_BIT_INTERRUPT_MODE + 12 becomes M_IO_INTERRUPT_ACTIVATION + M_AUX_IO6 MdigControl/Inquire M_USER_BIT_INTERRUPT_MODE + 13 becomes M_IO_INTERRUPT_ACTIVATION + M_AUX_IO7 MdigControl M_GRAB_TRIGGER with M_ACTIVATE becomes M_GRAB_TRIGGER_SOFTWARE with M_ACTIVATE MdigGetHookInfo M_GRAB_EXPOSURE_TRIGGER_MISSED becomes M_TIMER_TRIGGER_MISSED MdigControl/Inquire M_GRAB_EXPOSURE + M_TIMERn becomes M_TIMER_STATE + M_TIMERn MdigControl M_GRAB_EXPOSURE + M_TIMERn with M_ACTIVATE becomes M_TIMER_TRIGGER_SOFTWARE + M_TIMERn with M_ACTIVATE MdigControl/Inquire M_GRAB_EXPOSURE_SOURCE + M_TIMERn becomes M_TIMER_TRIGGER_SOURCE + M_TIMERn MdigControl/Inquire M_GRAB_EXPOSURE_MODE + M_TIMERn becomes M_TIMER_OUTPUT_INVERTER + M_TIMERn MdigControl/Inquire M_GRAB_EXPOSURE_DELAY_CLOCK_MODE + M_TIMERn becomes M_TIMER_DELAY_CLOCK_ACTIVATION + M_TIMERn MdigControl/Inquire M_GRAB_EXPOSURE_DELAY_CLOCK_SOURCE + M_TIMERn becomes M_TIMER_DELAY_CLOCK_SOURCE + M_TIMERn MdigControl/Inquire M_GRAB_EXPOSURE_TRIGGER_MODE + M_TIMERn becomes M_TIMER_TRIGGER_ACTIVATION + M_TIMERn MdigControl/Inquire M_GRAB_EXPOSURE_CLOCK_SOURCE + M_TIMERn becomes M_TIMER_CLOCK_SOURCE + M_TIMERn MdigControl/Inquire M_GRAB_EXPOSURE_USAGE + M_TIMERn becomes M_TIMER_USAGE + M_TIMERn MdigControl/Inquire M_GRAB_EXPOSURE_TRIGGER_MISSED + M_TIMERn becomes M_TIMER_TRIGGER_MISSED + M_TIMERn MdigControl/Inquire M_GRAB_EXPOSURE_TRIGGER_MISSED_STATUS + M_TIMERn becomes M_TIMER_TRIGGER_MISSED_STATUS + M_TIMERn MdigControl/Inquire M_GRAB_EXPOSURE_TRIGGER_DIVIDER + M_TIMERn becomes M_TIMER_TRIGGER_RATE_DIVIDER + M_TIMERn MdigControl/Inquire M_GRAB_EXPOSURE_ARM + M_TIMERn becomes M_TIMER_ARM + M_TIMERn MdigControl/Inquire M_GRAB_EXPOSURE_ARM + M_TIMERn with M_ACTIVATE becomes M_TIMER_ARM_SOFTWARE + M_TIMERn with M_ACTIVATE MdigControl/Inquire M_GRAB_EXPOSURE_ARM_SOURCE + M_TIMERn becomes M_TIMER_ARM_SOURCE + M_TIMERn MdigControl/Inquire M_GRAB_EXPOSURE_ARM_MODE + M_TIMERn becomes M_TIMER_ARM_ACTIVATION + M_TIMERn MdigControl/Inquire M_GRAB_EXPOSURE_TIME_MAX + M_TIMERn becomes M_TIMER_DURATION_MAX + M_TIMERn MdigControl/Inquire M_GRAB_EXPOSURE_TIME + M_TIMERn becomes M_TIMER_DURATION + M_TIMERn MdigControl/Inquire M_GRAB_EXPOSURE_TIME_DELAY + M_TIMERn becomes M_TIMER_DELAY + M_TIMERn MdigControl/Inquire M_GRAB_EXPOSURE_CLOCK_FREQUENCY + M_TIMERn becomes M_TIMER_CLOCK_FREQUENCY + M_TIMERn MdigControl/Inquire M_GRAB_EXPOSURE_TIMEOUT + M_TIMERn becomes M_TIMER_TIMEOUT + M_TIMERn MdigControl/Inquire M_GRAB_EXPOSURE_MEASURED + M_TIMERn becomes M_TIMER_VALUE + M_TIMERn 2. MIL 9 to MIL 10 conversion examples. 2.1 Setting a user-bit. Using Mil 9 IO API: MdigControl(MilDigitizer, M_USER_BIT_VALUE + 2, M_ON); MdigControl(MilDigitizer, M_USER_BIT_MODE + 2, M_OUTPUT); Using Mil 10 IO API: MdigControl(MilDigitizer, M_USER_BIT_STATE + M_USER_BIT2, M_ON); MdigControl(MilDigitizer, M_IO_SOURCE + M_AUX_IO8, M_USER_BIT2); MdigControl(MilDigitizer, M_IO_MODE + M_AUX_IO8, M_OUTPUT); 2.2 Inquiring a user-bit. Using Mil 9 IO API: MdigControl(MilDigitizer, M_USER_BIT_MODE + 2, M_INPUT); MdigInquire(MilDigitizer, M_USER_BIT_VALUE + 2, &amp;Value); Using Mil 10 IO API: MdigControl(MilDigitizer, M_IO_MODE + M_AUX_IO8, M_INPUT); MdigInquire(MilDigitizer, M_IO_STATUS + M_AUX_IO8, &amp;Value); 2.3 Hooking a callback function on a user-bit. Using Mil 9 IO API: MdigControl(MilDigitizer, M_USER_BIT_MODE + 2, M_INPUT); MdigControl(MilDigitizer, M_USER_BIT_INTERRUPT_MODE + 2, M_EDGE_RISING); MdigHookFunction(MilDigitizer, M_USER_BIT_CHANGE, HookHandlerFnc, &amp;HookData); MdigControl(MilDigitizer, M_USER_BIT_INTERRUPT_STATE + 2, M_ENABLE); MIL_INT HookHandlerFnc(MIL_INT HookType, MIL_ID EventId, void *UserDataPtr) { MIL_INT UserBit = 0; MdigGetHookInfo(EventId, M_USER_BIT, &amp;UserBit); // UserBit will be 2 when interrupt is fired. } Using Mil 10 IO API: MdigControl(MilDigitizer, M_IO_MODE + M_AUX_IO8, M_INPUT); MdigControl(MilDigitizer, M_IO_INTERRUPT_ACTIVATION + M_AUX_IO8, M_EDGE_RISING); MdigHookFunction(MilDigitizer, M_IO_CHANGE, HookHandlerFnc, &amp;HookData); MdigControl(MilDigitizer, M_IO_INTERRUPT_STATE + M_AUX_IO8, M_ENABLE); MIL_INT HookHandlerFnc(MIL_INT HookType, MIL_ID EventId, void *UserDataPtr) { MIL_INT IOSource = 0; MdigGetHookInfo(EventId, M_IO_INTERRUPT_SOURCE , &amp;IOSource); // IOSource will be M_AUX_IO8 when interrupt is fired. } 2.4 Setting a grab trigger source. Using Mil 9 IO API: MdigControl(MilDigitizer, M_GRAB_TRIGGER_SOURCE, M_HARDWARE_PORT0); Using Mil 10 IO API: MdigControl(MilDigitizer, M_GRAB_TRIGGER_SOURCE, M_AUX_IO0); 2.5 Setting a timer trigger source. Using Mil 9 IO API: MdigControl(MilDigitizer, M_GRAB_EXPOSURE_SOURCE, M_HARDWARE_PORT0); Using Mil 10 IO API: MdigControl(MilDigitizer, M_TIMER_TRIGGER_SOURCE, M_AUX_IO0); ",
      "wordCount": 1560,
      "subEntries": []
    },
    {
      "id": "milSolios_files",
      "wordCount": 0
    }
  ]
}]
[{
  "id": "UG_graphics",
  "version": "2024020714",
  "title": "Generating graphics",
  "subTitles": null,
  "location": "MIL UG P04: 2D related information",
  "pageURL": "content\\UserGuide\\graphics\\ChapterInformation.htm",
  "text": " Chapter 26: Generating graphics This chapter describes the graphic functionality that is available with MIL. MIL and graphics in general Steps to performing annotations 2D graphics context Default 2D graphics context Specifying the camera calibration information Drawing graphics Drawing vectors Drawing direction Drawing graphics in a calibrated image Drawing graphics with offset and zoom Writing text 2D graphics list Annotating the display with a 2D graphics list Creating and modifying graphics interactively Hooking a function to a 2D graphics list event Creating graphics interactively Details about creating graphics interactively Rectangle Arc, ellipse, and circle Polygon Polyline Line ",
  "wordCount": 99,
  "subEntries": [
    {
      "id": "UG_graphics_MIL_and_graphics_in_general",
      "version": null,
      "title": "MIL and graphics in general",
      "subTitles": null,
      "location": "MIL UG P04: 2D related information",
      "pageURL": "content\\UserGuide\\graphics\\MIL_and_graphics_in_general.htm",
      "text": " MIL and graphics in general The MIL package supports drawing and text functions that are useful in typical image processing or machine vision applications. Basic graphics are provided with functions of the MIL Graphics module. In addition, processing and analysis modules have a draw function that can draw settings or results that can be visually represented. These functions can be used, for example, to create a condition buffer, draw destructively in an image, or annotate the display non-destructively. MIL provides a MIL object called a 2D graphics list, where graphics, created using the functions provided in the Graphics module or using the processing or analysis modules, can be added and then used to annotate an image at one time. Graphics can also be created or edited interactively in a display. These can be used to indirectly create a mask for an image or create the region of interest of an image interactively. MIL and graphics in general ",
      "wordCount": 159,
      "subEntries": []
    },
    {
      "id": "UG_graphics_Steps_to_performing_annotations",
      "version": null,
      "title": "Steps to performing annotations",
      "subTitles": null,
      "location": "MIL UG P04: 2D related information",
      "pageURL": "content\\UserGuide\\graphics\\Steps_to_performing_annotations.htm",
      "text": " Steps to performing annotations The following steps provide a basic methodology for using the MIL Graphics module to perform annotations: Allocate a 2D graphics context, using MgraAlloc() to store your drawing preference (for example, foreground and background color). Allocate an image buffer, using MbufAlloc...(), or, allocate a 2D graphics list, using MgraAllocList(), on which to perform the drawing operation. If necessary, associate the 2D graphics list with a display, using MdispControl() with M_ASSOCIATED_GRAPHIC_LIST_ID, to non-destructively annotate the image selected to the display. If necessary, modify 2D graphics context or 2D graphics list settings, using MgraControl() or MgraControlList(). Draw graphics destructively in an image buffer or add graphics to the 2D graphics list, using: One of the functions provided in the MIL Graphics module, such as MgraArc() or MgraRect(). A draw function of a processing or analysis module (for example, MbeadDraw() or MmetDraw()). MgraInteractive(), to interactively create and add graphics to the 2D graphics list. A display must have the 2D graphics list associated with it (MdispControl() with M_ASSOCIATED_GRAPHIC_LIST_ID) and the display must allow modification to graphics associated with it (MdispControl() with M_GRAPHIC_LIST_INTERACTIVE). If necessary, annotate an image destructively with the graphics contained in the 2D graphics list, using MgraDraw(). Free all your allocated objects using MgraFree(), unless M_UNIQUE_ID was specified during allocation. Steps to performing annotations ",
      "wordCount": 218,
      "subEntries": []
    },
    {
      "id": "UG_graphics_Graphics_context",
      "version": null,
      "title": "2D graphics context",
      "subTitles": [
        "Default 2D graphics context",
        "Specifying the camera calibration information"
      ],
      "location": "MIL UG P04: 2D related information",
      "pageURL": "content\\UserGuide\\graphics\\Graphics_context.htm",
      "text": " 2D graphics context A 2D graphics context is used to control the behavior of graphics and drawings before they are rendered in an image or added to a 2D graphics list. To allocate a 2D graphics context, use MgraAlloc(). Whenever an annotation is done in an image buffer, 2D graphics context settings are applied to the graphics, which you can change according to your requirements using MgraControl(). Whenever a graphic is added to a 2D graphics list, it inherits 2D graphics context settings, which you can change afterwards using MgraControlList(). The following 2D graphics context settings apply to all graphics: Foreground color. This determines the color in which graphics are drawn. The default foreground color value is the highest positive buffer value (typically corresponds to white). To change the default, use MgraControl() with M_COLOR. Note that a grayscale value can be any integer or floating-point number. If the given value exceeds the range of possible values that can be stored in each band of the destination buffer, the least significant bits of the value are used. Draw offset and zoom. This determines whether to draw graphics and results into an image buffer with an offset and zoom. The default is no offset or zoom. For more information, see the Drawing graphics with offset and zoom subsection of the Drawing graphics section later in this chapter. Input units. This determines the units to use for all applicable settings, such as position, dimension, and angle. The default is pixels. To change the default, use MgraControl() with M_INPUT_UNITS. Camera calibration information. This determines the camera calibration information to use to interpret positioning and dimensioning information of a graphic defined in world units. The default is to use the camera calibration information associated with the destination. Conversion mode. This determines how the graphic shape will be rendered, when the graphic has been defined in world units and the destination image does not have a constant pixel size, using either MgraControl() or MgraControlList() with M_GRAPHIC_CONVERSION_MODE. Line Thickness. This determines the thickness of the lines and diameter of the dots drawn, in pixel units. The default thickness is 1 pixel. To change the default, use either MgraControl() or MgraControlList() with M_LINE_THICKNESS. Once you are satisfied with the graphics settings, you should determine whether you need to clear the destination image buffer prior to drawing in it. You can use MgraClear() or MbufClear() to clear the buffer to a specific color. To clear a 16-bit or 32-bit multi-band buffer to a color value, use MgraClear(). Note that, unlike MbufClear(), MgraClear() does not remove a camera calibration context associated with the image buffer. Default 2D graphics context When a MIL application context is allocated, using MappAlloc() or MappAllocDefault(), a default 2D graphics context is automatically allocated. It can be used in the same way as a normal 2D graphics context allocated with MgraAlloc(). Since the default 2D graphics context (M_DEFAULT) is simply another 2D graphics context, you can change its settings according to your needs using MgraControl(). Note that there is a different default 2D graphics context for each thread. Specifying the camera calibration information When rendering (drawing or displaying) a graphic, that has been defined in world units (M_INPUT_UNITS set to M_WORLD), MIL can interpret positioning and dimensioning information of the graphic solely using camera calibration information associated with the graphic. By default, MIL uses the destination camera calibration information, that is, the camera calibration information of the image buffer (or image buffer selected to the display) in which the graphic is to be rendered. Alternatively, you can have MIL use the source camera calibration information, that is, the camera calibration information of a camera calibration context, image buffer, or processing or analysis module result buffer, associated with the graphic (before being rendered in a destination image buffer). The source camera calibration information is specified using MgraControl() or MgraControlList() with M_GRAPHIC_SOURCE_CALIBRATION. If this control type is set using MgraControl(), the camera calibration information will be associated with the 2D graphics context, not copied. For example, if the relative coordinate system changes after using M_GRAPHIC_SOURCE_CALIBRATION, it will be reflected in the camera calibration information that is used. Alternatively, if MgraControlList() is used to set the source camera calibration information, the camera calibration information will be copied to an internal camera calibration context; it will not be associated with the 2D graphics list. For example, if the relative coordinate system changes after using M_GRAPHIC_SOURCE_CALIBRATION, it will have no effect on the graphic. If only the destination camera calibration information is available, it will be used to render the graphic. However, if the camera calibration information of both the destination and source are available, you should use M_FIXTURE to identify with respect to which of their relative coordinate systems the positioning and dimensioning information is to be specified. If with respect to that of the destination camera calibration information (M_FIXTURE set to M_USE_DESTINATION_FIRST), the source camera calibration information is not used. If with respect to that of the source camera calibration information (M_FIXTURE set to M_USE_SOURCE_FIRST), positions and dimensions are transformed from this relative coordinate system to the absolute coordinate system; then, since it is assumed that there is only one absolute coordinate system, these positions and dimensions are transformed from the absolute coordinate system to the pixel coordinate system, using the destination camera calibration information. If the destination camera calibration information is not available, the source camera calibration information will be used for the world to pixel mapping. 2D graphics context Default 2D graphics context Specifying the camera calibration information ",
      "wordCount": 923,
      "subEntries": []
    },
    {
      "id": "UG_graphics_Drawing_graphics",
      "version": null,
      "title": "Drawing graphics",
      "subTitles": [
        "Drawing vectors",
        "Drawing direction",
        "Drawing graphics in a calibrated image",
        "Drawing graphics with offset and zoom"
      ],
      "location": "MIL UG P04: 2D related information",
      "pageURL": "content\\UserGuide\\graphics\\Drawing_graphics.htm",
      "text": " Drawing graphics There are multiple ways to annotate an image. The functions provided by the MIL Graphics module allow you to draw graphics of geometric shapes or text. The M...Draw() functions of processing and analysis modules allow you to draw module-specific features into your image. With the functions provided by the MIL Graphics module, you can draw the outline of most shapes. The width of a line forming a graphics outline (including lines and dots) is one pixel by default, and can be modified using MgraControl() or MgraControlList() with M_LINE_THICKNESS; however, when zooming graphics drawn in an image, the outline size can appear larger than its set value. Graphics can be rotated, filled, and drawn multiple times. Examples of MIL graphics MgraLine() and MgraLines() MgraLines() with M_POLYLINE MgraLines() with M_POLYGON MgraLines() with M_POLYGON + M_FILLED MgraVectors() and MgraVectorsGrid() MgraArc() MgraArcFill() MgraArcAngle() with M_CONTOUR MgraArcAngle() with M_SECTOR MgraRect() MgraRectFill() MgraRectAngle() MgraRectAngle() with M_FILLED MgraDot() MgraDots() MgraText() If you need complex filled-in shapes, you can draw a graphic's outline (using one of the Mgra...() functions) and use MgraFill() to fill it. MgraFill() performs a boundary-type seed fill. It fills an area of the target buffer with the current foreground color, starting from the specified seed position. Filling occurs on adjacent pixels of the same value as the original seed pixel. Note that text is a unique type of graphic. For more information, see the Writing text section later in this chapter. Processing and analysis modules (such as Bead or Edge Finder) have a function that can draw specific settings or results into an image buffer or 2D graphics list. Each draw function (M...Draw()) can draw into an image buffer without restriction, but some restrictions exist when drawing in a 2D graphics list. When drawing a graphic in an image buffer, it is drawn destructively (raster-based), changing the image's pixel values along the specified graphic. Instead of destructively drawing the graphic in an image, you can also use the same function to add the graphic to the 2D graphics list and annotate the display non-destructively. For more information, see the 2D graphics list section later in this chapter. Drawing vectors You can draw vectors in an image (or add them to a 2D graphics list) by calling MgraVectors() (to draw vectors at arbitrary positions) or MgraVectorsGrid() (to draw vectors at equally spaced positions). When calling MgraVectors(), you must explicitly specify the starting positions and displacements of the vectors. The following example shows how MIL uses this information to draw two vectors in the destination image. When calling MgraVectorsGrid(), you must specify two image buffers: one containing pixel values corresponding to the vectors' X-displacements, and the other containing pixel values corresponding to the vectors' Y-displacements. You must also specify a stride value, to establish the pixels for which to draw a vector. If you set the stride to 1, a vector is drawn in the destination image for every position, according to that position's corresponding X- and Y-displacements. By default, vectors are not drawn for pixels whose displacements are both 0. Vectors that extend past the size of the destination image are clipped. You can consider MgraVectorsGrid() a grid type drawing because it is based on every position (pixel) in the image. Although you can draw a vector for every position (by setting the stride to 1), the result is often unintelligible (unless the displacement buffers have a significant number of regularly distributed positions with no displacement). Increasing the stride helps regulate the vectors drawn. In the following example, with the stride set to 2, a vector is drawn in the destination image for every second position, in the X-direction and in the Y-direction, according to the corresponding displacements (highlighted by a gray box). MIL always draws a vector for the first position (0,0), and applies the stride from there. Typically, the displacement buffers come from the result of a previous image processing operation. For example, the vectors in the following image show the gradient of an edge detection done with MimConvolve(). For more information about drawing vectors from an image processing result, refer to the following MIL example: mgravectors.cpp Drawing direction You can draw an arrow pointing in the direction with which graphics were defined. This only affects graphics that can have such a direction; for example, arc, ellipse, line, rectangle, and ring. MIL ignores this setting for other graphics. MIL does not draw the direction arrow if the graphic is filled. This setting does not affect drawings created using a processing or analysis module draw function (M...Draw()). This affects graphics drawn destructively (raster-based), as well as graphics added to a 2D graphics list (vector-based version), which can then be used to non-destructively annotate a display. The direction arrow can be drawn in the primary and secondary direction of the graphic. For example, if you draw the primary direction for a rectangle defined with MgraRectAngle(), the arrow will point in the angular direction set with the Angle parameter. The following table lists the primary and secondary direction for the graphics. Graphic Primary direction Secondary direction Rectangle For MgraRect(), the primary direction is established by the angle that results from the rectangle's definition. For MgraRectAngle(), the primary direction is established by the rotation parameter setting (Angle). For MgraRect() and MgraRectAngle(), the secondary direction is equal to the PrimaryDirection - 90°. Arc For MgraArc() and MgraArcAngle(), the primary direction is established by the arc's definition, and is taken counter-clockwise along its tangent (tangential). For MgraArcAngle(), the arc's definition includes a rotation parameter setting (XAxisAngle). For MgraArc() and MgraArcAngle(), the secondary direction is from the arc's center to its radius (radial). Line, polyline, and polygon For MgraLine() and MgraLines() (for lines and polylines), the primary direction is from the line or polyline's start point to its end point. For MgraLines() (when defining polygons), the primary direction is from the start point to the end point of the polygon's last segment. For MgraLine() and MgraLines() (for lines, polylines, and polygons), the secondary direction is equal to - 90° from the PrimaryDirection. Drawing graphics in a calibrated image When a graphic is drawn, position, dimension, and angle information is interpreted according to the unit of measurement set using MgraControl() with M_INPUT_UNITS. If part of the graphic falls outside of the specified image buffer, that part is clipped off. A graphic defined in world units does not necessarily respect the graphic shape when viewed in pixel units, if there is distortion. For example, a straight-edge rectangle in world units might have arced edges when converted to pixel units due to spatial distortion. There are three different ways to manage graphic conversion from world to pixel units when distortion is present. To draw the graphic following distortion, the graphic can be converted respecting the camera calibration information exactly using MgraControl() (or MgraControlList()) with M_GRAPHIC_CONVERSION_MODE set to M_RESHAPE_FOLLOWING_DISTORTION. Alternatively, MIL can convert only the graphic's key points or features (for example, intersection-points, center-point or radius) using the camera calibration information, with M_GRAPHIC_CONVERSION_MODE set to M_RESHAPE_FROM_POINTS; the remainder of the graphic is drawn from these points, ignoring any non-linear distortion. This is the default mode. It is the fastest and is accurate as long as there is only linear distortion. If you require a dot or straight-edge rectangle with 90 degree angles drawn, ignoring all distortion, use M_GRAPHIC_CONVERSION_MODE set to M_PRESERVE_SHAPE_AVERAGE. Drawing graphics with offset and zoom Using MgraControl() with M_DRAW_OFFSET_X and M_DRAW_OFFSET_Y, you can offset the position of graphics in the destination image by a specified amount in pixels. The offset values are subtracted from the specified position of the graphic when it is rendered (because you are specifying where the old location is with respect to the new location). In addition, using MgraControl() with M_DRAW_ZOOM_X and M_DRAW_ZOOM_Y, you can have a graphic appear zoomed when rendered. The specified zoom factors will enlarge or shrink the apparent dimensions of a graphic in the X- and Y-direction. Any portion of a graphic that falls outside of the destination image when offset or zoomed is not drawn. This is particularly useful when drawing the results of a processing or analysis operation, using most of the M...Draw() functions. This allows you to draw a subset of positional results and settings (for example, the edge map of a region of an image) at a required magnification and starting from a required location in a destination image. For example, the following image shows the edge map of a region of a source image, beginning at the point (X draw-offset, Y draw-offset) in the source image's coordinate system, and being drawn and zoomed by a factor of 3 in both X- and Y- directions, in a destination image buffer using MedgeDraw(). M_DRAW_OFFSET_... and M_DRAW_ZOOM_... are also useful to draw results, obtained from a child buffer, as if they were obtained from an operation on its parent buffer. For example, the following image shows results obtained from a child buffer drawn in a parent buffer, with and without offset. Since the offsets are subtracted from the position at which to draw in the destination, this example requires M_DRAW_OFFSET_... be set to negative values to draw the edges at the right location in the destination image. Drawing graphics Drawing vectors Drawing direction Drawing graphics in a calibrated image Drawing graphics with offset and zoom ",
      "wordCount": 1547,
      "subEntries": []
    },
    {
      "id": "UG_graphics_Writing_text",
      "version": null,
      "title": "Writing text",
      "subTitles": null,
      "location": "MIL UG P04: 2D related information",
      "pageURL": "content\\UserGuide\\graphics\\Writing_text.htm",
      "text": " Writing text To perform text annotations, use MgraText(), which writes a string at the specified position in a given buffer. The position is interpreted according to the specified units and associated coordinate system set using MgraControl() with M_INPUT_UNITS. MgraText() can also add text to a 2D graphics list. For more information, see the 2D graphics list section later in this chapter. Text is drawn using the current foreground color of the 2D graphics context. The 2D graphics context also assigns the following settings to text: Background mode. This determines whether to fill the background of the text. The default is to fill the background. To change the default (for example, to make it transparent), use MgraControl() with M_BACKGROUND_MODE. Background color. This determines the color used behind text. The default background color value is zero (typically corresponds to black). To change the default, use MgraControl() with M_BACKCOLOR or MgraBackColor(). Font. This determines the text's font. You can choose between a bitmap font, or a TrueType font installed on your computer. To change the text font, use MgraFont(). You can specify a TrueType font using MgraFont(). You can use the default TrueType font of your operating system by passing M_FONT_DEFAULT_TTF, or you can specify a font and style by passing a MIL_TEXT string according to the following format: Family: Weight: Slant (for example, \" Arial: Bold: Italic \"). You can also pass a MIL_TEXT string with the path to a TrueType font file (for example, \"C:\\myDirectory\\myTrueTypeFont.ttf \"). If a specified TrueType font does not support a character code that needs to be drawn, you can have MIL search for a suitable font to draw the character using MgraControl() with M_FONT_AUTO_SELECT. You can specify the size of TrueType fonts using MgraControl() with M_FONT_SIZE. With bitmap fonts, it is not possible to specify an exact font size other than the three provided default sizes (M_FONT_DEFAULT_LARGE, M_FONT_DEFAULT_MEDIUM, and M_FONT_DEFAULT_SMALL). However, using MgraControl() with M_FONT_X_SCALE and M_FONT_Y_SCALE, or MgraFontScale(), you can scale any of the three default bitmap sizes to a more suitable size. Horizontal and vertical alignment. This determines the alignment of the text in the horizontal and vertical direction. The defaults are left-aligned and top-aligned, with respect to the string's specified X- and Y-position. To change the defaults, use MgraControl() with M_TEXT_ALIGN_HORIZONTAL and M_TEXT_ALIGN_VERTICAL. Text border. This allows you to draw a border around the block of text that you want to print. You can draw a border above, below, to the left, or to the right of the text, or any combination of the four directions. The default is to draw no borders. To change the defaults, use MgraControl() with M_TEXT_BORDER. Text direction. This allows you to specify the direction to draw the text. The default is to draw the text from left to right. To change the defaults, use MgraControl() with M_TEXT_DIRECTION. For an example of how to perform multiple text annotations with differing fonts, see: mgratext.cpp Writing text ",
      "wordCount": 489,
      "subEntries": []
    },
    {
      "id": "UG_graphics_Graphics_list",
      "version": null,
      "title": "2D graphics list",
      "subTitles": [
        "Annotating the display with a 2D graphics list "
      ],
      "location": "MIL UG P04: 2D related information",
      "pageURL": "content\\UserGuide\\graphics\\Graphics_list.htm",
      "text": " 2D graphics list A 2D graphics list is a MIL object that allows you to temporarily store graphics in vector (mathematical) form for later drawing or for defining the geometry of another MIL object (for example, the ROI of an image buffer). When annotating an image buffer without a 2D graphics list, the graphic is drawn destructively in that image, and is raster-based. That is, the drawing changes the image's pixel values along the specified graphic. Once graphics are drawn in this way, they can only be modified on a pixel-by-pixel basis. However, if you draw a graphic in a 2D graphics list, the graphic is added to the list in vector (mathematical) form. Although drawing graphics destructively into an image buffer with a graphics function (such as MgraLine()) can seem faster, in certain cases, it can be preferable to first add the graphics to a list, and then draw them, using MgraDraw(). By doing so, you can: Permit the graphic to be zoomed without pixelization effects and changes in line thickness when rendered on a display that is being zoomed. Have more efficient code by adding all the graphics to a memory efficient object (2D graphics list), and then using those graphics to annotate numerous images. If required, you can use MgraControlList() to modify the graphics before each call to MgraDraw(). Add the graphics to the list once, using world units, and then annotate numerous images, each with their own camera calibration context. For example, if two cameras have taken an image in the same absolute coordinate system, and you wish to annotate both images at the same world position, you can define the graphics in world units and the graphics will be mapped, using the camera calibration context of each image, to the correct area in the pixel coordinate system. Add the graphics to the list in world units before you have the calibrated image. Create an M_VECTOR region of interest (ROI) for an image buffer, which is then used by some processing functions (for example, McodeRead()). Interactively create and modify graphics from a display. To allocate a 2D graphics list, use MgraAllocList(). To add graphics to the list, use one of the Mgra...() graphics functions (for example, MgraDot()) or use the M...Draw() function of a processing or analysis module; however, pass the 2D graphics list identifier instead of an image buffer identifier. You define the graphic itself as if it were being drawn in an image. For example, a dot is always defined with an X- and Y-position, regardless of whether you are drawing it in an image or adding it to a 2D graphics list. /* Draw a dot directly in an image. */ MgraDot(GraphicsContextId, ImageId, 100, 120); /* Add a dot graphic in a graphics list. */ MgraDot(GraphicsContextId, GraphicsListId, 100, 120); For more information about how graphics are defined and drawn, see the Drawing graphics section earlier in this chapter. Some draw operations of M...Draw() functions cannot draw in a 2D graphics list or have restrictions when drawing in a 2D graphics list. For more information, see the relevant M...Draw() function in the MIL Reference. If required, you can also use MgraDraw() to draw the graphics, contained in a list, destructively in an image all at once. /* Add a line in the graphics list and draw this graphics list in an image. */ MgraLine(GraphicsContextId, GraphicsListId, 100, 100, 200, 200); MgraDraw(GraphicsListId, ImageId, M_DEFAULT); /* This has the same effect as doing MgraLine(GraphicsContextId, ImageId, 100, 100, 200, 200); */ When you add graphics to the list, the graphics inherit the current settings of the specified 2D graphics context; however, there is no link between the 2D graphics list and the 2D graphics context. Graphics already in the list are not affected by changes made to the context. For example, if you have a 2D graphics list that contains blue graphics, but you change the 2D graphics context so that graphics can have a red color, the graphics already in the list will retain their blue color, and only graphics added after the change to the context will be red. Graphics can be accessed from the 2D graphics list using either an index or label value. Both values are attributed to the graphic when it is added to the list. In the case of the index value, it refers to the graphic's position in the 2D graphics list, and can change if graphics are moved or deleted. In the case of the label value, it is a label given to the graphic when added to the list and will not change, even if the order of the graphics in the list changes due to graphics being deleted or moved. You can retrieve a graphic's label using MgraInquireList() with M_LAST_LABEL immediately after adding the graphic to the list. Note that when using multiple threads, M_LAST_LABEL will return the label of the last graphic added to the list for the thread on which MgraInquireList() is called. To adjust the settings of graphics in the list, use MgraControlList(). To inquire current 2D graphics list settings, use MgraInquireList(). To remove graphics from the list, use MgraClear() or MgraControlList() with M_DELETE. To copy graphics from one 2D graphics list to another, use MgraCopy(). To move graphics in a 2D graphics list, use MgraCopy() with M_MOVE. The following example demonstrates how to add graphics to a 2D graphics list, and how to change its settings. /* Add a first dot in a graphics list, with color blue. */ MgraControl(GraphicsContextId, M_COLOR, M_COLOR_BLUE); MgraDot(GraphicsContextId, GraphicsListId, 100, 120); MgraInquireList(GraphicsListId, M_LIST, M_DEFAULT, M_LAST_LABEL, &amp;BlueDotLabel); /* Add a second dot in a graphics list, with color red. */ MgraControl(GraphicsContextId, M_COLOR, M_COLOR_RED); MgraDot(GraphicsContextId, GraphicsListId, 100, 130); MgraInquireList(GraphicsListId, M_LIST, M_DEFAULT, M_LAST_LABEL, &amp;RedDotLabel); /* (Note that the first dot remains blue). */ /* ... */ /* Change the position of the blue dot in the list. */ MgraInquireList(GraphicsListId, M_GRAPHIC_LABEL(BlueDotLabel), M_DEFAULT, M_POSITION_X, &amp;PositionX); PositionX *= 2.0; MgraControlList(GraphicsListId, M_GRAPHIC_LABEL(BlueDotLabel), M_DEFAULT, M_POSITION_X, PositionX); Annotating the display with a 2D graphics list Typically, the graphics in a 2D graphics list are used to annotate the display non-destructively, using MdispControl() with M_ASSOCIATED_GRAPHIC_LIST_ID; this associates the display with the 2D graphics list. By default, modifications to the graphics within the list are immediately reflected in the non-destructive annotation of the display (refresh not required). To change this behavior, use MdispControl() with M_UPDATE_GRAPHIC_LIST. Only one 2D graphics list can be associated with a display. If you associate a 2D graphics list with a display that already has been associated with one, the previous 2D graphics list is disassociated from the display and the new one is associated. Since the graphics in the list are in vector form, the zooming behavior of a display with 2D graphics list annotations will be different than if you had drawn graphics destructively in the image selected to the display. For example, when zooming a display with 2D graphics list annotations, there is no loss of clarity, missing graphic elements, or changes in line thickness (which, as mentioned earlier in the chapter, is one pixel by default, and can be modified using MgraControl() or MgraControlList() with M_LINE_THICKNESS). The following example shows how a 2D graphics list is used to annotate the display. /* Add a line in the graphics list. */ MgraLine(GraphicsContextId, GraphicsListId, 100, 100, 200, 200); /* Annotate a display using the graphics list. */ MdispControl(DisplayId, M_ASSOCIATED_GRAPHIC_LIST_ID, GraphicsListId); /* Zoom the display. The line's thickness does not change; it remains at one pixel. */ MdispZoom(DisplayId, 2.0, 2.0); /* Change the color of the line in the graphics list. This will automatically update the display. */ MgraControlList(GraphicsListId, M_GRAPHIC_INDEX(0), M_DEFAULT, M_COLOR, M_COLOR_GREEN); For more information, see the Using a 2D graphics list subsection of the Annotating the displayed image non-destructively section of Chapter 25: Displaying an image. 2D graphics list Annotating the display with a 2D graphics list ",
      "wordCount": 1306,
      "subEntries": []
    },
    {
      "id": "UG_graphics_Creating_and_modifying_graphics_interactively",
      "version": null,
      "title": "Creating and modifying graphics interactively",
      "subTitles": [
        "Hooking a function to a 2D graphics list event ",
        "Creating graphics interactively",
        "Details about creating graphics interactively",
        "Rectangle",
        "Arc, ellipse, and circle",
        "Polygon",
        "Polyline",
        "Line"
      ],
      "location": "MIL UG P04: 2D related information",
      "pageURL": "content\\UserGuide\\graphics\\Creating_and_modifying_graphics_interactively.htm",
      "text": " Creating and modifying graphics interactively You can create and edit graphics interactively in a display. This can be useful to, for example, interactively define a graphic that covers a required region, and then use the graphic to define or modify a region of interest. The following steps provide a basic methodology for enabling and controlling interactivity with graphics: Associate a 2D graphics list with your display using MdispControl() with M_ASSOCIATED_GRAPHIC_LIST_ID. If necessary, restrict interactive properties of graphics using MgraControl() or MgraControlList(). Hook a function to the 2D graphics list event caused by a change in the state of interactivity of a graphic, using MgraHookFunction() with M_INTERACTIVE_GRAPHIC_STATE_MODIFIED. For example, if the state of interactivity changes from M_STATE_..._DRAGGED to M_STATE_..._HOVERED, a graphic has been modified interactively. Make graphics in the 2D graphics list interactive using MdispControl() with M_GRAPHIC_LIST_INTERACTIVE. If necessary, allow the user to add graphics interactively to the 2D graphics list using MgraInteractive() set to one of the possible graphics types. With a graphic that has interactivity enabled, you can move a graphic's position, resize the graphic, or rotate the graphic. When a user clicks on a displayed graphic with interactivity enabled, the graphic is considered selected. By default, you must click on the contour of a graphic to select it. To select closed graphics (such as circles) by clicking anywhere on them, even if they are not filled, call MgraControlList() and enable M_EASY_SELECTION. A selected graphic is typically surrounded by a selection box (represented with a dotted line) with handles around it that allows a user to resize or rotate the graphic. Certain graphics can also have handles specific to that graphic. For example, an arc has handles to increase its length and the polygon has handles to change the position of each vertex. When you restrict any or all of the interactive properties of a graphic using MgraControl() or MgraControlList(), the handles specific to that property will not appear. For example, disabling interactive rotation will cause the rotate handle to not appear when the graphic is selected. You can select multiple graphics on the display by pressing the Ctrl key while clicking on the required graphics. To change this behavior, call MgraControlList() with M_MULTIPLE_SELECTION_KEY. The 2D graphics list has default behaviors for interactively moving, resizing, or rotating its graphics. To modify these behaviors, call MgraControlList() with M_MODE_.... For example, if you click on a corner of a graphic's selection box and drag your mouse to resize the graphic, the opposite corner remains fixed. This happens because M_MODE_RESIZE is set to M_FIXED_CORNER by default. To modify this resizing behavior so that, as you drag a corner of the selection box with your mouse, all corners move symmetrically (and the center remains fixed), set M_MODE_RESIZE to M_FIXED_CENTER. The 2D graphics list also has default behaviors for interactively moving, resizing, or rotating its graphics with your mouse while pressing the Alt (M_MODE_..._ALT), Ctrl (M_MODE_..._CTRL), or Shift (M_MODE_..._SHIFT) key. Instead of using your mouse to move, resize, or rotate interactively selected graphics, you can use keys on the keyboard. For example, you can specify that pressing the Arrow keys will move the selected graphic. To specify keyboard keys with which to manipulate (perform actions on) interactively selected graphics, call MgraControlList() with M_ACTION_KEY_.... For a complete list of settings that let you control interactivity in your application, refer to MgraControl() or MgraControlList(). Hooking a function to a 2D graphics list event The MIL Graphics module allows you to hook a function to a 2D graphics list event using MgraHookFunction(). When developing applications that allow interactive user manipulations of graphics, it can be advantageous if a function is hooked to the event caused by a change in the state of interactivity in the 2D graphics list (M_INTERACTIVE_GRAPHIC_STATE_MODIFIED). The associated function will automatically be triggered whenever the state of interactivity is changed. The state of interactivity (M_INTERACTIVE_GRAPHIC_STATE) indicates the active interaction state occurring on the selected graphics in the 2D graphics list. If, for example, a graphic is displayed with interactive mode enabled, and the cursor is not hovered over the graphic or one of its handles, then the state of interactivity is M_STATE_IDLE. If the user then hovers over the graphic or one of its handles with the cursor, the state of interactivity changes to M_STATE_GRAPHIC_HOVERED or M_STATE_HANDLE_HOVERED, respectively. If the user then holds down the left mouse button when hovering over the graphic or one of its handles, the state of interactivity changes to M_STATE_GRAPHIC_DRAGGED or M_STATE_HANDLE_DRAGGED, respectively. There are other events to which you can hook a function, such as M_GRAPHIC_LIST_MODIFIED, M_GRAPHIC_MODIFIED, and M_GRAPHIC_SELECTION_MODIFIED. These events will trigger due to both interactive and programmatic changes. For an example of using MgraHookFunction() in an application with an interactive graphic, see: mgrainteractive.cpp Creating graphics interactively You can allow a user to interactively add a graphic to a 2D graphics list. The function MgraInteractive() changes the state of interactivity of the 2D graphics list to allow the user to define graphics in the display using the mouse. The graphic types that can be created interactively are: an arc (M_GRAPHIC_TYPE_ARC), a dot (M_GRAPHIC_TYPE_DOT), a line (M_GRAPHIC_TYPE_LINE), a polygon (M_GRAPHIC_TYPE_POLYGON), a polyline (M_GRAPHIC_TYPE_POLYLINE), and a rectangle (M_GRAPHIC_TYPE_RECT). By calling MgraInteractive() with one of these values, the state of interactivity changes to M_STATE_WAITING_FOR_CREATION. For more information about how to create these graphics interactively, see the Details about creating graphics interactively subsection of this section. When in an M_STATE_WAITING_FOR_CREATION state, the user is expected to define a graphic interactively in the display. Note, however, that MgraInteractive() is asynchronous and only changes the state of interactivity; it will not wait for the user to define the graphic. You should have your application wait for the user to finish defining the graphic, before calling further functions. When the user begins defining the graphic, the state of interactivity (M_INTERACTIVE_GRAPHIC_STATE) changes to M_STATE_BEING_CREATED. After a user has defined the graphic interactively, the state of interactivity returns to M_STATE_IDLE and you can continue your application from that moment. If the program does not wait for the user to create the graphic after a call to MgraInteractive(), your application might not perform as you initially intended. Waiting for user interaction can be accomplished by hooking a function to M_INTERACTIVE_GRAPHIC_STATE_MODIFIED event and having the hook function signal the end of the thread wait event. The following example shows how to wait for the user to interactively add a rectangle to the 2D graphics list and then use this graphic to define the ROI of an image buffer. The hook-handler function is called each time the state of interactivity changes, and checks if the state has changed to M_STATE_BEING_CREATED. A data structure is used to store information inquired in the hook-handler function. Note that when using interactive graphics, the graphics can potentially be added in a different thread. In the following example, the label of the graphic is obtained using MgraGetHookInfo() with M_GRAPHIC_LABEL_VALUE rather than using MgraInquireList() with M_LAST_LABEL. This is due to the fact that MgraGetHookInfo() with M_GRAPHIC_LABEL_VALUE will return the label value of an interactively created graphic regardless of the thread in which the graphic was added. /* Structure used to hold information for the hook function. */ struct CreateGraphicInfo { MIL_ID CreationDoneEventThrId; MIL_INT CreatedGraphicLabel; }; /* Function used to interactively define graphic for use as an ROI */ static MIL_INT DefineRectROI(MIL_ID SysId, MIL_ID ImageId, MIL_ID GraphicsContextId, MIL_ID GraphicsListId) { /* Create a synchronization event to indicate when graphic creation is done. */ CreateGraphicInfo HookInfo; MthrAlloc(SysId, M_EVENT, M_NOT_SIGNALED+M_AUTO_RESET, M_NULL, M_NULL, &amp;HookInfo.CreationDoneEventThrId); /* Hook a function to detect when the graphic's creation has ended, and pass a MIL event to it, in order to notify the thread to resume. */ MgraHookFunction(GraphicsListId, M_INTERACTIVE_GRAPHIC_STATE_MODIFIED, &amp;WaitUntilCreationEnds, &amp;HookInfo); /* Set the graphics list's state to M_WAIT_FOR_CREATION. This allows the user to add a graphic interactively to the list from the display. The graphic is created by clicking in the display at the location you require one of the rectangle's corners and dragging your cursor to the opposite corner. */ MgraInteractive(GraphicsContextId, GraphicsListId, M_GRAPHIC_TYPE_RECT, M_DEFAULT, M_AXIS_ALIGNED_RECT); /* Wait for the graphic creation to end. The function hooked to the event will set the event state to M_SIGNALED to indicate that graphic creation has ended. */ MthrWait(HookInfo.CreationDoneEventThrId, M_EVENT_WAIT, M_NULL); /* Free allocated resources. */ MthrFree(HookInfo.CreationDoneEventThrId); /* Get the label of the newly created rectangle. Note that MgraInquireList() with M_LAST_LABEL might not work at this point, since the graphic might have been created in a separate thread. The call to retrieve the graphic's label is performed in the hooked function, after the graphic is added to the list.*/ MIL_INT RectangleLabel = HookInfo.CreatedGraphicLabel; /* Use the user-defined rectangle to define the region of interest for later processing.*/ MbufSetRegion(ImageId, GraphicsListId, M_DEFAULT, M_RASTERIZE+M_FILL_REGION, M_DEFAULT); /* Return the label of the rectangle to the main function */ return RectangleLabel; } Where the hooked function is: /* Hook function used to notify a thread that interactive graphic creation has ended. */ static MIL_INT MFTYPE WaitUntilCreationEnds(MIL_INT HookType, MIL_ID EventId, void *UserDataPtr) { /* Casts UserDataPtr to the data type of the hook information structure. */ CreateGraphicInfo* HookInfoPtr = (CreateGraphicInfo*)UserDataPtr; /* Get the previous and current interactive states of the graphics list. */ MIL_INT PreviousInteractiveState, CurrentInteractiveState; MgraGetHookInfo(EventId, M_INTERACTIVE_GRAPHIC_PREVIOUS_STATE, &amp;PreviousInteractiveState); MgraGetHookInfo(EventId, M_INTERACTIVE_GRAPHIC_STATE, &amp;CurrentInteractiveState); if (CurrentInteractiveState == M_STATE_BEING_CREATED) { /* If the current state is M_STATE_BEING_CREATED, the graphic being created has been assigned a label value and position in the graphics list. Fetch its label and store it in the hook information structure. */ MgraGetHookInfo(EventId, M_GRAPHIC_LABEL_VALUE, &amp;HookInfoPtr-&gt;CreatedGraphicLabel); } else if (PreviousInteractiveState == M_STATE_BEING_CREATED) { /* If the previous state was M_STATE_BEING_CREATED, graphic creation is done. Set the event state to M_SIGNALED so the waiting thread can continue execution. */ MthrControl(HookInfoPtr-&gt;CreationDoneEventThrId, M_EVENT_SET, M_SIGNALED); } return M_NULL; } MgraInteractive() can be useful if your application requires toolbars for a graphical user interface. For example, you can use another API to create a toolbar, with one of its buttons calling MgraInteractive() with M_GRAPHIC_TYPE_RECT. After clicking on the toolbar button, the user can create a rectangle in the display to specify where to perform processing or analysis in the image. Details about creating graphics interactively The following subsections illustrate some details about how to interactively create graphics, by calling MgraInteractive() with M_GRAPHIC_TYPE_.... Rectangle M_GRAPHIC_TYPE_RECT adds a rectangle to the 2D graphics list by defining it interactively in the display. Typically, M_GRAPHIC_TYPE_RECT is set to M_AXIS_ALIGNED_RECT, to define an axis-aligned rectangle. This requires you to click on a rectangle's corner in the display, and then drag the mouse to the opposite corner. An example of this behavior can be seen in the animation below. M_GRAPHIC_TYPE_RECT can also be set to M_ORIENTED_RECT, to define an oriented rectangle. This requires three clicks in the display. By default, the first click defines a fixed corner of the rectangle, the second click defines its width (a line extending to the fixed corner) and orientation, and the third click defines its height on one side of the width line. An example of this behavior can be seen in the animation below. Arc, ellipse, and circle M_GRAPHIC_TYPE_ARC adds an arc to the 2D graphics list by defining it interactively in the display. You can also use M_GRAPHIC_TYPE_ARC to interactively define a circle or ellipse. Typically, M_GRAPHIC_TYPE_ARC is to M_AXIS_ALIGNED_ELLIPSE, to define an axis-aligned ellipse (or circle). This requires you to click on one corner of the ellipse bounding box in the display, and then drag the mouse to the opposite corner. An example of this behavior can be seen in the animation below. By setting M_GRAPHIC_TYPE_ARC to M_ARC_THREE_POINTS, you can define a circular arc. This requires three clicks in the display. The first and third clicks determine the arc's start angle and end angle (not necessarily in this order); the second click establishes the position of the arc. An example of this behavior can be seen in the animation below. Instead of using the ellipse's bounding box, you can set M_GRAPHIC_TYPE_ARC to M_CIRCLE, to use the circumference of a circle. An example of this behavior can be seen in the animation below. Polygon M_GRAPHIC_TYPE_POLYGON adds a polygon to the 2D graphics list by defining it interactively in the display. This requires you to left-click each polygon vertex in the display, except for the last vertex, which you must define with a right-click. By default, creating a polygon while holding down the Alt key snaps the next polygon segment to 15° angles. An example of this behavior can be seen in the animation below. Polyline M_GRAPHIC_TYPE_POLYLINE adds a polyline to the 2D graphics list by defining it interactively in the display. This requires you to left-click each polyline vertex in the display, except for the last vertex, which you must define with a right-click. By default, creating a polyline while holding down the Alt key snaps the next polyline segment to 15° angles. An example of this behavior can be seen in the animation below. Line M_GRAPHIC_TYPE_LINE adds a line to the 2D graphics list by defining the line interactively in the display. This requires you to click on the line's start point in the display, and then drag the mouse to the line's end point. Holding Alt during line manipulations will restrict its orientation to specific angles; use M_ANGLE_SNAPPING_VALUE to specify the snapping angle values. An example of this behavior can be seen in the animation below. Creating and modifying graphics interactively Hooking a function to a 2D graphics list event Creating graphics interactively Details about creating graphics interactively Rectangle Arc, ellipse, and circle Polygon Polyline Line ",
      "wordCount": 2244,
      "subEntries": []
    }
  ]
}]
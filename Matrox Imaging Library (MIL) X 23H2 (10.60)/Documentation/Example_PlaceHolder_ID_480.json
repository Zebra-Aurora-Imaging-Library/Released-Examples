[{
  "id": "Example_PlaceHolder_ID",
  "version": "2024020714",
  "title": "Example_PlaceHolder_Title",
  "wordCount": 0,
  "subEntries": [
    {
      "id": "Examples_Processing_2dCalibration_CalGenChessGrid_CPP_addfiducials_cpp",
      "version": "2024020714",
      "title": "addfiducials.cpp",
      "location": "Sample Code from MIL Examples",
      "text": " Top //*************************************************************************************** // // File name: addfiducials.cpp // Location: See Matrox Example Launcher in the MIL Control Center // // // Synopsis: This file implements AddFiducials(), declared in common.h. // // Copyright (C) Matrox Electronic Systems Ltd., 1992-2024. // All Rights Reserved #include \"common.h\" //***************************************************************************** // Structure containing information to encode in a fiducial. //***************************************************************************** struct FiducialInfoStruct { UnitEnum Unit; MIL_INT SpacingExponent; // spacing exponent in [-5, 4] MIL_INT SpacingMantissaX; // mantissa for the X spacing; can be 1 or 3 digits long MIL_INT SpacingMantissaY; // mantissa for the Y spacing; can be 1 or 3 digits long MIL_INT FiducialPositionX; // X position of the fiducial relative to the grid reference point, in terms of grid squares MIL_INT FiducialPositionY; // Y position of the fiducial relative to the grid reference point, in terms of grid squares static const MIL_INT MAX_ENCODED_STRING_LENGTH = 32; // real maximum is 16 digits, +1 for \\0 MIL_TEXT_CHAR EncodedString[MAX_ENCODED_STRING_LENGTH]; // all the information above, encoded in a Datamatrix string // Uses all members to create EncodedString. void Encode(); }; //***************************************************************************** // Basic digit encoding function. Starts at CurPtr and writes exactly NumDigits // characters, which are the digits of ValueToEncode (left-padded with zeros). // CurPtr is moved by the function. //***************************************************************************** static void EncodeAndMovePointer(MIL_INT ValueToEncode, MIL_INT NumDigits, MIL_TEXT_PTR&amp; CurPtr) { MIL_INT PowerOf10 = 1; for (MIL_INT i = 1; i &lt; NumDigits; ++i) PowerOf10 *= 10; for (MIL_INT i = 0; i &lt; NumDigits; ++i) { MIL_INT DigitToEncode = ValueToEncode / PowerOf10; if (!(0 &lt;= DigitToEncode &amp;&amp; DigitToEncode &lt;= 9)) throw MIL_TEXT(\"ValueToEncode is larger than the maximum number of digits\"); MIL_TEXT_CHAR Char = static_cast&lt;MIL_TEXT_CHAR&gt;(MIL_TEXT('0') + DigitToEncode); *CurPtr++ = Char; ValueToEncode %= PowerOf10; PowerOf10 /= 10; } } //***************************************************************************** // Takes a filled FiducialInfoStruct and generates its EncodedString member, // according to the fiducial encoding supported by the MIL calibration module. //***************************************************************************** void FiducialInfoStruct::Encode() { const MIL_INT NEED_2_SPACINGS_BIT = (1 &lt;&lt; 3); const MIL_INT NEED_3_DIGITS_SPACINGS_BIT = (1 &lt;&lt; 4); const MIL_INT NEED_2_DIGITS_POSITIONS_BIT = (1 &lt;&lt; 5); const MIL_INT NEED_3_DIGITS_POSITIONS_BIT = (1 &lt;&lt; 6); const MIL_INT SPACING_EXPONENT_OFFSET = 5; if (!(-5 &lt;= SpacingExponent &amp;&amp; SpacingExponent &lt;= 4)) throw MIL_TEXT(\"Spacing exponent is out of the range [-5, 4]\"); if (!(0 &lt;= SpacingMantissaX &amp;&amp; SpacingMantissaX &lt;= 999)) throw MIL_TEXT(\"X spacing's mantissa cannot be represented on 3 digits\"); if (!(0 &lt;= SpacingMantissaY &amp;&amp; SpacingMantissaY &lt;= 999)) throw MIL_TEXT(\"Y spacing's mantissa cannot be represented on 3 digits\"); if (!(-500 &lt;= FiducialPositionX &amp;&amp; FiducialPositionX &lt;= 499)) throw MIL_TEXT(\"The fiducial X position is out of the range [-500, 499]\"); if (!(-500 &lt;= FiducialPositionY &amp;&amp; FiducialPositionY &lt;= 499)) throw MIL_TEXT(\"The fiducial Y position is out of the range [-500, 499]\"); // Determine the configuration field first. MIL_INT ConfigField = 0; // bit 0-2 must be set to 0. if (SpacingMantissaX != SpacingMantissaY) ConfigField |= NEED_2_SPACINGS_BIT; // bit set because we need 2 spacing fields if (SpacingMantissaX &gt;= 10 || SpacingMantissaY &gt;= 10) ConfigField |= NEED_3_DIGITS_SPACINGS_BIT; // bit set because we need 3 digits for spacings if (FiducialPositionX != 0 || FiducialPositionY != 0) { if ( -50 &lt;= FiducialPositionX &amp;&amp; FiducialPositionX &lt;= 49 &amp;&amp; -50 &lt;= FiducialPositionY &amp;&amp; FiducialPositionY &lt;= 49 ) ConfigField |= NEED_2_DIGITS_POSITIONS_BIT; // bit set because we need 2 digits for positions else if ( -500 &lt;= FiducialPositionX &amp;&amp; FiducialPositionX &lt;= 499 &amp;&amp; -500 &lt;= FiducialPositionY &amp;&amp; FiducialPositionY &lt;= 499 ) ConfigField |= NEED_3_DIGITS_POSITIONS_BIT; // bit set because we need 3 digits for positions } // else no bit set indicates there is no position field // The fiducial is valid. Ready to start encoding. MIL_TEXT_PTR CurPtr = EncodedString; EncodeAndMovePointer(ConfigField, 2, CurPtr); EncodeAndMovePointer(static_cast&lt;MIL_INT&gt;(Unit), 1, CurPtr); EncodeAndMovePointer(SpacingExponent + SPACING_EXPONENT_OFFSET, 1, CurPtr); MIL_INT NumSpacingDigits = ((ConfigField &amp; NEED_3_DIGITS_SPACINGS_BIT) != 0 ? 3 : 1); EncodeAndMovePointer(SpacingMantissaX, NumSpacingDigits, CurPtr); if ((ConfigField &amp; NEED_2_SPACINGS_BIT) != 0) EncodeAndMovePointer(SpacingMantissaY, NumSpacingDigits, CurPtr); if ((ConfigField &amp; (NEED_2_DIGITS_POSITIONS_BIT | NEED_3_DIGITS_POSITIONS_BIT)) != 0) { MIL_INT NumPositionDigits = ((ConfigField &amp; NEED_3_DIGITS_POSITIONS_BIT) != 0 ? 3 : 2); MIL_INT PositionOffset = ((ConfigField &amp; NEED_3_DIGITS_POSITIONS_BIT) != 0 ? 500 : 50); EncodeAndMovePointer(FiducialPositionX + PositionOffset, NumPositionDigits, CurPtr); EncodeAndMovePointer(FiducialPositionY + PositionOffset, NumPositionDigits, CurPtr); } // Terminate string. *CurPtr++ = MIL_TEXT('\\0'); if (CurPtr - EncodedString &gt;= FiducialInfoStruct::MAX_ENCODED_STRING_LENGTH) throw MIL_TEXT(\"The fiducial encoded string is too long (buffer overrun)\"); } //***************************************************************************** // Class that uses the MIL code module to generate the datamatrix fiducials. // Encapsulates all MIL objects, so that they are correctly freed, even in the // presence of exceptions. //***************************************************************************** class CDatamatrixDrawer { public: CDatamatrixDrawer(MIL_ID SysId, MIL_ID GridImageId); ~CDatamatrixDrawer(); void Draw(MIL_INT ChildStartX, MIL_INT ChildStartY, MIL_INT ChildSizeX, MIL_INT ChildSizeY, MIL_INT FilenameIndex, const FiducialInfoStruct&amp; FiducialInfo); private: MIL_ID m_SysId; // system on which to allocate MIL objects MIL_ID m_CodeContextId; // code context used to draw fiducials MIL_ID m_CodeModelId; // specific code model in the code context MIL_ID m_DestChildId; // child buffer on top of the grid image passed to the constructor MIL_ID m_CodeImageId; // temporary image buffer used as destination of McodeWrite() }; //***************************************************************************** // Constructor. //***************************************************************************** CDatamatrixDrawer::CDatamatrixDrawer(MIL_ID SysId, MIL_ID GridImageId) : m_SysId (SysId), m_CodeContextId(M_NULL), m_CodeModelId (M_NULL), m_CodeImageId (M_NULL), m_DestChildId (M_NULL) { McodeAlloc(m_SysId, M_DEFAULT, M_DEFAULT, &amp;m_CodeContextId); McodeModel(m_CodeContextId, M_ADD, M_DATAMATRIX, M_NULL, M_DEFAULT, &amp;m_CodeModelId); McodeControl(m_CodeModelId, M_ERROR_CORRECTION, M_ECC_200); MbufChild2d(GridImageId, 0, 0, 1, 1, &amp;m_DestChildId); } //***************************************************************************** // Destructor. Ensures all MIL objects are correctly freed, even in the // presence of exceptions. //***************************************************************************** CDatamatrixDrawer::~CDatamatrixDrawer() { if (m_DestChildId != M_NULL) MbufFree (m_DestChildId ); if (m_CodeImageId != M_NULL) MbufFree (m_CodeImageId ); if (m_CodeContextId != M_NULL) McodeFree(m_CodeContextId); } //***************************************************************************** // Uses the MIL code module to generate the datamatrix fiducial that encodes // the string in FiducialInfo, rescales it and copies it in the destination. //***************************************************************************** void CDatamatrixDrawer::Draw(MIL_INT ChildStartX, MIL_INT ChildStartY, MIL_INT ChildSizeX, MIL_INT ChildSizeY, MIL_INT FilenameIndex, const FiducialInfoStruct&amp; FiducialInfo) { // Determine the image size needed for McodeWrite(). MIL_ID WriteResultId = McodeAllocResult(m_SysId, M_CODE_WRITE_RESULT, M_NULL); McodeWrite(m_CodeModelId, M_NULL, FiducialInfo.EncodedString, M_DEFAULT, WriteResultId); MIL_INT CodeSizeX, CodeSizeY; McodeGetResult(WriteResultId, M_WRITE_SIZE_X + M_TYPE_MIL_INT, &amp;CodeSizeX); McodeGetResult(WriteResultId, M_WRITE_SIZE_Y + M_TYPE_MIL_INT, &amp;CodeSizeY); if (CodeSizeX != CodeSizeY) // MimResize(M_FILL_DESTINATION) should not be used throw MIL_TEXT(\"This example expects a square datamatrix\"); // Allocate a temporary image and draw the fiducial. // Free the image from a previous call, if necessary. if (m_CodeImageId != M_NULL) MbufFree(m_CodeImageId); MbufAlloc2d(m_SysId, CodeSizeX, CodeSizeY, 8+M_UNSIGNED, M_IMAGE+M_PROC, &amp;m_CodeImageId); McodeWrite(m_CodeModelId, m_CodeImageId, FiducialInfo.EncodedString, M_DEFAULT, WriteResultId); // Free code write result buffer McodeFree(WriteResultId); // Save the fiducial image. const MIL_INT MAX_FILENAME_LEN = 256; MIL_TEXT_CHAR Filename[MAX_FILENAME_LEN]; MosSprintf(Filename, MAX_FILENAME_LEN, OUTPUT_CODE_NAME, (int)FilenameIndex); MbufExport(Filename, OUTPUT_FILE_FORMAT, m_CodeImageId); MosPrintf(MIL_TEXT(\" At position (%d, %d): saved as '%s'\\n\"), (int)FiducialInfo.FiducialPositionX, (int)FiducialInfo.FiducialPositionY, Filename); // Change the fiducial colors. MIL_DOUBLE CodeForegroundColor = 0.0; MIL_DOUBLE CodeBackgroundColor = 255.0; if (FOREGROUND_COLOR == CodeBackgroundColor) { MimArith(m_CodeImageId, M_NULL, m_CodeImageId, M_NOT); CodeForegroundColor = 255.0; CodeBackgroundColor = 0.0; } if (FOREGROUND_COLOR != CodeForegroundColor) MimClip(m_CodeImageId, m_CodeImageId, M_EQUAL, CodeForegroundColor, M_NULL, FOREGROUND_COLOR, M_NULL); if (BACKGROUND_COLOR != CodeBackgroundColor) MimClip(m_CodeImageId, m_CodeImageId, M_EQUAL, CodeBackgroundColor, M_NULL, BACKGROUND_COLOR, M_NULL); // Set the child in the grid image according to the given parameters. MbufChildMove(m_DestChildId, ChildStartX, ChildStartY, ChildSizeX, ChildSizeY, M_DEFAULT); // Scale the fiducial and write it in the destination image. MimResize(m_CodeImageId, m_DestChildId, M_FILL_DESTINATION, M_FILL_DESTINATION, M_NEAREST_NEIGHBOR + M_OVERSCAN_FAST); } //***************************************************************************** // Loops through all the fiducials, as specified in gridconfig.h, encodes the // grid information, generates datamatrix fiducials and adds them to the // destination grid image. //***************************************************************************** void AddFiducials(MIL_ID GridImageId, const GridInfoStruct&amp; GridInfo, MIL_DOUBLE PixelsPerSquareX, MIL_DOUBLE PixelsPerSquareY) { #if NUM_FIDUCIALS &gt; 0 // Minimum number of squares around the fiducial. const MIL_INT FIDUCIAL_SPACING = 1; // Compute min/max logical positions (inclusive) for validation. MIL_INT MinPosX = NUM_SQUARES_FOR_QUIET_ZONE; MIL_INT MinPosY = NUM_SQUARES_FOR_QUIET_ZONE; MIL_INT MaxPosX = GridInfo.NumSquaresX - NUM_SQUARES_FOR_QUIET_ZONE; MIL_INT MaxPosY = GridInfo.NumSquaresY - NUM_SQUARES_FOR_QUIET_ZONE; MIL_INT RefPointPosX = GridInfo.GetReferencePositionX(); MIL_INT RefPointPosY = GridInfo.GetReferencePositionY(); if ( !(MinPosX &lt;= RefPointPosX &amp;&amp; RefPointPosX &lt;= MaxPosX) || !(MinPosY &lt;= RefPointPosY &amp;&amp; RefPointPosY &lt;= MaxPosY) ) throw MIL_TEXT(\"The grid reference point falls outside the grid\"); // Copy relevant grid information in the fiducial. FiducialInfoStruct FiducialInfo; FiducialInfo.Unit = UNIT; FiducialInfo.SpacingExponent = GridInfo.SpacingExponent; FiducialInfo.SpacingMantissaX = GridInfo.SpacingMantissaX; FiducialInfo.SpacingMantissaY = GridInfo.SpacingMantissaY; // Create MIL code objects to draw the fiducials. MIL_ID SysId; MbufInquire(GridImageId, M_OWNER_SYSTEM, &amp;SysId); CDatamatrixDrawer DatamatrixDrawer(SysId, GridImageId); MosPrintf(MIL_TEXT(\"Fiducials:\\n\")); MosPrintf(MIL_TEXT(\"----------\\n\")); for (MIL_INT i = 0; i &lt; NUM_FIDUCIALS; ++i) { // Compute fiducial bounding box, in terms of squares. if (!(2 &lt;= FIDUCIAL_SIZE[i] &amp;&amp; FIDUCIAL_SIZE[i] &lt;= 3)) throw MIL_TEXT(\"Unsupported fiducial size (must be 2 or 3)\"); MIL_INT FiducialMinX = RefPointPosX + FIDUCIAL_POS_X[i]; MIL_INT FiducialMinY = RefPointPosY + FIDUCIAL_POS_Y[i]; MIL_INT FiducialMaxX = FiducialMinX + FIDUCIAL_SIZE[i]; MIL_INT FiducialMaxY = FiducialMinY + FIDUCIAL_SIZE[i]; // Check that there is enough space around the fiducial. MIL_INT SafeFiducialMinX = FiducialMinX - FIDUCIAL_SPACING; MIL_INT SafeFiducialMinY = FiducialMinY - FIDUCIAL_SPACING; MIL_INT SafeFiducialMaxX = FiducialMaxX + FIDUCIAL_SPACING; MIL_INT SafeFiducialMaxY = FiducialMaxY + FIDUCIAL_SPACING; if ( !(MinPosX &lt;= FiducialMinX &amp;&amp; FiducialMaxX &lt;= MaxPosX) || !(MinPosY &lt;= FiducialMinY &amp;&amp; FiducialMaxY &lt;= MaxPosY) ) throw MIL_TEXT(\"The fiducial falls outside the grid\"); if ( !(MinPosX &lt;= SafeFiducialMinX &amp;&amp; SafeFiducialMaxX &lt;= MaxPosX) || !(MinPosY &lt;= SafeFiducialMinY &amp;&amp; SafeFiducialMaxY &lt;= MaxPosY) ) throw MIL_TEXT(\"The fiducial is too close to the grid border\"); for (MIL_INT j = 0; j &lt; NUM_FIDUCIALS; ++j) { if (i == j) continue; MIL_INT OtherFiducialMinX = RefPointPosX + FIDUCIAL_POS_X[j]; MIL_INT OtherFiducialMinY = RefPointPosY + FIDUCIAL_POS_Y[j]; MIL_INT OtherFiducialMaxX = OtherFiducialMinX + FIDUCIAL_SIZE[j]; MIL_INT OtherFiducialMaxY = OtherFiducialMinY + FIDUCIAL_SIZE[j]; if ( !( OtherFiducialMaxX &lt;= SafeFiducialMinX || SafeFiducialMaxX &lt;= OtherFiducialMinX || OtherFiducialMaxY &lt;= SafeFiducialMinY || SafeFiducialMaxY &lt;= OtherFiducialMinY ) ) throw MIL_TEXT(\"Fiducials are overlapping\"); } // Encode the fiducial information. FiducialInfo.FiducialPositionX = FIDUCIAL_POS_X[i]; FiducialInfo.FiducialPositionY = FIDUCIAL_POS_Y[i]; FiducialInfo.Encode(); // Compute the pixel bounding box in the grid image. MIL_INT ChildStartX = static_cast&lt;MIL_INT&gt;((FiducialMinX + FIDUCIAL_INDENT) * PixelsPerSquareX + 0.5); MIL_INT ChildStartY = static_cast&lt;MIL_INT&gt;((FiducialMinY + FIDUCIAL_INDENT) * PixelsPerSquareY + 0.5); MIL_INT ChildEndX = static_cast&lt;MIL_INT&gt;((FiducialMaxX - FIDUCIAL_INDENT) * PixelsPerSquareX + 0.5); MIL_INT ChildEndY = static_cast&lt;MIL_INT&gt;((FiducialMaxY - FIDUCIAL_INDENT) * PixelsPerSquareY + 0.5); MIL_INT ChildSizeX = ChildEndX - ChildStartX + 1; MIL_INT ChildSizeY = ChildEndY - ChildStartY + 1; // Create a child buffer around the bounding box and fill it with the datamatrix. DatamatrixDrawer.Draw(ChildStartX, ChildStartY, ChildSizeX, ChildSizeY, i, FiducialInfo); } MosPrintf(MIL_TEXT(\"\\n\")); #endif } ",
      "wordCount": 1611
    },
    {
      "id": "Examples_Processing_2dCalibration_CalGenChessGrid_CPP_calgenchessgrid_cpp",
      "version": "2024020714",
      "title": "calgenchessgrid.cpp",
      "location": "Sample Code from MIL Examples",
      "text": " Top //*************************************************************************************** // // File name: CalGenChessGrid.cpp // Location: See Matrox Example Launcher in the MIL Control Center // // // Synopsis: This example generates an image of a calibration grid according to // the specifications in gridconfig.h. It can generate chessboard // grids with or without fiducials. // // Copyright (C) Matrox Electronic Systems Ltd., 1992-2024. // All Rights Reserved #include \"common.h\" //**************************************************************************** // Example description. //**************************************************************************** void PrintHeader() { MosPrintf(MIL_TEXT(\"[EXAMPLE NAME]\\n\") MIL_TEXT(\"CalGenChessGrid\\n\\n\") MIL_TEXT(\"[SYNOPSIS]\\n\") MIL_TEXT(\"This example demonstrates how to generate an image of a\\n\") MIL_TEXT(\"calibration grid according to the user-defined specifications in\\n\") MIL_TEXT(\"gridconfig.h. It can generate chessboard grids with or without\\n\") MIL_TEXT(\"fiducials. The resulting grid can be used with the MIL camera\\n\") MIL_TEXT(\"calibration module (Mcal).\\n\\n\") MIL_TEXT(\"Note, everything that is demonstrated by this example can be \\n\") MIL_TEXT(\"performed interactively using MIL CoPilot's \\\"Chessboard Grid Builder\\\".\\n\\n\") MIL_TEXT(\"[MODULES USED]\\n\") MIL_TEXT(\"Modules used: application, buffer, code, display, graphics, image\\n\") MIL_TEXT(\"processing, system.\\n\\n\") MIL_TEXT(\"Press any key to continue.\\n\\n\")); MosGetch(); } //***************************************************************************** // Draws a thick rectangle. The start and end coordinates determine the outer // corners of the rectangle. //***************************************************************************** inline void DrawThickRect(MIL_ID ContextGraId, MIL_ID ImageId, MIL_DOUBLE Color, MIL_INT ThicknessX, MIL_INT ThicknessY, MIL_INT StartX, MIL_INT StartY, MIL_INT EndX, MIL_INT EndY) { MgraControl(ContextGraId, M_COLOR, Color); MgraRectFill(ContextGraId, ImageId, StartX , StartY , EndX , StartY+ThicknessY-1); MgraRectFill(ContextGraId, ImageId, StartX , EndY-ThicknessY+1, EndX , EndY ); MgraRectFill(ContextGraId, ImageId, StartX , StartY , StartX+ThicknessX-1, EndY ); MgraRectFill(ContextGraId, ImageId, EndX-ThicknessX+1, StartY , EndX , EndY ); } //***************************************************************************** // Contains all necessary pixel dimensions to draw the grid image and its // annotations. //***************************************************************************** struct AnnotationStruct { MIL_DOUBLE PixelsPerSquareX; // number of pixels in the X direction for each grid square MIL_DOUBLE PixelsPerSquareY; // number of pixels in the Y direction for each grid square MIL_INT MaxPixelsPerSquareInt; // maximum of PixelsPerSquareX and PixelsPerSquareY, rounded up; used as a base unit for some annotations MIL_INT ImageSizeX; // width (in pixels) of the grid image, without annotations MIL_INT ImageSizeY; // height (in pixels) of the grid image, without annotations MIL_INT FullSizeX; // width (in pixels) of the grid image, with annotations MIL_INT FullSizeY; // height (in pixels) of the grid image, with annotations MIL_INT LeftBorder; // number of pixels reserved for annotations on the left MIL_INT RightBorder; // number of pixels reserved for annotations on the right MIL_INT TopBorder; // number of pixels reserved for annotations on the top MIL_INT BottomBorder; // number of pixels reserved for annotations on the bottom MIL_INT BorderThickness; // thickness in pixels of the border separating the grid from the annotations MIL_INT LastPixelOfGridX; // X pixel coordinate of the lower-right corner of the grid (start of annotations) MIL_INT LastPixelOfGridY; // Y pixel coordinate of the lower-right corner of the grid (start of annotations) }; //***************************************************************************** // Computes all necessary pixel dimensions to draw the grid image and its // annotations, according to the grid parameters previously computed. //***************************************************************************** AnnotationStruct ComputeAnnotationParameters(const GridInfoStruct&amp; GridInfo) { AnnotationStruct Annotation; // Compute the number of pixels per square. if (DPI &lt;= 0.0) throw MIL_TEXT(\"DPI must be positive\"); MIL_DOUBLE PixelsPerInch = DPI; MIL_DOUBLE PixelsPerWorldUnit = GetInchesPerWorldUnit(UNIT) * PixelsPerInch; Annotation.PixelsPerSquareX = GridInfo.SpacingX * PixelsPerWorldUnit; Annotation.PixelsPerSquareY = GridInfo.SpacingY * PixelsPerWorldUnit; Annotation.MaxPixelsPerSquareInt = static_cast&lt;MIL_INT&gt;(ceil( Annotation.PixelsPerSquareX &gt; Annotation.PixelsPerSquareY ? Annotation.PixelsPerSquareX : Annotation.PixelsPerSquareY)); // Compute the grid image size. Annotation.ImageSizeX = static_cast&lt;MIL_INT&gt;(ceil(GridInfo.NumSquaresX * Annotation.PixelsPerSquareX)); Annotation.ImageSizeY = static_cast&lt;MIL_INT&gt;(ceil(GridInfo.NumSquaresY * Annotation.PixelsPerSquareY)); // Compute the annotation border size. if (DRAW_ANNOTATIONS) { Annotation.BorderThickness = static_cast&lt;MIL_INT&gt;(ceil(BORDER_THICKNESS * Annotation.MaxPixelsPerSquareInt)); Annotation.LeftBorder = Annotation.MaxPixelsPerSquareInt; // 1 square worth of space for symmetry Annotation.RightBorder = Annotation.MaxPixelsPerSquareInt; // 1 square worth of space for the arrow indicator Annotation.TopBorder = Annotation.MaxPixelsPerSquareInt; // 1 square worth of space for the arrow indicator // Since ImageSizeX is used to determine the legend font size, and we want the vertical // space to be proportional to the font size, compute a bottom border size proportional // to ImageSizeX. Annotation.BottomBorder = static_cast&lt;MIL_INT&gt;(Annotation.ImageSizeX * BOTTOM_SPACE_FACTOR); } else { // No borders, since there are no annotations. Annotation.BorderThickness = 0; Annotation.LeftBorder = 0; Annotation.RightBorder = 0; Annotation.TopBorder = 0; Annotation.BottomBorder = 0; } // Compute the full image size (grid + annotations). Annotation.FullSizeX = Annotation.ImageSizeX + Annotation.LeftBorder + Annotation.RightBorder; Annotation.FullSizeY = Annotation.ImageSizeY + Annotation.TopBorder + Annotation.BottomBorder; // Compute lower-right corner of grid. Annotation.LastPixelOfGridX = Annotation.LeftBorder + Annotation.ImageSizeX - 1; Annotation.LastPixelOfGridY = Annotation.TopBorder + Annotation.ImageSizeY - 1; return Annotation; } //***************************************************************************** // Draws the border, the legend and reference point indicators. //***************************************************************************** void DrawAnnotations(MIL_ID ContextGraId, MIL_ID FullImageId, const GridInfoStruct&amp; GridInfo, const AnnotationStruct&amp; Annotation) { // Draw the border. DrawThickRect(ContextGraId, FullImageId, BORDER_COLOR, Annotation.BorderThickness, Annotation.BorderThickness, Annotation.LeftBorder - Annotation.BorderThickness, Annotation.TopBorder - Annotation.BorderThickness, Annotation.LastPixelOfGridX + Annotation.BorderThickness, Annotation.LastPixelOfGridY + Annotation.BorderThickness); // Determine the font size for the legend. MIL_INT FontSize = static_cast&lt;MIL_INT&gt;(FONT_SIZE_FACTOR * Annotation.ImageSizeX); if (FontSize &lt;= 9) throw MIL_TEXT(\"Font size is too small, use a higher DPI\"); MgraFont(ContextGraId, FONT_NAME); MgraControl(ContextGraId, M_FONT_SIZE, FontSize); MgraControl(ContextGraId, M_COLOR, FOREGROUND_COLOR); MgraControl(ContextGraId, M_BACKCOLOR, BACKGROUND_COLOR); // Prepare the legend text. const MIL_INT MAX_LEGEND_LENGTH = 256; MIL_TEXT_CHAR Legend[MAX_LEGEND_LENGTH]; MIL_CONST_TEXT_PTR UnitName = GetUnitName(UNIT); MosSprintf(Legend, MAX_LEGEND_LENGTH, MIL_TEXT(\"Grid size: %g %s x %g %s%sRow/column number: %d x %d%sRow/column spacing: %g %s x %g %s\"), GridInfo.GridSizeX, UnitName, GridInfo.GridSizeY, UnitName, SEPARATOR, (int)(GridInfo.NumSquaresY - 2 * NUM_SQUARES_FOR_QUIET_ZONE + 1), (int)(GridInfo.NumSquaresX - 2 * NUM_SQUARES_FOR_QUIET_ZONE + 1), SEPARATOR, GridInfo.SpacingY, UnitName, GridInfo.SpacingX, UnitName); // Draw the legend. MIL_INT TextVerticalOffset = static_cast&lt;MIL_INT&gt;(TEXT_VERTICAL_OFFSET * Annotation.ImageSizeX); MgraText(ContextGraId, FullImageId, Annotation.PixelsPerSquareX, Annotation.LastPixelOfGridY + TextVerticalOffset, Legend); #if NUM_FIDUCIALS &gt; 0 const MIL_INT TRIANGLE_LENGTH_TO_WIDTH_RATIO = 2; // Draw triangles to indicate the grid reference point. MIL_INT RefPointSquareNoX = GridInfo.GetReferencePositionX(); MIL_INT RefPointSquareNoY = GridInfo.GetReferencePositionY(); MIL_INT RefPointPixelPosX = static_cast&lt;MIL_INT&gt;(RefPointSquareNoX * Annotation.PixelsPerSquareX) + Annotation.LeftBorder; MIL_INT RefPointPixelPosY = static_cast&lt;MIL_INT&gt;(RefPointSquareNoY * Annotation.PixelsPerSquareY) + Annotation.TopBorder; MIL_INT TriangleOffset = static_cast&lt;MIL_INT&gt;(ceil(TRIANGLE_OFFSET * Annotation.MaxPixelsPerSquareInt)); MIL_INT TriangleLength = static_cast&lt;MIL_INT&gt;(ceil(TRIANGLE_LENGTH * Annotation.MaxPixelsPerSquareInt)); MgraControl(ContextGraId, M_COLOR, FOREGROUND_COLOR); MIL_INT TriangleVerticesX[3], TriangleVerticesY[3]; // Draw the triangle to the top. TriangleVerticesX[0] = RefPointPixelPosX; TriangleVerticesX[1] = TriangleVerticesX[0] - TriangleLength / (2 * TRIANGLE_LENGTH_TO_WIDTH_RATIO); TriangleVerticesX[2] = TriangleVerticesX[0] + TriangleLength / (2 * TRIANGLE_LENGTH_TO_WIDTH_RATIO); TriangleVerticesY[0] = Annotation.TopBorder - TriangleOffset; TriangleVerticesY[1] = TriangleVerticesY[0] - TriangleLength; TriangleVerticesY[2] = TriangleVerticesY[1]; MgraLines(ContextGraId, FullImageId, 3, TriangleVerticesX, TriangleVerticesY, M_NULL, M_NULL, M_POLYGON+M_FILLED); // Draw the triangle to the right or to the left, whichever is closest. if (RefPointSquareNoX &lt;= GridInfo.NumSquaresX / 2) { // To the left. TriangleVerticesX[0] = Annotation.LeftBorder - TriangleOffset; TriangleVerticesX[1] = TriangleVerticesX[0] - TriangleLength; } else { // To the right. TriangleVerticesX[0] = Annotation.LastPixelOfGridX + TriangleOffset; TriangleVerticesX[1] = TriangleVerticesX[0] + TriangleLength; } TriangleVerticesX[2] = TriangleVerticesX[1]; TriangleVerticesY[0] = RefPointPixelPosY; TriangleVerticesY[1] = TriangleVerticesY[0] - TriangleLength / (2 * TRIANGLE_LENGTH_TO_WIDTH_RATIO); TriangleVerticesY[2] = TriangleVerticesY[0] + TriangleLength / (2 * TRIANGLE_LENGTH_TO_WIDTH_RATIO); MgraLines(ContextGraId, FullImageId, 3, TriangleVerticesX, TriangleVerticesY, M_NULL, M_NULL, M_POLYGON+M_FILLED); #endif } //***************************************************************************** // Compute a zoom factor so that the grid image can fit in the screen. //***************************************************************************** void SetZoomFactor(MIL_ID DispId, MIL_INT GridSizeX, MIL_INT GridSizeY) { MIL_DOUBLE ZoomFactor = 1.0; if (GridSizeX &gt; MAX_DISPLAY_SIZE_X) ZoomFactor = static_cast&lt;MIL_DOUBLE&gt;(MAX_DISPLAY_SIZE_X) / GridSizeX; if (GridSizeY &gt; MAX_DISPLAY_SIZE_Y) { MIL_DOUBLE MaxZoomFactor = static_cast&lt;MIL_DOUBLE&gt;(MAX_DISPLAY_SIZE_Y) / GridSizeY; if (MaxZoomFactor &lt; ZoomFactor) ZoomFactor = MaxZoomFactor; } if (ZoomFactor &lt; 1.0) MdispZoom(DispId, ZoomFactor, ZoomFactor); } //***************************************************************************** // Structure containing all MIL objects. Ensures that all objects will be // correctly freed, even in the presence of exceptions. //***************************************************************************** struct MILObjectsStruture { MIL_ID AppId; // application context MIL_ID SysId; // system MIL_ID ContextGraId; // graphics context MIL_ID FullImageId; // image buffer of the grid, with annotations if applicable MIL_ID GridImageId; // child buffer of FullImageId, contains only the grid MIL_ID DispId; // display // Constructor cleanly initializes all identifiers. MILObjectsStruture() : AppId (M_NULL), SysId (M_NULL), ContextGraId(M_NULL), FullImageId (M_NULL), GridImageId (M_NULL), DispId (M_NULL) { } // Destructor ensures all objects are freed, even in the presence of exceptions. ~MILObjectsStruture() { if (DispId != M_NULL) MdispFree(DispId ); if (GridImageId != M_NULL) MbufFree(GridImageId ); if (FullImageId != M_NULL) MbufFree(FullImageId ); if (ContextGraId != M_NULL) MgraFree(ContextGraId); if (SysId != M_NULL) MsysFree(SysId ); if (AppId != M_NULL) MappFree(AppId ); } }; //***************************************************************************** // Main. //***************************************************************************** int MosMain(void) { PrintHeader(); try { // Allocate MIL objects. MILObjectsStruture MILObjects; MappAlloc(M_NULL, M_DEFAULT, &amp;MILObjects.AppId); MsysAlloc(MILObjects.AppId, M_SYSTEM_HOST, M_DEFAULT, M_DEFAULT, &amp;MILObjects.SysId); MgraAlloc(MILObjects.SysId, &amp;MILObjects.ContextGraId); // Compute all grid and annotation parameters according to gridconfig.h. GridInfoStruct GridInfo = ComputeGridParameters(); AnnotationStruct Annotation = ComputeAnnotationParameters(GridInfo); // Allocate the full image. MbufAlloc2d(MILObjects.SysId, Annotation.FullSizeX, Annotation.FullSizeY, 8+M_UNSIGNED, M_IMAGE+M_PROC+M_DISP, &amp;MILObjects.FullImageId); MbufChild2d(MILObjects.FullImageId, Annotation.LeftBorder, Annotation.TopBorder, Annotation.ImageSizeX, Annotation.ImageSizeY, &amp;MILObjects.GridImageId); MbufClear(MILObjects.FullImageId, BACKGROUND_COLOR); // Create the chessboard pattern. MgraControl(MILObjects.ContextGraId, M_COLOR, FOREGROUND_COLOR); for (MIL_INT y = 0; y &lt; GridInfo.NumSquaresY; ++y) { for (MIL_INT x = 0; x &lt; GridInfo.NumSquaresX; ++x) { if ((x &amp; 0x1) == (y &amp; 0x1)) // if this is a black cell { MgraRectFill(MILObjects.ContextGraId, MILObjects.GridImageId, x * Annotation.PixelsPerSquareX, y * Annotation.PixelsPerSquareY, (x+1) * Annotation.PixelsPerSquareX - 1, (y+1) * Annotation.PixelsPerSquareY - 1); } } } // Create the quiet zone. DrawThickRect(MILObjects.ContextGraId, MILObjects.GridImageId, BACKGROUND_COLOR, static_cast&lt;MIL_INT&gt;(QUIET_ZONE_BORDER * Annotation.PixelsPerSquareX), static_cast&lt;MIL_INT&gt;(QUIET_ZONE_BORDER * Annotation.PixelsPerSquareY), 0, 0, Annotation.ImageSizeX-1, Annotation.ImageSizeY-1); // Draw fiducials, if any. AddFiducials(MILObjects.GridImageId, GridInfo, Annotation.PixelsPerSquareX, Annotation.PixelsPerSquareY); // If enabled, draw the grid border, the reference point indicators and the legend. if (DRAW_ANNOTATIONS) DrawAnnotations(MILObjects.ContextGraId, MILObjects.FullImageId, GridInfo, Annotation); // Save the grid image with the correct DPI. MbufControl(MILObjects.FullImageId, M_RESOLUTION_X, DPI); MbufControl(MILObjects.FullImageId, M_RESOLUTION_Y, DPI); MbufExport(OUTPUT_GRID_NAME, OUTPUT_FILE_FORMAT, MILObjects.FullImageId); // Show the image and print some information. MdispAlloc(MILObjects.SysId, M_DEFAULT, MIL_TEXT(\"M_DEFAULT\"), M_WINDOWED, &amp;MILObjects.DispId); SetZoomFactor(MILObjects.DispId, Annotation.FullSizeX, Annotation.FullSizeY); MdispSelect(MILObjects.DispId, MILObjects.FullImageId); MosPrintf(MIL_TEXT(\"Image saved:\\n\")); MosPrintf(MIL_TEXT(\"------------\\n\")); MosPrintf(MIL_TEXT(\" Name: '%s'\\n\"), OUTPUT_GRID_NAME); MosPrintf(MIL_TEXT(\" Size: %d x %d\\n\"), (int)Annotation.FullSizeX, (int)Annotation.FullSizeY); MosPrintf(MIL_TEXT(\"\\n\")); MosPrintf(MIL_TEXT(\"To print this image correctly:\\n\")); MosPrintf(MIL_TEXT(\" - Set your printer resolution to %d DPI or higher.\\n\"), (int)DPI); MosPrintf(MIL_TEXT(\" - Print with software that takes the DPI into account.\\n\")); MosPrintf(MIL_TEXT(\" - Disable any 'fit' or 'scale' option in the print dialog.\\n\")); MosPrintf(MIL_TEXT(\" - Verify the printed grid dimensions.\\n\")); MosPrintf(MIL_TEXT(\"\\n\")); MosPrintf(MIL_TEXT(\"Press any key to end.\\n\")); MosGetch(); // All MIL objects are freed here, in MILObjectsStruture's destructor. } catch (MIL_CONST_TEXT_PTR ErrorMessage) { MosPrintf(MIL_TEXT(\"\\nERROR:\\n %s.\\n\\n\"), ErrorMessage); MosPrintf(MIL_TEXT(\"Press any key to end.\\n\")); MosGetch(); } return 0; } ",
      "wordCount": 1573
    },
    {
      "id": "Examples_Processing_2dCalibration_CalGenChessGrid_CPP_computegridparams_cpp",
      "version": "2024020714",
      "title": "computegridparams.cpp",
      "location": "Sample Code from MIL Examples",
      "text": " Top //*************************************************************************************** // // File name: computegridparams.cpp // Location: See Matrox Example Launcher in the MIL Control Center // // // Synopsis: This file implements ComputeGridParameters(), declared in common.h. // // Copyright (C) Matrox Electronic Systems Ltd., 1992-2024. // All Rights Reserved #include \"common.h\" //***************************************************************************** // Returns the base 10 exponent of the given value. //***************************************************************************** static inline MIL_INT GetExponent(MIL_DOUBLE Value) { return static_cast&lt;MIL_INT&gt;(floor(log10(Value))); } //***************************************************************************** // Returns the divisor that is used to get the mantissa out of a value, for the // given exponent. //***************************************************************************** static inline MIL_DOUBLE ComputeRoundingPowerOf10(MIL_INT Exponent) { if (SPACING_ROUNDING == RoundUpTo3Digits) Exponent -= 2; // mantissa will have two more digits return pow(10.0, static_cast&lt;int&gt;(Exponent)); } //***************************************************************************** // Given an exponent, returns the mantissa of the given value, rounded up // according to the rounding rule chosen. //***************************************************************************** static MIL_INT GetRoundedUpMantissa(MIL_DOUBLE Value, MIL_INT Exponent) { MIL_DOUBLE Mantissa = Value / ComputeRoundingPowerOf10(Exponent); MIL_DOUBLE RoundedMantissa; if (SPACING_ROUNDING == RoundUpTo1or2or5) { if (Mantissa &lt;= 1.0) RoundedMantissa = 1.0; else if (Mantissa &lt;= 2.0) RoundedMantissa = 2.0; else if (Mantissa &lt;= 5.0) RoundedMantissa = 5.0; else RoundedMantissa = 10.0; } else { RoundedMantissa = ceil(Mantissa); } return static_cast&lt;MIL_INT&gt;(RoundedMantissa); } //***************************************************************************** // While rounding up, the number of digits in the mantissa can increase. This // function is used to reduce it back (and increase the exponent accordingly). //***************************************************************************** static void AdjustExponent(MIL_INT* pExponent, MIL_INT* pMantissa) { MIL_INT MaxMantissa = (SPACING_ROUNDING == RoundUpTo3Digits ? 1000 : 10); if (*pMantissa &gt;= MaxMantissa) { *pMantissa /= 10; ++*pExponent; } } //***************************************************************************** // Given the final exponent and rounded up mantissa, compute the spacing to // be used in the calibration grid. //***************************************************************************** static inline MIL_DOUBLE ComputeSpacing(MIL_INT SpacingExponent, MIL_INT SpacingMantissa) { return SpacingMantissa * ComputeRoundingPowerOf10(SpacingExponent); } //***************************************************************************** // Ensure that the mantissa has the correct number of digits. //***************************************************************************** static void ValidateMantissa(MIL_INT Mantissa) { bool IsValid = false; switch (SPACING_ROUNDING) { case RoundUpTo3Digits: if (1 &lt;= Mantissa &amp;&amp; Mantissa &lt; 1000) IsValid = true; break; case RoundUpTo1Digit: if (1 &lt;= Mantissa &amp;&amp; Mantissa &lt; 10) IsValid = true; break; case RoundUpTo1or2or5: if (Mantissa == 1 || Mantissa == 2 || Mantissa == 5) IsValid = true; break; } if (!IsValid) throw MIL_TEXT(\"Mantissa does not have the correct number of digits\"); } //***************************************************************************** // According to the user options in gridconfig.h, choose the grid dimensions, // number of squares and spacings. //***************************************************************************** GridInfoStruct ComputeGridParameters() { GridInfoStruct GridInfo; if (MIN_GRID_SIZE_X &lt;= 0.0 || MIN_GRID_SIZE_Y &lt;= 0.0) throw MIL_TEXT(\"Grid size must be positive\"); // Print input parameters. MIL_CONST_TEXT_PTR UnitName = GetUnitName(UNIT); MosPrintf(MIL_TEXT(\"Grid input parameters\\n\")); MosPrintf(MIL_TEXT(\"---------------------\\n\")); MosPrintf(MIL_TEXT(\" Minimum grid size (w/o quiet zone): %g %s x %g %s\\n\"), MIN_GRID_SIZE_X, UnitName, MIN_GRID_SIZE_Y, UnitName); #if SPECIFY_NUM_SQUARES_DIRECTLY MosPrintf(MIL_TEXT(\" Maximum number of grid squares: %d x %d\\n\"), (int)MAX_NUM_SQUARES_X, (int)MAX_NUM_SQUARES_Y); MosPrintf(MIL_TEXT(\" Enforce square chessboard cells: %s\\n\"), ENFORCE_SQUARE_CELLS ? MIL_TEXT(\"Yes\") : MIL_TEXT(\"No\")); #else MosPrintf(MIL_TEXT(\" Camera field of view along X: %g %s\\n\"), CAMERA_FOV_X, UnitName); MosPrintf(MIL_TEXT(\" Camera resolution along X: %d pixels\\n\"), (int)CAMERA_RESOLUTION_X); #endif MosPrintf(MIL_TEXT(\" Spacing rounding mode: \")); switch (SPACING_ROUNDING) { case RoundUpTo3Digits: MosPrintf(MIL_TEXT(\"3-digits mantissa\\n\")); break; case RoundUpTo1Digit: MosPrintf(MIL_TEXT(\"1-digit mantissa\\n\")); break; case RoundUpTo1or2or5: MosPrintf(MIL_TEXT(\"1-digit mantissa (1, 2 or 5)\\n\")); break; default: throw MIL_TEXT(\"Unknown rounding mode\"); } MosPrintf(MIL_TEXT(\"\\n\")); // Compute the minimum spacings according to the minimum grid size and other parameters. #if SPECIFY_NUM_SQUARES_DIRECTLY if (MAX_NUM_SQUARES_X &lt; 3) throw MIL_TEXT(\"Number of squares must be at least 3\"); if (MAX_NUM_SQUARES_Y &lt; 3) throw MIL_TEXT(\"Number of squares must be at least 3\"); MIL_DOUBLE DesiredSpacingX = MIN_GRID_SIZE_X / static_cast&lt;MIL_DOUBLE&gt;(MAX_NUM_SQUARES_X); MIL_DOUBLE DesiredSpacingY = MIN_GRID_SIZE_Y / static_cast&lt;MIL_DOUBLE&gt;(MAX_NUM_SQUARES_Y); bool EnforceSquareCells = ENFORCE_SQUARE_CELLS; #else if (CAMERA_FOV_X &lt;= 0.0) throw MIL_TEXT(\"Camera field of view must be positive\"); if (CAMERA_RESOLUTION_X &lt;= 0) throw MIL_TEXT(\"Camera resolution must be positive\"); MIL_INT MaxSquaresInCamera = CAMERA_RESOLUTION_X / MIN_CAMERA_PIXELS_PER_SQUARE; MIL_DOUBLE DesiredSpacingX = CAMERA_FOV_X / MaxSquaresInCamera; MIL_DOUBLE DesiredSpacingY = DesiredSpacingX; bool EnforceSquareCells = true; #endif // Choose the exponent using the largest spacing, then compute and round the mantissae of // both spacings. if (DesiredSpacingX &gt;= DesiredSpacingY) { GridInfo.SpacingExponent = GetExponent(DesiredSpacingX); GridInfo.SpacingMantissaX = GetRoundedUpMantissa(DesiredSpacingX, GridInfo.SpacingExponent); // Rounding up might have increased the number of digits in the mantissa. AdjustExponent(&amp;GridInfo.SpacingExponent, &amp;GridInfo.SpacingMantissaX); if (EnforceSquareCells) GridInfo.SpacingMantissaY = GridInfo.SpacingMantissaX; else GridInfo.SpacingMantissaY = GetRoundedUpMantissa(DesiredSpacingY, GridInfo.SpacingExponent); } else { GridInfo.SpacingExponent = GetExponent(DesiredSpacingY); GridInfo.SpacingMantissaY = GetRoundedUpMantissa(DesiredSpacingY, GridInfo.SpacingExponent); // Rounding up might have increased the number of digits in the mantissa. AdjustExponent(&amp;GridInfo.SpacingExponent, &amp;GridInfo.SpacingMantissaY); if (EnforceSquareCells) GridInfo.SpacingMantissaX = GridInfo.SpacingMantissaY; else GridInfo.SpacingMantissaX = GetRoundedUpMantissa(DesiredSpacingX, GridInfo.SpacingExponent); } // Compute back the spacings to be used from the rounded mantissae and exponent. GridInfo.SpacingX = ComputeSpacing(GridInfo.SpacingExponent, GridInfo.SpacingMantissaX); GridInfo.SpacingY = ComputeSpacing(GridInfo.SpacingExponent, GridInfo.SpacingMantissaY); ValidateMantissa(GridInfo.SpacingMantissaX); ValidateMantissa(GridInfo.SpacingMantissaY); // Compute the final number of squares using the rounded spacings. GridInfo.NumSquaresX = static_cast&lt;MIL_INT&gt;(ceil(MIN_GRID_SIZE_X / GridInfo.SpacingX)); GridInfo.NumSquaresY = static_cast&lt;MIL_INT&gt;(ceil(MIN_GRID_SIZE_Y / GridInfo.SpacingY)); if (GridInfo.NumSquaresX &lt; 2) GridInfo.NumSquaresX = 2; if (GridInfo.NumSquaresY &lt; 2) GridInfo.NumSquaresY = 2; // Include one square on each side for the quiet zone. GridInfo.NumSquaresX += 2 * NUM_SQUARES_FOR_QUIET_ZONE; GridInfo.NumSquaresY += 2 * NUM_SQUARES_FOR_QUIET_ZONE; // Compute the final grid size, including quiet zone. GridInfo.GridSizeX = GridInfo.NumSquaresX * GridInfo.SpacingX; GridInfo.GridSizeY = GridInfo.NumSquaresY * GridInfo.SpacingY; // Print output parameters. MosPrintf(MIL_TEXT(\"Computed grid parameters\\n\")); MosPrintf(MIL_TEXT(\"------------------------\\n\")); MosPrintf(MIL_TEXT(\" Grid size (with quiet zone): %g %s x %g %s\\n\"), GridInfo.GridSizeX, UnitName, GridInfo.GridSizeY, UnitName); MosPrintf(MIL_TEXT(\" Number of grid squares: %d x %d\\n\"), (int)(GridInfo.NumSquaresX - 2 * NUM_SQUARES_FOR_QUIET_ZONE), (int)(GridInfo.NumSquaresY - 2 * NUM_SQUARES_FOR_QUIET_ZONE)); if (GridInfo.SpacingX == GridInfo.SpacingY) MosPrintf(MIL_TEXT(\" Spacing: %g %s\\n\"), GridInfo.SpacingX, UnitName); else MosPrintf(MIL_TEXT(\" Spacings: %g %s x %g %s\\n\"), GridInfo.SpacingX, UnitName, GridInfo.SpacingY, UnitName); MosPrintf(MIL_TEXT(\"\\n\")); return GridInfo; } ",
      "wordCount": 874
    },
    {
      "id": "Examples_Processing_2dCalibration_CalGenChessGrid_CPP_units_cpp",
      "version": "2024020714",
      "title": "units.cpp",
      "location": "Sample Code from MIL Examples",
      "text": " Top //*************************************************************************************** // // File name: units.cpp // Location: See Matrox Example Launcher in the MIL Control Center // // // Synopsis: This file implements functions related to units display and conversion. // // Copyright (C) Matrox Electronic Systems Ltd., 1992-2024. // All Rights Reserved #include \"common.h\" //***************************************************************************** // Converts the Units enum to a short string. //***************************************************************************** MIL_CONST_TEXT_PTR GetUnitName(UnitEnum Units) { switch (Units) { case Kilometers : return MIL_TEXT(\"km\"); case Meters : return MIL_TEXT(\"m\"); case Centimeters: return MIL_TEXT(\"cm\"); case Millimeters: return MIL_TEXT(\"mm\"); case Micrometers: return MIL_TEXT(\"um\"); case Miles : return MIL_TEXT(\"miles\"); case Feet : return MIL_TEXT(\"ft\"); case Inches : return MIL_TEXT(\"in\"); case Mils : return MIL_TEXT(\"mils\"); default: throw MIL_TEXT(\"Unknown unit\"); } } //***************************************************************************** // Converts 1 world unit to inches. Useful for DPI-related computations. //***************************************************************************** MIL_DOUBLE GetInchesPerWorldUnit(UnitEnum Units) { const MIL_DOUBLE INCHES_PER_METER = 1000.0 / 25.4; switch (Units) { case Kilometers : return INCHES_PER_METER * 1000.0; case Meters : return INCHES_PER_METER; case Centimeters: return INCHES_PER_METER / 100.0; case Millimeters: return INCHES_PER_METER / 1000.0; case Micrometers: return INCHES_PER_METER / 1000000.0; case Miles : return 1760.0 * 3.0 * 12.0; case Feet : return 12.0; case Inches : return 1.0; case Mils : return 1.0 / 1000.0; default: throw MIL_TEXT(\"Unknown unit\"); } } ",
      "wordCount": 204
    }
  ]
}]
[{
  "id": "UG_NET",
  "version": "2024020714",
  "title": "Using MIL with.NET",
  "subTitles": null,
  "location": "MIL UG P10: Other programming languages, APIs, and operating systems",
  "pageURL": "content\\UserGuide\\NET\\ChapterInformation.htm",
  "text": " Chapter 60: Using MIL with .NET This chapter explains how to use MIL while writing C# in .NET. MIL with .NET overview Installing and upgrading the MIL.NET wrapper Requirements and installation notes Installing MIL.NET for Linux Installing MIL after .NET Installing .NET after MIL Upgrading to new versions of Matrox.MatroxImagingLibrary.dll Building a .NET application using MIL MIL inclusion procedure for .NET Calling MIL functions and constants in .NET Disabling compiler warnings in .NET Procedure for disabling compiler warnings in C# Data types in MIL with .NET MIL_ID and MIL_INT Data type equivalents Using .NET strings with MIL Memory management while using MIL with .NET M...Free() versus finalizers Invoking the garbage collector Pinning memory to be used by MbufCreate...() Delegates and MIL hook-type functions Lifetime of delegates passed to MIL hook-type functions Passing user data to a user-defined function Error handling Using WPF with MIL XAML skeleton example MIL with .NET example Compiling MIL C# examples under Linux ",
  "wordCount": 159,
  "subEntries": [
    {
      "id": "UG_NET_MIL_with_NET_overview",
      "version": null,
      "title": "MIL with.NET overview",
      "subTitles": null,
      "location": "MIL UG P10: Other programming languages, APIs, and operating systems",
      "pageURL": "content\\UserGuide\\NET\\MIL_with_NET_overview.htm",
      "text": " MIL with .NET overview The MIL.NET wrapper allows you to use MIL with C# in a .NET environment. Using Microsoft's Platform Invoke technology, the MIL.NET wrapper exposes the Matrox Imaging Library's functionally to .NET languages such as C#. Essentially, the MIL.NET wrapper is a set of classes, structures, and delegates that exposes all the MIL functions as methods, and all the MIL constants as constants of the class. Typically, the term function is used in reference to C/C++, and the term method is used in reference to object-oriented languages like C#. However, they imply essentially the same thing; methods are simply functions defined in a class and that typically are used on objects of that class. For consistency with the rest of the MIL documentation, we use the term function throughout, regardless of the language and context being discussed. .NET is a managed environment, which means that it has certain characteristics, such as garbage collection and the Common Language Runtime, that make it different from programming in standard C/C++. However, programming using MIL in a managed .NET environment is very similar to programming with MIL in C/C++, as long as you keep the concepts of writing managed code in mind. Note that this chapter does not expand upon the concepts inherent to managed code, nor does it detail the syntax of C#. For information about these topics, refer to http://msdn.microsoft.com. MIL with.NET overview ",
      "wordCount": 235,
      "subEntries": []
    },
    {
      "id": "UG_NET_Installing_and_upgrading_the_MIL_wrapper",
      "version": null,
      "title": "Installing and upgrading the MIL.NET wrapper",
      "subTitles": [
        "Requirements and installation notes",
        "Installing MIL.NET for Linux",
        "Installing MIL after .NET",
        "Installing .NET after MIL",
        "Upgrading to new versions of Matrox.MatroxImagingLibrary.dll"
      ],
      "location": "MIL UG P10: Other programming languages, APIs, and operating systems",
      "pageURL": "content\\UserGuide\\NET\\Installing_and_upgrading_the_MIL_wrapper.htm",
      "text": " Installing and upgrading the MIL.NET wrapper When MIL is either initially installed or upgraded, the MIL.NET wrapper is automatically installed or upgraded as well. Requirements and installation notes The specific hardware and software requirements for using MIL are detailed in the Requirements to run MIL section of Chapter 1: Introduction. After installing MIL on your computer, the following files can be found in the Matrox Imaging\\MIL\\MIL.NET directory: Matrox.MatroxImagingLibrary.dll. This is the Interop assembly for using MIL with .NET. Matrox.MatroxImagingLibrary.xml. This is the XML file for IntelliSense support in Visual Studio. Examples for C# can be found in the Matrox Imaging\\MIL\\Examples\\ directory. Installing MIL.NET for Linux MIL for Linux provides the MIL.NET wrapper and C# examples for the Microsoft .NET 6 framework. There are minor differences to the installation steps depending on whether you are installing MIL after .NET or vice versa. Installing MIL after .NET To install MIL after installing .NET, make sure the .NET executable is located in the /usr/local/bin or /usr/bin path; this is because sudo restricts the PATH environment variable. You can also create a link to the path using the following sudo command. sudo ln -s /usr/local/bin/dotnet /Path/To/DotNetBin Launch the MIL setup and select the .Net and Scripting component. The setup will then install the MIL.NET wrapper. Installing .NET after MIL To install .NET after installing MIL, make sure the .Net and Scripting component was selected when MIL was installed. After installing .NET, add the MIL.NET wrapper using the following command: dotnet nuget add source /opt/matrox_imaging/mil/mil.net/NuGet --name mil.net To check that the MIL.NET wrapper was successfully installed, enter the following command: dotnet nuget list source MIL.NET should be present in the returned list. Upgrading to new versions of Matrox.MatroxImagingLibrary.dll To upgrade an existing project with a new version of the Matrox.MatroxImagingLibrary assembly, you must open your project, rebuild the application, and re-deploy it. This is necessary because the Matrox.MatroxImagingLibrary.dll file is copied to your application's directory when the application is built. Therefore, installing a new version of Matrox.MatroxImagingLibrary.dll won't upgrade existing applications without rebuilding them. To update your project, follow these steps to change the reference to Matrox.MatroxImagingLibrary. Open your project. From the Solution Explorer, expand the References folder. Select Matrox.MatroxImagingLibrary and remove the reference to this assembly by pressing the Delete key or by right-clicking and selecting Remove from the presented context menu. Follow the steps in the Building a .NET application using MIL section later in this chapter to add a new reference to Matrox.MatroxImagingLibrary. Rebuild your application. Installing and upgrading the MIL.NET wrapper Requirements and installation notes Installing MIL.NET for Linux Installing MIL after .NET Installing .NET after MIL Upgrading to new versions of Matrox.MatroxImagingLibrary.dll ",
      "wordCount": 444,
      "subEntries": []
    },
    {
      "id": "UG_NET_Building_a_NET_application_using_MIL",
      "version": null,
      "title": "Building a.NET application using MIL",
      "subTitles": [
        "MIL inclusion procedure for.NET",
        "Calling MIL functions and constants in.NET",
        "Disabling compiler warnings in .NET",
        "Procedure for disabling compiler warnings in C#"
      ],
      "location": "MIL UG P10: Other programming languages, APIs, and operating systems",
      "pageURL": "content\\UserGuide\\NET\\Building_a_NET_application_using_MIL.htm",
      "text": " Building a .NET application using MIL For MIL functions and constants to be available in a managed .NET application, you must first add a reference to Matrox.MatroxImaginglibrary.dll in Visual Studio; this gives the code access to all of MIL. Once this is done, your code can use the language-specific call to include the library. Note that all MIL modules are contained in a single namespace, Matrox.MatroxImagingLibrary. The following details the procedure for referencing and including MIL in C# in a managed .NET environment. MIL inclusion procedure for .NET To use MIL functions and constants, you must first reference Matrox.MatroxImaginglibrary.dll, and optionally, include the library in your code. To start using MIL in an existing .NET project: In Visual Studio, from the Project menu, select Add Reference. In the Add Reference dialog box, select the Browse tab. Go to the Matrox Imaging\\MIL\\MIL.NET directory, select Matrox.MatroxImaginglibrary.dll, and click on the OK button to add the reference. Add the following to your code to include the functions and constants in the Matrox.MatroxImagingLibrary namespace: Language Reference statement Visual C# using Matrox.MatroxImagingLibrary; Note you could optionally avoid including the entire library and preface each MIL function call with [[Matrox.MatroxImagingLibrary.]MIL.MilFunction(...)]. Add MIL code in your application, keeping in mind the differences of programing with the MIL.NET wrapper, which are discussed throughout this chapter. When using the MIL.NET wrapper, you must compile using the 64-bit configuration. Typically, you should use custom MIL data types (for example, MIL_ID and MIL_INT), as opposed to language-specific data types. This allows for a more portable application. See the Data types in MIL with .NET section later in this chapter for more information on MIL_ID and MIL_INT. Calling MIL functions and constants in .NET Once the Matrox.MatroxImagingLibrary.dll is properly referenced and accessible by your code, calling MIL functions is almost identical in .NET as it is in unmanaged C/C++. MIL is in a MIL.NET wrapper, and all MIL functions and constants are static members of the class. The only difference in calling a function or using a constant lies in prefacing each MIL function and each MIL constant with \"MIL.\", assuming you have included the library in your code as outlined in step 4 of the MIL inclusion procedure for .NET subsection. // C++ sample function call MbufAlloc2d(ownerSystem, 640, 480, 8 + M_UNSIGNED, M_IMAGE + M_PROC, &amp;_bufID); // C# sample function call. // Note the 'MIL.' preface for the function name and constants MIL.MbufAlloc2d(ownerSystem, 640, 480, 8 + MIL.M_UNSIGNED, MIL.M_IMAGE + MIL.M_PROC, ref _bufID); Disabling compiler warnings in .NET If you recompile a MIL application with deprecated constants and functions, compiler warnings will now typically be generated. Deprecated constants and functions should no longer be used since they could be removed in a future major release of MIL (for example, MIL 11). All code that produces warnings about deprecated features should be updated to the code's current equivalent. For more information on how to update deprecated constants and functions to the code's current equivalent, see the Compiler warnings for deprecated constants and functions subsection of the Compiling and linking section of Chapter 1: Introduction. Deprecated MIL functions and constants in the .NET environment are denoted with the Obsolete attribute. The Obsolete attribute is a .NET feature that marks a program entity as one that is no longer recommended for use. Whenever you use a program entity marked as Obsolete, the compiler will generate a warning or an error. You can disable warnings about Obsolete features by following the procedures below. Note, however, that code with deprecated features might not compile with a future major release of MIL if you disable warnings and do not replace the code with the current standard. Procedure for disabling compiler warnings in C# There are two possible ways to disable compiler warnings when building an application in C#: one that disables compiler warnings caused by the Obsolete attribute for an encapsulated piece of code, and one that disables compiler warnings caused by the Obsolete attribute across the entire project. To disable compiler warnings for a portion of your C# application (for example, a block of code that should be updated to the code's current equivalent), you can encapsulate your code with the #pragma warning directive. This is preferable to disabling the compiler warnings globally, since it will disable the compiler warnings caused by the Obsolete attribute for only a block of MIL code rather than your entire project. Encapsulate your code between the following preprocessor directives: #pragma warning disable 612, 618 // Disable warnings for code marked as Obsolete. // MIL Code that generates the warning #pragma warning restore 612, 618 // Restore warnings for code marked as Obsolete. To disable compiler warnings caused by the Obsolete attribute across the entire project, perform the following steps. Note that this will disable all compiler warnings caused by the Obsolete attribute, including constants and functions not related to MIL. Open the Project Properties dialog box in Microsoft Visual Studio, by either selecting the 'projectName' Properties item in the Project menu, or by right-clicking on the project's name in the Solution Explorer pane and selecting Properties. In the Build tab of the Project Properties dialog box, add 0612;0618 to the Suppress warnings text box. Repeat step 2 for each build configuration and platform combination. Building a.NET application using MIL MIL inclusion procedure for.NET Calling MIL functions and constants in.NET Disabling compiler warnings in .NET Procedure for disabling compiler warnings in C# ",
      "wordCount": 903,
      "subEntries": []
    },
    {
      "id": "UG_NET_Data_types_in_MIL_with_NET",
      "version": null,
      "title": "Data types in MIL with.NET",
      "subTitles": [
        "MIL_ID and MIL_INT",
        "Data type equivalents"
      ],
      "location": "MIL UG P10: Other programming languages, APIs, and operating systems",
      "pageURL": "content\\UserGuide\\NET\\Data_types_in_MIL_with_NET.htm",
      "text": " Data types in MIL with .NET MIL uses many custom data types, but only MIL_ID and MIL_INT are included in both the MIL.NET wrapper and MIL. For every other data type, an equivalent data type needs to be used instead. MIL_ID and MIL_INT The MIL_ID and MIL_INT data types have been included in the MIL.NET wrapper, and so are usable when writing C# code. Other data types require a language-specific equivalent. The MIL_ID and MIL_INT data types implement the IComparable and the IConvertible interfaces. Please refer to the .NET framework's documentation for more information on these interfaces. The MIL_INT type is a structure provided to enable writing portable code. The MIL_INT type implements explicit conversion operators for the basic .NET types. This allows you to perform basic arithmetic and logical operations between a MIL_INT and any other numeric type, such as a long, double, or byte. Note that in a 64-bit operating system, MIL_INT behaves like a long. Data type equivalents The following chart explains the data type equivalents between MIL custom types, .NET types, and Visual C# types. When writing MIL code in C#, replace the MIL custom data type with the language specific equivalent data type in the chart. Note that MIL_ID and MIL_INT do not require an equivalent and can be used directly in C# code. Also note that the .NET type can be used in any .NET language, including C#. There are no .NET equivalents for the MIL_TEXT macro. When a function's parameter takes one of the macros in C, pass what you would to the macro directly to the function's parameter in .NET, without any reference to the macro itself. An example can be found in the MIL with .NET example section later in this chapter. MIL Custom Type .NET type Visual C# type MIL_ID MIL_ID 1 MIL_ID 1 MIL_INT MIL_INT 1 MIL_INT 1 MIL_UINT (32-bit) System.UInt32 uint MIL_UINT (64-bit) System.UInt64 ulong MIL_DOUBLE System.Double double MIL_INT8 System.SByte sbyte MIL_UINT8 System.Byte byte MIL_INT16 System.Int16 short MIL_UINT16 System.UInt16 ushort MIL_INT32 System.Int32 int MIL_UINT32 System.UInt32 uint MIL_INT64 System.Int64 long MIL_UINT64 System.UInt64 ulong MIL_TEXT_PTR System.String string MIL_FLOAT System.Single float MIL_BUFFER_INFO System.IntPtr System.IntPtr MIL_FPGA_CONTEXT System.IntPtr System.IntPtr 1 This data type can be used in this language only with the MIL.NET wrapper. Data types in MIL with.NET MIL_ID and MIL_INT Data type equivalents ",
      "wordCount": 384,
      "subEntries": []
    },
    {
      "id": "UG_NET_Using_NET_strings_with_MIL",
      "version": null,
      "title": " Using.NET strings with MIL",
      "subTitles": null,
      "location": "MIL UG P10: Other programming languages, APIs, and operating systems",
      "pageURL": "content\\UserGuide\\NET\\Using_NET_strings_with_MIL.htm",
      "text": " Using .NET strings with MIL Strings are handled differently in managed code than in unmanaged code. In managed code, strings are immutable (read-only) objects. Some MIL functions, such as M...Inquire() or M...GetResult(), have a parameter that requires a pointer to a modifiable string. Since strings are immutable in .NET, additional steps must be taken to use these functions. In these cases, you must create a StringBuilder object, and pass that StringBuilder object, rather than a pointer to a string, to the MIL function. The following example demonstrates how this is done. using System.Text; using Matrox.MatroxImagingLibrary; namespace StringsWithMIL.SingleString { class MyDigitizer { private MIL_ID _digId = MIL.M_NULL; public MyDigitizer(MIL_ID ownerSystem) { // Allocate the default digitizer on the specified system. MIL.MdigAlloc(ownerSystem, MIL.M_DEFAULT, \"M_DEFAULT\", MIL.M_DEFAULT, ref _digId); } public string Format { get { // Initialize a new StringBuilder object. // MIL will resize it to the appropriate size. StringBuilder format = new StringBuilder(); MIL.MdigInquire(_digId, MIL.M_FORMAT, format); // Use the ToString method to return a string from the StringBuilder object. return format.ToString(); } } } } When the call to the MIL function returns, the StringBuilder object contains a sequence of characters that ends with a null terminating character ('\\0'). Then, you can retrieve the string object by calling the ToString function of the StringBuilder instance. Using.NET strings with MIL ",
      "wordCount": 220,
      "subEntries": []
    },
    {
      "id": "UG_NET_Memory_management_while_using_MIL_with_NET",
      "version": null,
      "title": " Memory management while using MIL with.NET",
      "subTitles": [
        "M...Free() versus finalizers",
        "Invoking the garbage collector",
        "Pinning memory to be used by MbufCreate...()"
      ],
      "location": "MIL UG P10: Other programming languages, APIs, and operating systems",
      "pageURL": "content\\UserGuide\\NET\\Memory_management_while_using_MIL_with_NET.htm",
      "text": " Memory management while using MIL with .NET One of the key features of writing code in a managed environment is the garbage collector. To move from writing unmanaged C/C++ to managed C#, it is important to understand how memory is managed in C#. The .NET garbage collector is responsible for the allocation and release of objects in managed memory. Whenever an object is initialized using the New operator, the garbage collector allocates memory for that object and tracks its usage within your application. To free memory, the garbage collector sweeps through managed memory and frees the memory allocated to all objects that are no longer in use by your application. The timing of a garbage collection is unpredictable; it is possible, however, to force a garbage collection using the .NET System.GC.Collect function. M...Free() versus finalizers Objects that rely on a garbage collection scheme in the .NET environment have nondeterministic finalizers. These finalizers are called when the garbage collector decides to delete the object and not when the object is out of scope. Therefore, you cannot rely on having your resources freed by the object's finalizer since you do not know when the finalizers will be called. You should trap errors that might cause your call to an M...Free() function to be skipped. Any code between the allocation of a MIL object and the M...Free() function calls should be placed in a Try block, while an M...Free() function should be placed in a Finally block. Invoking the garbage collector To manually invoke the garbage collector, use the .NET System.GC.Collect function. The garbage collector disposes of all objects that are out of scope and that are no longer referenced by any active pointer. For more information on the system.GC class, refer to the .NET documentation available through the MSDN library. Note that it is good practice to let the garbage collector choose the most appropriate time to run. Pinning memory to be used by MbufCreate...() MbufCreate2d() and MbufCreateColor() create a MIL buffer that contains a pointer to a previously allocated block of memory. In a .NET application, memory is managed by the common language runtime's garbage collector, so steps must be taken to protect the block of memory from being moved or deleted, otherwise the buffer might point to random (garbage) data. To protect the block of memory, use the GCHandle structure to create a pinned object that contains the block of memory; a pinned object is not moved or deleted by the garbage collector, and so protects the block of memory it contains. The following code demonstrates how to create a pinned object to encapsulate a previously allocated block of memory, and how to create a buffer, using MbufCreate...(), that has a pointer to this protected block of memory. using System.Runtime.InteropServices; using Matrox.MatroxImagingLibrary; namespace MemoryManagement { class MappedBuffer2d { private MIL_ID _bufferId = MIL.M_NULL; private GCHandle _handle; public MappedBuffer2d(MIL_ID systemId, int sizeX, int sizeY, byte[,] imageData) { _handle = GCHandle.Alloc(imageData, GCHandleType.Pinned); // cast the returned address to a ulong because MbufCreate2d expects a ulong ulong addressOfImageData = (ulong)_handle.AddrOfPinnedObject(); MIL.MbufCreate2d(systemId, sizeX, sizeY, 8 + MIL.M_UNSIGNED, MIL.M_IMAGE + MIL.M_DISP, MIL.M_HOST_ADDRESS, sizeX, addressOfImageData, ref _bufferId); } public void Free() { if (_bufferId != MIL.M_NULL) { MIL.MbufFree(_bufferId); _handle.Free(); } } } } Memory management while using MIL with.NET M...Free() versus finalizers Invoking the garbage collector Pinning memory to be used by MbufCreate...() ",
      "wordCount": 559,
      "subEntries": []
    },
    {
      "id": "UG_NET_Delegates_and_hook_functions",
      "version": null,
      "title": " Delegates and MIL hook-type functions",
      "subTitles": [
        "Lifetime of delegates passed to MIL hook-type functions",
        "Passing user data to a user-defined function"
      ],
      "location": "MIL UG P10: Other programming languages, APIs, and operating systems",
      "pageURL": "content\\UserGuide\\NET\\Delegates_and_hook_functions.htm",
      "text": " Delegates and MIL hook-type functions Delegates are objects that contain a reference to functions, and as such, they are similar to function pointers in C++. The MIL.NET wrapper declares a several delegate types, and each one for use with a specific MIL hook-type function; MIL hook-type functions are those MIL functions that take a pointer to a user-defined (hook-handler or event-handler) function. When using a MIL hook-type function in .NET, use a delegate instead of a pointer to a user-defined function. The following table lists the MIL hook-type functions and their associated delegate type. MIL hook-type function Associated delegate type MappHookFunction() MIL_APP_HOOK_FUNCTION_PTR MbufHookFunction() MIL_BUF_HOOK_FUNCTION_PTR MdigHookFunction(), MdigProcess() MIL_DIG_HOOK_FUNCTION_PTR MdispHookFunction() MIL_DISP_HOOK_FUNCTION_PTR MfuncAlloc() MFUNCFCTPTR MocrHookFunction() MIL_OCR_HOOK_FUNCTION_PTR MsysHookFunction() MIL_SYS_HOOK_FUNCTION_PTR MthrAlloc() MIL_THREAD_FUNCTION_PTR MfpgaHookFunction() MIL_FPGA_HOOK_FUNCTION_PTR MdigFocus() MIL_FOCUS_HOOK_FUNCTION_PTR To create a new instance of a delegate, you must pass a user-defined function, with the proper signature and return type, to the constructor of the delegate object. The following table outlines the proper signature and return type for each type of delegate. Delegate type Return type Parameter types MIL_APP_HOOK_FUNCTION_PTR MIL_INT MIL_INT, MIL_ID, IntPtr MIL_BUF_HOOK_FUNCTION_PTR MIL_INT MIL_INT, MIL_ID, IntPtr MIL_DIG_HOOK_FUNCTION_PTR MIL_INT MIL_INT, MIL_ID, IntPtr MIL_DISP_HOOK_FUNCTION_PTR MIL_INT MIL_INT, MIL_ID, IntPtr MFUNCFCTPTR void MIL_ID MIL_OCR_HOOK_FUNCTION_PTR MIL_INT MIL_INT, string, IntPtr MIL_SYS_HOOK_FUNCTION_PTR MIL_INT MIL_INT, MIL_ID, IntPtr MIL_THREAD_FUNCTION_PTR MIL_INT IntPtr MIL_FPGA_HOOK_FUNCTION_PTR MIL_INT MIL_INT, MIL_ID, IntPtr MIL_FOCUS_HOOK_FUNCTION_PTR MIL_INT MIL_INT, MIL_INT, IntPtr For more information on the requirements of the user-defined function, please refer to the description of the corresponding hook-type function. Lifetime of delegates passed to MIL hook-type functions Delegate objects passed to a MIL hook-type function must stay alive as long as the user-defined function is hooked in MIL. This is because MIL needs to keep a pointer to the user-defined function to call it when the specified event occurs. Since out of scope delegates are subject to be collected by the common language runtime's (CLR's) garbage collector, you must ensure that the delegate will be in scope long enough; otherwise, it could result in an Null reference exception when the specified event occurs. Typically, delegates should be declared as members of the class that calls the MIL hook-type function, as in the following example: using System; using Matrox.MatroxImagingLibrary; namespace Delegates.Correct { class MyDigitizer { private MIL_ID _digitizerId = MIL.M_NULL; private MIL_DIG_HOOK_FUNCTION_PTR _myDelegate; public MyDigitizer(MIL_ID sysId) { MIL.MdigAlloc(sysId, MIL.M_DEFAULT, \"M_DEFAULT\", MIL.M_DEFAULT, ref _digitizerId); _myDelegate = new MIL_DIG_HOOK_FUNCTION_PTR(MyHookHandler); MIL.MdigHookFunction(_digitizerId, MIL.M_GRAB_START, _myDelegate, MIL.M_NULL); } public MIL_INT MyHookHandler(MIL_INT hookType, MIL_ID eventId, IntPtr userDataPtr) { return MIL.M_NULL; } } } The following example demonstrates an easy-to-make error; the delegate object myDel is declared in the scope of the class constructor, as opposed to being declared as a member of the class that calls the MIL hook-type function. When the constructor exits, myDel goes out of scope and will eventually be reclaimed by the garbage collector. When this happens, any further attempts from MIL to call the user-defined function will result in an exception. using System; using Matrox.MatroxImagingLibrary; namespace Delegates.Incorrect { class MyDigitizer { private MIL_ID _digitizerId = MIL.M_NULL; public MyDigitizer(MIL_ID sysId) { MIL.MdigAlloc(sysId, MIL.M_DEFAULT, \"M_DEFAULT\", MIL.M_DEFAULT, ref _digitizerId); MIL_DIG_HOOK_FUNCTION_PTR myDel = new MIL_DIG_HOOK_FUNCTION_PTR(MyHookHandler); MIL.MdigHookFunction(_digitizerId, MIL.M_GRAB_START, myDel, MIL.M_NULL); } public MIL_INT MyHookHandler(MIL_INT hookType, MIL_ID eventId, IntPtr userDataPtr) { return MIL.M_NULL; } } } Passing user data to a user-defined function Some applications might require user data to be available to the user-defined (hook-handler) function. To pass this user data to the user-defined function, and to protect this user data from the CLR's garbage collector, you should encapsulate the user data in an object, and encapsulate this new user data object in a GCHandle object. Note that a pinned GCHandle object is not needed because MIL does not directly reference the memory address of the user data object. The following example demonstrates how to pass user data to a user-defined function through the creation of a user data object encapsulated by a GCHandle object. using System; using System.Runtime.InteropServices; using Matrox.MatroxImagingLibrary; namespace Delegates.UserData { class MyUserData { public MIL_INT MyValue; } class MyDigitizer { private MIL_ID _digitizerId = MIL.M_NULL; private MIL_DIG_HOOK_FUNCTION_PTR _myDelegate; private MyUserData _myUserData; private GCHandle _userDataHandle; public MyDigitizer(MIL_ID sysId) { MIL.MdigAlloc(sysId, MIL.M_DEFAULT, \"M_DEFAULT\", MIL.M_DEFAULT, ref _digitizerId); } public void Hook() { // Prepare user data object _myUserData = new MyUserData(); _myUserData.MyValue = 10; // Allocate a regular GCHandle to inform the garbage collector // not to move the object. _userDataHandle = GCHandle.Alloc(_myUserData); _myDelegate = new MIL_DIG_HOOK_FUNCTION_PTR(MyHookHandler); MIL.MdigHookFunction(_digitizerId, MIL.M_GRAB_START, _myDelegate, GCHandle.ToIntPtr(_userDataHandle)); } public MIL_INT MyHookHandler(MIL_INT hookType, MIL_ID eventId, IntPtr userDataPtr) { if (userDataPtr != IntPtr.Zero) { // Use this to get the user data object reference from the GCHandle GCHandle userDataHandle = GCHandle.FromIntPtr(userDataPtr); MyUserData userData = userDataHandle.Target as MyUserData; if (userData.MyValue == 10) { // do something } } return MIL.M_NULL; } public void Unhook() { // Unhook the function in MIL. MIL.MdigHookFunction(_digitizerId, MIL.M_GRAB_START + MIL.M_UNHOOK, _myDelegate, GCHandle.ToIntPtr(_userDataHandle)); // Free the GCHandle when no longer needed _userDataHandle.Free(); } } } It is not only important to inform the garbage collector not to move an object, it is also important to let the garbage collector know when it can move an object. This is done by releasing the GCHandle object with its Free function. This is shown in the Unhook function of the above example. Delegates and MIL hook-type functions Lifetime of delegates passed to MIL hook-type functions Passing user data to a user-defined function ",
      "wordCount": 876,
      "subEntries": []
    },
    {
      "id": "UG_NET_Error_handling",
      "version": null,
      "title": " Error handling",
      "subTitles": null,
      "location": "MIL UG P10: Other programming languages, APIs, and operating systems",
      "pageURL": "content\\UserGuide\\NET\\Error_handling.htm",
      "text": " Error handling By default, when an error occurs in a MIL function, a message box is displayed. MIL allows you to control printing errors to the screen using MappControl() with M_ERROR. An option is available in .NET languages to throw exceptions instead of displaying a message box. Once enabled, when an error occurs in a function, a .NET exception is thrown instead of a message box being displayed. Exceptions thrown by MIL functions are fully compatible with try/catch blocks. To enable exceptions, use MappControl() with M_ERROR set to M_THROW_EXCEPTION. The following example demonstrates how to enable exceptions, and how to use them with a try/catch block. using System; using System.Text; using Matrox.MatroxImagingLibrary; namespace MILErrors { class MyApplication { private MIL_ID _milApplication = MIL.M_NULL; public MyApplication() { MIL.MappAlloc(MIL.M_NULL, MIL.M_DEFAULT, ref _milApplication); // Tell MIL to throw exceptions when an error occurs. // The type of Exception thrown by MIL functions is MILException MIL.MappControl(_milApplication, MIL.M_ERROR, MIL.M_THROW_EXCEPTION); } } class MyImage { private MIL_ID _bufId = MIL.M_NULL; public MyImage(MIL_ID ownerSystem, MIL_INT numberOfBands, MIL_INT sizeX, MIL_INT sizeY) { try { MIL.MbufAllocColor(ownerSystem, numberOfBands, sizeX, sizeY, 8 + MIL.M_UNSIGNED, MIL.M_IMAGE + MIL.M_DISP + MIL.M_PROC + MIL.M_GRAB, ref _bufId); } catch (MILException exception) { Console.WriteLine(\"Image Allocation Error : {0}\", exception.Message); } } } } Error handling ",
      "wordCount": 211,
      "subEntries": []
    },
    {
      "id": "UG_NET_Using_WPF_with_MIL",
      "version": null,
      "title": "Using WPF with MIL",
      "subTitles": [
        "XAML skeleton example"
      ],
      "location": "MIL UG P10: Other programming languages, APIs, and operating systems",
      "pageURL": "content\\UserGuide\\NET\\Using_WPF_with_MIL.htm",
      "text": " Using WPF with MIL The MIL .NET wrapper allows you to display MIL image buffers using Windows Presentation Foundation (WPF). The following steps explain how to add WPF support to a MIL .NET project: Add a reference to Matrox.MatroxImaginglibrary.WPF.dll in your project. It can be found in the MIL installation directory under Matrox Imaging\\MIL\\MIL.NET. Add the following prefix declaration to the root tag of your XAML file to map an XML namespace to the MIL WPF Display control's assembly: xmlns:milwpf=\"clr-namespace:Matrox.MatroxImagingLibrary.WPF;assembly=Matrox.MatroxImagingLibrary.WPF\" Add a &lt;milwpf:MILWPFDisplay&gt; tag to your XAML page. Associate the MILWPFDisplay control with a MIL M_WPF display, using the DisplayId property. WPF provides several ways to create the association (for example, data bindings and code behind). The MdispWPF example adds the following properties to the MILWPFDisplay tag to use the control in the code-behind and to bind the MIL M_WPF display (MilDisplayId) to the control. Property Sample Value Notes x:Name _milWPFDisplayControl This property is a standard identifier for all XAML objects see: https://docs.microsoft.com/en-us/dotnet/desktop/xaml-services/xname-directive. DisplayId {Binding MilDisplayId} This property is not required if you are using the code-behind method. For more on binding, see: https://docs.microsoft.com/en-us/dotnet/desktop/wpf/data/data-binding-overview. For more information on dependency properties in WPF, see: https://docs.microsoft.com/en-us/dotnet/desktop/wpf/advanced/dependency-properties-overview?view=netframeworkdesktop-4.8. For a complete example, see MdispWPF in the Matrox Example Launcher in the MIL Control Center. XAML skeleton example This is a complete WPF XAML page that includes MIL. This page will require that a display is allocated using MdispAlloc() with M_WPF. &lt;Window x:Class=\"MdispWPF.MainWindow\" xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\" xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\" xmlns:mc=\"http://schemas.openxmlformats.org/markup-compatibility/2006\" xmlns:milwpf=\"clr-namespace:Matrox.MatroxImagingLibrary.WPF;assembly=Matrox.MatroxImagingLibrary.WPF\"&gt; &lt;milwpf:MILWPFDisplay x:Name=\"_milWPFDisplayControl\" DisplayId=\"{Binding MilDisplayId}\" /&gt; &lt;/Window&gt; Using WPF with MIL XAML skeleton example ",
      "wordCount": 257,
      "subEntries": []
    },
    {
      "id": "UG_NET_MIL_with_NET_example",
      "version": null,
      "title": " MIL with.NET example",
      "subTitles": [
        "Compiling MIL C# examples under Linux"
      ],
      "location": "MIL UG P10: Other programming languages, APIs, and operating systems",
      "pageURL": "content\\UserGuide\\NET\\MIL_with_NET_example.htm",
      "text": " MIL with .NET example The two snippets below perform identical procedures, but the first is written in C++, while the second is written in C#. The comments in the C# code identify the MIL-specific differences. class MyDisplay { private: MIL_ID _dispId; public: MyDisplay(MIL_ID ownerSystem) { // Allocate the default display on the specified system. MdispAlloc(ownerSystem, M_DEFAULT, MIL_TEXT(\"M_DEFAULT\"), M_DEFAULT, &amp;_dispId); // Set a custom title for the display window. MdispControl(_dispId, M_TITLE, MIL_TEXT(\"My Display\")); } MIL_DOUBLE GetZoomFactorX() { MIL_DOUBLE xFactor = 0.0; MdispInquire(_dispId, M_ZOOM_FACTOR_X, &amp;xFactor); return xFactor; } bool GetOverlayEnabled() { MIL_INT overlay = MdispInquire(_dispId, M_OVERLAY, M_NULL); return (overlay == M_ENABLE) ? true : false; } }; using System.Text; using Matrox.MatroxImagingLibrary; namespace DataTypes { class MyDisplay { private MIL_ID _dispId = MIL.M_NULL; public MyDisplay(MIL_ID ownerSystem) { // The MIL_TEXT macro in C++ is replaced by a string in C#. MIL.MdispAlloc(ownerSystem, MIL.M_DEFAULT, \"M_DEFAULT\", MIL.M_DEFAULT, ref _dispId); // Set a custom title for the display window. MIL.MdispControl(_dispId, MIL.M_TITLE, \"My Display\"); } public double ZoomFactorX { get { // The double type has the same representation in 32-bit and 64-bit // No need to use a custom data type to write portable code. double xFactor = 0.0; MIL.MdispInquire(_dispId, MIL.M_ZOOM_FACTOR_X, ref xFactor); return xFactor; } } public bool OverlayEnabled { get { // Using the MIL_INT type ensures that the code will be portable // It allows using the same code to compile a 32-bit and 64-bit // version of the application. MIL_INT overlay = MIL.MdispInquire(_dispId, MIL.M_OVERLAY, MIL.M_NULL); return (overlay == MIL.M_ENABLE) ? true : false; } } } } Compiling MIL C# examples under Linux Compiling MIL C# examples under Linux requires that .NET is installed in the /usr/share/dotnet directory or that the DOTNET_ROOT environment variable is exported. To compile all C# examples, enter the following commands: cd $MILDIR/examples make all_dotnet MIL with.NET example Compiling MIL C# examples under Linux ",
      "wordCount": 307,
      "subEntries": []
    }
  ]
}]
[{
  "id": "Example_PlaceHolder_ID",
  "version": "2024020714",
  "title": "Example_PlaceHolder_Title",
  "wordCount": 0,
  "subEntries": [
    {
      "id": "Examples_BoardSpecific_General_MdigProcess16VD_CPP_mdigprocess16vd_cpp",
      "version": "2024020714",
      "title": "mdigprocess16vd.cpp",
      "location": "Sample Code from MIL Examples",
      "text": " Top /***********************************************************************************/ /* * File name: MDigProcessMultiple.cpp * Location: See Matrox Example Launcher in the MIL Control Center * * * Synopsis: This program shows how to use multiple digitizers to do acquisition * and displaying. * The main starts an independent processing job for each digitizer * (one per camera) and then waits for a key to be pressed to stop them. * * This example is based on MDigProcess.cpp * * Copyright (C) Matrox Electronic Systems Ltd., 1992-2024. * All Rights Reserved */ #include &lt;mil.h&gt; #include &lt;math.h&gt; #include &lt;io.h&gt; #include &lt;windows.h&gt; // Maximum number of digitizer and displays. #define MAX_DIGITIZER_NUM 16 #define MAX_DISPLAYS 4 #define BUFFERING_SIZE_MAX 4 // User's processing function prototype and hook parameter structure. MIL_INT MFTYPE ProcessingFunction(MIL_INT HookType, MIL_ID HookId, void* HookDataPtr); typedef struct { MIL_INT Enabled; MIL_INT Index; MIL_INT SizeX; MIL_INT SizeY; } DISPLAY_DEVICE_PARAM; typedef struct { MIL_INT DeviceNum; MIL_ID MilSystem; MIL_ID MilDigitizer; MIL_ID MilDisplay; MIL_ID MilImageDisp; MIL_ID MilImageDispChild; MIL_ID MilGrabBufferList[BUFFERING_SIZE_MAX]; MIL_INT MilGrabBufferListSize; MIL_INT IsCameraPresent; MIL_INT ProcessedImageCount; MIL_INT SizeBand; MIL_INT SizeX; MIL_INT SizeY; } DIG_PARAM; int MosMain(void) { MIL_ID MilApplication = M_NULL; MIL_ID MilSystem = M_NULL; MIL_ID MilDisplayCur = M_NULL; MIL_ID MilImageDispCur = M_NULL; MIL_ID MilImageDisp = M_NULL; DIG_PARAM DigParam[MAX_DIGITIZER_NUM] = { 0 }; MIL_ID MilDisplay[MAX_DIGITIZER_NUM] = { 0 }; DISPLAY_DEVICE_PARAM DisplayParam[MAX_DIGITIZER_NUM] = {0}; DISPLAY_DEVICE DisplayDevice = {0}; DEVMODE DisplayDeviceMode = {0}; MIL_INT32 NumberOfDigitizersToUse = MAX_DIGITIZER_NUM; MIL_INT NumberOfDisplays = 0; MIL_INT WindowCount = 0; MIL_INT NbrOfXWindows = 0; MIL_INT NbrOfYWindows = 0; MIL_INT DisplayPosIndex = 0; MIL_INT DispIndex = 0; MIL_INT DevNum = 0; MIL_INT32 i = 0; /////////////////////////////////// // Allocate application and system. MappAlloc(M_NULL, M_DEFAULT, &amp;MilApplication); MsysAlloc(M_DEFAULT, M_SYSTEM_DEFAULT, M_DEFAULT, M_DEFAULT, &amp;MilSystem); //////////////////////////////////////////////////// // Inquire the number of display devices (monitors). DisplayDevice.cb = sizeof(DISPLAY_DEVICE); DisplayDeviceMode.dmSize = sizeof(DEVMODE); DevNum = 0; for(i = 0; i&lt; NumberOfDigitizersToUse; i++) { if(EnumDisplayDevices(NULL, i, &amp;DisplayDevice, 0) &amp;&amp; DisplayDevice.StateFlags &amp; DISPLAY_DEVICE_ATTACHED_TO_DESKTOP) { EnumDisplaySettings(DisplayDevice.DeviceName, ENUM_CURRENT_SETTINGS, &amp;DisplayDeviceMode); NumberOfDisplays++; DisplayParam[DevNum].Enabled = 1; DisplayParam[DevNum].Index = i; DisplayParam[DevNum].SizeX = DisplayDeviceMode.dmPelsWidth; DisplayParam[DevNum].SizeY = DisplayDeviceMode.dmPelsHeight; DevNum++; } } //////////////////////////////////////////////////////////////////////////////////////// // Inquire the number of digitizers to use and the number of displays to display them in. NumberOfDisplays = min(MAX_DISPLAYS, NumberOfDisplays); NumberOfDigitizersToUse = (MIL_INT32)min(MAX_DIGITIZER_NUM, MsysInquire(MilSystem, M_DIGITIZER_NUM, M_NULL)); MosPrintf(MIL_TEXT(\"Enter the number of digitizers to use (max: %d): \\n\"), (int)NumberOfDigitizersToUse); scanf(\"%d\", &amp;NumberOfDigitizersToUse); NumberOfDigitizersToUse = min(NumberOfDigitizersToUse, NumberOfDigitizersToUse); NumberOfDisplays = min(NumberOfDisplays, NumberOfDigitizersToUse); if((NumberOfDisplays &gt; 1) &amp;&amp; (NumberOfDigitizersToUse &gt; 1)) { MIL_INT32 lNbrOfDisplays = 0; MosPrintf(MIL_TEXT(\"Enter the number of display devices (monitors) \") MIL_TEXT(\"to use (max: %d): \\n\"), (int)NumberOfDisplays); scanf(\"%d\", &amp;lNbrOfDisplays); NumberOfDisplays = min(lNbrOfDisplays, NumberOfDisplays); } //////////////////////////////////////////////////////////////////////////// // Loop through each digitizer to allocate grab buffers and associated display. for(DevNum = 0; DevNum &lt; NumberOfDigitizersToUse; DevNum++) { DIG_PARAM *pDig = &amp;DigParam[DevNum]; DISPLAY_DEVICE_PARAM *pDisp = &amp;DisplayParam[DispIndex]; // Allocate digitizer. MdigAlloc(MilSystem, DevNum, MIL_TEXT(\"M_DEFAULT\"), M_DEFAULT, &amp;pDig-&gt;MilDigitizer); // Inquire digitizer settings. pDig-&gt;MilSystem = MilSystem; pDig-&gt;DeviceNum = DevNum; pDig-&gt;SizeBand = MdigInquire(pDig-&gt;MilDigitizer, M_SIZE_BAND, M_NULL); pDig-&gt;SizeX = MdigInquire(pDig-&gt;MilDigitizer, M_SIZE_X, M_NULL); pDig-&gt;SizeY = MdigInquire(pDig-&gt;MilDigitizer, M_SIZE_Y, M_NULL); // Allocate grab buffers for this digitizer. pDig-&gt;MilGrabBufferListSize = BUFFERING_SIZE_MAX; for(i = 0; i &lt; pDig-&gt;MilGrabBufferListSize; i++) { MbufAllocColor(MilSystem, 3, pDig-&gt;SizeX, pDig-&gt;SizeY, 8 + M_UNSIGNED, M_IMAGE + M_GRAB + M_YUV16 + M_PACKED + M_ON_BOARD, &amp;pDig-&gt;MilGrabBufferList[i]); if(!pDig-&gt;MilGrabBufferList[i]) { MosPrintf(MIL_TEXT(\"Unable to allocate grab buffers.\\n\")); MosPrintf(MIL_TEXT(\"Please reduce buffering size.\\n\")); MosGetchar(); return 0; } } ////////////////////////////////////////// // Allocate a MilDisplay for each monitor. if(DevNum &gt;= WindowCount) { MIL_INT MaxNbrOfWindowsPerDisplay; MdispAlloc(MilSystem, DispIndex, MIL_TEXT(\"M_DEFAULT\"), M_DEFAULT, &amp;MilDisplayCur); // Calculate the number of digitizers to display in each Window. if(DispIndex+1 == NumberOfDisplays) MaxNbrOfWindowsPerDisplay = NumberOfDigitizersToUse - DevNum; else MaxNbrOfWindowsPerDisplay = NumberOfDigitizersToUse / NumberOfDisplays; NbrOfXWindows = (MIL_INT) max(pDisp-&gt;SizeX / pDig-&gt;SizeX, sqrt((double)MaxNbrOfWindowsPerDisplay) + 0.99); NbrOfXWindows = min(NbrOfXWindows, MaxNbrOfWindowsPerDisplay); NbrOfYWindows = (MIL_INT) ((MaxNbrOfWindowsPerDisplay / (double)NbrOfXWindows) + 0.99); WindowCount = WindowCount + (NbrOfXWindows * NbrOfYWindows); MbufAllocColor(MilSystem, pDig-&gt;SizeBand, pDig-&gt;SizeX * NbrOfXWindows, pDig-&gt;SizeY * NbrOfYWindows, 8 + M_UNSIGNED, M_IMAGE + M_DISP + (pDig-&gt;SizeBand == 3? M_BGR32 + M_PACKED:0) + M_NON_PAGED, &amp;MilImageDispCur); // Clear and select the display buffer. MbufClear(MilImageDispCur, M_COLOR_BLACK); MdispSelect(MilDisplayCur, MilImageDispCur); DisplayPosIndex = 0; DispIndex++; } pDig-&gt;MilDisplay = MilDisplayCur; pDig-&gt;MilImageDisp = MilImageDispCur; // Allocate a child display buffer for this digitizer. // The grab buffer will be copied into this buffer. MIL_INT XPos, YPos; XPos = (DisplayPosIndex%NbrOfXWindows) * pDig-&gt;SizeX; YPos = (DisplayPosIndex/NbrOfXWindows) * pDig-&gt;SizeY; pDig-&gt;MilImageDispChild = MbufChild2d(pDig-&gt;MilImageDisp, XPos, YPos, pDig-&gt;SizeX, pDig-&gt;SizeY, M_NULL); MosPrintf(MIL_TEXT(\"Allocating digitizer device %2d on display device %2d. \\n\"), DevNum, DispIndex); DisplayPosIndex++; } /////////////////////////////////////// // Start MdigProcess on each digitizer. MosPrintf(MIL_TEXT(\"\\n\\nStarting MdigProcess on %d digitizer(s).\\n\"), (int)NumberOfDigitizersToUse); MappControl(M_DEFAULT, M_ERROR, M_PRINT_DISABLE); for(DevNum = 0; DevNum &lt; NumberOfDigitizersToUse; DevNum++) { DIG_PARAM *pDig = &amp;DigParam[DevNum]; if(MdigInquire(pDig-&gt;MilDigitizer, M_CAMERA_PRESENT, M_NULL)) pDig-&gt;IsCameraPresent = TRUE; else pDig-&gt;IsCameraPresent = FALSE; MdigProcess(pDig-&gt;MilDigitizer, pDig-&gt;MilGrabBufferList, pDig-&gt;MilGrabBufferListSize, M_START, M_DEFAULT, ProcessingFunction, pDig); } ///////////////////////// // Print grab statistics. while(!MosKbhit()) { COORD Coord; Coord.X = 0; Coord.Y = (SHORT) (8 + NumberOfDigitizersToUse); // At each second. MosSleep(1000); SetConsoleCursorPosition(GetStdHandle(STD_OUTPUT_HANDLE), Coord); for(DevNum = 0; DevNum &lt; NumberOfDigitizersToUse; DevNum++) { double FrameRate = 0; MIL_INT FramesMissed = 0; DIG_PARAM *pDig = &amp;DigParam[DevNum]; // Inquire and print MdigProcess statistics. MdigInquire(pDig-&gt;MilDigitizer, M_PROCESS_FRAME_RATE, &amp;FrameRate); MdigInquire(pDig-&gt;MilDigitizer, M_PROCESS_FRAME_MISSED, &amp;FramesMissed); MosPrintf(MIL_TEXT(\"Dig #: %2d, %6d frames grabbed at %5.2f (f/s).\"), DevNum, pDig-&gt;ProcessedImageCount, FrameRate); // Print if a camera is present. if(pDig-&gt;IsCameraPresent) { if(FramesMissed &gt; 1) MosPrintf(MIL_TEXT(\"%6d frames were missed. \"), FramesMissed); else if(FramesMissed == 1) MosPrintf(MIL_TEXT(\"1 frame was missed. \")); } else { MosPrintf(MIL_TEXT(\" No camera is present. \")); } MosPrintf(MIL_TEXT(\"\\n\")); } } MosGetchar(); MosPrintf(MIL_TEXT(\"\\n\\nExiting...\\n\")); // Stop MdigProcess for each digitizer. for(DevNum = 0; DevNum &lt; NumberOfDigitizersToUse; DevNum++) { DIG_PARAM *pDig = &amp;DigParam[DevNum]; MdigProcess(pDig-&gt;MilDigitizer, pDig-&gt;MilGrabBufferList, pDig-&gt;MilGrabBufferListSize, M_STOP, M_DEFAULT, ProcessingFunction, pDig); } ////////////////////////////// // Free allocated MIL objects. for(DevNum = 0; DevNum &lt; NumberOfDigitizersToUse; DevNum++) { for (i = 0; i &lt; DigParam[DevNum].MilGrabBufferListSize; i++) { if(DigParam[DevNum].MilGrabBufferList[i]) { MbufFree(DigParam[DevNum].MilGrabBufferList[i]); DigParam[DevNum].MilGrabBufferList[i] = M_NULL; } } if(DigParam[DevNum].MilImageDispChild) MbufFree(DigParam[DevNum].MilImageDispChild); if(MilImageDisp != DigParam[DevNum].MilImageDisp) { MilImageDisp = DigParam[DevNum].MilImageDisp; MbufFree(MilImageDisp); MdispFree(DigParam[DevNum].MilDisplay); } MdigFree(DigParam[DevNum].MilDigitizer); } MsysFree(MilSystem); MappFree(MilApplication); return 0; } //////////////////////////////////////////////////////////////////// // MdigProcess processing function called every time a grab is done. MIL_INT MFTYPE ProcessingFunction(MIL_INT HookType, MIL_ID HookId, void* HookDataPtr) { DIG_PARAM *pDig = (DIG_PARAM *)HookDataPtr; MIL_ID ModifiedBufferId; // Get grab buffer. MdigGetHookInfo(HookId, M_MODIFIED_BUFFER+M_BUFFER_ID, &amp;ModifiedBufferId); pDig-&gt;ProcessedImageCount++; // Inquire if a camera is present, if so copy the grab buffer to the display. if(!MdigInquire(pDig-&gt;MilDigitizer, M_CAMERA_PRESENT, NULL)) { pDig-&gt;IsCameraPresent = FALSE; MgraText(M_DEFAULT, pDig-&gt;MilImageDispChild, 20, 20, MIL_TEXT(\"Sorry, no camera is present\")); } else { pDig-&gt;IsCameraPresent = TRUE; MbufCopy(ModifiedBufferId, pDig-&gt;MilImageDispChild); } return 0; } ",
      "wordCount": 1001
    }
  ]
}]
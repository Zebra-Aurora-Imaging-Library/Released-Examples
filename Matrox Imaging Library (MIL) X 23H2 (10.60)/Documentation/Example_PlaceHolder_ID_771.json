[{
  "id": "Example_PlaceHolder_ID",
  "version": "2024020714",
  "title": "Example_PlaceHolder_Title",
  "wordCount": 0,
  "subEntries": [
    {
      "id": "Examples_Processing_Classification_ClassDetectionCompleteTrain_CPP_classdetectioncompletetrain_cpp",
      "version": "2024020714",
      "title": "classdetectioncompletetrain.cpp",
      "location": "Sample Code from MIL Examples",
      "text": " Top //************************************************************************************* // // File name: ClassDetectionCompleteTrain.cpp // Location: See Matrox Example Launcher in the MIL Control Center // // // Synopsis: This program uses the classification module to train // a context that can detect knots in wood. // // Note: GPU training can be enabled with a MIL update for 64-bit. // This can dramatically increase the training speed. // // Copyright (C) Matrox Electronic Systems Ltd., 1992-2024. // All Rights Reserved #include &lt;mil.h&gt; #include &lt;windows.h&gt; #include &lt;algorithm&gt; #include &lt;cstdlib&gt; #include &lt;set&gt; //============================================================================== // Example description. //============================================================================== void PrintHeader() { MosPrintf( MIL_TEXT(\"[EXAMPLE NAME]\\n\") MIL_TEXT(\"ClassDetectionCompleteTrain\\n\\n\") MIL_TEXT(\"[SYNOPSIS]\\n\") MIL_TEXT(\"This example trains an object detection classifier to detect knots of different\\n\") MIL_TEXT(\"sizes in wood.\\n\") MIL_TEXT(\"The first step imports the dataset.\\n\") MIL_TEXT(\"The second step trains a context and displays the train evolution.\\n\") MIL_TEXT(\"The final step performs predictions on a test dataset using the trained object\\n\") MIL_TEXT(\"detection classifier as a final check of its performance.\\n\\n\") MIL_TEXT(\"[MODULES USED]\\n\") MIL_TEXT(\"Modules used: application, system, display, buffer,\\n\") MIL_TEXT(\"graphic, classification.\\n\\n\")); } //============================================================================== // Constants. //============================================================================== #define EXAMPLE_IMAGE_ROOT_PATH M_IMAGE_PATH MIL_TEXT(\"Classification/PlywoodTrain/\") #define EXAMPLE_DATASET_ROOT_PATH EXAMPLE_IMAGE_ROOT_PATH MIL_TEXT(\"Dataset\") #define EXAMPLE_TEST_DATASET_ROOT_PATH EXAMPLE_IMAGE_ROOT_PATH MIL_TEXT(\"TestDataset\") #define EXAMPLE_PRETRAINED_PATH EXAMPLE_IMAGE_ROOT_PATH MIL_TEXT(\"PlywoodODNet.mclass\") #define EXAMPLE_TRAIN_DESTINATION_PATH MIL_TEXT(\"Train/\") static const MIL_DOUBLE MATCH_IOU_THRESHOLD_VALUE = 30.0; //============================================================================== // Classes. //============================================================================== class CTrainEvolutionDashboard { public: CTrainEvolutionDashboard( MIL_ID MilSystem, MIL_ID TrainCtx, MIL_INT TrainImageSizeX, MIL_INT TrainImageSizeY, MIL_INT TrainEngineUsed, const MIL_STRING&amp; TrainEngineDescription); ~CTrainEvolutionDashboard(); void AddEpochData(MIL_DOUBLE Loss, MIL_INT CurEpoch, MIL_DOUBLE EpochBenchMean); void AddMiniBatchData( MIL_DOUBLE Loss, MIL_INT MinibatchIdx, MIL_INT EpochIdx, MIL_INT NbBatchPerEpoch); MIL_ID GetDashboardBufId() const { return m_DashboardBufId; } private: void UpdateTrainLoss(MIL_DOUBLE Loss); void UpdateDevLoss(MIL_DOUBLE Loss); void UpdateTrainLossGraph( MIL_DOUBLE Loss, MIL_INT MiniBatchIdx, MIL_INT EpochIdx, MIL_INT NbBatchPerEpoch); void UpdateDevLossGraph(MIL_DOUBLE Loss, MIL_INT EpochIdx); void UpdateProgression(MIL_INT MinibatchIdx, MIL_INT EpochIdx, MIL_INT NbBatchPerEpoch); void DrawSectionSeparators(); void DrawBufferFrame(MIL_ID BufId, MIL_INT FrameThickness); void InitializeLossGraph(); void WriteGeneralTrainInfo( MIL_INT MinibatchSize, MIL_INT TrainImageSizeX, MIL_INT TrainImageSizeY, MIL_DOUBLE LearningRate, MIL_INT TrainEngineUsed, const MIL_STRING&amp; TrainEngineDescription); MIL_UNIQUE_BUF_ID m_DashboardBufId {M_NULL}; MIL_UNIQUE_GRA_ID m_TheGraContext {M_NULL}; MIL_UNIQUE_BUF_ID m_LossInfoBufId {M_NULL}; MIL_UNIQUE_BUF_ID m_LossGraphBufId {M_NULL}; MIL_UNIQUE_BUF_ID m_ProgressionInfoBufId {M_NULL}; MIL_INT m_MaxEpoch {0}; MIL_INT m_DashboardWidth {0}; MIL_INT m_LastTrainMinibatchPosX {0}; MIL_INT m_LastTrainMinibatchPosY {0}; MIL_INT m_LastDevEpochLossPosX {0}; MIL_INT m_LastDevEpochLossPosY {0}; MIL_INT m_YPositionForTrainLossText {0}; MIL_INT m_YPositionForDevLossText {0}; MIL_DOUBLE m_EpochBenchMean {-1.0}; // Constants useful for the graph. const MIL_INT GRAPH_SIZE_X {600}; const MIL_INT GRAPH_SIZE_Y {400}; const MIL_INT GRAPH_TOP_MARGIN {30}; const MIL_INT MARGIN {50}; const MIL_INT EPOCH_AND_MINIBATCH_REGION_HEIGHT {190}; const MIL_INT PROGRESSION_INFO_REGION_HEIGHT {100}; const MIL_INT LOSS_EXPONENT_MAX {0}; const MIL_INT LOSS_EXPONENT_MIN {-5}; const MIL_DOUBLE COLOR_GENERAL_INFO {M_RGB888(0, 176, 255)}; const MIL_DOUBLE COLOR_DEV_SET_INFO {M_COLOR_MAGENTA}; const MIL_DOUBLE COLOR_TRAIN_SET_INFO {M_COLOR_GREEN}; const MIL_DOUBLE COLOR_PROGRESS_BAR {M_COLOR_DARK_GREEN}; }; //............................................................................ class CDatasetViewer { public: CDatasetViewer(MIL_ID MilSystem, MIL_ID Dataset, bool DisplayGroundTruth); CDatasetViewer(MIL_ID MilSystem, MIL_ID Dataset, MIL_ID StatCtx, MIL_ID StatRslt, bool DisplayGroundTruth); struct SIncorrectPredictionInfo { MIL_UUID m_EntryKey {}; MIL_INT m_NbRegions {0}; MIL_INT m_NbInstances {0}; MIL_INT m_NbClassMismatch {0}; MIL_INT m_NbFalseDetection {0}; MIL_INT m_NbMissedDetection {0}; MIL_INT m_Status {-1}; std::vector&lt;MIL_INT&gt; m_MatchedRegionIndexes; std::vector&lt;MIL_INT&gt; m_MatchedInstanceIndexes; }; private: void ViewDataset(); void PrintControls() const; void ProcessIncorrectPredictions(); void DrawOverlayIcons() const; void DrawOverlayImage(); void DrawOverlayTexts(); void DrawFalseDetection(const SIncorrectPredictionInfo&amp; IncorrectEntryInfo) const; void DrawMissedDetection(const SIncorrectPredictionInfo&amp; IncorrectEntryInfo) const; MIL_INT GetNumberOfGTs() const; bool ProcessUserInputControl(); MIL_INT GetIncorrectPredictionIndex() const; private: const MIL_ID m_System {}; const MIL_ID m_Dataset {}; const MIL_ID m_StatCtx {}; const MIL_ID m_StatRslt {}; bool m_DisplayGroundTruth {false}; bool m_DisplayIncorrectPredictionsOnly {false}; MIL_UNIQUE_DISP_ID m_Display {}; MIL_ID m_MilOverlay {}; MIL_UNIQUE_BUF_ID m_DisplayBuffer {}; MIL_UNIQUE_BUF_ID m_DisplayTarget {}; MIL_UNIQUE_GRA_ID m_DisGraList {}; MIL_UNIQUE_GRA_ID m_GraDrawCtx {}; MIL_UNIQUE_GRA_ID m_GraTextCtx {}; MIL_UNIQUE_GRA_ID m_GraCtxIncorrectPredictions {}; MIL_INT m_ImageSizeX {0}; MIL_INT m_ImageSizeY {0}; MIL_INT m_IconSize {0}; MIL_INT m_NbClasses {0}; MIL_INT m_NbEntries {0}; MIL_INT m_NbViewEntries {0}; MIL_INT m_EntryIndex {0}; MIL_UUID m_EntryKey {}; MIL_INT m_LastEntryIndex {0}; MIL_STRING m_OverlayText; std::vector&lt;SIncorrectPredictionInfo&gt; m_IncorrectPredictions; MIL_INT m_IncorrectPredictionIndex {0}; MIL_INT m_LastIncorrectPredictionIndex {0}; }; //============================================================================== // Structs. //============================================================================== struct SHookDatasetsPrepared { MIL_ID m_DashboardId {M_NULL}; MIL_ID m_MilDisplay {M_NULL}; }; //............................................................................ struct SHookEpochData { CTrainEvolutionDashboard* m_pTheDashboard {nullptr}; }; //............................................................................ struct SHookMiniBatchData { CTrainEvolutionDashboard* m_pTheDashboard {nullptr}; }; //............................................................................ struct SStatMetricInfo { MIL_DOUBLE m_ACC {0.0}; MIL_DOUBLE m_ERR {0.0}; MIL_DOUBLE m_TNR {0.0}; MIL_DOUBLE m_FPR {0.0}; MIL_DOUBLE m_TPR {0.0}; MIL_DOUBLE m_FNR {0.0}; MIL_DOUBLE m_PPV {0.0}; MIL_DOUBLE m_FDR {0.0}; MIL_DOUBLE m_F1 {0.0}; MIL_DOUBLE m_AP {0.0}; }; //............................................................................ struct SStatResultInfo { SStatMetricInfo m_Macro; SStatMetricInfo m_Micro; SStatMetricInfo m_Weighted; std::vector&lt;SStatMetricInfo&gt; m_PerClass; }; //============================================================================== // Functions. //============================================================================== MIL_INT CnnTrainEngineDLLInstalled(MIL_ID MilSystem); void GetImageSizes( MIL_ID MilSystem, MIL_ID Dataset, MIL_INT* pImgSizeX, MIL_INT* pImgSizeY); MIL_INT IsTrainingSupportedOnPlatform(MIL_ID MilSystem); void LoadDatasets(MIL_ID MilSystem, MIL_ID Dataset, MIL_ID TestDataset, bool SkipTrain); void PredictUsingTrainedContext( MIL_ID MilSystem, MIL_ID MilDisplay, MIL_ID TrainedCtx, MIL_ID TestDataset); void GetStatResults(MIL_ID MilSystem, MIL_ID TestDataset); void PrintStatResults(const SStatResultInfo&amp; StatResults, MIL_ID TestDataset); MIL_STRING GetTableHLine(MIL_INT NbColumns); void CheckErrorEntries(MIL_ID StatRslt); void PrintConfusionMatrix(MIL_ID StatRslt, MIL_ID TestDataset); void PrintStatusMessage(MIL_INT Status); MIL_STRING ConvertPrepareDataStatusToStr(MIL_INT Status); void SetAugmentationControls(MIL_ID TrainCtx, bool* pIsDevDataset); void SetTrainControls(MIL_ID TrainCtx); MIL_UNIQUE_CLASS_ID TrainTheModel( MIL_ID MilSystem, MIL_ID MilDisplay, MIL_ID Dataset); //============================================================================== // Hook functions. //============================================================================== MIL_INT MFTYPE HookDatasetsPreparedFunc(MIL_INT /*HookType*/, MIL_ID EventId, void* pUserData); MIL_INT MFTYPE HookEpochFunc(MIL_INT /*HookType*/, MIL_ID EventId, void* pUserData); MIL_INT MFTYPE HookMiniBatchFunc(MIL_INT /*HookType*/, MIL_ID EventId, void* pUserData); MIL_INT MFTYPE HookNumPreparedEntriesFunc(MIL_INT /*HookType*/, MIL_ID EventId, void* pUserData); //============================================================================== // Main. //============================================================================== int MosMain() { PrintHeader(); MIL_UNIQUE_APP_ID MilApplication = MappAlloc(M_NULL, M_DEFAULT, M_UNIQUE_ID); MIL_UNIQUE_SYS_ID MilSystem = MsysAlloc(M_DEFAULT, M_SYSTEM_HOST, M_DEFAULT, M_DEFAULT, M_UNIQUE_ID); MIL_UNIQUE_DISP_ID MilDisplay = MdispAlloc(MilSystem, M_DEFAULT, MIL_TEXT(\"M_DEFAULT\"), M_DEFAULT, M_UNIQUE_ID); MosPrintf(MIL_TEXT(\"\\nTo skip the training and proceed directly to prediction press &lt;s&gt;.\\n\")); MosPrintf(MIL_TEXT(\"Press any key to continue.\\n\\n\")); char KeyVal = (char)MosGetch(); bool SkipTrain = false; switch(KeyVal) { case 'S': case 's': SkipTrain = true; MosPrintf(MIL_TEXT(\"Skipping the training.\\n\")); break; } if(!SkipTrain &amp;&amp; IsTrainingSupportedOnPlatform(MilSystem) != M_TRUE) { MosPrintf(MIL_TEXT(\"Press any key to end.\\n\")); MosGetch(); return EXIT_FAILURE; } MosPrintf(MIL_TEXT(\"\\n***************************************************************\\n\")); MosPrintf(MIL_TEXT(\"IMPORTING THE DATASETS...\")); MosPrintf(MIL_TEXT(\"\\n***************************************************************\\n\")); MIL_UNIQUE_CLASS_ID Dataset = MclassAlloc(MilSystem, M_DATASET_IMAGES, M_DEFAULT, M_UNIQUE_ID); MIL_UNIQUE_CLASS_ID TestDataset = MclassAlloc(MilSystem, M_DATASET_IMAGES, M_DEFAULT, M_UNIQUE_ID); LoadDatasets(MilSystem, Dataset, TestDataset, SkipTrain); MIL_UNIQUE_CLASS_ID TrainedCtx; if(SkipTrain) { MosPrintf(MIL_TEXT(\"\\n***************************************************************\\n\")); MosPrintf(MIL_TEXT(\"RESTORING A PRETRAINED CONTEXT...\")); MosPrintf(MIL_TEXT(\"\\n***************************************************************\\n\")); TrainedCtx = MclassRestore(EXAMPLE_PRETRAINED_PATH, MilSystem, M_DEFAULT, M_UNIQUE_ID); MosPrintf(MIL_TEXT(\"Successfully restored the trained context.\\n\\n\")); } else { MosPrintf(MIL_TEXT(\"\\n***************************************************************\\n\")); MosPrintf(MIL_TEXT(\"TRAINING... THIS WILL TAKE SOME TIME...\")); MosPrintf(MIL_TEXT(\"\\n***************************************************************\\n\")); TrainedCtx = TrainTheModel(MilSystem, MilDisplay, Dataset); } if(TrainedCtx) { MosPrintf(MIL_TEXT(\"\\n***************************************************************\\n\")); MosPrintf(MIL_TEXT(\"PREDICTING USING THE TRAINED CONTEXT...\")); MosPrintf(MIL_TEXT(\"\\n***************************************************************\\n\")); PredictUsingTrainedContext(MilSystem, MilDisplay, TrainedCtx, TestDataset); } else { MosPrintf(MIL_TEXT(\"\\nTraining has not completed properly!\\n\")); MosPrintf(MIL_TEXT(\"Press any key to end.\\n\")); MosGetch(); return EXIT_FAILURE; } return 0; } //============================================================================== CTrainEvolutionDashboard::CTrainEvolutionDashboard( MIL_ID MilSystem, MIL_ID TrainCtx, MIL_INT TrainImageSizeX, MIL_INT TrainImageSizeY, MIL_INT TrainEngineUsed, const MIL_STRING&amp; TrainEngineDescription) { MclassInquire(TrainCtx, M_DEFAULT, M_MAX_EPOCH + M_TYPE_MIL_INT, &amp;m_MaxEpoch); MIL_DOUBLE InitLearningRate {0.0}; MclassInquire(TrainCtx, M_DEFAULT, M_INITIAL_LEARNING_RATE + M_TYPE_MIL_DOUBLE, &amp;InitLearningRate); MIL_INT MiniBatchSize {0}; MclassInquire(TrainCtx, M_DEFAULT, M_MINI_BATCH_SIZE + M_TYPE_MIL_INT, &amp;MiniBatchSize); const MIL_INT GraphBoxWidth = GRAPH_SIZE_X + 2 * MARGIN; const MIL_INT GraphBoxHeight = GRAPH_SIZE_Y + GRAPH_TOP_MARGIN + MARGIN; m_DashboardWidth = GraphBoxWidth; const MIL_INT DashboardHeight = GraphBoxHeight + EPOCH_AND_MINIBATCH_REGION_HEIGHT + PROGRESSION_INFO_REGION_HEIGHT; m_DashboardBufId = MbufAllocColor(MilSystem, 3, m_DashboardWidth, DashboardHeight, 8 + M_UNSIGNED, M_IMAGE + M_PROC + M_DISP, M_UNIQUE_ID); MbufClear(m_DashboardBufId, M_COLOR_BLACK); m_TheGraContext = MgraAlloc(MilSystem, M_UNIQUE_ID); const MIL_INT GraphYPosition = EPOCH_AND_MINIBATCH_REGION_HEIGHT; const MIL_INT ProgressionInfoYPosition = GraphYPosition + GraphBoxHeight; m_LossInfoBufId = MbufChild2d(m_DashboardBufId, 0, 0, GraphBoxWidth, EPOCH_AND_MINIBATCH_REGION_HEIGHT, M_UNIQUE_ID); m_LossGraphBufId = MbufChild2d(m_DashboardBufId, 0, GraphYPosition, GraphBoxWidth, GraphBoxHeight, M_UNIQUE_ID); m_ProgressionInfoBufId = MbufChild2d(m_DashboardBufId, 0, ProgressionInfoYPosition, m_DashboardWidth, PROGRESSION_INFO_REGION_HEIGHT, M_UNIQUE_ID); DrawSectionSeparators(); InitializeLossGraph(); WriteGeneralTrainInfo(MiniBatchSize, TrainImageSizeX, TrainImageSizeY, InitLearningRate, TrainEngineUsed, TrainEngineDescription); } //============================================================================== CTrainEvolutionDashboard::~CTrainEvolutionDashboard() { m_TheGraContext = M_NULL; m_LossInfoBufId = M_NULL; m_LossGraphBufId = M_NULL; m_ProgressionInfoBufId = M_NULL; m_DashboardBufId = M_NULL; } //============================================================================== void CTrainEvolutionDashboard::AddEpochData(MIL_DOUBLE Loss, MIL_INT CurEpoch, MIL_DOUBLE EpochBenchMean) { m_EpochBenchMean = EpochBenchMean; UpdateDevLoss(Loss); UpdateDevLossGraph(Loss, CurEpoch); } //============================================================================== void CTrainEvolutionDashboard::AddMiniBatchData( MIL_DOUBLE Loss, MIL_INT MinibatchIdx, MIL_INT EpochIdx, MIL_INT NbBatchPerEpoch) { UpdateTrainLoss(Loss); UpdateTrainLossGraph(Loss, MinibatchIdx, EpochIdx, NbBatchPerEpoch); UpdateProgression(MinibatchIdx, EpochIdx, NbBatchPerEpoch); } //============================================================================== void CTrainEvolutionDashboard::UpdateTrainLoss(MIL_DOUBLE Loss) { const MIL_INT TextMargin = MARGIN - 10; MgraControl(m_TheGraContext, M_COLOR, COLOR_TRAIN_SET_INFO); MIL_TEXT_CHAR LossText[512]; MosSprintf(LossText, 512, MIL_TEXT(\"Current train loss value: %11.7lf\"), Loss); MgraText(m_TheGraContext, m_LossInfoBufId, TextMargin, m_YPositionForTrainLossText, LossText); } //============================================================================== void CTrainEvolutionDashboard::UpdateDevLoss(MIL_DOUBLE Loss) { const MIL_INT TextMargin = MARGIN - 10; MgraControl(m_TheGraContext, M_COLOR, COLOR_DEV_SET_INFO); MIL_TEXT_CHAR LossText[512]; MosSprintf(LossText, 512, MIL_TEXT(\"Current dev loss value: %11.7lf\"), Loss); MgraText(m_TheGraContext, m_LossInfoBufId, TextMargin, m_YPositionForDevLossText, LossText); } //============================================================================== void CTrainEvolutionDashboard::UpdateTrainLossGraph( MIL_DOUBLE Loss, MIL_INT MiniBatchIdx, MIL_INT EpochIdx, MIL_INT NbBatchPerEpoch) { const MIL_INT NbMiniBatch = m_MaxEpoch * NbBatchPerEpoch; const MIL_INT CurMiniBatch = EpochIdx * NbBatchPerEpoch + MiniBatchIdx; const MIL_DOUBLE XRatio = static_cast&lt;MIL_DOUBLE&gt;(CurMiniBatch) / static_cast&lt;MIL_DOUBLE&gt;(NbMiniBatch); const MIL_INT CurTrainMBPosX = MARGIN + static_cast&lt;MIL_INT&gt;(XRatio * static_cast&lt;MIL_DOUBLE&gt;(GRAPH_SIZE_X)); const MIL_DOUBLE MaxVal = std::pow(10.0, LOSS_EXPONENT_MAX); const MIL_INT NbTick = LOSS_EXPONENT_MAX - LOSS_EXPONENT_MIN; // Saturate to the highest value of the graph. Loss = std::min&lt;MIL_DOUBLE&gt;(Loss, MaxVal); const MIL_DOUBLE Log10RemapPos = std::max&lt;MIL_DOUBLE&gt;(log10(Loss) + (-LOSS_EXPONENT_MIN), 0.0); const MIL_DOUBLE YRatio = Log10RemapPos / static_cast&lt;MIL_DOUBLE&gt;(NbTick); const MIL_INT CurTrainMBPosY = GRAPH_TOP_MARGIN + static_cast&lt;MIL_INT&gt;((1.0 - YRatio) * static_cast&lt;MIL_DOUBLE&gt;(GRAPH_SIZE_Y)); if(EpochIdx == 0 &amp;&amp; MiniBatchIdx == 0) { MgraControl(m_TheGraContext, M_COLOR, COLOR_TRAIN_SET_INFO); MgraDot(m_TheGraContext, m_LossGraphBufId, CurTrainMBPosX, CurTrainMBPosY); } else { MgraControl(m_TheGraContext, M_COLOR, COLOR_TRAIN_SET_INFO); MgraLine(m_TheGraContext, m_LossGraphBufId, m_LastTrainMinibatchPosX, m_LastTrainMinibatchPosY, CurTrainMBPosX, CurTrainMBPosY); } m_LastTrainMinibatchPosX = CurTrainMBPosX; m_LastTrainMinibatchPosY = CurTrainMBPosY; MgraControl(m_TheGraContext, M_COLOR, COLOR_GENERAL_INFO); // To clear the previous information. MgraText(m_TheGraContext, m_LossGraphBufId, MARGIN, GRAPH_TOP_MARGIN + GRAPH_SIZE_Y + 25, MIL_TEXT(\" \")); MIL_TEXT_CHAR EpochText[512]; MosSprintf(EpochText, 512, MIL_TEXT(\"Epoch %d :: Minibatch %d\"), EpochIdx, MiniBatchIdx); MgraText(m_TheGraContext, m_LossGraphBufId, MARGIN, GRAPH_TOP_MARGIN + GRAPH_SIZE_Y + 25, EpochText); } //============================================================================== void CTrainEvolutionDashboard::UpdateDevLossGraph(MIL_DOUBLE Loss, MIL_INT EpochIdx) { const MIL_DOUBLE XRatio = static_cast&lt;MIL_DOUBLE&gt;(EpochIdx + 1) / static_cast&lt;MIL_DOUBLE&gt;(m_MaxEpoch); const MIL_INT CurTrainMBPosX = MARGIN + static_cast&lt;MIL_INT&gt;(XRatio * static_cast&lt;MIL_DOUBLE&gt;(GRAPH_SIZE_X)); const MIL_DOUBLE MaxVal = std::pow(10.0, LOSS_EXPONENT_MAX); const MIL_INT NbTick = LOSS_EXPONENT_MAX - LOSS_EXPONENT_MIN; // Saturate to the highest value of the graph. Loss = std::min&lt;MIL_DOUBLE&gt;(Loss, MaxVal); const MIL_DOUBLE Log10RemapPos = std::max&lt;MIL_DOUBLE&gt;(log10(Loss) + (-LOSS_EXPONENT_MIN), 0.0); const MIL_DOUBLE YRatio = Log10RemapPos / static_cast&lt;MIL_DOUBLE&gt;(NbTick); const MIL_INT CurTrainMBPosY = GRAPH_TOP_MARGIN + static_cast&lt;MIL_INT&gt;((1.0 - YRatio) * static_cast&lt;MIL_DOUBLE&gt;(GRAPH_SIZE_Y)); if(EpochIdx == 0) { MgraControl(m_TheGraContext, M_COLOR, COLOR_DEV_SET_INFO); MgraDot(m_TheGraContext, m_LossGraphBufId, CurTrainMBPosX, CurTrainMBPosY); } else { MgraControl(m_TheGraContext, M_COLOR, COLOR_DEV_SET_INFO); MgraLine(m_TheGraContext, m_LossGraphBufId, m_LastDevEpochLossPosX, m_LastDevEpochLossPosY, CurTrainMBPosX, CurTrainMBPosY); } m_LastDevEpochLossPosX = CurTrainMBPosX; m_LastDevEpochLossPosY = CurTrainMBPosY; } //============================================================================== void CTrainEvolutionDashboard::UpdateProgression(MIL_INT MinibatchIdx, MIL_INT EpochIdx, MIL_INT NbBatchPerEpoch) { const MIL_INT YMargin = 20; const MIL_INT TextHeight = 30; const MIL_INT NbMinibatch = m_MaxEpoch * NbBatchPerEpoch; const MIL_INT NbMinibatchDone = EpochIdx * NbBatchPerEpoch + MinibatchIdx + 1; const MIL_INT NbMinibatchRemaining = NbMinibatch - NbMinibatchDone - 1; // Update estimated remaining time. MgraControl(m_TheGraContext, M_COLOR, COLOR_GENERAL_INFO); // The first epoch includes data loading and cannot be used to estimate the // remaining time accurately. if(EpochIdx == 0) { MgraText(m_TheGraContext, m_ProgressionInfoBufId, MARGIN, YMargin, MIL_TEXT(\"Estimated remaining time: N/A\")); } else { const MIL_DOUBLE MinibatchBenchMean = m_EpochBenchMean / static_cast&lt;MIL_DOUBLE&gt;(NbBatchPerEpoch); const MIL_DOUBLE RemainingTime = MinibatchBenchMean * static_cast&lt;MIL_DOUBLE&gt;(NbMinibatchRemaining); MIL_TEXT_CHAR RemainingTimeText[512]; MosSprintf(RemainingTimeText, 512, MIL_TEXT(\"Estimated remaining time: %8.0lf seconds\"), RemainingTime); if(NbMinibatchDone == NbMinibatch) { MgraText(m_TheGraContext, m_ProgressionInfoBufId, MARGIN, YMargin, MIL_TEXT(\"Training completed! \")); } else { MgraText(m_TheGraContext, m_ProgressionInfoBufId, MARGIN, YMargin, RemainingTimeText); } } // Update the progression bar. const MIL_INT ProgressionBarWidth = m_DashboardWidth - 2 * MARGIN; const MIL_INT ProgressionBarHeight = 30; MgraControl(m_TheGraContext, M_COLOR, COLOR_GENERAL_INFO); MgraRectFill(m_TheGraContext, m_ProgressionInfoBufId, MARGIN, YMargin + TextHeight, MARGIN + ProgressionBarWidth, YMargin + TextHeight + ProgressionBarHeight); const MIL_DOUBLE PercentageComplete = static_cast&lt;MIL_DOUBLE&gt;(NbMinibatchDone) / static_cast&lt;MIL_DOUBLE&gt;(NbMinibatch); const MIL_INT PercentageCompleteWidth = static_cast&lt;MIL_INT&gt;(PercentageComplete * ProgressionBarWidth); MgraControl(m_TheGraContext, M_COLOR, COLOR_PROGRESS_BAR); MgraRectFill(m_TheGraContext, m_ProgressionInfoBufId, MARGIN, YMargin + TextHeight, MARGIN + PercentageCompleteWidth, YMargin + TextHeight + ProgressionBarHeight); } //============================================================================== void CTrainEvolutionDashboard::DrawSectionSeparators() { // Draw a frame for the whole dashboard. DrawBufferFrame(m_DashboardBufId, 4); // Draw a frame for each section. DrawBufferFrame(m_LossInfoBufId, 2); DrawBufferFrame(m_LossGraphBufId, 2); DrawBufferFrame(m_ProgressionInfoBufId, 2); } //============================================================================== void CTrainEvolutionDashboard::DrawBufferFrame(MIL_ID BufId, MIL_INT FrameThickness) { const MIL_ID SizeX = MbufInquire(BufId, M_SIZE_X, M_NULL); const MIL_ID SizeY = MbufInquire(BufId, M_SIZE_Y, M_NULL); MgraControl(m_TheGraContext, M_COLOR, COLOR_GENERAL_INFO); MgraRectFill(m_TheGraContext, BufId, 0, 0, SizeX - 1, FrameThickness - 1); MgraRectFill(m_TheGraContext, BufId, SizeX - FrameThickness, 0, SizeX - 1, SizeY - 1); MgraRectFill(m_TheGraContext, BufId, 0, SizeY - FrameThickness, SizeX - 1, SizeY - 1); MgraRectFill(m_TheGraContext, BufId, 0, 0, FrameThickness - 1, SizeY - 1); } //============================================================================== void CTrainEvolutionDashboard::InitializeLossGraph() { // Draw axis. MgraControl(m_TheGraContext, M_COLOR, M_COLOR_WHITE); MgraRect(m_TheGraContext, m_LossGraphBufId, MARGIN, GRAPH_TOP_MARGIN, MARGIN + GRAPH_SIZE_X, GRAPH_TOP_MARGIN + GRAPH_SIZE_Y); MgraControl(m_TheGraContext, M_TEXT_ALIGN_HORIZONTAL, M_RIGHT); const MIL_INT NbLossValueTick = LOSS_EXPONENT_MAX - LOSS_EXPONENT_MIN; const MIL_DOUBLE TickRatio = 1.0 / static_cast&lt;MIL_DOUBLE&gt;(NbLossValueTick); MIL_DOUBLE TickNum = 0.0; for(MIL_INT i = LOSS_EXPONENT_MAX; i &gt;= LOSS_EXPONENT_MIN; i--) { MIL_TEXT_CHAR CurTickText[128]; MosSprintf(CurTickText, 128, MIL_TEXT(\"1e%d\"), i); const MIL_INT TickYPos = static_cast&lt;MIL_INT&gt;(TickNum * TickRatio * GRAPH_SIZE_Y); MgraText(m_TheGraContext, m_LossGraphBufId, MARGIN - 5, GRAPH_TOP_MARGIN + TickYPos, CurTickText); if((i != LOSS_EXPONENT_MAX) &amp;&amp; (i != LOSS_EXPONENT_MIN)) { MgraLine(m_TheGraContext, m_LossGraphBufId, MARGIN, GRAPH_TOP_MARGIN + TickYPos, MARGIN + 5, GRAPH_TOP_MARGIN + TickYPos); } TickNum = TickNum + 1.0; } MgraControl(m_TheGraContext, M_TEXT_ALIGN_HORIZONTAL, M_LEFT); const MIL_INT NbEpochTick = std::min&lt;MIL_INT&gt;(m_MaxEpoch, 10); const MIL_INT EpochTickValue = m_MaxEpoch / NbEpochTick; for(MIL_INT CurTick = 1; CurTick &lt;= m_MaxEpoch; CurTick += EpochTickValue) { const MIL_DOUBLE Percentage = static_cast&lt;MIL_DOUBLE&gt;(CurTick) / static_cast&lt;MIL_DOUBLE&gt;(m_MaxEpoch); const MIL_INT XOffset = static_cast&lt;MIL_INT&gt;(Percentage * GRAPH_SIZE_X); MgraText(m_TheGraContext, m_LossGraphBufId, MARGIN + XOffset, GRAPH_TOP_MARGIN + GRAPH_SIZE_Y + 5, M_TO_STRING(CurTick - 1)); MgraLine(m_TheGraContext, m_LossGraphBufId, MARGIN + XOffset, GRAPH_TOP_MARGIN + GRAPH_SIZE_Y - 5, MARGIN + XOffset, GRAPH_TOP_MARGIN + GRAPH_SIZE_Y); } } //============================================================================== void CTrainEvolutionDashboard::WriteGeneralTrainInfo( MIL_INT MinibatchSize, MIL_INT TrainImageSizeX, MIL_INT TrainImageSizeY, MIL_DOUBLE LearningRate, MIL_INT TrainEngineUsed, const MIL_STRING&amp; TrainEngineDescription) { MgraControl(m_TheGraContext, M_BACKGROUND_MODE, M_OPAQUE); MgraControl(m_TheGraContext, M_BACKCOLOR, M_COLOR_BLACK); MgraControl(m_TheGraContext, M_TEXT_ALIGN_HORIZONTAL, M_LEFT); const MIL_INT YMargin = 15; const MIL_INT TextHeight = 20; const MIL_INT TextMargin = MARGIN - 10; MIL_INT TextYPos = YMargin; MgraControl(m_TheGraContext, M_COLOR, COLOR_GENERAL_INFO); MIL_TEXT_CHAR TheString[512]; if(TrainEngineUsed == M_CPU) { MosSprintf(TheString, 512, MIL_TEXT(\"Training is being performed on the CPU\")); } else { MosSprintf(TheString, 512, MIL_TEXT(\"Training is being performed on the GPU\")); } MgraText(m_TheGraContext, m_LossInfoBufId, TextMargin, TextYPos, TheString); TextYPos += TextHeight; MosSprintf(TheString, 512, MIL_TEXT(\"Engine: %s\"), TrainEngineDescription.c_str()); MgraText(m_TheGraContext, m_LossInfoBufId, TextMargin, TextYPos, TheString); TextYPos += TextHeight; MosSprintf(TheString, 512, MIL_TEXT(\"Train image size: %dx%d\"), TrainImageSizeX, TrainImageSizeY); MgraText(m_TheGraContext, m_LossInfoBufId, TextMargin, TextYPos, TheString); TextYPos += TextHeight; MosSprintf(TheString, 512, MIL_TEXT(\"Max number of epochs: %d\"), m_MaxEpoch); MgraText(m_TheGraContext, m_LossInfoBufId, TextMargin, TextYPos, TheString); TextYPos += TextHeight; MosSprintf(TheString, 512, MIL_TEXT(\"Minibatch size: %d\"), MinibatchSize); MgraText(m_TheGraContext, m_LossInfoBufId, TextMargin, TextYPos, TheString); TextYPos += TextHeight; MosSprintf(TheString, 512, MIL_TEXT(\"Learning rate: %.2e\"), LearningRate); MgraText(m_TheGraContext, m_LossInfoBufId, TextMargin, TextYPos, TheString); TextYPos += TextHeight; // The loss will be drawn under later on, so we retain its position. m_YPositionForTrainLossText = TextYPos; TextYPos += TextHeight; m_YPositionForDevLossText = TextYPos; } //============================================================================== CDatasetViewer::CDatasetViewer(MIL_ID MilSystem, MIL_ID Dataset, MIL_ID StatCtx, MIL_ID StatRslt, bool DisplayGroundTruth) : m_System(MilSystem) , m_Dataset(Dataset) , m_DisplayGroundTruth(DisplayGroundTruth) , m_StatCtx(StatCtx) , m_StatRslt(StatRslt) { // Get the number of classes and the number of entries in total. MclassInquire(m_Dataset, M_DEFAULT, M_NUMBER_OF_CLASSES + M_TYPE_MIL_INT, &amp;m_NbClasses); MclassInquire(m_Dataset, M_DEFAULT, M_NUMBER_OF_ENTRIES + M_TYPE_MIL_INT, &amp;m_NbEntries); // Get the size of the image. GetImageSizes(m_System, m_Dataset, &amp;m_ImageSizeX, &amp;m_ImageSizeY); // Allocate a display for the dataset and the reference icons. m_Display = MdispAlloc(m_System, M_DEFAULT, MIL_TEXT(\"M_DEFAULT\"), M_DEFAULT, M_UNIQUE_ID); // Allocate and select display buffers. m_IconSize = m_ImageSizeY / m_NbClasses; m_DisplayBuffer = MbufAllocColor(m_System, 3, m_ImageSizeX + m_IconSize, m_ImageSizeY, 8 + M_UNSIGNED, M_IMAGE + M_PROC + M_DISP, M_UNIQUE_ID); m_DisplayTarget = MbufChild2d(m_DisplayBuffer, 0, 0, m_ImageSizeX, m_ImageSizeY, M_UNIQUE_ID); MbufClear(m_DisplayBuffer, M_COLOR_BLACK); MdispSelect(m_Display, m_DisplayBuffer); m_MilOverlay = MdispInquire(m_Display, M_OVERLAY_ID, M_NULL); // For bounding boxes and texts. m_DisGraList = MgraAllocList(m_System, M_DEFAULT, M_UNIQUE_ID); MdispControl(m_Display, M_ASSOCIATED_GRAPHIC_LIST_ID, m_DisGraList); // Allocate and set graphic contexts for draws and texts. m_GraDrawCtx = MgraAlloc(m_System, M_UNIQUE_ID); m_GraTextCtx = MgraAlloc(m_System, M_UNIQUE_ID); MgraControl(m_GraTextCtx, M_COLOR, M_COLOR_WHITE); ProcessIncorrectPredictions(); // Draw the reference icons of classes. DrawOverlayIcons(); // View the dataset with controls. ViewDataset(); } //============================================================================== CDatasetViewer::CDatasetViewer(MIL_ID MilSystem, MIL_ID Dataset, bool DisplayGroundTruth) : CDatasetViewer(MilSystem, Dataset, M_NULL, M_NULL, DisplayGroundTruth) {} //============================================================================== void CDatasetViewer::PrintControls() const { MosPrintf(MIL_TEXT(\"Here are the dataset viewer controls:\\n\")); MosPrintf(MIL_TEXT(\"n: Display next image\\n\")); MosPrintf(MIL_TEXT(\"p: Display previous image\\n\")); MosPrintf(MIL_TEXT(\"t: Toggle between the GT overlay and the prediction overlay\\n\")); MosPrintf(MIL_TEXT(\"f: Toggle between all entries and entries with incorrect predictions only\\n\")); MosPrintf(MIL_TEXT(\"e: Exit\\n\\n\")); MosPrintf(MIL_TEXT(\"Select a dataset viewer control:\\n\")); } //============================================================================== void CDatasetViewer::ViewDataset() { m_EntryIndex = 0; m_EntryKey = M_DEFAULT_KEY; m_NbViewEntries = m_NbEntries; m_IncorrectPredictionIndex = GetIncorrectPredictionIndex(); PrintControls(); bool Exit {false}; while(!Exit) { // Disable display refreshing until all draws are complete. MdispControl(m_Display, M_UPDATE, M_DISABLE); if(m_NbViewEntries) { // Load the current entry into the display buffer. MIL_STRING EntryImagePath; MclassInquireEntry(m_Dataset, m_EntryIndex, m_EntryKey, M_DEFAULT, M_ENTRY_IMAGE_PATH_ABS, EntryImagePath); MbufLoad(EntryImagePath, m_DisplayTarget); } else { // Draw a black image. MbufClear(m_DisplayTarget, M_COLOR_BLACK); } // Remove opacity. MdispControl(m_Display, M_OVERLAY_OPACITY, 0.0); // Reset overlay and graphic list for updated draws. MbufClear(m_MilOverlay, 0); MgraClear(M_DEFAULT, m_DisGraList); // Draw the image with bounding boxes and the texts. DrawOverlayImage(); DrawOverlayTexts(); // Refresh display. MdispControl(m_Display, M_UPDATE, M_ENABLE); // Process user key input. Exit = ProcessUserInputControl(); } } //============================================================================== void CDatasetViewer::ProcessIncorrectPredictions() { // If stat result buffer is passed, show the failed detections if there are any. if(m_StatRslt != M_NULL) { // List the entries with errors. std::set&lt;MIL_UUID&gt; MismatchEntries, MissedEntries, FDEntries; std::vector&lt;MIL_UUID&gt; EntriesElement; for(MIL_INT GtIndex = 0; GtIndex &lt; m_NbClasses + 1; GtIndex++) { for(MIL_INT PredIndex = 0; PredIndex &lt; m_NbClasses + 1; PredIndex++) { if(GtIndex != PredIndex) { // Check for missed detections. if(PredIndex == m_NbClasses) { MclassGetResultStat(m_StatRslt, M_CLASS_INDEX(GtIndex), M_NO_CLASS, M_DEFAULT, M_CONFUSION_MATRIX_USED_ENTRIES_ELEMENT, EntriesElement); MissedEntries.insert(EntriesElement.cbegin(), EntriesElement.cend()); } // Check for false detections. else if(GtIndex == m_NbClasses) { MclassGetResultStat(m_StatRslt, M_NO_CLASS, M_CLASS_INDEX(PredIndex), M_DEFAULT, M_CONFUSION_MATRIX_USED_ENTRIES_ELEMENT, EntriesElement); FDEntries.insert(EntriesElement.cbegin(), EntriesElement.cend()); } // Check for class mismatches. else { MclassGetResultStat(m_StatRslt, M_CLASS_INDEX(GtIndex), M_CLASS_INDEX(PredIndex), M_DEFAULT, M_CONFUSION_MATRIX_USED_ENTRIES_ELEMENT, EntriesElement); MismatchEntries.insert(EntriesElement.cbegin(), EntriesElement.cend()); } } } } // Print the number of entries that failed based on error type. std::set&lt;MIL_UUID&gt; FailedEntries; if(!MismatchEntries.empty()) { MIL_INT NbMismatchEntries = (MIL_INT)MismatchEntries.size(); MosPrintf(MIL_TEXT(\"%d entries have class mismatches\\n\"), NbMismatchEntries); FailedEntries.insert(MismatchEntries.cbegin(), MismatchEntries.cend()); } if(!FDEntries.empty()) { MIL_INT NbFDEntries = (MIL_INT)FDEntries.size(); MosPrintf(MIL_TEXT(\"%d entries have false detections\\n\"), NbFDEntries); FailedEntries.insert(FDEntries.cbegin(), FDEntries.cend()); } if(!MissedEntries.empty()) { MIL_INT NbMissedEntries = (MIL_INT)MissedEntries.size(); MosPrintf(MIL_TEXT(\"%d entries have missed detections\\n\"), NbMissedEntries); FailedEntries.insert(MissedEntries.cbegin(), MissedEntries.cend()); } // Allocate and set a graphic context for false/missed detection only if there is at least one entry with a false/missed detection. if(!FDEntries.empty() || !MissedEntries.empty()) { m_GraCtxIncorrectPredictions = MgraAlloc(m_System, M_UNIQUE_ID); MgraControl(m_GraCtxIncorrectPredictions, M_LINE_THICKNESS, 3.0); MosPrintf(MIL_TEXT(\"Any false or missed detection is highlighted with a white border.\\n\")); } if(!FailedEntries.empty()) { // Reduce the score threshold step to speed up stat calculation per entry. const MIL_DOUBLE PER_ENTRY_SCORE_THRESHOLD_STEP {50.0}; MclassControl(m_StatCtx, M_CONTEXT, M_SCORE_THRESHOLD_STEP, PER_ENTRY_SCORE_THRESHOLD_STEP); MclassPreprocess(m_StatCtx, M_DEFAULT); } // Collect incorrect prediction info per entry. for(MIL_UUID EntryKey : FailedEntries) { SIncorrectPredictionInfo EntryInfo; EntryInfo.m_EntryKey = EntryKey; // Get matched regions and instances in that specific entry. MclassStatCalculate(m_StatCtx, m_Dataset, M_DEFAULT, EntryKey, m_StatRslt, M_DEFAULT); MclassGetResultStat(m_StatRslt, M_GENERAL, M_GENERAL, M_DEFAULT, M_STATUS + M_TYPE_MIL_INT, &amp;EntryInfo.m_Status); if(EntryInfo.m_Status == M_COMPLETE) { MclassGetResultStat(m_StatRslt, M_GENERAL, M_GENERAL, M_DEFAULT, M_NUMBER_OF_REGIONS + M_TYPE_MIL_INT, &amp;EntryInfo.m_NbRegions); MclassGetResultStat(m_StatRslt, M_GENERAL, M_GENERAL, M_DEFAULT, M_NUMBER_OF_INSTANCES + M_TYPE_MIL_INT, &amp;EntryInfo.m_NbInstances); MclassGetResultStat(m_StatRslt, M_ALL_INSTANCES, M_GENERAL, M_DEFAULT, M_MATCHED_REGION, EntryInfo.m_MatchedRegionIndexes); MclassGetResultStat(m_StatRslt, M_ALL_REGIONS, M_GENERAL, M_DEFAULT, M_MATCHED_INSTANCE, EntryInfo.m_MatchedInstanceIndexes); // Get the number of class mismatches. if(MismatchEntries.find(EntryKey) != MismatchEntries.cend()) { // List the entries with class mismatches, missed detections and false detections. for(MIL_INT GtIndex = 0; GtIndex &lt; m_NbClasses; GtIndex++) { for(MIL_INT PredIndex = 0; PredIndex &lt; m_NbClasses; PredIndex++) { if(GtIndex != PredIndex) { MIL_INT Element {}; MclassGetResultStat(m_StatRslt, M_CLASS_INDEX(GtIndex), M_CLASS_INDEX(PredIndex), M_DEFAULT, M_CONFUSION_MATRIX_ELEMENT, &amp;Element); EntryInfo.m_NbClassMismatch += Element; } } } } // Get the number of missing detections. if(MissedEntries.find(EntryKey) != MissedEntries.cend()) { EntryInfo.m_NbMissedDetection = std::count(EntryInfo.m_MatchedInstanceIndexes.cbegin(), EntryInfo.m_MatchedInstanceIndexes.cend(), M_INVALID); } // Get the number of false detections. if(FDEntries.find(EntryKey) != FDEntries.cend()) { EntryInfo.m_NbFalseDetection = std::count(EntryInfo.m_MatchedRegionIndexes.cbegin(), EntryInfo.m_MatchedRegionIndexes.cend(), M_INVALID); } } else { PrintStatusMessage(EntryInfo.m_Status); } m_IncorrectPredictions.push_back(EntryInfo); } if(!m_IncorrectPredictions.empty()) { MosPrintf(MIL_TEXT(\"\\n\")); } } } //============================================================================== void CDatasetViewer::DrawOverlayIcons() const { // Set up the display. for(MIL_INT ClassIndex = 0; ClassIndex &lt; m_NbClasses; ClassIndex++) { // Allocate a child buffer per product category. MIL_UNIQUE_BUF_ID MilChildSample = MbufChild2d(m_DisplayBuffer, m_ImageSizeX, ClassIndex * m_IconSize, m_IconSize, m_IconSize, M_UNIQUE_ID); MIL_UNIQUE_BUF_ID MilOverlayChildSample = MbufChild2d(m_MilOverlay, m_ImageSizeX, ClassIndex * m_IconSize, m_IconSize, m_IconSize, M_UNIQUE_ID); MbufClear(MilChildSample, M_COLOR_BLACK); MbufClear(MilOverlayChildSample, M_COLOR_BLACK); // Load the sample image. MIL_ID ClassIconId = MclassInquire(m_Dataset, M_CLASS_INDEX(ClassIndex), M_CLASS_ICON_ID + M_TYPE_MIL_ID, M_NULL); // Retrieve the class description. MIL_STRING Text; MclassInquire(m_Dataset, M_CLASS_INDEX(ClassIndex), M_CLASS_NAME, Text); if(ClassIconId != M_NULL) { // Retrieve the color associated to the class. MIL_DOUBLE ClassColor {}; MclassInquire(m_Dataset, M_CLASS_INDEX(ClassIndex), M_CLASS_DRAW_COLOR, &amp;ClassColor); // Draw the class name using the color associated to the class. MgraControl(M_DEFAULT, M_COLOR, ClassColor); MgraText(M_DEFAULT, MilChildSample, 10, 10, Text); MgraText(M_DEFAULT, MilOverlayChildSample, 10, 10, Text); const MIL_INT ClassImageExampleSizeX = MbufInquire(ClassIconId, M_SIZE_X, M_NULL); const MIL_INT ClassImageExampleSizeY = MbufInquire(ClassIconId, M_SIZE_Y, M_NULL); if((ClassImageExampleSizeX &gt;= m_IconSize) || (ClassImageExampleSizeY &gt;= m_IconSize)) { MimResize(ClassIconId, MilChildSample, M_FILL_DESTINATION, M_FILL_DESTINATION, M_AVERAGE); MimResize(ClassIconId, MilOverlayChildSample, M_FILL_DESTINATION, M_FILL_DESTINATION, M_AVERAGE); } else { const MIL_INT OffsetX = (m_IconSize - ClassImageExampleSizeX) / 2; const MIL_INT OffsetY = (m_IconSize - ClassImageExampleSizeY) / 2; MbufCopyColor2d(ClassIconId, MilChildSample, M_ALL_BANDS, 0, 0, M_ALL_BANDS, OffsetX, OffsetY, ClassImageExampleSizeX, ClassImageExampleSizeY); MbufCopyColor2d(ClassIconId, MilOverlayChildSample, M_ALL_BANDS, 0, 0, M_ALL_BANDS, OffsetX, OffsetY, ClassImageExampleSizeX, ClassImageExampleSizeY); } } // Draw an initial red rectangle around the buffer. MgraRect(M_DEFAULT, MilChildSample, 0, 1, m_IconSize - 1, m_IconSize - 2); MgraRect(M_DEFAULT, MilOverlayChildSample, 0, 1, m_IconSize - 1, m_IconSize - 2); } } //============================================================================== void CDatasetViewer::DrawOverlayImage() { if(m_NbViewEntries) { // Draw the desired overlay. if(m_DisplayGroundTruth) { if(m_IncorrectPredictionIndex != M_INVALID) { // Draw all the missed detections in that entry. DrawMissedDetection(m_IncorrectPredictions[m_IncorrectPredictionIndex]); } const MIL_INT NumGTs = GetNumberOfGTs(); MclassDrawEntry(M_DEFAULT, m_Dataset, m_DisGraList, M_DESCRIPTOR_TYPE_BOX + M_PSEUDO_COLOR, m_EntryIndex, m_EntryKey, M_OBJECT_DETECTION, M_DEFAULT, M_NULL, M_DEFAULT); m_OverlayText = MIL_TEXT(\"Ground truth overlay, there are \") + M_TO_STRING(NumGTs) + MIL_TEXT(\" GTs\"); } else { MIL_INT PredictInfo {M_FALSE}; MclassGetResultEntry(m_Dataset, m_EntryIndex, m_EntryKey, M_OBJECT_DETECTION, M_DEFAULT, M_PREDICT_INFO + M_TYPE_MIL_INT, &amp;PredictInfo); if(PredictInfo == M_TRUE) { if(m_IncorrectPredictionIndex != M_INVALID) { // Draw all the false detections in that entry. DrawFalseDetection(m_IncorrectPredictions[m_IncorrectPredictionIndex]); } MIL_INT NumInstances {0}; MclassGetResultEntry(m_Dataset, m_EntryIndex, m_EntryKey, M_OBJECT_DETECTION, M_DEFAULT, M_NUMBER_OF_INSTANCES + M_TYPE_MIL_INT, &amp;NumInstances); MclassDrawEntry(m_GraDrawCtx, m_Dataset, m_DisGraList, M_DRAW_BOX + M_DRAW_BOX_NAME + M_DRAW_BOX_SCORE, m_EntryIndex, m_EntryKey, M_OBJECT_DETECTION, M_DEFAULT, M_NULL, M_DEFAULT); m_OverlayText = M_TO_STRING(NumInstances) + MIL_TEXT(\" instance(s) found\"); } else { m_OverlayText = MIL_TEXT(\"No prediction to display\"); } } } } //============================================================================== void CDatasetViewer::DrawOverlayTexts() { const MIL_INT Y_MARGIN {15}; const MIL_INT TEXT_HEIGHT {20}; const MIL_INT TEXT_MARGIN {20}; MIL_STRING IndexText; if(m_NbViewEntries) { std::vector&lt;MIL_INT&gt; GraTextLabels; MIL_INT TextYPos = Y_MARGIN; IndexText = (m_DisplayIncorrectPredictionsOnly ? MIL_TEXT(\"Incorrect Prediction \") : MIL_TEXT(\"Entry Index \")) + M_TO_STRING(m_DisplayIncorrectPredictionsOnly ? m_IncorrectPredictionIndex : m_EntryIndex) + MIL_TEXT(\" / \") + M_TO_STRING(m_NbViewEntries - 1); MgraText(m_GraTextCtx, m_DisGraList, TEXT_MARGIN, TextYPos, IndexText); GraTextLabels.push_back(MgraInquireList(m_DisGraList, M_LIST, M_DEFAULT, M_LAST_LABEL, M_NULL)); TextYPos += TEXT_HEIGHT; MgraText(m_GraTextCtx, m_DisGraList, TEXT_MARGIN, TextYPos, m_OverlayText); GraTextLabels.push_back(MgraInquireList(m_DisGraList, M_LIST, M_DEFAULT, M_LAST_LABEL, M_NULL)); if(m_StatCtx != M_NULL &amp;&amp; m_StatRslt != M_NULL) { // Get the number of incorrect predictions. MIL_INT NbClassMismatch = 0; MIL_INT NbFalseDetection = 0; MIL_INT NbMissingDetection = 0; if(m_IncorrectPredictionIndex != M_INVALID) { NbClassMismatch = m_IncorrectPredictions[m_IncorrectPredictionIndex].m_NbClassMismatch; NbFalseDetection = m_IncorrectPredictions[m_IncorrectPredictionIndex].m_NbFalseDetection; NbMissingDetection = m_IncorrectPredictions[m_IncorrectPredictionIndex].m_NbMissedDetection; } // Show the number of incorrect predictions. MIL_STRING ClassMismatchText = MIL_TEXT(\"Class mismatch: \") + M_TO_STRING(NbClassMismatch); TextYPos += TEXT_HEIGHT; MgraText(m_GraTextCtx, m_DisGraList, TEXT_MARGIN, TextYPos, ClassMismatchText); GraTextLabels.push_back(MgraInquireList(m_DisGraList, M_LIST, M_DEFAULT, M_LAST_LABEL, M_NULL)); MIL_STRING FalseDetectionText = MIL_TEXT(\"False detection: \") + M_TO_STRING(NbFalseDetection); TextYPos += TEXT_HEIGHT; MgraText(m_GraTextCtx, m_DisGraList, TEXT_MARGIN, TextYPos, FalseDetectionText); GraTextLabels.push_back(MgraInquireList(m_DisGraList, M_LIST, M_DEFAULT, M_LAST_LABEL, M_NULL)); MIL_STRING MissingDetectionText = MIL_TEXT(\"Missing detection: \") + M_TO_STRING(NbMissingDetection); TextYPos += TEXT_HEIGHT; MgraText(m_GraTextCtx, m_DisGraList, TEXT_MARGIN, TextYPos, MissingDetectionText); GraTextLabels.push_back(MgraInquireList(m_DisGraList, M_LIST, M_DEFAULT, M_LAST_LABEL, M_NULL)); } // Change the graphic list input units to display units so that zooming // in and out won't change the size and location of the text. for(MIL_INT GraLabel : GraTextLabels) { MgraControlList(m_DisGraList, M_GRAPHIC_LABEL(GraLabel), M_DEFAULT, M_INPUT_UNITS, M_DISPLAY); } } else if(m_DisplayIncorrectPredictionsOnly) { IndexText = MIL_TEXT(\"No incorrect predictions!\"); MgraText(m_GraTextCtx, m_DisGraList, TEXT_MARGIN, Y_MARGIN, IndexText); MgraControlList(m_DisGraList, M_ALL, M_DEFAULT, M_INPUT_UNITS, M_DISPLAY); } } //============================================================================== void CDatasetViewer::DrawFalseDetection(const SIncorrectPredictionInfo&amp; IncorrectEntryInfo) const { // Highlight any false detection boxes. if(IncorrectEntryInfo.m_NbFalseDetection &gt; 0) { for(MIL_INT InstanceIndex = 0; InstanceIndex &lt; IncorrectEntryInfo.m_NbInstances; InstanceIndex++) { if(IncorrectEntryInfo.m_MatchedRegionIndexes[InstanceIndex] == M_INVALID) { // Get the bounding box location of the false detection. std::vector&lt;MIL_DOUBLE&gt; Corners; MclassGetResultEntry(m_Dataset, m_EntryIndex, m_EntryKey, M_OBJECT_DETECTION, M_INSTANCE_INDEX(InstanceIndex), M_BOX_4_CORNERS, Corners); MgraRect(m_GraCtxIncorrectPredictions, m_DisGraList, Corners[0], Corners[1], Corners[4], Corners[5]); } } } } //============================================================================== void CDatasetViewer::DrawMissedDetection(const SIncorrectPredictionInfo&amp; IncorrectEntryInfo) const { // Highlight any false detection boxes. if(IncorrectEntryInfo.m_NbMissedDetection &gt; 0) { for(MIL_INT RegionIndex = 0; RegionIndex &lt; IncorrectEntryInfo.m_NbRegions; RegionIndex++) { if(IncorrectEntryInfo.m_MatchedInstanceIndexes[RegionIndex] == M_INVALID) { MclassDrawEntry(m_GraCtxIncorrectPredictions, m_Dataset, m_DisGraList, M_DESCRIPTOR_TYPE_BOX, m_EntryIndex, m_EntryKey, M_OBJECT_DETECTION, M_REGION_INDEX(RegionIndex), M_NULL, M_DEFAULT); } } } } //============================================================================== MIL_INT CDatasetViewer::GetNumberOfGTs() const { MIL_INT NumGTs {0}; const MIL_INT NumRegions = MclassInquireEntry(m_Dataset, m_EntryIndex, m_EntryKey, M_DEFAULT, M_NUMBER_OF_REGIONS, M_NULL); // Skip region 0 which is the whole image; we want the bounding boxes. for(MIL_INT RegionIndex {1}; RegionIndex &lt; NumRegions; RegionIndex++) { NumGTs += MclassInquireEntry(m_Dataset, m_EntryIndex, m_EntryKey, M_REGION_INDEX(RegionIndex), M_NUMBER_OF_DESCRIPTOR_TYPE_BOX, M_NULL); } return NumGTs; } //============================================================================== bool CDatasetViewer::ProcessUserInputControl() { // Look for user key input. if(MosKbhit() != 0) { const char KeyVal = (char)MosGetch(); switch(KeyVal) { case 'N': case 'n': if(m_NbViewEntries &gt; 0) { if(m_DisplayIncorrectPredictionsOnly) { if(!m_IncorrectPredictions.empty()) { m_IncorrectPredictionIndex = std::min&lt;MIL_INT&gt;(++m_IncorrectPredictionIndex, m_NbViewEntries - 1); m_EntryKey = m_IncorrectPredictions[m_IncorrectPredictionIndex].m_EntryKey; m_LastIncorrectPredictionIndex = m_IncorrectPredictionIndex; } } else { m_EntryIndex = std::min&lt;MIL_INT&gt;(++m_EntryIndex, m_NbViewEntries - 1); m_LastEntryIndex = m_EntryIndex; m_IncorrectPredictionIndex = GetIncorrectPredictionIndex(); } } break; case 'P': case 'p': if(m_NbViewEntries &gt; 0) { if(m_DisplayIncorrectPredictionsOnly) { if(!m_IncorrectPredictions.empty()) { m_IncorrectPredictionIndex = std::max&lt;MIL_INT&gt;(--m_IncorrectPredictionIndex, 0); m_EntryKey = m_IncorrectPredictions[m_IncorrectPredictionIndex].m_EntryKey; m_LastIncorrectPredictionIndex = m_IncorrectPredictionIndex; } } else { m_EntryIndex = std::max&lt;MIL_INT&gt;(--m_EntryIndex, 0); m_LastEntryIndex = m_EntryIndex; m_IncorrectPredictionIndex = GetIncorrectPredictionIndex(); } } break; case 'E': case 'e': return true; break; case 'T': case 't': m_DisplayGroundTruth = !m_DisplayGroundTruth; break; case 'F': case 'f': m_DisplayIncorrectPredictionsOnly = !m_DisplayIncorrectPredictionsOnly; m_NbViewEntries = m_DisplayIncorrectPredictionsOnly ? (MIL_INT)m_IncorrectPredictions.size() : m_NbEntries; if(!m_IncorrectPredictions.empty()) { m_EntryIndex = m_DisplayIncorrectPredictionsOnly ? M_DEFAULT : m_LastEntryIndex; m_IncorrectPredictionIndex = m_DisplayIncorrectPredictionsOnly ? m_LastIncorrectPredictionIndex : GetIncorrectPredictionIndex(); m_EntryKey = m_DisplayIncorrectPredictionsOnly ? m_IncorrectPredictions[m_IncorrectPredictionIndex].m_EntryKey : M_DEFAULT_KEY; } break; default: break; } } return false; } //============================================================================== MIL_INT CDatasetViewer::GetIncorrectPredictionIndex() const { MIL_INT IncorrectPredictionIndex {M_INVALID}; if(!m_IncorrectPredictions.empty()) { MIL_UUID IncorrectEntryKey = m_EntryKey; if(!m_DisplayIncorrectPredictionsOnly) { MclassInquireEntry(m_Dataset, m_EntryIndex, M_DEFAULT_KEY, M_DEFAULT, M_ENTRY_KEY + M_TYPE_MIL_UUID, &amp;IncorrectEntryKey); } // Find the incorrect prediction info having that entry key. auto IterIncorrectPred = std::find_if(m_IncorrectPredictions.cbegin(), m_IncorrectPredictions.cend(), [&amp;IncorrectEntryKey](const SIncorrectPredictionInfo&amp; element) { return element.m_EntryKey == IncorrectEntryKey; }); if(IterIncorrectPred != m_IncorrectPredictions.cend()) { IncorrectPredictionIndex = std::distance(m_IncorrectPredictions.cbegin(), IterIncorrectPred); } } return IncorrectPredictionIndex; } //============================================================================== MIL_INT CnnTrainEngineDLLInstalled(MIL_ID MilSystem) { MIL_UNIQUE_CLASS_ID TrainCtx = MclassAlloc(MilSystem, M_TRAIN_DET, M_DEFAULT, M_UNIQUE_ID); MIL_INT IsInstalled {M_FALSE}; MclassInquire(TrainCtx, M_DEFAULT, M_TRAIN_ENGINE_IS_INSTALLED + M_TYPE_MIL_INT, &amp;IsInstalled); return IsInstalled; } //============================================================================== void GetImageSizes( MIL_ID MilSystem, MIL_ID Dataset, MIL_INT* pImgSizeX, MIL_INT* pImgSizeY) { MIL_STRING EntryImgPathAbs {}; MclassInquireEntry(Dataset, 0, M_DEFAULT_KEY, M_DEFAULT, M_ENTRY_IMAGE_PATH_ABS, EntryImgPathAbs); MbufDiskInquire(EntryImgPathAbs, M_SIZE_X, pImgSizeX); MbufDiskInquire(EntryImgPathAbs, M_SIZE_Y, pImgSizeY); } //============================================================================== MIL_INT IsTrainingSupportedOnPlatform(MIL_ID MilSystem) { MIL_ID MilSysOwnerApp {M_NULL}; MsysInquire(MilSystem, M_OWNER_APPLICATION, &amp;MilSysOwnerApp); MIL_INT SysPlatformBitness {M_NULL}; MappInquire(MilSysOwnerApp, M_PLATFORM_BITNESS, &amp;SysPlatformBitness); MIL_INT SysOsType {M_NULL}; MappInquire(MilSysOwnerApp, M_PLATFORM_OS_TYPE, &amp;SysOsType); const bool SupportedTrainingPlatform = ((SysPlatformBitness == 64) &amp;&amp; (SysOsType == M_OS_WINDOWS)); if(!SupportedTrainingPlatform) { MosPrintf(MIL_TEXT(\"\\n***** MclassTrain() is available only for Windows 64-bit platforms. *****\\n\")); return M_FALSE; } if(!CnnTrainEngineDLLInstalled(MilSystem)) { MosPrintf(MIL_TEXT(\"\\n***** MclassTrain() cannot run; no train engine is installed. *****\\n\")); return M_FALSE; } return M_TRUE; } //============================================================================== void LoadDatasets(MIL_ID MilSystem, MIL_ID Dataset, MIL_ID TestDataset, bool SkipTrain) { MclassImport(EXAMPLE_DATASET_ROOT_PATH, M_IMAGE_DATASET_FOLDER, Dataset, M_DEFAULT, M_COMPLETE, M_DEFAULT); MclassImport(EXAMPLE_TEST_DATASET_ROOT_PATH, M_IMAGE_DATASET_FOLDER, TestDataset, M_DEFAULT, M_COMPLETE, M_DEFAULT); MosPrintf(MIL_TEXT(\"The datasets were successfully imported.\\n\\n\")); if(!SkipTrain) { MosPrintf(MIL_TEXT(\"Press &lt;v&gt; to view the imported training dataset.\\n\")); } MosPrintf(MIL_TEXT(\"Press any key to continue...\\n\")); char KeyVal = (char)MosGetch(); if((KeyVal == 'v' || KeyVal == 'V') &amp;&amp; !SkipTrain) { MosPrintf(MIL_TEXT(\"\\n\\n*******************************************************\\n\")); MosPrintf(MIL_TEXT(\"VIEWING THE IMPORTED TRAINING DATASET...\\n\")); MosPrintf(MIL_TEXT(\"*******************************************************\\n\\n\")); CDatasetViewer DatasetViewer(MilSystem, Dataset, true); } } //============================================================================== void PredictUsingTrainedContext( MIL_ID MilSystem, MIL_ID MilDisplay, MIL_ID TrainedCtx, MIL_ID TestDataset) { MclassPreprocess(TrainedCtx, M_DEFAULT); MclassPredict(TrainedCtx, TestDataset, TestDataset, M_DEFAULT); MIL_INT NumEntries {0}; MclassInquire(TestDataset, M_DEFAULT, M_NUMBER_OF_ENTRIES + M_TYPE_MIL_INT, &amp;NumEntries); MosPrintf(MIL_TEXT(\"\\nPredictions will be performed on the test dataset as a final check\\nof the trained object detection classifier.\\n\")); MosPrintf(MIL_TEXT(\"The test dataset contains %d images.\\n\"), NumEntries); MosPrintf(MIL_TEXT(\"The prediction results will be shown for all %d images.\\n\\n\"), NumEntries); // Provide per-class and average statistics on the test set using MclassStatCalculate. GetStatResults(MilSystem, TestDataset); MosPrintf(MIL_TEXT(\"Press any key to end...\\n\")); MosGetch(); } //============================================================================== void GetStatResults(MIL_ID MilSystem, MIL_ID TestDataset) { MosPrintf(MIL_TEXT(\"\\n***************************************************************\\n\")); MosPrintf(MIL_TEXT(\"COMPUTING METRICS ON THE TESTSET...\\n\")); MosPrintf(MIL_TEXT(\"***************************************************************\\n\\n\")); MIL_UNIQUE_CLASS_ID StatCtx = MclassAlloc(MilSystem, M_STAT_DET, M_DEFAULT, M_UNIQUE_ID); MIL_UNIQUE_CLASS_ID StatRslt = MclassAllocResult(MilSystem, M_STAT_DET_RESULT, M_DEFAULT, M_UNIQUE_ID); // Compute stat. MclassControl(StatCtx, M_CONTEXT, M_MATCH_IOU_THRESHOLD, MATCH_IOU_THRESHOLD_VALUE); MclassPreprocess(StatCtx, M_DEFAULT); MclassStatCalculate(StatCtx, TestDataset, M_DEFAULT, M_DEFAULT_KEY, StatRslt, M_DEFAULT); MIL_INT Status {-1}; MclassGetResultStat(StatRslt, M_GENERAL, M_GENERAL, M_DEFAULT, M_STATUS + M_TYPE_MIL_INT, &amp;Status); // Check if there are entries that were not processed due to an error. CheckErrorEntries(StatRslt); if(Status == M_COMPLETE) { // Show the confusion matrix. PrintConfusionMatrix(StatRslt, TestDataset); SStatResultInfo StatResults; // Macro stat metrics which give equal importance to all classes. MclassGetResultStat(StatRslt, M_GENERAL, M_GENERAL, M_DEFAULT, M_ACCURACY_MACRO, &amp;StatResults.m_Macro.m_ACC); MclassGetResultStat(StatRslt, M_GENERAL, M_GENERAL, M_DEFAULT, M_ERROR_RATE_MACRO, &amp;StatResults.m_Macro.m_ERR); MclassGetResultStat(StatRslt, M_GENERAL, M_GENERAL, M_DEFAULT, M_TNR_MACRO, &amp;StatResults.m_Macro.m_TNR); MclassGetResultStat(StatRslt, M_GENERAL, M_GENERAL, M_DEFAULT, M_FPR_MACRO, &amp;StatResults.m_Macro.m_FPR); MclassGetResultStat(StatRslt, M_GENERAL, M_GENERAL, M_DEFAULT, M_RECALL_MACRO, &amp;StatResults.m_Macro.m_TPR); MclassGetResultStat(StatRslt, M_GENERAL, M_GENERAL, M_DEFAULT, M_FNR_MACRO, &amp;StatResults.m_Macro.m_FNR); MclassGetResultStat(StatRslt, M_GENERAL, M_GENERAL, M_DEFAULT, M_PRECISION_MACRO, &amp;StatResults.m_Macro.m_PPV); MclassGetResultStat(StatRslt, M_GENERAL, M_GENERAL, M_DEFAULT, M_FDR_MACRO, &amp;StatResults.m_Macro.m_FDR); MclassGetResultStat(StatRslt, M_GENERAL, M_GENERAL, M_DEFAULT, M_F1SCORE_MACRO, &amp;StatResults.m_Macro.m_F1); MclassGetResultStat(StatRslt, M_GENERAL, M_GENERAL, M_DEFAULT, M_AVERAGE_PRECISION_MACRO, &amp;StatResults.m_Macro.m_AP); // Micro stat metrics which give equal importance to all samples. MclassGetResultStat(StatRslt, M_GENERAL, M_GENERAL, M_DEFAULT, M_ACCURACY_OVERALL, &amp;StatResults.m_Micro.m_ACC); MclassGetResultStat(StatRslt, M_GENERAL, M_GENERAL, M_DEFAULT, M_ERROR_RATE_OVERALL, &amp;StatResults.m_Micro.m_ERR); MclassGetResultStat(StatRslt, M_GENERAL, M_GENERAL, M_DEFAULT, M_TNR_MICRO, &amp;StatResults.m_Micro.m_TNR); MclassGetResultStat(StatRslt, M_GENERAL, M_GENERAL, M_DEFAULT, M_FPR_MICRO, &amp;StatResults.m_Micro.m_FPR); MclassGetResultStat(StatRslt, M_GENERAL, M_GENERAL, M_DEFAULT, M_RECALL_MICRO, &amp;StatResults.m_Micro.m_TPR); MclassGetResultStat(StatRslt, M_GENERAL, M_GENERAL, M_DEFAULT, M_FNR_MICRO, &amp;StatResults.m_Micro.m_FNR); MclassGetResultStat(StatRslt, M_GENERAL, M_GENERAL, M_DEFAULT, M_PRECISION_MICRO, &amp;StatResults.m_Micro.m_PPV); MclassGetResultStat(StatRslt, M_GENERAL, M_GENERAL, M_DEFAULT, M_FDR_MICRO, &amp;StatResults.m_Micro.m_FDR); MclassGetResultStat(StatRslt, M_GENERAL, M_GENERAL, M_DEFAULT, M_F1SCORE_MICRO, &amp;StatResults.m_Micro.m_F1); // Weighted stat metrics which give importance according to the proportion of entries per class. MclassGetResultStat(StatRslt, M_GENERAL, M_GENERAL, M_DEFAULT, M_ACCURACY_WEIGHTED, &amp;StatResults.m_Weighted.m_ACC); MclassGetResultStat(StatRslt, M_GENERAL, M_GENERAL, M_DEFAULT, M_ERROR_RATE_WEIGHTED, &amp;StatResults.m_Weighted.m_ERR); MclassGetResultStat(StatRslt, M_GENERAL, M_GENERAL, M_DEFAULT, M_TNR_WEIGHTED, &amp;StatResults.m_Weighted.m_TNR); MclassGetResultStat(StatRslt, M_GENERAL, M_GENERAL, M_DEFAULT, M_FPR_WEIGHTED, &amp;StatResults.m_Weighted.m_FPR); MclassGetResultStat(StatRslt, M_GENERAL, M_GENERAL, M_DEFAULT, M_RECALL_WEIGHTED, &amp;StatResults.m_Weighted.m_TPR); MclassGetResultStat(StatRslt, M_GENERAL, M_GENERAL, M_DEFAULT, M_FNR_WEIGHTED, &amp;StatResults.m_Weighted.m_FNR); MclassGetResultStat(StatRslt, M_GENERAL, M_GENERAL, M_DEFAULT, M_PRECISION_WEIGHTED, &amp;StatResults.m_Weighted.m_PPV); MclassGetResultStat(StatRslt, M_GENERAL, M_GENERAL, M_DEFAULT, M_FDR_WEIGHTED, &amp;StatResults.m_Weighted.m_FDR); MclassGetResultStat(StatRslt, M_GENERAL, M_GENERAL, M_DEFAULT, M_F1SCORE_WEIGHTED, &amp;StatResults.m_Weighted.m_F1); MclassGetResultStat(StatRslt, M_GENERAL, M_GENERAL, M_DEFAULT, M_AVERAGE_PRECISION_WEIGHTED, &amp;StatResults.m_Weighted.m_AP); // Per class stat metrics. const MIL_INT NbClasses = MclassInquire(TestDataset, M_DEFAULT, M_NUMBER_OF_CLASSES, M_NULL); for(MIL_INT ClassIndex = 0; ClassIndex &lt; NbClasses; ClassIndex++) { SStatMetricInfo StatMetricsClass; MclassGetResultStat(StatRslt, M_CLASS_INDEX(ClassIndex), M_GENERAL, M_DEFAULT, M_ACCURACY, &amp;StatMetricsClass.m_ACC); MclassGetResultStat(StatRslt, M_CLASS_INDEX(ClassIndex), M_GENERAL, M_DEFAULT, M_ERROR_RATE, &amp;StatMetricsClass.m_ERR); MclassGetResultStat(StatRslt, M_CLASS_INDEX(ClassIndex), M_GENERAL, M_DEFAULT, M_TNR, &amp;StatMetricsClass.m_TNR); MclassGetResultStat(StatRslt, M_CLASS_INDEX(ClassIndex), M_GENERAL, M_DEFAULT, M_FPR, &amp;StatMetricsClass.m_FPR); MclassGetResultStat(StatRslt, M_CLASS_INDEX(ClassIndex), M_GENERAL, M_DEFAULT, M_RECALL, &amp;StatMetricsClass.m_TPR); MclassGetResultStat(StatRslt, M_CLASS_INDEX(ClassIndex), M_GENERAL, M_DEFAULT, M_FNR, &amp;StatMetricsClass.m_FNR); MclassGetResultStat(StatRslt, M_CLASS_INDEX(ClassIndex), M_GENERAL, M_DEFAULT, M_PRECISION, &amp;StatMetricsClass.m_PPV); MclassGetResultStat(StatRslt, M_CLASS_INDEX(ClassIndex), M_GENERAL, M_DEFAULT, M_FDR, &amp;StatMetricsClass.m_FDR); MclassGetResultStat(StatRslt, M_CLASS_INDEX(ClassIndex), M_GENERAL, M_DEFAULT, M_F1SCORE, &amp;StatMetricsClass.m_F1); MclassGetResultStat(StatRslt, M_CLASS_INDEX(ClassIndex), M_GENERAL, M_DEFAULT, M_AVERAGE_PRECISION, &amp;StatMetricsClass.m_AP); StatResults.m_PerClass.push_back(StatMetricsClass); } // Print stat results. PrintStatResults(StatResults, TestDataset); MosPrintf(MIL_TEXT(\"Press any key to continue...\\n\")); MosGetch(); MosPrintf(MIL_TEXT(\"\\n***************************************************************\\n\")); MosPrintf(MIL_TEXT(\"VIEWING THE PREDICTED TEST DATASET...\\n\")); MosPrintf(MIL_TEXT(\"***************************************************************\\n\")); // Print the number of entries that failed and show them. CDatasetViewer DatasetViewer(MilSystem, TestDataset, StatCtx, StatRslt, false); } else { PrintStatusMessage(Status); } } //============================================================================== void PrintStatResults(const SStatResultInfo&amp; Stats, MIL_ID TestDataset) { // Get the appropriate horizontal line for the stat table. MIL_STRING HLine = GetTableHLine(4); // Print micro, macro and weighted stats. MosPrintf(MIL_TEXT(\"%-11s|%11s|%11s|%11s\\n\"), MIL_TEXT(\"Metric\"), MIL_TEXT(\"Micro\"), MIL_TEXT(\"Macro\"), MIL_TEXT(\"Weighted\")); MosPrintf(MIL_TEXT(\"%s\\n\"), HLine.c_str()); MosPrintf(MIL_TEXT(\"%-11s|%11.2f|%11.2f|%11.2f\\n\"), MIL_TEXT(\"Accuracy\"), Stats.m_Micro.m_ACC, Stats.m_Macro.m_ACC, Stats.m_Weighted.m_ACC); MosPrintf(MIL_TEXT(\"%-11s|%11.2f|%11.2f|%11.2f\\n\"), MIL_TEXT(\"Error Rate\"), Stats.m_Micro.m_ERR, Stats.m_Macro.m_ERR, Stats.m_Weighted.m_ERR); MosPrintf(MIL_TEXT(\"%-11s|%11.2f|%11.2f|%11.2f\\n\"), MIL_TEXT(\"TNR\"), Stats.m_Micro.m_TNR, Stats.m_Macro.m_TNR, Stats.m_Weighted.m_TNR); MosPrintf(MIL_TEXT(\"%-11s|%11.2f|%11.2f|%11.2f\\n\"), MIL_TEXT(\"FPR\"), Stats.m_Micro.m_FPR, Stats.m_Macro.m_FPR, Stats.m_Weighted.m_FPR); MosPrintf(MIL_TEXT(\"%-11s|%11.2f|%11.2f|%11.2f\\n\"), MIL_TEXT(\"Recall\"), Stats.m_Micro.m_TPR, Stats.m_Macro.m_TPR, Stats.m_Weighted.m_TPR); MosPrintf(MIL_TEXT(\"%-11s|%11.2f|%11.2f|%11.2f\\n\"), MIL_TEXT(\"FNR\"), Stats.m_Micro.m_FNR, Stats.m_Macro.m_FNR, Stats.m_Weighted.m_FNR); MosPrintf(MIL_TEXT(\"%-11s|%11.2f|%11.2f|%11.2f\\n\"), MIL_TEXT(\"Precision\"), Stats.m_Micro.m_PPV, Stats.m_Macro.m_PPV, Stats.m_Weighted.m_PPV); MosPrintf(MIL_TEXT(\"%-11s|%11.2f|%11.2f|%11.2f\\n\"), MIL_TEXT(\"FDR\"), Stats.m_Micro.m_FDR, Stats.m_Macro.m_FDR, Stats.m_Weighted.m_FDR); MosPrintf(MIL_TEXT(\"%-11s|%11.2f|%11.2f|%11.2f\\n\"), MIL_TEXT(\"F1 Score\"), Stats.m_Micro.m_F1, Stats.m_Macro.m_F1, Stats.m_Weighted.m_F1); MosPrintf(MIL_TEXT(\"%-11s|%11s|%11.2f|%11.2f\\n\"), MIL_TEXT(\"AP\"), MIL_TEXT(\"N/A\"), Stats.m_Macro.m_AP, Stats.m_Weighted.m_AP); // Print per-class stats. MosPrintf(MIL_TEXT(\"\\n%-11s\"), MIL_TEXT(\"Metric\")); const MIL_INT NbClasses = MclassInquire(TestDataset, M_DEFAULT, M_NUMBER_OF_CLASSES, M_NULL); for(MIL_INT ClassIndex = 0; ClassIndex &lt; NbClasses; ClassIndex++) { // Get class name. MIL_STRING ClassName; MclassInquire(TestDataset, M_CLASS_INDEX(ClassIndex), M_CLASS_NAME, ClassName); MosPrintf(MIL_TEXT(\"|%11s\"), ClassName.c_str()); } HLine = GetTableHLine(NbClasses + 1); MosPrintf(MIL_TEXT(\"\\n%s\"), HLine.c_str()); MosPrintf(MIL_TEXT(\"\\n%-11s\"), MIL_TEXT(\"Accuracy\")); for(MIL_INT ClassIndex = 0; ClassIndex &lt; NbClasses; ClassIndex++) { MosPrintf(MIL_TEXT(\"|%11.2f\"), Stats.m_PerClass[ClassIndex].m_ACC); } MosPrintf(MIL_TEXT(\"\\n%-11s\"), MIL_TEXT(\"Error Rate\")); for(MIL_INT ClassIndex = 0; ClassIndex &lt; NbClasses; ClassIndex++) { MosPrintf(MIL_TEXT(\"|%11.2f\"), Stats.m_PerClass[ClassIndex].m_ERR); } MosPrintf(MIL_TEXT(\"\\n%-11s\"), MIL_TEXT(\"TNR\")); for(MIL_INT ClassIndex = 0; ClassIndex &lt; NbClasses; ClassIndex++) { MosPrintf(MIL_TEXT(\"|%11.2f\"), Stats.m_PerClass[ClassIndex].m_TNR); } MosPrintf(MIL_TEXT(\"\\n%-11s\"), MIL_TEXT(\"FPR\")); for(MIL_INT ClassIndex = 0; ClassIndex &lt; NbClasses; ClassIndex++) { MosPrintf(MIL_TEXT(\"|%11.2f\"), Stats.m_PerClass[ClassIndex].m_FPR); } MosPrintf(MIL_TEXT(\"\\n%-11s\"), MIL_TEXT(\"Recall\")); for(MIL_INT ClassIndex = 0; ClassIndex &lt; NbClasses; ClassIndex++) { MosPrintf(MIL_TEXT(\"|%11.2f\"), Stats.m_PerClass[ClassIndex].m_TPR); } MosPrintf(MIL_TEXT(\"\\n%-11s\"), MIL_TEXT(\"FNR\")); for(MIL_INT ClassIndex = 0; ClassIndex &lt; NbClasses; ClassIndex++) { MosPrintf(MIL_TEXT(\"|%11.2f\"), Stats.m_PerClass[ClassIndex].m_FNR); } MosPrintf(MIL_TEXT(\"\\n%-11s\"), MIL_TEXT(\"Precision\")); for(MIL_INT ClassIndex = 0; ClassIndex &lt; NbClasses; ClassIndex++) { MosPrintf(MIL_TEXT(\"|%11.2f\"), Stats.m_PerClass[ClassIndex].m_PPV); } MosPrintf(MIL_TEXT(\"\\n%-11s\"), MIL_TEXT(\"FDR\")); for(MIL_INT ClassIndex = 0; ClassIndex &lt; NbClasses; ClassIndex++) { MosPrintf(MIL_TEXT(\"|%11.2f\"), Stats.m_PerClass[ClassIndex].m_FDR); } MosPrintf(MIL_TEXT(\"\\n%-11s\"), MIL_TEXT(\"F1 Score\")); for(MIL_INT ClassIndex = 0; ClassIndex &lt; NbClasses; ClassIndex++) { MosPrintf(MIL_TEXT(\"|%11.2f\"), Stats.m_PerClass[ClassIndex].m_F1); } MosPrintf(MIL_TEXT(\"\\n%-11s\"), MIL_TEXT(\"AP\")); for(MIL_INT ClassIndex = 0; ClassIndex &lt; NbClasses; ClassIndex++) { MosPrintf(MIL_TEXT(\"|%11.2f\"), Stats.m_PerClass[ClassIndex].m_AP); } MosPrintf(MIL_TEXT(\"\\n\\n\")); } //============================================================================== MIL_STRING GetTableHLine(MIL_INT NbColumns) { MIL_STRING HLine(NbColumns * 12 - 1, MIL_TEXT_CHAR('-')); for(MIL_INT IterCol = 1; IterCol &lt; NbColumns; IterCol++) { HLine[IterCol * 12 - 1] = MIL_TEXT_CHAR('+'); } return HLine; } //============================================================================== void CheckErrorEntries(MIL_ID StatRslt) { // List entries with errors. std::vector&lt;MIL_UUID&gt; ErrorEntries; MclassGetResultStat(StatRslt, M_GENERAL, M_GENERAL, M_DEFAULT, M_ERROR_ENTRIES, ErrorEntries); if(!ErrorEntries.empty()) { MosPrintf(MIL_TEXT(\"\\t%d entries have an error status.\\n\"), (MIL_INT)ErrorEntries.size()); } } //============================================================================== void PrintConfusionMatrix(MIL_ID StatRslt, MIL_ID TestDataset) { const MIL_INT NbClasses = MclassInquire(TestDataset, M_DEFAULT, M_NUMBER_OF_CLASSES, M_NULL); // Get the appropriate horizontal line for the stat table. MIL_STRING HLine = GetTableHLine(NbClasses + 2); MosPrintf(MIL_TEXT(\"'No class' column shows unmatched ground truths (missed detections).\\n\")); MosPrintf(MIL_TEXT(\"'No class' row shows unmatched detections (false detections).\\n\\n\")); MosPrintf(MIL_TEXT(\"Confusion Matrix:\\n\")); MosPrintf(MIL_TEXT(\"%-11s\"), MIL_TEXT(\"GT\\\\Pred.\")); std::vector&lt;MIL_STRING&gt; ClassNames(NbClasses); for(MIL_INT ClassIndex = 0; ClassIndex &lt; NbClasses; ClassIndex++) { // Get class name. MclassInquire(TestDataset, M_CLASS_INDEX(ClassIndex), M_CLASS_NAME, ClassNames[ClassIndex]); MosPrintf(MIL_TEXT(\"|%11s\"), ClassNames[ClassIndex].c_str()); } MosPrintf(MIL_TEXT(\"|%11s\\n\"), MIL_TEXT(\"No class\")); MosPrintf(MIL_TEXT(\"%s\"), HLine.c_str()); for(MIL_INT ClassIndex = 0; ClassIndex &lt; NbClasses + 1; ClassIndex++) { std::vector&lt;MIL_INT&gt; ConfusionMatrixRow; if(ClassIndex &lt; NbClasses) { MclassGetResultStat(StatRslt, M_CLASS_INDEX(ClassIndex), M_GENERAL, M_DEFAULT, M_CONFUSION_MATRIX_ROW, ConfusionMatrixRow); MosPrintf(MIL_TEXT(\"\\n%-11s\"), ClassNames[ClassIndex].c_str()); } else { MclassGetResultStat(StatRslt, M_NO_CLASS, M_GENERAL, M_DEFAULT, M_CONFUSION_MATRIX_ROW, ConfusionMatrixRow); MosPrintf(MIL_TEXT(\"\\n%-11s\"), MIL_TEXT(\"No class\")); } for(MIL_INT Element : ConfusionMatrixRow) { MosPrintf(MIL_TEXT(\"|%11d\"), Element); } } MosPrintf(MIL_TEXT(\"\\n\\n\")); } //============================================================================== void PrintStatusMessage(MIL_INT Status) { switch(Status) { case M_INTERNAL_ERROR: MosPrintf(MIL_TEXT(\"An unexpected internal error has occurred!\\n\")); break; case M_NON_FINITE_VALUE_DETECTED: MosPrintf(MIL_TEXT(\"Training terminated because a non-finite value was detected!\\n\")); break; case M_NOT_ENOUGH_GPU_MEMORY: MosPrintf(MIL_TEXT(\"Ran out of GPU memory, try reducing the batch size!\\n\")); break; case M_NOT_ENOUGH_MEMORY: MosPrintf(MIL_TEXT(\"Ran out of memory, try reducing the batch size!\\n\")); break; case M_TIMEOUT_REACHED: MosPrintf(MIL_TEXT(\"Timeout reached, try increasing the timeout!\\n\")); break; case M_ZERO_USED_ENTRIES: MosPrintf(MIL_TEXT(\"No entries were used, they are all in error!\\n\")); break; case M_CALCULATE_NOT_PERFORMED: MosPrintf(MIL_TEXT(\"The calculate operation was not performed!\\n\")); break; case M_STOPPED_BY_REQUEST: MosPrintf(MIL_TEXT(\"The current execution was explicitly stopped!\\n\")); break; default: MosPrintf(MIL_TEXT(\"Unexpected status code received!\\n\")); break; } } //============================================================================== MIL_STRING ConvertPrepareDataStatusToStr(MIL_INT Status) { switch(Status) { case M_COMPLETE: return MIL_TEXT(\"M_COMPLETE\"); case M_INVALID_AUG_OP_FOR_1_BAND_BUFFER: return MIL_TEXT(\"M_INVALID_AUG_OP_FOR_1_BAND_BUFFER\"); case M_INVALID_AUG_OP_FOR_1_BIT_BUFFER: return MIL_TEXT(\"M_INVALID_AUG_OP_FOR_1_BIT_BUFFER\"); case M_SOURCE_TOO_SMALL_FOR_DERICHE_OP: return MIL_TEXT(\"M_SOURCE_TOO_SMALL_FOR_DERICHE_OP\"); case M_FLOAT_IMAGE_NOT_NORMALIZED: return MIL_TEXT(\"M_FLOAT_IMAGE_NOT_NORMALIZED\"); case M_FAILED_TO_SAVE_IMAGE: return MIL_TEXT(\"M_FAILED_TO_SAVE_IMAGE\"); case M_IMAGE_FILE_NOT_FOUND: return MIL_TEXT(\"M_IMAGE_FILE_NOT_FOUND\"); case M_IMAGE_FILE_INVALID: return MIL_TEXT(\"M_IMAGE_FILE_INVALID\"); case M_INVALID_BUFFER_SIGN_FOR_AUG: return MIL_TEXT(\"M_INVALID_BUFFER_SIGN_FOR_AUG\"); case M_INVALID_CENTER: return MIL_TEXT(\"M_INVALID_CENTER\"); case M_MASK_FILE_NOT_FOUND: return MIL_TEXT(\"M_MASK_FILE_NOT_FOUND\"); case M_RESIZED_IMAGE_TOO_SMALL: return MIL_TEXT(\"M_RESIZED_IMAGE_TOO_SMALL\"); case M_INTERNAL_ERROR: return MIL_TEXT(\"M_INTERNAL_ERROR\"); default: return MIL_TEXT(\"Unhandled prepare data status!\"); } } //============================================================================== void SetAugmentationControls(MIL_ID TrainCtx, bool* pIsDevDataset) { MIL_ID PrepareDataCtx {M_NULL}; MclassInquire(TrainCtx, M_DEFAULT, M_PREPARE_DATA_CONTEXT_ID + M_TYPE_MIL_ID, &amp;PrepareDataCtx); // Reproducibility. MclassControl(PrepareDataCtx, M_DEFAULT, M_SEED_MODE, M_USER_DEFINED); MclassControl(PrepareDataCtx, M_DEFAULT, M_SEED_VALUE, 16); // Number of augmentations. MclassControl(PrepareDataCtx, M_DEFAULT, M_AUGMENT_NUMBER_MODE, M_FACTOR); MclassControl(PrepareDataCtx, M_DEFAULT, M_AUGMENT_NUMBER_FACTOR, 9.0); MclassControl(PrepareDataCtx, M_DEFAULT, M_AUGMENT_BALANCING, 0.0); // Presets. MclassControl(PrepareDataCtx, M_DEFAULT, M_PRESET_TRANSLATION, M_ENABLE); MclassControl(PrepareDataCtx, M_DEFAULT, M_PRESET_ROTATION, M_ENABLE); MclassControl(PrepareDataCtx, M_DEFAULT, M_PRESET_FLIP, M_ENABLE); MIL_ID AugmentContext {M_NULL}; MclassInquire(PrepareDataCtx, M_DEFAULT, M_AUGMENT_CONTEXT_ID + M_TYPE_MIL_ID, &amp;AugmentContext); // Chosen probability to achieve on average 1.75 of the following augmentations. MIL_INT Probability = 35; MimControl(AugmentContext, M_AUG_HUE_OFFSET_OP, M_ENABLE); MimControl(AugmentContext, M_AUG_HUE_OFFSET_OP + M_PROBABILITY, Probability); MimControl(AugmentContext, M_AUG_HUE_OFFSET_OP_MAX, 360); MimControl(AugmentContext, M_AUG_HUE_OFFSET_OP_MIN, 0); MimControl(AugmentContext, M_AUG_LIGHTING_DIRECTIONAL_OP, M_ENABLE); MimControl(AugmentContext, M_AUG_LIGHTING_DIRECTIONAL_OP + M_PROBABILITY, Probability); MimControl(AugmentContext, M_AUG_LIGHTING_DIRECTIONAL_OP_INTENSITY_MAX, 1.2); MimControl(AugmentContext, M_AUG_LIGHTING_DIRECTIONAL_OP_INTENSITY_MIN, 0.8); MimControl(AugmentContext, M_AUG_INTENSITY_ADD_OP, M_ENABLE); MimControl(AugmentContext, M_AUG_INTENSITY_ADD_OP + M_PROBABILITY, Probability); MimControl(AugmentContext, M_AUG_INTENSITY_ADD_OP_DELTA, 32); MimControl(AugmentContext, M_AUG_INTENSITY_ADD_OP_MODE, M_LUMINANCE); MimControl(AugmentContext, M_AUG_INTENSITY_ADD_OP_VALUE, 0); MimControl(AugmentContext, M_AUG_SATURATION_GAIN_OP, M_ENABLE); MimControl(AugmentContext, M_AUG_SATURATION_GAIN_OP + M_PROBABILITY, Probability); MimControl(AugmentContext, M_AUG_SATURATION_GAIN_OP_MAX, 1.5); MimControl(AugmentContext, M_AUG_SATURATION_GAIN_OP_MIN, 0.75); MimControl(AugmentContext, M_AUG_NOISE_MULTIPLICATIVE_OP, M_ENABLE); MimControl(AugmentContext, M_AUG_NOISE_MULTIPLICATIVE_OP + M_PROBABILITY, Probability); MimControl(AugmentContext, M_AUG_NOISE_MULTIPLICATIVE_OP_DISTRIBUTION, M_UNIFORM); MimControl(AugmentContext, M_AUG_NOISE_MULTIPLICATIVE_OP_INTENSITY_MIN, 0); MimControl(AugmentContext, M_AUG_NOISE_MULTIPLICATIVE_OP_STDDEV, 0.1); MimControl(AugmentContext, M_AUG_NOISE_MULTIPLICATIVE_OP_STDDEV_DELTA, 0.1); // Hook to show augmentations' progress. MclassHookFunction(PrepareDataCtx, M_PREPARE_ENTRY_POST, HookNumPreparedEntriesFunc, pIsDevDataset); } //============================================================================== void SetTrainControls(MIL_ID TrainCtx) { // Delete and create training directory. MIL_INT TrainFolderExists {M_FALSE}; MappFileOperation(M_DEFAULT, EXAMPLE_TRAIN_DESTINATION_PATH, M_NULL, M_NULL, M_FILE_EXISTS, M_DEFAULT, &amp;TrainFolderExists); if(TrainFolderExists == M_TRUE) { MappFileOperation(M_DEFAULT, EXAMPLE_TRAIN_DESTINATION_PATH, M_NULL, M_NULL, M_FILE_DELETE_DIR, M_RECURSIVE, M_NULL); } MappFileOperation(M_DEFAULT, EXAMPLE_TRAIN_DESTINATION_PATH, M_NULL, M_NULL, M_FILE_MAKE_DIR, M_DEFAULT, M_NULL); MclassControl(TrainCtx, M_DEFAULT, M_TRAIN_DESTINATION_FOLDER, EXAMPLE_TRAIN_DESTINATION_PATH); MclassControl(TrainCtx, M_DEFAULT, M_MAX_EPOCH, 20); MclassControl(TrainCtx, M_DEFAULT, M_MINI_BATCH_SIZE, 4); MclassControl(TrainCtx, M_DEFAULT, M_INITIAL_LEARNING_RATE, 0.001); MclassControl(TrainCtx, M_DEFAULT, M_LEARNING_RATE_DECAY, 0.1); MclassControl(TrainCtx, M_DEFAULT, M_SPLIT_SEED_MODE, M_FIXED); MclassControl(TrainCtx, M_DEFAULT, M_SPLIT_PERCENTAGE, 80.0); } //============================================================================== MIL_UNIQUE_CLASS_ID TrainTheModel( MIL_ID MilSystem, MIL_ID MilDisplay, MIL_ID Dataset) { MIL_UNIQUE_CLASS_ID TrainCtx = MclassAlloc(MilSystem, M_TRAIN_DET, M_DEFAULT, M_UNIQUE_ID); MIL_UNIQUE_CLASS_ID TrainRslt = MclassAllocResult(MilSystem, M_TRAIN_DET_RESULT, M_DEFAULT, M_UNIQUE_ID); bool IsDevDataset = false; SetAugmentationControls(TrainCtx, &amp;IsDevDataset); SetTrainControls(TrainCtx); MclassPreprocess(TrainCtx, M_DEFAULT); MIL_INT TrainEngineUsed {M_NULL}; MclassInquire(TrainCtx, M_DEFAULT, M_TRAIN_ENGINE_USED + M_TYPE_MIL_INT, &amp;TrainEngineUsed); if(TrainEngineUsed == M_GPU) { MIL_INT GpuTrainEngineStatus {M_NULL}; MclassInquire(TrainCtx, M_CONTEXT, M_GPU_TRAIN_ENGINE_LOAD_STATUS + M_TYPE_MIL_INT, &amp;GpuTrainEngineStatus); if(GpuTrainEngineStatus == M_JIT_COMPILATION_REQUIRED) { MosPrintf(MIL_TEXT(\"\\nWarning :: The training might not be optimal for the current system.\\n\")); MosPrintf(MIL_TEXT(\"Use the CNN Train Engine Test under Classification in MILConfig for more information.\\n\")); MosPrintf(MIL_TEXT(\"It may take some time before displaying the first results...\\n\")); } } else if(TrainEngineUsed == M_CPU) { MosPrintf(MIL_TEXT(\"\\nWarning :: The training is being done on the CPU.\\n\")); MosPrintf(MIL_TEXT(\"If a training on GPU was expected, use the CNN Train Engine Test under Classification in MILConfig for more information.\\n\")); } MIL_STRING TrainEngineDescription {}; MclassInquire(TrainCtx, M_DEFAULT, M_TRAIN_ENGINE_USED_DESCRIPTION, TrainEngineDescription); MIL_INT ImgSizeX {0}; MIL_INT ImgSizeY {0}; GetImageSizes(MilSystem, Dataset, &amp;ImgSizeX, &amp;ImgSizeY); CTrainEvolutionDashboard TheTrainEvolutionDashboard( MilSystem, TrainCtx, ImgSizeX, ImgSizeY, TrainEngineUsed, TrainEngineDescription); SHookEpochData EpochData {}; EpochData.m_pTheDashboard = &amp;TheTrainEvolutionDashboard; MclassHookFunction(TrainCtx, M_EPOCH_TRAINED, HookEpochFunc, &amp;EpochData); SHookMiniBatchData MiniBatchData {}; MiniBatchData.m_pTheDashboard = &amp;TheTrainEvolutionDashboard; MclassHookFunction(TrainCtx, M_MINI_BATCH_TRAINED, HookMiniBatchFunc, &amp;MiniBatchData); SHookDatasetsPrepared DatasetsPreparedData {}; DatasetsPreparedData.m_DashboardId = TheTrainEvolutionDashboard.GetDashboardBufId(); DatasetsPreparedData.m_MilDisplay = MilDisplay; MclassHookFunction(TrainCtx, M_DATASETS_PREPARED, HookDatasetsPreparedFunc, &amp;DatasetsPreparedData); MosPrintf(MIL_TEXT(\"Augmenting the datasets before training.\\n\")); MclassTrain(TrainCtx, M_NULL, Dataset, M_NULL, TrainRslt, M_DEFAULT); MIL_UNIQUE_CLASS_ID TrainedCtx {}; MIL_INT Status {-1}; MclassGetResult(TrainRslt, M_DEFAULT, M_STATUS + M_TYPE_MIL_INT, &amp;Status); if(Status == M_COMPLETE) { MosPrintf(MIL_TEXT(\"\\nTraining completed successfully!\\n\")); TrainedCtx = MclassAlloc(MilSystem, M_CLASSIFIER_DET_PREDEFINED, M_DEFAULT, M_UNIQUE_ID); MclassCopyResult(TrainRslt, M_DEFAULT, TrainedCtx, M_DEFAULT, M_TRAINED_CLASSIFIER, M_DEFAULT); const MIL_STRING SaveCtxName = MIL_TEXT(\"PlywoodODNet.mclass\"); MclassSave(SaveCtxName, TrainedCtx, M_DEFAULT); MosPrintf(MIL_TEXT(\"\\nThe trained context was saved: \\\"%s\\\".\\n\"), SaveCtxName.c_str()); MosPrintf(MIL_TEXT(\"\\nA training report was saved: \\\"TrainReport.csv\\\".\\n\")); MclassExport(MIL_TEXT(\"TrainReport.csv\"), M_FORMAT_TXT, TrainRslt, M_DEFAULT, M_TRAIN_REPORT, M_DEFAULT); std::vector&lt;MIL_DOUBLE&gt; DevLosses {}; MclassGetResult(TrainRslt, M_DEFAULT, M_DEV_DATASET_EPOCH_LOSS, DevLosses); MIL_INT LastUpdatedEpochIndex {0}; MclassGetResult(TrainRslt, M_DEFAULT, M_LAST_EPOCH_UPDATED_PARAMETERS + M_TYPE_MIL_INT, &amp;LastUpdatedEpochIndex); MosPrintf(MIL_TEXT(\"\\nThe best epoch is considered to be the epoch with the lowest dev loss.\\n\")); MosPrintf(MIL_TEXT(\"\\nThe best epoch was epoch %d with loss on the dev dataset of %.8lf.\\n\"), LastUpdatedEpochIndex, DevLosses[LastUpdatedEpochIndex]); MosPrintf(MIL_TEXT(\"\\nPress any key to continue...\\n\")); MosGetch(); } else if(Status == M_STOPPED_BY_REQUEST) { MosPrintf(MIL_TEXT(\"\\nThe training was stopped so we have restored a pre-trained context to predict with.\\n\")); TrainedCtx = MclassRestore(EXAMPLE_PRETRAINED_PATH, MilSystem, M_DEFAULT, M_UNIQUE_ID); MosPrintf(MIL_TEXT(\"\\nPress any key to continue...\\n\")); MosGetch(); } else { PrintStatusMessage(Status); } return TrainedCtx; } //============================================================================== MIL_INT MFTYPE HookDatasetsPreparedFunc(MIL_INT /*HookType*/, MIL_ID EventId, void* pUserData) { SHookDatasetsPrepared* pHookData = reinterpret_cast&lt;SHookDatasetsPrepared*&gt;(pUserData); MIL_ID TrainRslt {M_NULL}; MclassGetHookInfo(EventId, M_RESULT_ID + M_TYPE_MIL_ID, &amp;TrainRslt); MIL_ID MilSystem {M_NULL}; MclassInquire(TrainRslt, M_DEFAULT, M_OWNER_SYSTEM + M_TYPE_MIL_ID, &amp;MilSystem); MIL_UNIQUE_CLASS_ID PrpTrainDataset = MclassAlloc(MilSystem, M_DATASET_IMAGES, M_DEFAULT, M_UNIQUE_ID); MclassCopyResult(TrainRslt, M_DEFAULT, PrpTrainDataset, M_DEFAULT, M_PREPARED_TRAIN_DATASET, M_DEFAULT); MosPrintf(MIL_TEXT(\"Press &lt;v&gt; to view the augmented train dataset.\\nPress any key to continue...\\n\")); char KeyVal = (char)MosGetch(); if(KeyVal == 'v' || KeyVal == 'V') { MosPrintf(MIL_TEXT(\"\\n\\n*******************************************************\\n\")); MosPrintf(MIL_TEXT(\"VIEWING THE AUGMENTED TRAIN DATASET...\")); MosPrintf(MIL_TEXT(\"\\n*******************************************************\\n\\n\")); CDatasetViewer DatasetViewer(MilSystem, PrpTrainDataset, true); } MosPrintf(MIL_TEXT(\"\\nThe training has started.\\n\")); MosPrintf(MIL_TEXT(\"It can be paused at any time by pressing 'p'.\\n\")); MosPrintf(MIL_TEXT(\"It can then be stopped or continued.\\n\")); MosPrintf(MIL_TEXT(\"\\nDuring training, you can observe the evolution of the losses\\n\")); MosPrintf(MIL_TEXT(\"of the train and dev datasets together.\\n\")); MosPrintf(MIL_TEXT(\"The best epoch is determined by the epoch with the smallest dev loss.\\n\")); MdispSelect(pHookData-&gt;m_MilDisplay, pHookData-&gt;m_DashboardId); return M_NULL; } //============================================================================== MIL_INT MFTYPE HookEpochFunc(MIL_INT /*HookType*/, MIL_ID EventId, void* pUserData) { SHookEpochData* pHookData = reinterpret_cast&lt;SHookEpochData*&gt;(pUserData); MIL_DOUBLE CurBench = 0.0; MIL_DOUBLE CurBenchMean = -1.0; MIL_INT CurEpochIndex = 0; MclassGetHookInfo(EventId, M_EPOCH_INDEX + M_TYPE_MIL_INT, &amp;CurEpochIndex); MappTimer(M_DEFAULT, M_TIMER_READ, &amp;CurBench); const MIL_DOUBLE EpochBenchMean = CurBench / (CurEpochIndex + 1); MIL_DOUBLE DevLoss = 0; MclassGetHookInfo(EventId, M_DEV_DATASET_LOSS, &amp;DevLoss); pHookData-&gt;m_pTheDashboard-&gt;AddEpochData(DevLoss, CurEpochIndex, EpochBenchMean); return M_NULL; } //============================================================================== MIL_INT MFTYPE HookMiniBatchFunc(MIL_INT /*HookType*/, MIL_ID EventId, void* pUserData) { SHookMiniBatchData* pHookData = reinterpret_cast&lt;SHookMiniBatchData*&gt;(pUserData); MIL_DOUBLE Loss = 0; MclassGetHookInfo(EventId, M_MINI_BATCH_LOSS, &amp;Loss); MIL_INT MiniBatchIdx = 0; MclassGetHookInfo(EventId, M_MINI_BATCH_INDEX + M_TYPE_MIL_INT, &amp;MiniBatchIdx); MIL_INT EpochIdx = 0; MclassGetHookInfo(EventId, M_EPOCH_INDEX + M_TYPE_MIL_INT, &amp;EpochIdx); MIL_INT NbMiniBatchPerEpoch = 0; MclassGetHookInfo(EventId, M_MINI_BATCH_PER_EPOCH + M_TYPE_MIL_INT, &amp;NbMiniBatchPerEpoch); if(EpochIdx == 0 &amp;&amp; MiniBatchIdx == 0) { MappTimer(M_DEFAULT, M_TIMER_RESET, M_NULL); } pHookData-&gt;m_pTheDashboard-&gt;AddMiniBatchData(Loss, MiniBatchIdx, EpochIdx, NbMiniBatchPerEpoch); if(MosKbhit() != 0) { char KeyVal = (char)MosGetch(); if(KeyVal == 'p' || KeyVal == 'P') { MosPrintf(MIL_TEXT(\"\\nPress 's' to stop the training or any other key to continue.\\n\")); while(MosKbhit() == 0) { KeyVal = (char)MosGetch(); if(KeyVal == 's' || KeyVal == 'S') { MIL_ID HookInfoTrainResId = M_NULL; MclassGetHookInfo(EventId, M_RESULT_ID + M_TYPE_MIL_ID, &amp;HookInfoTrainResId); MclassControl(HookInfoTrainResId, M_DEFAULT, M_STOP_TRAIN, M_DEFAULT); MosPrintf(MIL_TEXT(\"The training has been stopped.\\n\")); break; } else { MosPrintf(MIL_TEXT(\"The training will continue.\\n\")); break; } } } } return(M_NULL); } //============================================================================== MIL_INT MFTYPE HookNumPreparedEntriesFunc(MIL_INT /*HookType*/, MIL_ID EventId, void* pUserData) { bool* pIsDevDataset = reinterpret_cast&lt;bool*&gt;(pUserData); MIL_ID SrcDataset {M_NULL}; MclassGetHookInfo(EventId, M_SRC_DATASET_ID + M_TYPE_MIL_ID, &amp;SrcDataset); MIL_INT NumPrpEntries {0}; MclassGetHookInfo(EventId, M_NUMBER_OF_PREPARED_SRC_ENTRIES + M_TYPE_MIL_INT, &amp;NumPrpEntries); const MIL_INT NumEntries = MclassInquire(SrcDataset, M_DEFAULT, M_NUMBER_OF_ENTRIES, M_NULL); if(NumPrpEntries == 1) { *pIsDevDataset ? MosPrintf(MIL_TEXT(\"Preparing the dev dataset...\\n\")) : MosPrintf(MIL_TEXT(\"Augmenting the train dataset...\\n\")); } MIL_INT Status {-1}; MclassGetHookInfo(EventId, M_STATUS + M_TYPE_MIL_INT, &amp;Status); const MIL_STRING StatusStr = ConvertPrepareDataStatusToStr(Status); MIL_TEXT_CHAR EndOfLine = '\\r'; if(Status != M_COMPLETE) { EndOfLine = '\\n'; } MosPrintf(MIL_TEXT(\"Entry %d of %d completed with status: %s.%c\"), NumPrpEntries, NumEntries, StatusStr.c_str(), EndOfLine); if(NumPrpEntries == NumEntries) { EndOfLine == '\\r' ? MosPrintf(MIL_TEXT(\"\\n\\n\")) : MosPrintf(MIL_TEXT(\"\\n\")); *pIsDevDataset = true; } return M_NULL; } ",
      "wordCount": 6243
    }
  ]
}]
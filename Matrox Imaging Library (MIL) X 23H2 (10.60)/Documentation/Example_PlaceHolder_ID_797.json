[{
  "id": "Example_PlaceHolder_ID",
  "version": "2024020714",
  "title": "Example_PlaceHolder_Title",
  "wordCount": 0,
  "subEntries": [
    {
      "id": "Examples_Processing_3dPreprocessing_PointCloudNeighborhoodPreparation_CPP_pointcloudneighborhoodpreparation_cpp",
      "version": "2024020714",
      "title": "pointcloudneighborhoodpreparation.cpp",
      "location": "Sample Code from MIL Examples",
      "text": " Top //***************************************************************************************/ // // File name: PointCloudNeighborhoodPreparation.cpp // Location: See Matrox Example Launcher in the MIL Control Center // // // Synopsis: This program demonstrates how to prepare point clouds for processing // functions making use of neighborhood operations. // // Copyright (C) Matrox Electronic Systems Ltd., 1992-2024. // All Rights Reserved //***************************************************************************************/ #include &lt;mil.h&gt; #include &lt;cstdlib&gt; #include &lt;cmath&gt; #include \"Utilities.h\" #include \"../../../3dUtil/C++/Display3dLinker.h\" #include &lt;cstdlib&gt; //****************************************************************************** // Constants. //****************************************************************************** static const MIL_INT NUMBER_CASES = 3; static const MIL_INT NUMBER_OF_CHIPS = 24; static const MIL_DOUBLE CHIP_DIMENSION = 25; static const MIL_DOUBLE CHIP_DIMENSION_TOLERANCE = 5; static const MIL_INT NUMBER_ORGANIZED_NEIGHBORS = 7; static const MIL_INT NUMBER_KDTREE_NEIGHBORS = 49; static const MIL_INT IDEAL_NUMBER_NEIGHBORS = 25; static const MIL_INT NUMBER_SAMPLES = 1024; static const MIL_DOUBLE DISTANCE_FACTOR = 15.0; static const MIL_DOUBLE MIN_NEIGHBORHOOD_HEALTH = 75.0; // in % static const MIL_DOUBLE MAX_ASPECT_RATIO = 3.0; //****************************************************************************** // Example files. //****************************************************************************** #define EX_PATH(x) (M_IMAGE_PATH MIL_TEXT(\"PointCloudNeighborhoodPreparation/\") MIL_TEXT(x)) static MIL_STRING FILE_PATHS[NUMBER_CASES] = { EX_PATH(\"OrganizedScanDepthMapContainer.mbufc\"), EX_PATH(\"OrganizedScanBadAspectRatio.mbufc\"), EX_PATH(\"UnorganizedScanBadAspectRatio.mbufc\"), }; //****************************************************************************** // Function declarations. //****************************************************************************** void PrintHeader(); MIL_DOUBLE ComputeNeighborSearchMaxDistance(MIL_ID MilSystem, MIL_ID MilPC, MIL_INT SearchMode); void AddNormals(MIL_ID MilSystem, MIL_INT MilContainer, const SNeighborSearchInfo&amp; NeighborSearcher); bool FindChips(MIL_ID MilSystem, MIL_INT GraList, MIL_ID MilPC); SNeighborStats ComputeNeighborStats(MIL_ID MilSystem, MIL_ID MilPC, const SNeighborSearchInfo&amp; NeighborSearcher, MIL_DOUBLE&amp; ExecTime); void FixNeighborhoodHealth(MIL_ID MilSystem, MIL_ID MilPC, MIL_DOUBLE MedianNbNeighbors, SNeighborSearchInfo&amp; NeighborSearcher); SStats ComputeAspectRatioStats(MIL_ID MilSystem, MIL_ID MilPC, const SNeighborSearchInfo&amp; NeighborSearcher, MIL_DOUBLE&amp; ExecTime); void FixAspectRatio(MIL_ID MilSystem, MIL_ID MilPC, MIL_DOUBLE MedianAspectRatio); void ComputeAndPrintStats(MIL_ID MilSystem, MIL_ID MilSrcPC, MIL_ID MilPreparedPC, SNeighborSearchInfo PreparedNeighborSearcher); void ComputeNeighborAndAspectRatioStats(MIL_ID MilSystem, MIL_ID MilPC, SNeighborSearchInfo NeighborSearcher, SNeighborStats&amp; NeighborStats, SStats&amp; ARStats); //******************************************************************************* // Prints the Example's description. //******************************************************************************* void PrintHeader() { MosPrintf(MIL_TEXT(\"[EXAMPLE NAME]\\n\") MIL_TEXT(\"PointCloudNeighborhoodPreparation\\n\\n\") MIL_TEXT(\"[SYNOPSIS]\\n\") MIL_TEXT(\"This example demonstrates how to prepare point clouds for processing functions\\n\") MIL_TEXT(\"making use of neighborhood operations, such as M3dimNormals and M3dmodFind.\\n\\n\") MIL_TEXT(\"[MODULES USED]\\n\") MIL_TEXT(\"Modules used: 3D Image Processing, 3D Display, 3D Model Finder,\\n\") MIL_TEXT(\"3D Geometry, 3D Graphics, Display, Image Processing, and Buffer.\\n\\n\")); } //******************************************************************************* // Computes the maximum distance for neighbor search queries. //******************************************************************************* MIL_DOUBLE ComputeNeighborSearchMaxDistance(MIL_ID MilSystem, MIL_ID MilPC, MIL_INT SearchMode) { MIL_DOUBLE MaxDistance; if(SearchMode == M_TREE) { // Compute the average density in the point cloud. // This is used to set the maximum distance constraint of the KD tree. auto MilDensityStatContext = M3dimAlloc(MilSystem, M_STATISTICS_CONTEXT, M_DEFAULT, M_UNIQUE_ID); auto MilDensityStatResult = M3dimAllocResult(MilSystem, M_STATISTICS_RESULT, M_DEFAULT, M_UNIQUE_ID); M3dimControl(MilDensityStatContext, M_NUMBER_OF_SAMPLES, NUMBER_SAMPLES); M3dimControl(MilDensityStatContext, M_DISTANCE_TO_NEAREST_NEIGHBOR, M_ENABLE); M3dimControl(MilDensityStatContext, M_CALCULATE_MEDIAN, M_ENABLE); M3dimStat(MilDensityStatContext, MilPC, MilDensityStatResult, M_DEFAULT); const auto MedianDistance = M3dimGetResult(MilDensityStatResult, M_DISTANCE_TO_NEAREST_NEIGHBOR_MEDIAN, M_NULL); MaxDistance = DISTANCE_FACTOR * MedianDistance; } else { // No distance constraint. MaxDistance = M_INFINITE; } return MaxDistance; } //******************************************************************************* // Adds a normals component to the container. //******************************************************************************* void AddNormals(MIL_ID MilSystem, MIL_INT MilContainer, const SNeighborSearchInfo&amp; NeighborSearcher) { auto MilNormalContext = M3dimAlloc(MilSystem, M_NORMALS_CONTEXT, M_DEFAULT, M_UNIQUE_ID); if(NeighborSearcher.SearchMode == M_ORGANIZED) { M3dimControl(MilNormalContext, M_NEIGHBOR_SEARCH_MODE, M_ORGANIZED); M3dimControl(MilNormalContext, M_NEIGHBORHOOD_ORGANIZED_SIZE, NUMBER_ORGANIZED_NEIGHBORS); } else { M3dimControl(MilNormalContext, M_NEIGHBOR_SEARCH_MODE, M_TREE); M3dimControl(MilNormalContext, M_MAXIMUM_NUMBER_NEIGHBORS, IDEAL_NUMBER_NEIGHBORS); M3dimControl(MilNormalContext, M_NEIGHBORHOOD_DISTANCE, NeighborSearcher.MaxDistance); } M3dimNormals(MilNormalContext, MilContainer, MilContainer, M_DEFAULT); } //******************************************************************************* // Finds the chips in the container using the rectangular plane 3D model finder. //******************************************************************************* bool FindChips(MIL_ID MilSystem, MIL_INT GraList, MIL_ID MilSrcContainer) { auto MilTempContainer = MbufAllocContainer(MilSystem, M_PROC | M_DISP, M_DEFAULT, M_UNIQUE_ID); MbufCopy(MilSrcContainer, MilTempContainer); auto MilModContext = M3dmodAlloc(MilSystem, M_FIND_RECTANGULAR_PLANE_CONTEXT, M_DEFAULT, M_UNIQUE_ID); auto MilModResult = M3dmodAllocResult(MilSystem, M_FIND_RECTANGULAR_PLANE_RESULT, M_DEFAULT, M_UNIQUE_ID); M3dmodDefine(MilModContext, M_ADD, M_RECTANGLE, CHIP_DIMENSION, CHIP_DIMENSION, CHIP_DIMENSION_TOLERANCE, CHIP_DIMENSION_TOLERANCE, M_DEFAULT, M_DEFAULT, M_DEFAULT); M3dmodControl(MilModContext, 0, M_NUMBER, NUMBER_OF_CHIPS); M3dmodPreprocess(MilModContext, M_DEFAULT); MappTimer(M_DEFAULT, M_TIMER_RESET + M_SYNCHRONOUS, M_NULL); M3dmodFind(MilModContext, MilTempContainer, MilModResult, M_DEFAULT); const auto Time = 1000*MappTimer(M_DEFAULT, M_TIMER_READ + M_SYNCHRONOUS, M_NULL); // in ms const auto ModStatus = M3dmodGetResult(MilModResult, M_DEFAULT, M_STATUS, M_NULL); const auto NbOccurences = (MIL_INT)M3dmodGetResult(MilModResult, M_DEFAULT, M_NUMBER, M_NULL); if(ModStatus == M_SUCCESS) { MosPrintf(MIL_TEXT(\"%d/%d occurences were found in %.0f ms. \"), NbOccurences, NUMBER_OF_CHIPS, Time); if(NbOccurences &gt; 0) { M3dmodDraw3d(M_DEFAULT, MilModResult, M_ALL, GraList, M_DEFAULT, M_DEFAULT); MosPrintf(MIL_TEXT(\"These are shown in the display.\")); } MosPrintf(MIL_TEXT(\"\\n\\n\")); WaitForKey(); } else { MosPrintf(MIL_TEXT(\"The model finder was not successful in its operation.\\n\\n\")); WaitForKey(); } return ModStatus == M_SUCCESS &amp;&amp; NbOccurences == NUMBER_OF_CHIPS; } //******************************************************************************* // Computes the neighborhood statistics. //******************************************************************************* SNeighborStats ComputeNeighborStats(MIL_ID MilSystem, MIL_ID MilPC, const SNeighborSearchInfo&amp; NeighborSearcher, MIL_DOUBLE&amp; ExecTime) { // Setup the statistics context, including the neighborhood healthy threshold // and the number of samples used for the statistic calculations. auto MilStatContext = M3dimAlloc(MilSystem, M_STATISTICS_CONTEXT, M_DEFAULT, M_UNIQUE_ID); M3dimControl(MilStatContext, M_NUMBER_OF_VALID_NEIGHBORS, M_ENABLE); M3dimControl(MilStatContext, M_CALCULATE_MEDIAN, M_ENABLE); M3dimControl(MilStatContext, M_CALCULATE_ROBUST_STDEV, M_ENABLE); M3dimControl(MilStatContext, M_NUMBER_OF_SAMPLES, NUMBER_SAMPLES); M3dimControl(MilStatContext, M_NEIGHBORHOOD_HEALTHY_THRESHOLD, IDEAL_NUMBER_NEIGHBORS); if(NeighborSearcher.SearchMode == M_ORGANIZED) { M3dimControl(MilStatContext, M_NEIGHBOR_SEARCH_MODE, M_ORGANIZED); M3dimControl(MilStatContext, M_NEIGHBORHOOD_ORGANIZED_SIZE, NUMBER_ORGANIZED_NEIGHBORS); } else // M_TREE { M3dimControl(MilStatContext, M_NEIGHBOR_SEARCH_MODE, M_TREE); M3dimControl(MilStatContext, M_MAX_DISTANCE, NeighborSearcher.MaxDistance); } // Compute and get the statistics. auto MilStatResult = M3dimAllocResult(MilSystem, M_STATISTICS_RESULT, M_DEFAULT, M_UNIQUE_ID); MappTimer(M_DEFAULT, M_TIMER_RESET + M_SYNCHRONOUS, M_NULL); M3dimStat(MilStatContext, MilPC, MilStatResult, M_DEFAULT); ExecTime = 1000 * MappTimer(M_DEFAULT, M_TIMER_READ + M_SYNCHRONOUS, M_NULL); SNeighborStats Stats; M3dimGetResult(MilStatResult, M_NUMBER_OF_VALID_NEIGHBORS_MEDIAN, &amp;Stats.Median); M3dimGetResult(MilStatResult, M_NUMBER_OF_VALID_NEIGHBORS_ROBUST_STDEV, &amp;Stats.RobustStdDev); M3dimGetResult(MilStatResult, M_NEIGHBORHOOD_HEALTHY_PERCENTAGE, &amp;Stats.NeighborhoodHealth); return Stats; } //******************************************************************************* // Fixes the neighborhood health by subsampling the point cloud or // removing the distance contraint. //******************************************************************************* void FixNeighborhoodHealth(MIL_ID MilSystem, MIL_ID MilPC, MIL_DOUBLE MedianNbNeighbors, SNeighborSearchInfo&amp; NeighborSearcher) { if(NeighborSearcher.SearchMode == M_ORGANIZED) { MosPrintf(MIL_TEXT(\"We will try to fix it by subsampling the point cloud.\\n\\n\")); WaitForKey(); auto MilLatticeContext = M3dimAlloc(MilSystem, M_LATTICE_CONTEXT, M_DEFAULT, M_UNIQUE_ID); auto MilSubsampleContext = M3dimAlloc(MilSystem, M_SUBSAMPLE_CONTEXT, M_DEFAULT, M_UNIQUE_ID); M3dimControl(MilLatticeContext, M_RELATIVE_CELL_SIZE_Z, M_INFINITE); M3dimControl(MilLatticeContext, M_RELATIVE_CELL_SIZE_Y, MAX_ASPECT_RATIO); // Compute the ideal neighborhood kernel dimension to achieve the minimum health threshold. const auto IdealKernelDimension = (std::sqrt(std::pow(NUMBER_ORGANIZED_NEIGHBORS, 2) * IDEAL_NUMBER_NEIGHBORS / MedianNbNeighbors)); // Use the ideal kernel dimension to sample the point cloud // such that the neighborhood health is restored while keeping the original kernel dimension. const auto SampleRatio = (MIL_DOUBLE)NUMBER_ORGANIZED_NEIGHBORS / IdealKernelDimension; M3dimControl(MilLatticeContext, M_FRACTION_OF_POINTS, SampleRatio); MappTimer(M_DEFAULT, M_TIMER_RESET + M_SYNCHRONOUS, M_NULL); M3dimLattice(MilLatticeContext, MilPC, M_NULL, MilSubsampleContext, M_DEFAULT); M3dimSample(MilSubsampleContext, MilPC, MilPC, M_DEFAULT); const auto ExecTime = 1000 * MappTimer(M_DEFAULT, M_TIMER_READ + M_SYNCHRONOUS, M_NULL); // in ms MosPrintf(MIL_TEXT(\"The subsampling took %.0f ms.\\n\\n\"), ExecTime); } else { MosPrintf(MIL_TEXT(\"We will switch off the distance constraint for KD tree neighbor queries.\\n\\n\")); NeighborSearcher.MaxDistance = M_INFINITE; } } //******************************************************************************* // Computes the aspect ratio's median and robust standard deviation. //******************************************************************************* SStats ComputeAspectRatioStats(MIL_ID MilSystem, MIL_ID MilPC, const SNeighborSearchInfo&amp; NeighborSearcher, MIL_DOUBLE&amp; ExecTime) { // Setup the statistics context. auto MilStatContext = M3dimAlloc(MilSystem, M_STATISTICS_CONTEXT, M_DEFAULT, M_UNIQUE_ID); M3dimControl(MilStatContext, M_NEIGHBORHOOD_ASPECT_RATIO, M_ENABLE); M3dimControl(MilStatContext, M_CALCULATE_MEDIAN, M_ENABLE); M3dimControl(MilStatContext, M_CALCULATE_ROBUST_STDEV, M_ENABLE); M3dimControl(MilStatContext, M_NUMBER_OF_SAMPLES, NUMBER_SAMPLES); if(NeighborSearcher.SearchMode == M_ORGANIZED) { M3dimControl(MilStatContext, M_NEIGHBOR_SEARCH_MODE, M_ORGANIZED); M3dimControl(MilStatContext, M_NEIGHBORHOOD_ORGANIZED_SIZE, NUMBER_ORGANIZED_NEIGHBORS); } else // M_TREE { M3dimControl(MilStatContext, M_NEIGHBOR_SEARCH_MODE, M_TREE); M3dimControl(MilStatContext, M_MAX_DISTANCE, NeighborSearcher.MaxDistance); } auto MilStatResult = M3dimAllocResult(MilSystem, M_STATISTICS_RESULT, M_DEFAULT, M_UNIQUE_ID); MappTimer(M_DEFAULT, M_TIMER_RESET + M_SYNCHRONOUS, M_NULL); M3dimStat(MilStatContext, MilPC, MilStatResult, M_DEFAULT); ExecTime = 1000 * MappTimer(M_DEFAULT, M_TIMER_READ + M_SYNCHRONOUS, M_NULL); SStats ARStats; M3dimGetResult(MilStatResult, M_NEIGHBORHOOD_ASPECT_RATIO_MEDIAN, &amp;ARStats.Median); M3dimGetResult(MilStatResult, M_NEIGHBORHOOD_ASPECT_RATIO_ROBUST_STDEV, &amp;ARStats.RobustStdDev); return ARStats; } //******************************************************************************* // Fixes the aspect ratio by uniformly subsampling the point cloud. //******************************************************************************* void FixAspectRatio(MIL_ID MilSystem, MIL_ID MilPC, MIL_DOUBLE MedianAspectRatio) { auto MilLatticeContext = M3dimAlloc(MilSystem, M_LATTICE_CONTEXT, M_DEFAULT, M_UNIQUE_ID); auto MilSubsampleContext = M3dimAlloc(MilSystem, M_SUBSAMPLE_CONTEXT, M_DEFAULT, M_UNIQUE_ID); // Uniformly sample the point cloud to achieve the desired aspect ratio. M3dimControl(MilLatticeContext, M_RELATIVE_CELL_SIZE_Z, M_INFINITE); M3dimControl(MilLatticeContext, M_RELATIVE_CELL_SIZE_X, 1); M3dimControl(MilLatticeContext, M_RELATIVE_CELL_SIZE_Y, 1); M3dimControl(MilLatticeContext, M_FRACTION_OF_POINTS, 2.0 / MedianAspectRatio); MappTimer(M_DEFAULT, M_TIMER_RESET + M_SYNCHRONOUS, M_NULL); M3dimLattice(MilLatticeContext, MilPC, M_NULL, MilSubsampleContext, M_DEFAULT); M3dimSample(MilSubsampleContext, MilPC, MilPC, M_DEFAULT); const auto ExecTime = 1000 * MappTimer(M_DEFAULT, M_TIMER_READ + M_SYNCHRONOUS, M_NULL); // in ms MosPrintf(MIL_TEXT(\"The subsampling took %.0f ms.\\n\\n\"), ExecTime); } //******************************************************************************* // Computes and prints statistics about the source and prepared containers. //******************************************************************************* void ComputeAndPrintStats(MIL_ID MilSystem, MIL_ID MilSrcPC, MIL_ID MilPreparedPC, SNeighborSearchInfo PreparedNeighborSearcher) { SNeighborSearchInfo SrcNeighborSearcher; SrcNeighborSearcher.SearchMode = PreparedNeighborSearcher.SearchMode; SrcNeighborSearcher.MaxDistance = ComputeNeighborSearchMaxDistance(MilSystem, MilSrcPC, SrcNeighborSearcher.SearchMode); SNeighborStats SrcNeighborStats; SStats SrcARStats; ComputeNeighborAndAspectRatioStats(MilSystem, MilSrcPC, SrcNeighborSearcher, SrcNeighborStats, SrcARStats); const auto NbSrcPoints = M3dimGet(MilSrcPC, M_COMPONENT_RANGE, M_DEFAULT, M_DEFAULT, M_NULL, M_NULL, M_NULL); SNeighborStats PreparedNeighborStats; SStats PreparedARStats; ComputeNeighborAndAspectRatioStats(MilSystem, MilPreparedPC, PreparedNeighborSearcher, PreparedNeighborStats, PreparedARStats); const auto NbPreparedPoints = M3dimGet(MilPreparedPC, M_COMPONENT_RANGE, M_DEFAULT, M_DEFAULT, M_NULL, M_NULL, M_NULL); MosPrintf(MIL_TEXT(\" Source point cloud Prepared point cloud \\n\")); MosPrintf(MIL_TEXT(\"--------------------------------------------------------------------\\n\")); MosPrintf(MIL_TEXT(\"Number of valid neighbors : %7.2f +/- %4.2f %7.2f +/- %4.2f\\n\"), SrcNeighborStats.Median, SrcNeighborStats.RobustStdDev, PreparedNeighborStats.Median, PreparedNeighborStats.RobustStdDev); MosPrintf(MIL_TEXT(\"Neighborhood health (%%) : %7.2f %7.2f\\n\"), SrcNeighborStats.NeighborhoodHealth, PreparedNeighborStats.NeighborhoodHealth); MosPrintf(MIL_TEXT(\"Local aspect ratio : %7.2f +/- %4.2f %7.2f +/- %4.2f\\n\"), SrcARStats.Median, SrcARStats.RobustStdDev, PreparedARStats.Median, PreparedARStats.RobustStdDev); MosPrintf(MIL_TEXT(\"Ratio of number of points : %7.2f %7.2f \\n\"), 1.0, (MIL_DOUBLE)NbPreparedPoints/(MIL_DOUBLE)NbSrcPoints); MosPrintf(MIL_TEXT(\"--------------------------------------------------------------------\\n\\n\")); WaitForKey(); } //******************************************************************************* // Computes the neighbor and aspect ratio stats. //******************************************************************************* void ComputeNeighborAndAspectRatioStats(MIL_ID MilSystem, MIL_ID MilPC, SNeighborSearchInfo NeighborSearcher, SNeighborStats&amp; NeighborStats, SStats&amp; ARStats) { MIL_DOUBLE DummyExecTime; NeighborStats = ComputeNeighborStats(MilSystem, MilPC, NeighborSearcher, DummyExecTime); if(NeighborStats.NeighborhoodHealth &lt; MIN_NEIGHBORHOOD_HEALTH &amp;&amp; NeighborSearcher.SearchMode == M_ORGANIZED) { // Since the organized neighborhood health is not good, // compute the aspect ratio using the KD tree // as the neighbor searcher. NeighborSearcher.SearchMode = M_TREE; } ARStats = ComputeAspectRatioStats(MilSystem, MilPC, NeighborSearcher, DummyExecTime); } //******************************************************************************* // Main function. //******************************************************************************* int MosMain(void) { PrintHeader(); // Allocate a MIL Application and System. auto MilApplication = MappAlloc(M_NULL, M_DEFAULT, M_UNIQUE_ID); auto MilSystem = MsysAlloc(M_DEFAULT, M_SYSTEM_HOST, M_DEFAULT, M_DEFAULT, M_UNIQUE_ID); WaitForKey(); // Allocate displays and destination buffers. auto MilSrcDisplay = Alloc3dDisplayId(MilSystem, SRC_DISPLAY_INFO.PositionX, SRC_DISPLAY_INFO.PositionY, SRC_DISPLAY_INFO.Size, SRC_DISPLAY_INFO.Size, SRC_DISPLAY_INFO.Title); if(!MilSrcDisplay) return EXIT_FAILURE; auto MilDstDisplay = Alloc3dDisplayId(MilSystem, DST_DISPLAY_INFO.PositionX, DST_DISPLAY_INFO.PositionY, DST_DISPLAY_INFO.Size, DST_DISPLAY_INFO.Size, DST_DISPLAY_INFO.Title); if(!MilDstDisplay) return EXIT_FAILURE; auto GraListSrc = M3ddispInquire(MilSrcDisplay, M_3D_GRAPHIC_LIST_ID, M_NULL); auto GraListDst = M3ddispInquire(MilDstDisplay, M_3D_GRAPHIC_LIST_ID, M_NULL); bool ExtraVerbose = true; auto MilOriginalPC = MbufAllocContainer(MilSystem, M_PROC | M_DISP, M_DEFAULT, M_UNIQUE_ID); for(MIL_INT i = 0; i &lt; NUMBER_CASES; ++i) { MosPrintf(MIL_TEXT(\"-------------------------------- Case %d/%d --------------------------------\\n\\n\"), i + 1, NUMBER_CASES); const auto FileExists = RestorePointCloud(MilSystem, FILE_PATHS[i], MilOriginalPC); if(!FileExists) { MosPrintf(MIL_TEXT(\"\\n\") MIL_TEXT(\"The file needed to run this example is missing. You need \\n\") MIL_TEXT(\"to obtain and apply a separate specific update to have it.\\n\\n\")); MosPrintf(MIL_TEXT(\"Press any key to end.\\n\\n\")); MosGetch(); return EXIT_FAILURE; } M3ddispSelect(MilSrcDisplay, MilOriginalPC, M_DEFAULT, M_DEFAULT); // Copy point cloud to keep original one intact. auto MilPC = MbufAllocContainer(MilSystem, M_PROC | M_DISP, M_DEFAULT, M_UNIQUE_ID); MbufCopy(MilOriginalPC, MilPC); // Synchronize displays. CDisplayLinker DisplayLinker({MilSrcDisplay, MilDstDisplay}); MosPrintf(MIL_TEXT(\"A point cloud of an array of microchips is displayed.\\n\")); MosPrintf(MIL_TEXT(\"We will try to find the microchips using the rectangular plane 3D model finder\\n\")); MosPrintf(MIL_TEXT(\"without any preprocessing steps.\\n\\n\")); WaitForKey(); SNeighborSearchInfo NeighborSearcher; NeighborSearcher.SearchMode = IsPointCloudOrganized(MilPC) ? M_ORGANIZED : M_TREE; if(NeighborSearcher.SearchMode == M_ORGANIZED) MosPrintf(MIL_TEXT(\"The point cloud is organized, so we will use the organized neighbor search mode.\\n\\n\")); else MosPrintf(MIL_TEXT(\"The point cloud is unorganized, so we will use the KD tree neighbor search mode.\\n\\n\")); WaitForKey(); // Adds normal component to point cloud. Needed for the 3D model finder operation. AddNormals(MilSystem, MilPC, NeighborSearcher); // Find the chips in the original point cloud. auto WasSuccessful = FindChips(MilSystem, GraListSrc, MilPC); if(!WasSuccessful) { MosPrintf(MIL_TEXT(\"The model finder did not find all the occurences.\\n\")); MosPrintf(MIL_TEXT(\"To diagnose the issue, we can compute and\\n\")); MosPrintf(MIL_TEXT(\"analyze some statistics about the point cloud.\\n\\n\")); } MosPrintf(MIL_TEXT(\"First, we will compute statistics about the point cloud's neighborhoods.\\n\\n\")); WaitForKey(); NeighborSearcher.MaxDistance = ComputeNeighborSearchMaxDistance(MilSystem, MilPC, NeighborSearcher.SearchMode); // Compute and get the neighbor statistics. MIL_DOUBLE ExecTime; const auto NeighborStats = ComputeNeighborStats(MilSystem, MilPC, NeighborSearcher, ExecTime); MosPrintf(MIL_TEXT(\"The median number of valid neighbors is %.2f +/- %.2f\\n\"), NeighborStats.Median, NeighborStats.RobustStdDev); MosPrintf(MIL_TEXT(\"and the neighborhood health is %.2f%%.\\n\"), NeighborStats.NeighborhoodHealth); MosPrintf(MIL_TEXT(\"The computation took %.f ms.\\n\\n\"), ExecTime); if(ExtraVerbose) { MosPrintf(MIL_TEXT(\"The \\\"Health\\\" metric indicates the percentage of points with\\n\") MIL_TEXT(\"at least % d valid neighbors.\\n\\n\"), IDEAL_NUMBER_NEIGHBORS); } WaitForKey(); // Check the neighborhood health. if(NeighborStats.NeighborhoodHealth &lt; MIN_NEIGHBORHOOD_HEALTH) { MosPrintf(MIL_TEXT(\"The neighborhood health is below the minimum threshold of %.2f%%.\\n\"), MIN_NEIGHBORHOOD_HEALTH); FixNeighborhoodHealth(MilSystem, MilPC, NeighborStats.Median, NeighborSearcher); if(i == 0) { ShowZoomedInConfidence(MilSystem, MilOriginalPC, MilPC, MilSrcDisplay, MilDstDisplay); } } else { MosPrintf(MIL_TEXT(\"The neighborhood health is above the mimimum threshold of %.2f%%.\\n\\n\"), MIN_NEIGHBORHOOD_HEALTH); } MosPrintf(MIL_TEXT(\"Second, we will compute the approximate local aspect ratio of the point cloud.\\n\\n\")); WaitForKey(); // Compute and get the aspect ratio statistics. const auto ARStats = ComputeAspectRatioStats(MilSystem, MilPC, NeighborSearcher, ExecTime); MosPrintf(MIL_TEXT(\"The median neighborhood aspect ratio is %.2f +/- %.2f.\\n\"), ARStats.Median, ARStats.RobustStdDev); MosPrintf(MIL_TEXT(\"The computation took %.f ms.\\n\\n\"), ExecTime); WaitForKey(); if(ExtraVerbose) { MosPrintf(MIL_TEXT(\"For processing functions such as normals computation and 3D plane finder,\\n\")); MosPrintf(MIL_TEXT(\"an aspect ratio closer to unity provides better results. \\n\\n\")); } // Check the aspect ratio. if(ARStats.Median &gt; MAX_ASPECT_RATIO) { MosPrintf(MIL_TEXT(\"The aspect ratio is greater than the maximum acceptable value of %.2f.\\n\"), MAX_ASPECT_RATIO); MosPrintf(MIL_TEXT(\"We will try to fix it by uniformly subsampling the point cloud.\\n\\n\")); WaitForKey(); FixAspectRatio(MilSystem, MilPC, ARStats.Median); // Update the KD tree maximum distance constraint for // the newly obtained point cloud. if(NeighborSearcher.SearchMode == M_TREE &amp;&amp; NeighborSearcher.MaxDistance != M_INFINITE) { NeighborSearcher.MaxDistance = ComputeNeighborSearchMaxDistance(MilSystem, MilPC, NeighborSearcher.SearchMode); } if(i == 1) { ShowZoomedInRegion(MilSystem, MilOriginalPC, MilPC, MilSrcDisplay, MilDstDisplay); } } else { MosPrintf(MIL_TEXT(\"The aspect ratio is below the maximum acceptable value of %.2f.\\n\\n\"), MAX_ASPECT_RATIO); } M3ddispSelect(MilDstDisplay, MilPC, M_SELECT, M_DEFAULT); MosPrintf(MIL_TEXT(\"The prepared point cloud is shown in the second display.\\n\\n\")); MosPrintf(MIL_TEXT(\"Some statistics will be shown for the original and prepared point clouds.\\n\\n\")); WaitForKey(); ComputeAndPrintStats(MilSystem, MilOriginalPC, MilPC, NeighborSearcher); MosPrintf(MIL_TEXT(\"We will now try to find the microchips using the newly prepared point cloud.\\n\\n\")); WaitForKey(); // Adds normal component to point cloud. Needed for the 3D model finder operation. AddNormals(MilSystem, MilPC, NeighborSearcher); // Find the chips in the subsampled point cloud. WasSuccessful = FindChips(MilSystem, GraListDst, MilPC); if(WasSuccessful) { MosPrintf(MIL_TEXT(\"All the instances were found.\\n\\n\")); } MosPrintf(MIL_TEXT(\"--------------------------------------------------------------------------\\n\\n\")); if(i &lt; NUMBER_CASES - 1) { MosPrintf(MIL_TEXT(\"Press any key to continue with the next case.\\n\\n\")); } M3dgraRemove(GraListSrc, M_ALL, M_DEFAULT); M3dgraRemove(GraListDst, M_ALL, M_DEFAULT); M3ddispSelect(MilSrcDisplay, M_NULL, M_CLOSE, M_DEFAULT); M3ddispSelect(MilDstDisplay, M_NULL, M_CLOSE, M_DEFAULT); ExtraVerbose = false; } MosPrintf(MIL_TEXT(\"Press any key to end.\\n\\n\")); MosGetch(); return 0; } ",
      "wordCount": 2052
    }
  ]
}]
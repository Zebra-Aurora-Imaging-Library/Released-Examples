[{
  "id": "UG_IOsignals",
  "version": "2024020714",
  "title": " I/O signals and communicating with external devices",
  "subTitles": null,
  "location": "MIL UG P09: Communication",
  "pageURL": "content\\UserGuide\\IOsignals\\ChapterInformation.htm",
  "text": " Chapter 56: I/O signals and communicating with external devices This chapter explains how to control and inquire non-video input and output (I/O) signals of your hardware. Note that not all Matrox products have I/O signals. For more information on I/O signals supported by your hardware, refer to the MIL Hardware-specific Notes for your Matrox product. Communicating with external devices using I/O signals overview Steps to use I/O signals Using Matrox Intellicam's Feature Browser Basic concepts when dealing with I/O signals Using input signals Polling the state of input signals Using interrupts with input signals Using input signals as triggers Setting up an output signal Routing a source to an output signal User-bits and controlling the state of output signals Timers and coordinating events Timers in the advanced I/O engine Delay and duration Timer modes: triggered or continuous Steps to set up timers Timer clock source Using quadrature input from a rotary encoder Interpreting the direction of movement from the Gray code Using the rotary decoder's counter Using the rotary decoder's output to trigger a timer or a grab Pixel aspect ratio Using I/O command lists Steps to use an I/O command list Scheduling I/O commands Commands that can be added to the I/O command list Using an I/O command list latch Examples Always grabbing an image when the conveyor belt is at a given position Parts traveling along a conveyor belt that are fixed in position example Different parts traveling along a conveyor belt that are ejected by different devices example Parts traveling along a conveyor belt that are not fixed in position example ",
  "wordCount": 266,
  "subEntries": [
    {
      "id": "UG_IOsignals_Communicating_with_external_devices_using_IO_signals_overview",
      "version": null,
      "title": " Communicating with external devices using I/O signals overview",
      "subTitles": null,
      "location": "MIL UG P09: Communication",
      "pageURL": "content\\UserGuide\\IOsignals\\Communicating_with_external_devices_using_IO_signals_overview.htm",
      "text": " Communicating with external devices using I/O signals overview Many non-video input and output signals on your camera, Matrox frame grabber (or interface board), or Matrox computer can be controlled using MIL to synchronize with, react to, and/or cause external events. For example, you can route input or output (I/O) signals for synchronizing with or controlling other devices, such as an external trigger device or a strobe light, respectively. These I/O signals are categorized into three groups: auxiliary signals, camera control signals, and transport layer signals. Depending on the signal, an I/O signal can support one or more functionalities, such as: Clock input or output. CSYNC, HSYNC, or VSYNC. Data valid. Exposure output. Field polarity input. I/O command register bit output. Pulse-train strobe output. Quadrature input. Timer output. Trigger input. Trigger signal bypass. User input. User output. For more information on which functionalities are supported by the signals of your hardware, refer to the Connectors and signal names section of the MIL Hardware-specific Notes chapter for your Matrox product. In addition, some products have an advanced I/O engine (for example, Iris GTX, or Indio), which refers to a series of hardware elements that allow you to communicate and coordinate events with I/O pins. These elements, like timers, I/O command lists, and rotary decoders are further described in this chapter. Only those I/O signals with matching MIL information are documented in MIL Help. Note that if your hardware supports I/O command lists, you can schedule commands to affect a bit of an I/O command register and route this bit's state to an output signal that supports this type of the output. You can schedule commands based on time or positional (rotary decoder) information. When working with I/O signals, you will primarily be using functions in the Digitizer module (MdigControl() and MdigInquire()) or the System module (MsysControl() and MsysInquire()), depending on your hardware. You can use Matrox Intellicam's Feature Browser to interactively test the digitizer and system settings in real-time; depending on your Matrox product, you can also save the settings selected in the Feature Browser to the DCF for your camera. Communicating with external devices using I/O signals overview ",
      "wordCount": 359,
      "subEntries": []
    },
    {
      "id": "UG_IOsignals_Steps_to_use_IO_signals",
      "version": null,
      "title": "Steps to use I/O signals",
      "subTitles": [
        "Using Matrox Intellicam's Feature Browser"
      ],
      "location": "MIL UG P09: Communication",
      "pageURL": "content\\UserGuide\\IOsignals\\Steps_to_use_IO_signals.htm",
      "text": " Steps to use I/O signals The following steps provide a typical methodology to use I/O signals. Note that, depending on your hardware, you will need to use either the MdigControl() and MdigInquire() functions, or the MsysControl() and MsysInquire() functions, to control or inquire about the I/O signal. For more information on which function to use, refer to the Connectors and signal names section of the MIL Hardware-specific Notes chapter for your Matrox product. If the I/O signal can be transmitted using one of several formats and the default setting is not appropriate, specify the format using MdigControl() or MsysControl() with M_IO_FORMAT. For an output signal, set-up the source of the signal. For example, if you want to route the output of a timer to an I/O signal, you can use MdigControl() with M_TIMER_... control types to set-up the timer. Configure the I/O signal according to its purpose. For output signals (or bidirectional signals that you will set to output mode), specify the type of signal to be routed to it, using MdigControl() or MsysControl() with M_IO_SOURCE. For input signals (or bidirectional signals that you will set to input mode), specify the input signal (M_AUX_IOn) as the source of the required event. For example, specify auxiliary input signal M_AUX_IO5 as the signal to use to trigger a grab operation (MdigControl() with M_GRAB_TRIGGER_SOURCE set to M_AUX_IO5). You can also poll the state of an input signal using MdigInquire() or MsysInquire() with M_IO_STATUS, and act upon it. Note that step #2 does not necessarily need to be performed before step #3; however, it ensures that you know what is being routed on the signal initially. If the I/O signal is a bidirectional signal, specify its mode (direction) using MdigControl() or MsysControl() with M_IO_MODE set to either M_INPUT or M_OUTPUT. Note that in some cases, the bidirectional signal is full-duplex, which can receive input signals and transmit output signals simultaneously (for example, transport layer (TL) trigger signals). For full-duplex signals, you typically do not have to set the mode of the signal unless you are inquiring its state; that is, call MdigControl() or MsysControl() with M_IO_MODE, followed by a call to MdigInquire() or MsysInquire() with M_IO_STATUS. Using Matrox Intellicam's Feature Browser You can test settings for I/O signals and other hardware-specific features interactively in real-time with Matrox Intellicam's Feature Browser. That is, you can use this interactive user interface to set any of the MdigControl() and MsysControl() (and MdigControlFeature()) control types available for your Matrox product, and then inquire the results immediately. For example, you can fine-tune the duration of a timer output signal's delay and active portion by adjusting the values in the Matrox Feature Browser, and verify the result in real-time; otherwise, you would have to re-compile your application program each time you made an adjustment to see the effects of the change. To help build your application program, Matrox Intellicam's Feature Browser provides code snippets with the MIL functions and MIL constants associated with your selected settings. You can copy and paste these code snippets into your application's code. For information on how to use Matrox Intellicam's Feature Browser, refer to the Matrox Intellicam Help. To verify if you can save the settings you selected using the Feature Browser directly to the DCF for your camera, refer to the Using your Matrox product with MIL section of the MIL Hardware-specific Notes chapter for your Matrox product. Steps to use I/O signals Using Matrox Intellicam's Feature Browser ",
      "wordCount": 577,
      "subEntries": []
    },
    {
      "id": "UG_IOsignals_Basic_concepts_when_dealing_with_the_IO_signals",
      "version": null,
      "title": "Basic concepts when dealing with I/O signals",
      "subTitles": null,
      "location": "MIL UG P09: Communication",
      "pageURL": "content\\UserGuide\\IOsignals\\Basic_concepts_when_dealing_with_the_IO_signals.htm",
      "text": " Basic concepts when dealing with I/O signals The basic concepts and vocabulary conventions when dealing with I/O signals are: Auxiliary signal. A non-video signal that can be controlled and supports one or more functionalities. Bit-encoded value. A number whose bits each represent a setting. Camera control signal (CC signal). A signal that can only be routed to the camera because it is transmitted on the same cable as is used to receive video. Input/output signal (I/O signal). A non-video signal that can be used to send or receive non-video information from another device. The term encompasses input signals, output signals, and bidirectional signals that can be configured to be used as either an input signal or an output signal. Interrupt. A notification that an event occurred. If an event handler (hooked function) has been set up to handle this event, it will start executing upon receiving notification that the event occurred. Transport layer signal (TL signal). The transport layer signal, typically a trigger signal, is an embedded bidirectional signal transmitted on the physical transport layer connection with your CoaXPress standard-compliant camera. Typically, the TL signal is bundled with other control and data signals along the same cable, and is therefore not pin-specific nor is it listed in the pin-out tables for your board. User-bit. A bit in a static-user-output register. A user-bit can be routed to an output signal (or a bidirectional signal set to output) to control its state (high or low). Static-user-output register. A register whose bits can be used to control the state of output signals (or bidirectional signals set to output). These bits, often referred to as user-bits, remain the same (static) until changed by the application. Signal format. The format of the signal specifies the electrical characteristics of the signal that is transmitted/received. Basic concepts when dealing with I/O signals ",
      "wordCount": 307,
      "subEntries": []
    },
    {
      "id": "UG_IOsignals_Using_user_input_signals",
      "version": null,
      "title": "Using input signals",
      "subTitles": [
        "Polling the state of input signals",
        "Using interrupts with input signals",
        "Using input signals as triggers"
      ],
      "location": "MIL UG P09: Communication",
      "pageURL": "content\\UserGuide\\IOsignals\\Using_user_input_signals.htm",
      "text": " Using input signals You can route any external signal that meets electrical specifications, to an auxiliary input signal (or a bidirectional I/O signal set to input); your application can then use it for a specific purpose, as long as the functionality is supported by the auxiliary input signal. For example, if the input signal supports user input (user-defined input), you can poll (inquire) the state of the input signal to monitor or react to its state. Alternatively, if your hardware supports it, you can enable the generation of an interrupt when the user input signal changes state, and then hook a function to it. You can also use an input signal as a trigger for some operation or performing image acquisition. Some Matrox boards can also decode an input from a rotary encoder, which you can use to trigger an event; for more information on rotary decoders, refer to the Using quadrature input from a rotary encoder section later in this chapter. Depending on your hardware, you will need to use either the Mdig...() functions or the Msys...() functions to use the input signals. For more information on which functions to use and which functionalities are supported by the signals for your hardware, refer to the Connectors and signal names section of the MIL Hardware-specific Notes chapter for your Matrox product. Polling the state of input signals For input signals (or bidirectional I/O signals set to input) which support user input, you can use a continuous loop to poll (inquire) the input signal to determine if it is high or low, and then, react to its state or a change in its state. To inquire the current state of one specific I/O signal, use either MdigInquire() or MsysInquire() with M_IO_STATUS. To inquire the current state of all the I/O signals, use either MdigInquire() or MsysInquire() with M_IO_STATUS_ALL. M_IO_STATUS_ALL returns a bit-encoded value that specifies the current state of each of the input and output signals of your hardware (if their state is inquirable), whereby M_AUX_IO0 is represented by the least-significant bit of the bit-encoded value. For example, inquiring M_IO_STATUS_ALL for auxiliary signals could return 0x44, equivalent to 101100 in binary, which would mean that I/O signals associated with MIL constants M_AUX_IO2, M_AUX_IO3, and M_AUX_IO5 are high, and all other I/O signals are low. Note that the state of certain signals cannot be inquired (for example, signals exclusively dedicated for triggers). When using M_IO_STATUS_ALL to inquire the status of all the I/O signals, if there are I/O signals that cannot be inquired, the bits representing those signals, in the bit-encoded value returned, are not necessarily valid; these bits should be ignored. Using interrupts with input signals If supported in hardware, instead of polling an input signal (that supports user input) to check its state and react to it, you can have a signal generate an interrupt when it changes state. You can then hook a function to this event to perform some operation or action upon this event. To react to a change in the state of a specified input signal, based on an interrupt, perform the following steps: Specify whether the input signal should generate an interrupt upon a rising edge, falling edge, or both, using either MdigControl() or MsysControl() with M_IO_INTERRUPT_ACTIVATION + M_AUX_IOn. Hook a function to the input signal's change of state, using either MdigHookFunction() or MsysHookFunction() with M_IO_CHANGE. Within the scope of the hook function itself, inquire which signal(s) generated the interrupt, using either MdigGetHookInfo() or MsysGetHookInfo() with M_IO_INTERRUPT_SOURCE, and then, execute according to the result of the inquiry. If the signal to be used is a bidirectional signal, set the signal to input mode, using either MdigControl() or MsysControl() with M_IO_MODE + M_AUX_IOn set to M_INPUT. Enable the interrupt state for the input signal, using M_IO_INTERRUPT_STATE + M_AUX_IOn set to M_ENABLE. The following code snippet demonstates how to declare your hook handler function and to use an auxiliary input signal (M_AUX_IO8) to generate an interrupt when its state changes from low to high. /* Hook function declaration. */ MIL_INT MFTYPE HookHandlerFnct(MIL_INT HookType, MIL_ID EventId, void* UserDataPtr) { MIL_INT IOSource = 0; MdigGetHookInfo(EventId, M_IO_INTERRUPT_SOURCE, &amp;IOSource); // IOSource will be M_AUX_IO8 when interrupt is fired. if (IOSource == M_AUX_IO8) { /* Perform some action.*/ } return 0; } void UsingInputSignals(MIL_ID MilDigitizer, MIL_ID MilImage) { void* HookData = 0; /* Specify to generate an interrupt upon the low-to-high input signal state transition. */ MdigControl(MilDigitizer, M_IO_INTERRUPT_ACTIVATION + M_AUX_IO8, M_EDGE_RISING); /* Specify to hook a function to the specified interrupt. */ MdigHookFunction(MilDigitizer, M_IO_CHANGE, HookHandlerFnct, (void*) &amp;HookData); /* Enable the specified interrupt. */ MdigControl(MilDigitizer, M_IO_INTERRUPT_STATE + M_AUX_IO8, M_ENABLE); /* ... */ Using input signals as triggers If supported in hardware, you can use an input signal (or a bidirectional signal set to input) as a trigger source. For example, you can specify to use a specific input signal to trigger a timer using MdigControl() with M_TIMER_TRIGGER_SOURCE set to M_AUX_IOn, or you can use a specific input signal to trigger image acquisition using MdigControl() with M_GRAB_TRIGGER_SOURCE set to M_AUX_IOn. You must establish how to use the signal to trigger, using MdigControl() with M_TIMER_TRIGGER_ACTIVATION or M_GRAB_TRIGGER_ACTIVATION; you can specify whether to generate a trigger upon a signal state transition or to trigger continuously according to signal polarity (high or low state). To use the trigger signal, you must first enable the timer or enable grabbing upon a trigger, so that it is ready to receive a trigger signal; to do so, use MdigControl() with M_TIMER_STATE or M_GRAB_TRIGGER_STATE, respectively. For information on this topic, see the Grabbing with triggers section of Chapter 27: Grabbing with your digitizer. The following code snippet demonstrates how to use auxiliary input signal 1 (M_AUX_IO1) to trigger the grab of an image sent from a connected camera. /* Specify to use an input signal as the trigger source for grabbing an image.*/ MdigControl(MilDigitizer, M_GRAB_TRIGGER_SOURCE, M_AUX_IO1); /* Specify to trigger the grab when the signal transitions from low to high.*/ MdigControl(MilDigitizer, M_GRAB_TRIGGER_ACTIVATION, M_EDGE_RISING); /* Enable digitizer to wait for a trigger to grab. */ MdigControl(MilDigitizer, M_GRAB_TRIGGER_STATE, M_ENABLE); /* Execute grab (upon trigger). */ MdigGrab(MilDigitizer, MilImage); Using input signals Polling the state of input signals Using interrupts with input signals Using input signals as triggers ",
      "wordCount": 1035,
      "subEntries": []
    },
    {
      "id": "UG_IOsignals_Setting_up_an_output_signal",
      "version": null,
      "title": "Setting up an output signal",
      "subTitles": [
        "Routing a source to an output signal",
        "User-bits and controlling the state of output signals"
      ],
      "location": "MIL UG P09: Communication",
      "pageURL": "content\\UserGuide\\IOsignals\\Setting_up_an_output_signal.htm",
      "text": " Setting up an output signal Before using an output signal, you have to specify its purpose; that is, you must establish the type of signal that will be routed to it. For example, you can route the output of a timer to a specific output signal, to control or synchronize with an external device. Most output signals can also output a user signal to start or stop an event; in this case, you essentially route the state (on or off) of a bit of a static-user-output register to the output signal. In addition, certain auxiliary input signals can be rerouted to certain output signals. Depending on your hardware, you will need to use either the MdigControl() and MdigInquire() functions, or the MsysControl() and MsysInquire() functions to use the output signals. For more information on which function to use, refer to the Connectors and signal names section of the MIL Hardware-specific Notes chapter for your Matrox product. Routing a source to an output signal The source of an output signal (or a bidirectional signal set to output) is typically specified by the DCF. Otherwise, by default, the source is set to the signal's associated bit in a static-user-output register; for more information, see the User-bits and controlling the state of output signals subsection of this section. Use MdigControl() or MsysControl() with M_IO_SOURCE to specify the source of an output signal. For information on which type of signal can be routed onto a specific pin/signal, refer to the Connectors and signal names section of the MIL Hardware-specific Notes chapter for your Matrox product. For example, the camera control (CC) output signals of Matrox Radient eCL support timer output, user output, VSYNC output, HSYNC output, clock output, or rerouting of specific auxiliary input signals. You can set the source of these CC signals to any one of these types of signals. For instance, using MdigControl(), you can set the source of M_CC_IO1 to M_TIMER1 to control when a camera will expose its CCD, and set the source of M_CC_IO2 to M_TIMER2 to control a strobe light, such that the strobe light is only on when the camera's CCD is exposed. You can verify the state (on or off) of a specific signal or of all signals using MdigInquire() or MsysInquire() (depending on your hardware), with M_IO_STATUS or M_IO_STATUS_ALL, respectively. Note that the state of certain signals cannot be inquired (for example, most auxiliary output signals). When using M_IO_STATUS_ALL to inquire the status of all the I/O signals, if there are I/O signals that cannot be inquired, the bits representing those signals, in the bit-encoded value returned, are not necessarily valid; these bits should be ignored. For details on how to use M_IO_STATUS or M_IO_STATUS_ALL to inquire the state of a signal, refer to the Polling the state of input signals subsection of the Using input signals section earlier in this chapter. Note that, if you set the signal mode (direction) before setting up the source of the signal, the signal will begin transmitting the default source. If the state of the default source for the signal is not appropriate, you must set up the source of the signal before setting its mode. In the following code snippet, a bidirectional signal (M_AUX_IO9 on a Matrox Solios eA/XA), which can be transmitted in one of two formats (TTL or LVDS), is set. /* M_AUX_IO9 can be transmitted in TTL or LVDS format. Specify the TTL format. */ MdigControl(MilDigitizer, M_IO_FORMAT + M_AUX_IO9, M_TTL); /* Set the source of the signal to timer 1. */ MdigControl(MilDigitizer, M_IO_SOURCE + M_AUX_IO9, M_TIMER1); /* If the signal is a bidirectional signal, specify the mode. */ MdigControl(MilDigitizer, M_IO_MODE + M_AUX_IO9, M_OUTPUT); User-bits and controlling the state of output signals If you have results that you would like to use to control an external device (for example, to start or stop a process), you can do so by controlling the bits of a static-user-output register. These bits, often referred to as user-bits, can be used to control the state of output signals (or bidirectional signals set to output). Note that most output signals can only output a specific bit. This bit is denoted in the Connectors and signal names section of the MIL Hardware-specific Notes chapter for your Matrox product. The MIL I/O signal number is not necessarily the bit number. For all hardware supporting I/O signals that can transmit user output, there is a static-user-output register for the auxiliary signals, referred to as the main static-user-output register. If your hardware has a Camera Link connector, there will be a 2-bit register whose bits can be routed to the camera control (CC) signals (M_USER_BIT_CC_IO). If your hardware supports transport layer (TL) signals, there will be a 1-bit register whose bit can be routed to the TL trigger signal (M_USER_BIT_TL_TRIGGER0). Only the bits in the static-user-output registers associated with the output signals are meaningful; the other bits are ignored. To route the state of a user-bit to an output signal, use MdigControl() or MsysControl() with M_IO_SOURCE and M_USER_BITn. To set the state of a specific bit in any static-user-output register, use MdigControl() or MsysControl() with M_USER_BIT_STATE and combine it with M_USER_BITn, M_USER_BIT_CC_IOn, or M_USER_BIT_TL_TRIGGER, depending on the bit to affect. To simultaneously set or inquire the state of all the bits in a static-user-output register, use MdigControl() / MsysControl() or MdigInquire() / MsysInquire() (respectively), with M_USER_BIT_STATE_ALL; use this MIL constant with a combination value to specify the static-user-output register to affect (for example, use M_USER_BIT_STATE_ALL + M_USER_BIT_CC_IO for the camera control static-user-output register). When setting M_USER_BIT_STATE_ALL, specify a control value in the form of a bit-encoded value that establishes the state of all the bits of the specified static-user-output register. For example, setting M_USER_BIT_STATE_ALL to 0x44 (hexadecimal equivalent to 101100 in binary), sets M_USER_BIT2, M_USER_BIT3, and M_USER_BIT5 to a value of 1, and sets all other bits to 0. Note that, when inquiring the state of all the bits, the return value is also a bit-encoded value that specifies the current setting of each bit, where M_USER_BIT0 is represented by the least-significant bit of the bit-encoded value. The following code snippet demonstrates how to route the state of two user-bits (M_USER_BIT5 and M_USER_BIT0) to their corresponding auxiliary I/O signal (M_AUX_IO3 and M_AUX_IO12). Recall that the number of a user-bit and its corresponding auxiliary I/O signal are not necessarily the same; it depends on the board (in this snippet, the numbers of Matrox Radient eCL were used). Initially, the state of the two user-bits are set to 0, so a low signal is outputted. The snippet then shows how to change the two bits and their associated auxiliary I/O signals simultaneously, without affecting the other user-bits (and their associated signals). /* In this example, M_AUX_IO3 is a bidirectional signal and M_AUX_IO12 is an output signal. */ /* For the board in question, only the state of user-bit 5 can be routed to M_AUX_IO3 */ /* (in output mode), while only the state of user-bit 0 can be routed to M_AUX_IO12. */ /* Set the initial state of bit 5 and 0 of the main static-user-output register to off.*/ MsysControl(MilSystem, M_USER_BIT_STATE + M_USER_BIT5, M_OFF); MsysControl(MilSystem, M_USER_BIT_STATE + M_USER_BIT0, M_OFF); /* Set the source of the output signal to user-bit 5 and 0. */ MsysControl(MilSystem, M_IO_SOURCE + M_AUX_IO3, M_USER_BIT5); MsysControl(MilSystem, M_IO_SOURCE + M_AUX_IO12, M_USER_BIT0); /* Set bidirectional signal M_AUX_IO3 to output mode. */ MsysControl(MilSystem, M_IO_MODE + M_AUX_IO3, M_OUTPUT); /* Perform some operation that establishes whether user-bit 5 and/or 0 should be set to on. */ /* Store the result in ResultOfOperation. */ /* ... */ /* Set user-bits 5 and 0 according to the calculated results, while leaving all other */ /* user-bits in their current state. */ MsysInquire(MilSystem, M_USER_BIT_STATE_ALL, &amp;CurrentValueOfAllBits); switch (ResultOfOperation) { case 0: /* Set user-bit 5 to off and user-bit 0 to off. */ MsysControl(MilSystem, M_USER_BIT_STATE_ALL, (CurrentValueOfAllBits &amp; ~0x0021) | 0x0000); break; case 1: /* Set user-bit 5 to on and user-bit 0 to off. */ MsysControl(MilSystem, M_USER_BIT_STATE_ALL, (CurrentValueOfAllBits &amp; ~0x0021) | 0x0020); break; case 2: /* Set user-bit 5 to off and user-bit 0 to on. */ MsysControl(MilSystem, M_USER_BIT_STATE_ALL, (CurrentValueOfAllBits &amp; ~0x0021) | 0x0001); break; case 3: /* Set user-bit 5 to on and user-bit 0 to on. */ MsysControl(MilSystem, M_USER_BIT_STATE_ALL, (CurrentValueOfAllBits &amp; ~0x0021) | 0x0021); break; } Setting up an output signal Routing a source to an output signal User-bits and controlling the state of output signals ",
      "wordCount": 1399,
      "subEntries": []
    },
    {
      "id": "UG_IOsignals_Timers_and_coordinating_events",
      "version": null,
      "title": "Timers and coordinating events",
      "subTitles": [
        "Timers in the advanced I/O engine",
        "Delay and duration",
        "Timer modes: triggered or continuous",
        "Steps to set up timers",
        "Timer clock source"
      ],
      "location": "MIL UG P09: Communication",
      "pageURL": "content\\UserGuide\\IOsignals\\Timers_and_coordinating_events.htm",
      "text": " Timers and coordinating events Some frame grabbers have on-board timers that can be used with I/O signals to coordinate events with external devices. For example, when grabbing an image (with camera reset), you can use an auxiliary input signal as a trigger source for a timer, and use an auxiliary output signal to route the timer's output to initiate and set the duration of the camera exposure. For information on which signals can be used to trigger a timer and which can be used to route a timer's output, refer to the Connectors and signal names section of the MIL Hardware-specific Notes chapter for your Matrox product. Timers in the advanced I/O engine Some products also include a Matrox Advanced I/O engine, which is a series of hardware elements that allows you to communicate and coordinate events through I/O pins. The following diagram shows a functional diagram of the internal organization of a timer in the Matrox Advanced I/O engine. The diagram below illustrates the logic of the timer's controller found in the advanced I/O engine. Delay and duration A timer can output a signal, typically with one pulse (one low and one high segment) per cycle. You can set-up a timer to output a signal with one pulse per cycle either using MIL or in the DCF. For the few timers that can output a signal with one or two pulses per cycle, you can only set them up to output two pulses per cycle using the DCF. If you want to send the output of a timer to an auxiliary output signal, you should set up the timer before you call MdigControl() with M_IO_SOURCE set to M_TIMERn. In MIL, to specify the length of the segments (one low and one high) of the timer output signal, use MdigControl() with M_TIMER_DELAY and M_TIMER_DURATION. The timer delay (M_TIMER_DELAY) is the length of time before the active portion of the signal (M_TIMER_DURATION); the length of the active portion is often referred to as the timer duration. Typically, the specified delay segment is low and the specified duration is high (active-high signal). However, you can invert the signal, such that the specified delay segment is high and the specified duration is low (active-low signal), using MdigControl() with M_TIMER_OUTPUT_INVERTER. The following illustration demonstrates two timers with the same settings, except that timer 1 has M_TIMER_OUTPUT_INVERTER set to M_DISABLE and timer 2 has M_TIMER_OUTPUT_INVERTER set to M_ENABLE. Timer modes: triggered or continuous A timer can operate in one of two modes: triggered or continuous. In triggered mode, an enabled timer waits to receive a trigger signal, before it begins to output a signal with the specified delay and duration. To specify the trigger signal, use MdigControl() with M_TIMER_TRIGGER_SOURCE. To specify when, upon receiving the trigger signal, to activate the timer to output a signal, use MdigControl() with M_TIMER_TRIGGER_ACTIVATION; you can typically activate the timer upon a state transition (low-to-high or high-to-low) of the specified trigger signal. If supported by your digitizer, you can also trigger a timer with a software trigger. To do so, set the trigger source to software using MdigControl() with M_TIMER_TRIGGER_SOURCE set to M_SOFTWARE. Then, to issue the software trigger for the timer, call MdigControl() with M_TIMER_TRIGGER_SOFTWARE + M_TIMERn. In continuous mode, the timer starts to output a signal when it is enabled, and repeats the same cycle until the timer is disabled. You can use this type of signal, for example, to perform a task at fixed time intervals or to act as a clock. To set up your timer to output a signal continuously, use MdigControl() with M_TIMER_TRIGGER_SOURCE set to M_CONTINUOUS. To enable or disable a timer, use MdigControl() with M_TIMER_STATE. Steps to set up timers The illustration below is a visual summary of the group of MIL constants used to set up timers. Callout # MdigControl() control type Callout # MdigControl() control type 1 M_TIMER_STATE + M_TIMER1 5 M_TIMER_OUTPUT_INVERTER + M_TIMER1 2 M_TIMER_CLOCK_SOURCE + M_TIMER1 6 M_TIMER_DELAY + M_TIMER1 3 M_TIMER_TRIGGER_SOURCE + M_TIMER1 7 M_TIMER_DURATION + M_TIMER1 4 M_TIMER_TRIGGER_ACTIVATION + M_TIMER1 Perform the following steps to set up timer n (for example, timer 1): If the default is not appropriate, specify the clock source for the timer using MdigControl() with M_TIMER_CLOCK_SOURCE + M_TIMERn. For more information, see the Timer clock source subsection of this section. Specify the mode in which you will be using the timer. To use the timer in triggered mode, specify the signal to use as the trigger, using MdigControl() with M_TIMER_TRIGGER_SOURCE + M_TIMERn. To use the timer in continous mode, set M_TIMER_TRIGGER_SOURCE + M_TIMERn to M_CONTINUOUS. Note that, the output of a timer cannot be used as a trigger source for itself. Specify the timer delay (in nsec) using MdigControl() with M_TIMER_DELAY. Note that the delay must be greater than 0; otherwise, an error will be generated. Specify the duration of the active portion (in nsec) using MdigControl() with M_TIMER_DURATION. Note that this value must be greater than 0; otherwise, an error will be generated. In triggered mode, specify the trigger signal transition upon which to trigger the timer to begin transmitting, using MdigControl() with M_TIMER_TRIGGER_ACTIVATION + M_TIMERn. If you want the timer to output an active-low signal, invert the output of the timer using MdigControl() with M_TIMER_OUTPUT_INVERTER + M_TIMERn. Finally, use MdigControl() with M_TIMER_STATE + M_TIMERn to enable the timer. If in triggered mode, the timer will wait for a trigger signal before transmitting its output signal, with its specified delay and active time (duration). In the following code snippet, an auxiliary input signal ( M_AUX_IO1) is used as a trigger for timer 1; the timer output signal is sent to a connected camera. /* Specify to use an input signal as the trigger source for a timer. */ MdigControl(MilDigitizer, M_TIMER_TRIGGER_SOURCE + M_TIMER1, M_AUX_IO1); /* Set the delay between the trigger and the active portion of the timer to 1000 nsec. */ MdigControl(MilDigitizer, M_TIMER_DELAY + M_TIMER1, 1000); /* Set the duration of the active portion for the timer to 1 msec (1 million nsec). */ MdigControl(MilDigitizer, M_TIMER_DURATION + M_TIMER1, 1000000); /* Specify to trigger the timer when the trigger signal changes from low to high.*/ MdigControl(MilDigitizer, M_TIMER_TRIGGER_ACTIVATION + M_TIMER1, M_EDGE_RISING); /* Route the output of the timer onto a camera control output signal. */ MdigControl(MilDigitizer, M_IO_SOURCE + M_CC_IO1, M_TIMER1); /* Enable the timer to wait for a trigger.*/ MdigControl(MilDigitizer, M_TIMER_STATE + M_TIMER1, M_ENABLE); Timer clock source Although you set a timer in nanoseconds, a timer actually counts clock ticks; the numbers you enter are internally converted to clock ticks. The duration of each clock tick depends on the clock source. For some Matrox products that have timers, the clock that drives the specified timer is selectable using MdigControl() with M_TIMER_CLOCK_SOURCE. Typically, the default clock source is the pixel clock from the camera (M_PIXCLK). The timer output delay and active portion (M_TIMER_DELAY and M_TIMER_DURATION, respectively) must each be at least equivalent to one clock tick and be set within the hardware limitations of the timer, otherwise an error will be generated. The maximum time lapse (in seconds) of a timer before it resets is the maximum number of ticks that the timer can count up to divided by the frequency (f) of the clock source. For example, if a timer resets after a maximum of 16,777,215 clock ticks, and the clock frequency is 85 MHz, the summed value of M_TIMER_DELAY and M_TIMER_DURATION cannot be greater than 197 msec (16,777,215 clock ticks/85 MHz). Note that in some cases, you can adjust the clock source frequency in the DCF, within a limited range, to permit the required number of clock ticks per timer output cycle. To inquire the frequency of the clock that drives a specific timer, use MdigInquire() with M_TIMER_CLOCK_FREQUENCY + M_TIMERn. If your hardware supports at least two timers and if the available timer clock sources are not appropriate for your application, you can create your own clock using a timer. For example, if the clock frequency of your timer is very high, the maximum number of clock ticks that your timer supports might not be enough to generate a signal with the required period (delay + duration). In the following illustration, the first signal has a frequency of 4 Hz and represents the default clock source of timer 1. The second signal is timer 1's output (in continuous mode) with a cycle (timer delay + active portion), equivalent to 4 cycles of the default clock source (1 Hz). If timer 1's output is used as the clock source for another timer (for example, timer 2), then timer 2's output can be up to 4 times longer than when using the default clock source, but will lose 4 times the granularity. Note that a timer output cannot be a clock source for itself. The following code snippet demonstrates how to use one timer as a clock source for another; timer 2 uses timer 1 as a clock source to generate a signal with a long period (32 seconds), which would not be possible if timer 2 were using its default clock source. /* In this example, timer 1 is using the default clock source to generate a continuous output signal with a frequency of 0.5 MHz. Timer 2 will use timer 1 as a clock source to obtain a timer output with a signal period of 32 seconds per cycle. */ /* TIMER 1 SET-UP.*/ /* Specify to output a continuous signal for timer 1. */ MdigControl(MilDigitizer, M_TIMER_TRIGGER_SOURCE + M_TIMER1, M_CONTINUOUS); /* Timer 1 output delay and active portion (duration) set to 1000 nsec. */ MdigControl(MilDigitizer, M_TIMER_DELAY + M_TIMER1, 1000); MdigControl(MilDigitizer, M_TIMER_DURATION + M_TIMER1, 1000); /* TIMER 2 SET-UP.*/ /* Set the clock source of timer 2 to timer 1. */ MdigControl(MilDigitizer, M_TIMER_CLOCK_SOURCE + M_TIMER2, M_TIMER1); /* Specify to output a continuous signal for timer 2. */ MdigControl(MilDigitizer, M_TIMER_TRIGGER_SOURCE + M_TIMER2, M_CONTINUOUS); /* Timer 2 output delay set to 12 seconds (12 billion nsec). */ MdigControl(MilDigitizer, M_TIMER_DELAY + M_TIMER2, 12000000000); /* Timer 2 active portion (duration) set to 20 seconds (20 billion nsec). */ MdigControl(MilDigitizer, M_TIMER_DURATION + M_TIMER2, 20000000000); /* Enable (start) both timers.*/ MdigControl(MilDigitizer, M_TIMER_STATE + M_TIMER1, M_ENABLE); MdigControl(MilDigitizer, M_TIMER_STATE + M_TIMER2, M_ENABLE); Timers and coordinating events Timers in the advanced I/O engine Delay and duration Timer modes: triggered or continuous Steps to set up timers Timer clock source ",
      "wordCount": 1718,
      "subEntries": []
    },
    {
      "id": "UG_IOsignals_Using_quadrature_input_from_a_rotary_encoder",
      "version": null,
      "title": "Using quadrature input from a rotary encoder",
      "subTitles": [
        "Interpreting the direction of movement from the Gray code",
        "Using the rotary decoder's counter",
        "Using the rotary decoder's output to trigger a timer or a grab",
        "Pixel aspect ratio"
      ],
      "location": "MIL UG P09: Communication",
      "pageURL": "content\\UserGuide\\IOsignals\\Using_quadrature_input_from_a_rotary_encoder.htm",
      "text": " Using quadrature input from a rotary encoder Some Matrox products, typically frame grabbers, have a rotary decoder that can decode quadrature input (2-bit Gray code derived from two signals) from a rotary encoder. A rotary encoder is a device that provides information about the position and direction of a rotating shaft (for example, that of a conveyor belt). For each change in position of the rotating shaft, the rotary encoder also changes position (step); for each rotary encoder step, one of four possible Gray codes is transmitted (in a precise sequence) to the rotary decoder. Upon decoding a Gray code, the rotary decoder increments or decrements its internal counter depending on the direction (determined by the sequence of the Gray code). Since each rotary encoder step corresponds to a fixed linear displacement of an object on, for example, a conveyor belt moved by a rotating shaft, the position of the object can be calculated. In addition, the rotary decoder can output a signal (typically a pulse) upon a specific rotary decoder counter value and/or direction of movement, to trigger a grab or a timer. Rotary encoders are used for multiple purposes; in imaging, they are typically used in conjunction with a line scan camera to grab images of objects on a conveyor belt according to the displacement of the objects and independent of speed of the conveyor belt. You can have the rotary decoder output a signal to trigger a timer to start exposing the line scan camera's CCD based on the counter value (a required displacement), as well as send the timer output to trigger the grab of the line. The following illustration depicts the possible inputs and outputs related to the rotary decoder. Some or all of the inputs and outputs can be used (depending on your requirements and if your board supports them). The animation demonstrates the path of a signal once it is transmitted by the rotary encoder. Callout # MdigControl() control type Callout # MdigControl() control type 1 M_ROTARY_ENCODER_BIT0_SOURCE 7 M_ROTARY_ENCODER_POSITION_TRIGGER 2 M_ROTARY_ENCODER_BIT1_SOURCE 8 M_ROTARY_ENCODER_DIRECTION 3 M_ROTARY_ENCODER_POSITION 9 M_ROTARY_ENCODER_OUTPUT_MODE 4 M_ROTARY_ENCODER_RESET_SOURCE 10 M_TIMER_TRIGGER_SOURCE 5 M_ROTARY_ENCODER_FORCE_VALUE_SOURCE 11 M_GRAB_TRIGGER_SOURCE 6 M_ROTARY_ENCODER_MULTIPLIER 12 M_ROTARY_ENCODER_FRAME_END_READ By default, each rotary decoder is associated with the acquisition path of the current digitizer; that is, rotary decoder n is used on acquisition path n-1, where n is hardware-specific (for example, on Matrox Radient eV-CXP, it can be from 1 to 4). Some boards support using any rotary decoder on any acquisition path. If your board supports this type of interconnectivity, use the combination constant M_ROTARY_ENCODERn to specify the required rotary decoder to use. Interpreting the direction of movement from the Gray code The quadrature input (Gray code) is transmitted to the frame grabber using two input signals. To specify on which auxiliary input signals to receive bit 0 and bit 1 of the Gray code, use MdigControl() with M_ROTARY_ENCODER_BIT0_SOURCE and M_ROTARY_ENCODER_BIT1_SOURCE, respectively. Note that for some boards, if you specify the auxiliary input signal for one of the bits, the corresponding auxiliary input signal will automatically be assigned for the other bit. For information on which auxiliary input signals support quadrature input, refer to the Connectors and signal names section of the MIL Hardware-specific Notes chapter for your Matrox product. For each change in position of the rotating shaft monitored by a rotary encoder, the rotary encoder also changes position (step); for each rotary encoder step, one of the following four possible Gray codes is transmitted in a precise sequence to the rotary decoder. If the rotating shaft changes direction, the rotary encoder transmits the Gray code in the reverse sequence. The following animation shows how gray code affects the counter when output mode is set to FORWARD_ONLY. Each rotary encoder step (and consequently, each Gray code transmitted), increments or decrements the rotary decoder's counter. Incrementing the counter corresponds to an object on a conveyor belt moving in the forward direction; therefore, decrementing the counter corresponds to an object on a conveyor belt moving in the backwards direction. You must specify the direction of movement (consequently, whether to increment or decrement the counter) occurring when the Gray code sequence is 00 - 01 - 11 - 10, using MdigControl() with M_ROTARY_ENCODER_DIRECTION set to either M_FORWARD or M_BACKWARD, as per the following table: Set M_ROTARY_ENCODER_DIRECTION to If Gray code sequence is And the conveyor belt is moving So that the rotary decoder's counter M_FORWARD 00 - 01 - 11 - 10 Forward Increments Consequently 00 - 10 - 11 - 01 Backward Decrements M_BACKWARD 00 - 01 - 11 - 10 Backward Decrements Consequently 00 - 10 - 11 - 01 Forward Increments Using the rotary decoder's counter You can use the rotary decoder's counter to calculate the position, length, or displacement of an object. This calculation is done based on the fact that each rotary step increments (or decrements, depending on the direction) the counter, and that each step corresponds to a fixed linear displacement, determined by the physical setup. To calculate this type of information, you might need to mark a certain position or event with a known counter value, (for example, when you start scanning an item on a conveyor belt). You can reset the counter to zero or force it to 0xFFFFFFFF upon the rising edge of a signal (such as that of an auxiliary input signal). To do so, specify the signal using M_ROTARY_ENCODER_RESET_SOURCE or M_ROTARY_ENCODER_FORCE_VALUE_SOURCE, respectively. Also, if at any time you want to reset the counter to 0, you can use MdigControl() with M_ROTARY_ENCODER_POSITION. Note that you can inquire the current value of the counter using MdigInquire() with M_ROTARY_ENCODER_POSITION. You can have the rotary decoder internally generate a trigger upon a specific counter value using MdigControl() with M_ROTARY_ENCODER_POSITION_TRIGGER. You can then use this trigger in the following ways: Output the trigger to a timer; refer to the Using the rotary decoder's output to trigger a timer or a grab subsection of this section. Output the trigger to the grab controller; refer to the Using the rotary decoder's output to trigger a timer or a grab subsection of this section. Use the trigger to decimate (subsample) the rotary decoder's output; refer to the Pixel aspect ratio subsection of this section. Hook a function to the trigger by calling MdigHookFunction() with M_ROTARY_ENCODER. Note that, you can inquire the counter value at the end of the last grab using MdigInquire() with M_ROTARY_ENCODER_FRAME_END_POSITION. You can also retrieve the counter value at the end of a frame within the scope of a function hooked to a grab end or grab frame end event, using MdigGetHookInfo() with M_ROTARY_ENCODER_FRAME_END_POSITION. In either case, you must first set the rotary decoder to store this information using MdigControl() with M_ROTARY_ENCODER_FRAME_END_READ. Using the rotary decoder's output to trigger a timer or a grab As mentioned earlier, the rotary decoder can output a signal (typically a pulse) upon a specific rotary decoder counter value and/or direction of movement. If your frame grabber has a rotary decoder and supports timers, you can use the output of the rotary decoder to trigger a timer using MdigControl() with M_TIMER_TRIGGER_SOURCE set to M_ROTARY_ENCODER or M_ROTARY_ENCODERn. Similarly, you can send the rotary decoder output (independently or simultaneously) to the grab controller to trigger an image or line grab, using MdigControl() with M_GRAB_TRIGGER_SOURCE set to either M_ROTARY_ENCODER or M_ROTARY_ENCODERn. You can specify upon which counter value and/or direction of movement to output a pulse, using MdigControl() with M_ROTARY_ENCODER_OUTPUT_MODE. For example, the animation below depicts how 3 different output modes affect the images grabbed of items on a conveyor belt as it moves back and forth. In all 3 cases, the rotary decoder's output pulse is used to trigger a timer to start the exposure of a line scan camera's CCD, and start the grab of the line. The setup for case 3 is typically used to prevent grabbing unwanted or duplicate lines when an unplanned rotary displacement in the reverse direction occurs. The following steps must be included in the set-up of the rotary decoder in case 3: Before starting to grab the first frame, reset the rotary decoder's counter to 0, using MdigControl() with either M_ROTARY_ENCODER_RESET_SOURCE or M_ROTARY_ENCODER_POSITION. Specify to force the counter to -1 upon a reverse displacement (counter decrements), and only if the counter value was positive before the reverse displacement occurred, using MdigControl() with M_ROTARY_ENCODER_FORCE_VALUE_SOURCE set to M_STEP_BACKWARD_WHILE_POSITIVE. As originally mentioned, specify to have the rotary decoder output a pulse upon a forward displacement (counter increments), and only if the counter value was positive before the forward displacement occurred, using MdigControl() with M_ROTARY_ENCODER_OUTPUT_MODE set to M_STEP_FORWARD_WHILE_POSITIVE. The following table shows an example of what happens to the rotary decoder's counter value and which lines of an image are grabbed of an object on a conveyor belt, if it is setup as described for case 3. Camera scanning Rotary decoder's counter value: M_ROTARY_ENCODER_FORCE_VALUE_SOURCE is set to M_STEP_BACKWARD_WHILE_POSITIVE Force counter to -1? (Encoder reversed direction and counter positive before reversed) M_ROTARY_ENCODER_OUTPUT_MODE is set to M_STEP_FORWARD_WHILE_POSITIVE Rotary decoder outputs a pulse? (Counter incremented and was positive before increment) Line grabbed? Line 0 0 ... ... No Line 1 1 No Yes Yes ... ... ... ... ... Line 72 72 No Yes Yes Line 73 73 No Yes Yes Line 74 74 No Yes Yes Line 75 75 No Yes Yes Line 74 -1 Yes No No Line 73 -2 No No No Line 72 -3 No No No Line 73 -2 No No No Line 74 -1 No No No Line 75 0 No No No Line 76 1 No Yes Yes Line 77 2 No Yes Yes ... ... ... ... ... In the example above, the counter is reset to 0 before the camera scans the first line of the image. Image lines are grabbed when the rotary decoder outputs a pulse, which only happens if the counter increments and the counter is a positive value before the increment occurs. After the camera scans line 75, the conveyor belt takes a step in the reverse direction, while the counter is a positive value. Normally, the counter would have decremented by 1; however, since M_ROTARY_ENCODER_FORCE_VALUE_SOURCE is set to M_STEP_BACKWARD_WHILE_POSITIVE, the counter is forced to -1. The counter now reads a negative value and so when the conveyor belt continues to move in the reverse direction for another 2 steps, the counter decrements by 2, but the rotary decoder does not output a pulse; therefore, lines are not grabbed for any of these steps. After the camera scans line 72 (for the second time), the conveyor belt resumes moving in its original direction. When the camera scans line 75 (for the second time), it is not grabbed, since the counter value was negative before the counter incremented to 75. Line 76 is the first line to be grabbed after the conveyor belt reversed direction. Pixel aspect ratio As mentionned earlier, each rotary step corresponds to a fixed displacement. For example, there is a fixed displacement of an object on a conveyor belt each time the rotary encoder changes position. If you want to grab an image of the object on the conveyor belt with a line scan camera, it is important to set up the equipment to minimize distortion. To maintain a 1:1 pixel aspect ratio for each lined grabbed, the distance that each pixel represents along the horizontal direction of the scanned line should be the same as the displacement that occurs per step (which is equivalent to the distance between lines scanned). The animation below shows a common conveyor belt setup using a line scan camera and the effects of rotary speed and displacement on a grabbed image. If you are not able to control the displacement per rotary step or the position of the camera relative to the object, you can set up the rotary decoder to output a signal to trigger a new line scan and grab once a certain displacement has occurred. Case 1 shows an image of the object with the ideal 1:1 pixel aspect ratio. In case 2, the width (x) of the pixel is smaller than its height (y), which means that to compensate for the larger displacement, the rotary decoder needs to output more pulses per rotary step to scan lines at a higher frequency. If available for your board, the rotary decoder can output multiple pulses per step, when M_ROTARY_ENCODER_OUTPUT_MODE is set to M_STEP_... control values, and where the multiplying factor is specified using MdigControl() with M_ROTARY_ENCODER_MULTIPLIER. Note that when applying the multiplying factor, the rotary decoder's counter increments by the same factor for each step. For example, if the multiplying factor is 4 and the counter value is 6, when the next step occurs, the counter will increment through to 10, instead of 7. In case 3, the width (x) of the pixel is larger than its height (y), which means that to compensate for the smaller displacement, the rotary decoder needs to output fewer pulses than there are rotary steps. If available for your board, you can decimate (subsample) the signal that is output from the rotary decoder before sending it to a timer or grab controller. To do so, use MdigControl() with M_ROTARY_ENCODER_POSITION_TRIGGER set to the decimation value and reset the counter each time it reaches this value. The following animation shows the effect of the multiplier on a rotary encoder. In the following code snippet, a rotary encoder is used as a trigger source for an on-board timer; the timer output specifies when to scan a new line and sets the line scan camera's exposure time to 1 msec. The decimation is 10; that is, the rotary decoder only outputs a pulse once every 10 increments (rotary steps in the forward direction); so, the timer is only triggered once every 10 increments. /* Set the rotary decoder to output a pulse at every 10 steps (incremented).*/ MdigControl(MilDigitizer, M_ROTARY_ENCODER_DIRECTION, M_FORWARD); MdigControl(MilDigitizer, M_ROTARY_ENCODER_POSITION_TRIGGER, 10); MdigControl(MilDigitizer, M_ROTARY_ENCODER_RESET_SOURCE, M_POSITION_TRIGGER); MdigControl(MilDigitizer, M_ROTARY_ENCODER_OUTPUT_MODE, M_POSITION_TRIGGER); /* Program the timer to trigger on the rotary decoder output.*/ MdigControl(MilDigitizer, M_TIMER_DELAY + M_TIMER1, 1000); // 1us delay MdigControl(MilDigitizer, M_TIMER_DURATION + M_TIMER1, 1000000); // 1ms active time. MdigControl(MilDigitizer, M_TIMER_STATE + M_TIMER1, M_ENABLE); MdigControl(MilDigitizer, M_TIMER_TRIGGER_SOURCE + M_TIMER1, M_ROTARY_ENCODER); /* Reset the rotary decoder's counter to 0 (currently its value is unknown).*/ MdigControl(MilDigitizer, M_ROTARY_ENCODER_POSITION, 0); The following timing diagram illustrates a rotary decoder that outputs a pulse for every 5 position changes of the rotary encoder (decimation = 5). Each rotary decoder output pulse triggers the timer to start exposing the line scan camera's CCD. The timer output also triggers the grab controller to grab a line. The following timing diagram also illustrates when a line is exposed and grabbed if a decimation value of 5 is applied. However, in this example, the speed of the connected rotary device is now decelerating, indicated by the increased spacing (time lapse) between each step. When comparing this timing diagram with the one above, both rotary decoders output a pulse at the same step (position), illustrating that the speed of the rotary device does not effect the line grabbed when using a rotary encoder. Using quadrature input from a rotary encoder Interpreting the direction of movement from the Gray code Using the rotary decoder's counter Using the rotary decoder's output to trigger a timer or a grab Pixel aspect ratio ",
      "wordCount": 2548,
      "subEntries": []
    },
    {
      "id": "UG_IOsignals_Using_IO_command_lists",
      "version": null,
      "title": "Using I/O command lists",
      "subTitles": [
        "Steps to use an I/O command list",
        "Scheduling I/O commands",
        "Commands that can be added to the I/O command list",
        "Using an I/O command list latch",
        "Examples",
        "Always grabbing an image when the conveyor belt is at a given position",
        "Parts traveling along a conveyor belt that are fixed in position example ",
        "Different parts traveling along a conveyor belt that are ejected by different devices example",
        "Parts traveling along a conveyor belt that are not fixed in position example"
      ],
      "location": "MIL UG P09: Communication",
      "pageURL": "content\\UserGuide\\IOsignals\\Using_IO_command_lists.htm",
      "text": " Using I/O command lists Some Matrox hardware products have I/O command lists (for example, Zebra 4Sight EV7). I/O command lists allow you to schedule changing the state of a bit of an I/O command register at a specified time or counter value. You can route the state of the bit, for example, to an auxiliary output signal to control a connected device at a required moment; the state of the bit can also be used to trigger some other internal device (for example, a timer). An I/O command list allows you to schedule I/O commands in any order. You can allocate and control an I/O command list using the MsysIo...() functions. Steps to use an I/O command list The following steps provide a basic methodology for using an I/O command list on a Matrox hardware product: Allocate an I/O command list using MsysIoAlloc() with M_IO_COMMAND_LIST. You can allocate as many command lists as are available on your hardware product. When allocating an I/O command list, you must specify a signal as the counter source that will be used to schedule commands. The counter source can be either a clock, which allows you to schedule commands in time, or a specified signal, which allows you to schedule commands based on the number of transitions that occur on the signal. The latter case allows you to schedule commands, for example, based on the positional information provided by the output signal of your hardware product's rotary decoder (that is, distance). If necessary, route the state of the bits of the I/O command list's register to auxiliary output signals using MsysControl() with M_IO_SOURCE. This register is referred to as an I/O command register. If necessary, enable the use of one of the I/O command list's latches using MsysIoControl() with the M_REFERENCE_LATCH_... constants. Latches are used to store a timestamp or counter value upon the specified transition of a specified signal. You can then use this timestamp or counter value to schedule commands relative to this event. Add commands to the I/O command list using MsysIoCommandRegister(). Commands will change the state of a bit of the I/O command register at a specified time or counter value. Multiple I/O command register bits can be changed at a single moment. Commands can be added in any order. Free your I/O command list using MsysIoFree(), unless M_UNIQUE_ID was specified during allocation. Scheduling I/O commands The commands in the list are executed at a specified moment. To schedule commands, the I/O command list uses an internal counter to count clock ticks or transitions that occur on a signal specified as the counter source. The counter source is specified when you allocate the I/O command list using MsysIoAlloc(). The counter source can be a clock, an auxiliary signal, or the output signal of a rotary decoder. You schedule commands by specifying a delay from a specific reference moment. For the reference moment, you can inquire the counter value at a specific moment through software using MsysIoInquire() with M_REFERENCE_VALUE. Alternatively, you can use an I/O command list's latch to store the counter value at the moment of a hardware event; for more information, see the Using an I/O command list latch subsection of this section. If the I/O command list was allocated using a clock as the counter source (using MsysIoAlloc() with M_CLOCK), the internal counter counts the clock ticks and you schedule commands a certain amount of time, in seconds, after the reference moment. For example, you can schedule the command to execute 10 msec (0.01 sec) after a previously inquired reference moment. // Allocate a command list based on the internal clock MsysIoAlloc(SysId, M_IO_COMMAND_LIST1, M_IO_COMMAND_LIST, M_CLOCK, &amp;CmdListId); // Route the state of the I/O command list's register bits to auxiliary output signals MsysControl(SysId, M_IO_SOURCE+M_AUX_IO0, M_IO_COMMAND_LIST1 + M_IO_COMMAND_BIT0); MsysControl(SysId, M_IO_SOURCE+M_AUX_IO1, M_IO_COMMAND_LIST1 + M_IO_COMMAND_BIT1); MsysControl(SysId, M_IO_SOURCE+M_AUX_IO2, M_IO_COMMAND_LIST1 + M_IO_COMMAND_BIT2); MsysControl(SysId, M_IO_SOURCE+M_AUX_IO3, M_IO_COMMAND_LIST1 + M_IO_COMMAND_BIT3); // Add a command to the I/O command list to immediately change the state of M_IO_COMMAND_BIT0 // such that a low to high signal transition occurs on M_AUX_IO0 MsysIoCommandRegister(CmdListId, M_EDGE_RISING, M_REFERENCE_VALUE_CURRENT, 0, M_DEFAULT, M_IO_COMMAND_BIT0, M_NULL); // Add a command to the I/O command list to change the state of M_IO_COMMAND_BIT0 10 ms // after the function is called such that a high to low signal transition occurs on M_AUX_IO0 MsysIoCommandRegister(CmdListId, M_EDGE_FALLING, M_REFERENCE_VALUE_CURRENT, 0.010, M_DEFAULT, M_IO_COMMAND_BIT0, M_NULL); // Inquire the current timestamp so that it can be used as a reference point MsysIoInquire(CmdListId, M_REFERENCE_VALUE, &amp;ReferenceStamp); // Add a command to the I/O command list to change the state of M_IO_COMMAND_BIT3 15 ms // after the above reference moment, such that a positive 3 ms pulse occurs on M_AUX_IO3 MsysIoCommandRegister(CmdListId, M_PULSE_HIGH, ReferenceStamp, 0.015, 0.003, M_IO_COMMAND_BIT3, M_NULL); // ... // Free the I/O command list MsysIoFree(CmdListId); If the I/O command list was allocated using MsysIoAlloc() with M_AUX_IOn or M_ROTARY_ENCODERn as the counter source, the internal counter counts the number of signal transitions on the signal (by default, low-to-high signal transitions). For example, if you are using a rotary decoder's output signal as your counter source, you would schedule your commands based on the positional information provided by the signal (that is, distance). If your rotary decoder is set up to output a pulse each time a conveyor belt moves forward a step (MsysControl() with M_ROTARY_ENCODER_OUTPUT_MODE set to M_STEP_FORWARD), you can, for example, add a command that should be executed a constant number of forward steps after an object on the conveyor belt passes in front of a sensor. To set up a rotary decoder so that it outputs a pulse after a specific distance or when moving forward new steps (ignoring forward steps that occurred to return to an original position after an unplanned rotary displacement in the reverse direction occurs), see the Using quadrature input from a rotary encoder section earlier in this chapter. If a command has been added to the I/O command list to modify a specific bit of the I/O command register, and you attempt to add a different command to operate on the same bit at the same moment, the original entry will be overwritten. However, multiple commands can be added to execute at the same moment, as long as the commands are affecting different I/O command register bits. Commands that can be added to the I/O command list Using the MsysIoCommandRegister() function, you can add the following commands to an I/O command list: Cause a rising edge (M_EDGE_RISING). Changes the specified bit such that the associated signal will transition from low to high, if it is low. Cause a falling edge (M_EDGE_FALLING). Changes the specified bit such that the associated signal will transition from high to low, if it is high. Cause an active high pulse (M_PULSE_HIGH). This command actually adds two commands to the list: an M_EDGE_RISING followed by an M_EDGE_FALLING command a specified duration afterwards. Cause an active low pulse (M_PULSE_LOW). This command actually adds two commands to the list: an M_EDGE_FALLING followed by an M_EDGE_RISING command a specified duration afterwards. Cause a very short active high pulse (M_IMPULSE). Unlike M_PULSE_HIGH, a single command producing the shortest possible pulse is added to the list. This operation should not be output to external devices since it might be filtered out as noise. It can, however, be used to trigger internal hardware devices, such as timers. When adding a command to change an I/O command register bit such that a pulse is generated on the associated signal, two commands are actually added; one command to transition the signal at the specified moment and one command to transition the signal back to its original state after the specified pulse duration. Note that if you want to specify the duration of the pulse in seconds, but the counter source is not a clock (that is, the CounterSrc parameter of MsysIoAlloc() was set to anything other than M_CLOCK), use a timer to generate the pulse and the I/O command list to trigger the timer to generate the pulse; in this case, schedule an M_IMPULSE command and use the affected I/O command register bit as the trigger source of a timer. // Allocate a command list based on the rotary decoder's output signal MsysIoAlloc(SysId, M_IO_COMMAND_LIST1, M_IO_COMMAND_LIST, M_ROTARY_ENCODER1, &amp;CmdListId); // Setup timer MsysControl(SysId, M_TIMER_DELAY + M_TIMER1, 0); MsysControl(SysId, M_TIMER_DURATION + M_TIMER1, 10000000); //time in nsec MsysControl(SysId, M_TIMER_TRIGGER_SOURCE + M_TIMER1, M_IO_COMMAND_LIST1 + M_IO_COMMAND_BIT1); MsysControl(SysId, M_TIMER_STATE + M_TIMER1, M_ENABLE); // Trigger the timer with an M_IMPULSE command 50 rotary decoder pulses after a specific moment; // this will cause the timer to output a pulse of 10 msecs MsysIoCommandRegister(CmdListId, M_IMPULSE, ReferenceStamp, 50, M_DEFAULT, M_IO_COMMAND_BIT1, M_NULL); If you always want the command to change an I/O command register bit, use the + M_AUTO_REGISTER. Rather than waiting on a specified condition, the I/O command register bit is changed every time the latch is triggered. Note that, M_AUTO_REGISTER must be used with M_LATCHn. Using an I/O command list latch Each I/O command list on your Matrox hardware product has at least two latches that can be used to store the value of the command list's internal counter in hardware, upon a signal transition of a specified input signal. Using the latch, you can obtain the counter value at a particular moment; this is more precise than inquiring it in software using MsysIoInquire() with M_REFERENCE_VALUE. The counter value is stored in the latch until another signal transition occurs, which will overwrite the contents of the latch. To retrieve the latch's content, use MsysIoInquire() with M_REFERENCE_LATCH_VALUE or, if within the scope of a system hook-handler function, use MsysGetHookInfo() with M_REFERENCE_LATCH_VALUE. To enable the use of a latch, use MsysIoControl() with M_REFERENCE_LATCH_STATE. To change the input signal which triggers storing the counter value, use MsysIoControl() with M_REFERENCE_LATCH_TRIGGER_SOURCE. To change the signal transition upon which to store the counter value in the latch, use MsysIoControl() with M_REFERENCE_LATCH_ACTIVATION. As mentioned, if another signal transition occurs on the specified input signal, the contents of the latch will be overwritten with the counter value of that moment. To store the latch's contents in software (for example, into a queue) before it is overwritten, you can allow the specified input signal to generate an interrupt and hook a function to this event which retrieves the counter value stored by the latch. To enable interrupt generation on a signal, use MsysControl() with M_IO_INTERRUPT_STATE. To attach a hook-handler function to an I/O interrupt event, use MsysHookFunction() with M_IO_CHANGE. To retrieve the counter value stored by the latch in the hook-handler function, use MsysGetHookInfo() with M_REFERENCE_LATCH_VALUE. Examples The I/O command list can be used for many applications. The following sub-sections present 4 possible applications: Always grabbing an image when the conveyor belt is at a given position. Parts traveling along a conveyor belt that are fixed in position. Different parts traveling along a conveyor belt that are ejected by different devices. Parts traveling along a conveyor belt that are not fixed in position. Always grabbing an image when the conveyor belt is at a given position In this example, parts are moving along a conveyor belt but are fixed in their position on the conveyor belt. The parts are always taking 100 rotary encoder steps forward before reaching a camera, which will take a picture of the conveyor belt beneath it. For simplicity, the conveyor belt can only move forward and the camera is an areascan camera. A sensor detects each time a part is on the conveyor belt, and a rotary encoder is used to tell the camera when the part is best placed to take the picture. The camera is triggered by a rising pulse. An I/O command list is used to cause the camera's trigger to activate. The rotary decoder output is used as the counter source of the I/O command list so that scheduling of commands is based on a specified number of rotary encoder steps (distance that the part travels). A latch stores the value of the command list's internal counter automatically after 100 rotary encoder steps. Once the latch fires, the camera trigger's pulse rises, and a grab occurs. When the grab is complete, some processing is performed. This process repeats for each part passing the sensor. By using M_AUTO_REGISTER with a registered command, you guarantee that every time the latch fires, a grab will occur. // M_AUX_IO14: Receives rotary encoder bit 0 // M_AUX_IO15: Receives rotary encoder bit 1 // M_AUX_IO8 (input): Object detector // M_AUX_IO0 (output): trigger to the camera, 100 positions after object detector #define CAMERA_TRIGGER_OFFSET 100 // in rotary encoder steps MIL_INT MFTYPE ProcessingFunction(MIL_INT HookType, MIL_ID HookId, void* HookDataPtr); typedef struct _HOOK_PARAM { MIL_ID MilSystem; MIL_ID CmdListId; } HOOK_PARAM, *PHOOK_PARAM; // Setup triggered grab. MdigControl(MilDigitizer, M_GRAB_TRIGGER_SOURCE, M_AUX_IO0); MdigControl(MilDigitizer, M_GRAB_TRIGGER_ACTIVATION, M_EDGE_RISING); MdigControl(MilDigitizer, M_GRAB_TRIGGER_STATE, M_ENABLE); // Setup the rorary decoder; for simplicty, we assume the conveyor cannot move backwards. MsysControl(SysId, M_ROTARY_ENCODER_BIT0_SOURCE + M_ROTARY_ENCODER1, M_AUX_IO14); MsysControl(SysId, M_ROTARY_ENCODER_BIT1_SOURCE + M_ROTARY_ENCODER1, M_AUX_IO15); MsysControl(SysId, M_ROTARY_ENCODER_OUTPUT_MODE + M_ROTARY_ENCODER1, M_STEP_FORWARD); MsysControl(SysId, M_ROTARY_ENCODER_STATE + M_ROTARY_ENCODER1, M_ENABLE); // Link the grab trigger to an I/O command register bit. MsysControl(SysId, M_IO_SOURCE + M_AUX_IO0, M_IO_COMMAND_LIST1 + M_IO_COMMAND_BIT0); // Allocate an I/O command list where I/O commands are scheduled based on rotary decoder 1's output signal. CmdListId = MsysIoAlloc(SysId, M_IO_COMMAND_LIST1, M_IO_COMMAND_LIST, M_ROTARY_ENCODER1, M_NULL); if (CmdListId!= M_NULL) { // Latch the counter upon detection of the object MsysIoControl(CmdListId, M_REFERENCE_LATCH_TRIGGER_SOURCE+M_LATCH1, M_AUX_IO8); MsysIoControl(CmdListId, M_REFERENCE_LATCH_ACTIVATION+M_LATCH1, M_EDGE_RISING); MsysIoControl(CmdListId, M_REFERENCE_LATCH_STATE+M_LATCH1, M_ENABLE); // Every one hundred decoder steps after latch 1 is triggered, two I/O commands // are automatically added to the I/O command list to change register bit 0, // such that M_AUX_IO0 outputs an active high pulse. // Since M_AUX_IO0 is the grab trigger source, a frame will always be grabbed 100 // decoder steps after latch 1 is triggered. MsysIoCommandRegister(CmdListId, M_PULSE_HIGH+M_AUTO_REGISTER, M_LATCH1, CAMERA_TRIGGER_OFFSET, 1, M_IO_COMMAND_BIT0, M_NULL); // Start the grabbing and processing. // The processing function is called each time a frame is grabbed. MdigProcess(MilDigitizer, MilGrabBufferList, MilGrabBufferListSize, M_START, M_DEFAULT, ProcessingFunction, &amp;HookParam); // Print a message and wait for a key press before stopping the processing. MosPrintf(MIL_TEXT(\"Press &lt;Enter&gt; to stop. \\n\\n\")); MosGetch(); HookParam.MilSystem = SysId; HookParam.CmdListId = CmdListId; // Stop the grabbing and processing. MdigProcess(MilDigitizer, MilGrabBufferList, MilGrabBufferListSize, M_STOP, M_DEFAULT, ProcessingFunction, &amp;HookParam); // Release the auto-register, so that, if latch 1 is triggered, it will not cause // an I/O command to be added. MsysIoCommandRegister(CmdListId, M_PULSE_HIGH + M_AUTO_REGISTER_CANCEL, M_LATCH1, CAMERA_TRIGGER_OFFSET, 1, M_IO_COMMAND_BIT0, M_NULL); } // Free the I/O command list. MsysIoFree(CmdListId); Where the processing function is: // Defines the processing function, called by MdigProcess() MIL_INT MFTYPE ProcessingFunction(MIL_INT HookType, MIL_ID HookId, void* HookDataPtr) { PHOOK_PARAM pHookParam = (PHOOK_PARAM)HookDataPtr; MIL_ID ModifiedBufferId; /* Retrieve the MIL_ID of the grabbed buffer. */ MdigGetHookInfo(HookId, M_MODIFIED_BUFFER+M_BUFFER_ID, &amp;ModifiedBufferId); /* Execute the processing */ // ... PUT YOUR PROCESSING FUNCTION HERE return 0; } Parts traveling along a conveyor belt that are fixed in position example In this example, parts are moving along a conveyor belt but are fixed in their position on the conveyor belt. The parts are always taking 500 rotary encoder steps forward before reaching an ejector, which will discard the part if processing fails. For simplicity, the conveyor belt can only move forward and the camera is a frame-scan camera. A sensor detects each time a part is under the camera's field of view; the sensor's signal is used to trigger the grab. The ejector requires a pulse of 10 msec (0.01 sec) to successfully discard a part. An I/O command list is used to schedule the ejection of a part if it fails processing. The rotary decoder output is used as the counter source of the I/O command list so that scheduling of commands is based on rotary encoder steps (distance that the part travels). A latch stores the value of the command list's internal counter upon the trigger signal from the sensor; the hooked function retrieves the counter value stored in the latch and adds it to a queue. When the grab is complete, some processing is performed and a decision is made to discard or keep the part. If the part must be discarded, a command is added to discard the part 500 rotary encoder steps after the grab started. The ejector requires a pulse of 10 msec; however, if you use MsysIoCommandRegister() with M_PULSE_HIGH to add a pulse command, you would need to specify the duration of the pulse in rotary decoder output signal transitions (in distance instead of time), since the rotary decoder output signal is the counter source. To specify the pulse duration in time so that it is the correct width, an M_IMPULSE command is added instead and a timer is also used; the M_IMPULSE command affects an I/O command register bit that triggers the timer that outputs a signal with an appropriate pulse. // M_AUX_IO14: Receives rotary encoder bit 0 // M_AUX_IO15: Receives rotary encoder bit 1 // M_AUX_IO8 (input): Receives signal from sensor. // sensor sends same signal to M_AUX_IO0 of camera/digitizer. // M_AUX_IO1 (output): Sent to ejector from timer // M_TIMER1: Generates ejector pulse. Timer used so can specify pulse duration // in time and moment to execute command in rotary decoder output counts. #define PULSE_WIDTH 10000000 // 10 ms #define EJECTOR_OFFSET 500 // rotary decoder output counts static std::queue&lt;MIL_INT64&gt; ReferenceStamp; static CRITICAL_SECTION FifoLock; static MIL_ID CmdListId; static MIL_ID SysId; //... InitializeCriticalSection(&amp;FifoLock); //Initalizes mutex // Setup triggered grab. MdigControl(MilDigitizer, M_GRAB_TRIGGER_SOURCE, M_AUX_IO0); //camera/digitizer aux I/O (input) MdigControl(MilDigitizer, M_GRAB_TRIGGER_ACTIVATION, M_EDGE_RISING); MdigControl(MilDigitizer, M_GRAB_TRIGGER_STATE, M_ENABLE); // Setup rotary decoder; for simplicity, we assume the conveyor cannot move backward. MsysControl(SysId, M_ROTARY_ENCODER_BIT0_SOURCE + M_ROTARY_ENCODER1, M_AUX_IO14); MsysControl(SysId, M_ROTARY_ENCODER_BIT1_SOURCE + M_ROTARY_ENCODER1, M_AUX_IO15); MsysControl(SysId, M_ROTARY_ENCODER_OUTPUT_MODE + M_ROTARY_ENCODER1, M_STEP_FORWARD); MsysControl(SysId, M_ROTARY_ENCODER_STATE + M_ROTARY_ENCODER1, M_ENABLE); // Setup ejector pulse. MsysControl(SysId, M_IO_SOURCE + M_AUX_IO1, M_TIMER1); MsysControl(SysId, M_TIMER_DELAY + M_TIMER1, 0); MsysControl(SysId, M_TIMER_DURATION + M_TIMER1, PULSE_WIDTH); MsysControl(SysId, M_TIMER_TRIGGER_SOURCE + M_TIMER1, M_IO_COMMAND_LIST1 + M_IO_COMMAND_BIT1); MsysControl(SysId, M_TIMER_STATE + M_TIMER1, M_ENABLE); // Allocate a command list where commands are scheduled based on rotary decoder 1's output signal. MsysIoAlloc(SysId, M_IO_COMMAND_LIST1, M_IO_COMMAND_LIST, M_ROTARY_ENCODER1, &amp;CmdListId); if (CmdListId != M_NULL) { // Latch counter upon detection of part MsysIoControl(CmdListId, M_REFERENCE_LATCH_TRIGGER_SOURCE + M_LATCH1, M_AUX_IO8); MsysIoControl(CmdListId, M_REFERENCE_LATCH_ACTIVATION + M_LATCH1, M_EDGE_RISING); MsysIoControl(CmdListId, M_REFERENCE_LATCH_STATE + M_LATCH1, M_ENABLE); // Hook a function to sensor's signal (M_AUX_IO8); // hook-handler function reads and queues latched value. MsysControl(SysId, M_IO_INTERRUPT_ACTIVATION + M_AUX_IO8, M_EDGE_RISING); MsysHookFunction(SysId, M_IO_CHANGE, &amp;using_io_command_list_case_1::IoHookFunction, M_NULL); MsysControl(SysId, M_IO_INTERRUPT_STATE + M_AUX_IO8, M_ENABLE); // Start the grabbing and processing. // The processing function is called each time a frame is grabbed. MdigProcess(MilDigitizer, MilGrabBufferList, MilGrabBufferListSize, M_START, M_DEFAULT, &amp;using_io_command_list_case_1::ProcessingFunction, M_NULL); // Print a message and wait for a key press before stopping the processing. MosPrintf(MIL_TEXT(\"Press &lt;Enter&gt; to stop. \\n\\n\")); MosGetch(); MdigProcess(MilDigitizer, MilGrabBufferList, MilGrabBufferListSize, M_STOP, M_DEFAULT, ProcessingFunction, M_NULL); } // ... Where the function hooked to the I/O interrupt event and the processing function are: // IO interrupt hook function to read and queue latched value so it can be used as // the reference value to schedule a command for the newly grabbed part if necessary. static MIL_INT MFTYPE IoHookFunction(MIL_INT HookType, MIL_ID EventId, void *UserDataPtr) { MIL_INT PinNb = 0; MIL_INT64 RefStamp; // If the signal that called the hooked function is M_AUX_IO8. MsysGetHookInfo(SysId, EventId, M_IO_INTERRUPT_SOURCE, &amp;PinNb); if (PinNb == M_AUX_IO8) { // Get and queue latched value. MsysGetHookInfo(SysId, EventId, M_REFERENCE_LATCH_VALUE + M_IO_COMMAND_LIST1 + M_LATCH1, &amp;RefStamp); EnterCriticalSection(&amp;FifoLock); ReferenceStamp.push(RefStamp); LeaveCriticalSection(&amp;FifoLock); } return M_NULL; } //Each time a new frame is grabbed in a buffer, this function is called. static MIL_INT MFTYPE ProcessingFunction(MIL_INT HookType, MIL_ID HookId, void* HookDataPtr) { BOOL ShouldRejectTheObject = FALSE; MIL_INT64 RefStamp; MIL_ID ModifiedBufferId; /* Retrieve the MIL_ID of the grabbed buffer. */ MdigGetHookInfo(HookId, M_MODIFIED_BUFFER + M_BUFFER_ID, &amp;ModifiedBufferId); /* Execute the processing */ // ... PUT YOUR PROCESSING FUNCTION HERE AND SET ShouldRejectTheObject ACCORDINGLY // Reference latch FIFO should not be empty, but just in case. while (ReferenceStamp.empty()) MosSleep(1); // Remove a latched value from the queue even if not ejecting. EnterCriticalSection(&amp;FifoLock); RefStamp = ReferenceStamp.front(); ReferenceStamp.pop(); LeaveCriticalSection(&amp;FifoLock); // If required, insert an ejection pulse after the proper distance. if (ShouldRejectTheObject) MsysIoCommandRegister(CmdListId, M_IMPULSE, RefStamp, EJECTOR_OFFSET, M_DEFAULT, M_IO_COMMAND_BIT1, M_NULL); return M_NULL; } Different parts traveling along a conveyor belt that are ejected by different devices example In this example, three different parts are moving along a conveyor belt and each different part needs to be redirected to a different path. Three ejectors redirect the different parts to the correct path. Each ejector is a known distance away from a sensor that triggers the grab. Parts of type \"A\" are redirected by ejector A, which is 800 rotary encoder steps away from the sensor; parts of type \"B\" are redirected by ejector B, which is 1000 rotary encoder steps away from the sensor. Parts of type \"C\" are redirected by ejector C, which is 1200 rotary encoder steps away from the sensor. All three ejectors require a pulse of 10 msec (0.01 sec) to successfully discard a part. Again, an I/O command list is used to schedule the ejection of a part, and the rotary decoder output is used as the counter source of the I/O command list. A latch is used to store the command list's internal counter value upon the trigger signal from the sensor; the hooked function retrieves the counter value stored in the latch and adds it to a queue. When the grab is complete, some processing is performed and the part's type is determined. If the part is of type A, a command is added to discard the part 800 rotary encoder steps after the grab started; if the part is of type B, a command is added to discard the part 1000 rotary encoder steps after the grab started. If the part is of type C, a command is added to discard the part 1200 rotary encoder steps after the grab started. Since the rotary decoder output signal is the counter source, timers are again used. To specify the pulse duration in time (10 msec), an M_IMPULSE command is added to the command list to affect an I/O command register bit that triggers a timer that outputs a signal with an appropriate pulse. // M_AUX_IO0 (output): Ejector A // M_AUX_IO1 (output): Ejector B // M_AUX_IO2 (output): Ejector C // M_AUX_IO8 (input): sensor // M_TIMER1: generate ejector pulse in time duration for ejector A // M_TIMER2: generate ejector pulse in time duration for ejector B // M_TIMER3: generate ejector pulse in time duration for ejector C // M_AUX_IO14: Rotary encoder pin 1 // M_AUX_IO15: Rotary encoder pin 2 #define PULSE_WIDTH 10000000 // 10 ms #define EJECTOR_OFFSET_A 800 // rotary decoder output counts to ejector A #define EJECTOR_OFFSET_B 1000 // rotary decoder output counts to ejector B #define EJECTOR_OFFSET_C 1200 // rotary decoder output counts to ejector C static std::queue&lt;MIL_INT64&gt; ReferenceStamp; static CRITICAL_SECTION FifoLock; static MIL_ID CmdListId; static MIL_ID SysId; // ... InitializeCriticalSection(&amp;FifoLock); //Initalizes mutex // Setup triggered grab. MdigControl(MilDigitizer, M_GRAB_TRIGGER_SOURCE, M_AUX_IO0); //camera/digitizer aux I/O (input) MdigControl(MilDigitizer, M_GRAB_TRIGGER_ACTIVATION, M_EDGE_RISING); MdigControl(MilDigitizer, M_GRAB_TRIGGER_STATE, M_ENABLE); // Setup rotary decoder; for simplicity, we assume the conveyor cannot move backward. MsysControl(SysId, M_ROTARY_ENCODER_BIT0_SOURCE + M_ROTARY_ENCODER1, M_AUX_IO14); MsysControl(SysId, M_ROTARY_ENCODER_BIT1_SOURCE + M_ROTARY_ENCODER1, M_AUX_IO15); MsysControl(SysId, M_ROTARY_ENCODER_OUTPUT_MODE + M_ROTARY_ENCODER1, M_STEP_FORWARD); MsysControl(SysId, M_ROTARY_ENCODER_STATE + M_ROTARY_ENCODER1, M_ENABLE); // Setup Timer 1 for Ejector A MsysControl(SysId, M_IO_SOURCE + M_AUX_IO0, M_TIMER1); MsysControl(SysId, M_TIMER_TRIGGER_SOURCE + M_TIMER1, M_IO_COMMAND_LIST1 + M_IO_COMMAND_BIT0); MsysControl(SysId, M_TIMER_DELAY + M_TIMER1, 0); MsysControl(SysId, M_TIMER_DURATION + M_TIMER1, PULSE_WIDTH); // Setup Timer 2 for Ejector B MsysControl(SysId, M_IO_SOURCE + M_AUX_IO1, M_TIMER2); MsysControl(SysId, M_TIMER_TRIGGER_SOURCE + M_TIMER2, M_IO_COMMAND_LIST1 + M_IO_COMMAND_BIT1); MsysControl(SysId, M_TIMER_DELAY + M_TIMER2, 0); MsysControl(SysId, M_TIMER_DURATION + M_TIMER2, PULSE_WIDTH); // Setup Timer 3 for Ejector C MsysControl(SysId, M_IO_SOURCE + M_AUX_IO2, M_TIMER3); MsysControl(SysId, M_TIMER_TRIGGER_SOURCE + M_TIMER3, M_IO_COMMAND_LIST1 + M_IO_COMMAND_BIT2); MsysControl(SysId, M_TIMER_DELAY + M_TIMER3, 0); MsysControl(SysId, M_TIMER_DURATION + M_TIMER3, PULSE_WIDTH); // Start all three timers at the same time MsysControl(SysId, M_TIMER_STATE + M_TIMER1, M_ENABLE); MsysControl(SysId, M_TIMER_STATE + M_TIMER2, M_ENABLE); MsysControl(SysId, M_TIMER_STATE + M_TIMER3, M_ENABLE); // Allocate a command list where commands are scheduled based on rotary decoder 1's output signal. MsysIoAlloc(SysId, M_IO_COMMAND_LIST1, M_IO_COMMAND_LIST, M_ROTARY_ENCODER1, &amp;CmdListId); if (CmdListId != M_NULL) { // Latch counter upon detection of part MsysIoControl(CmdListId, M_REFERENCE_LATCH_TRIGGER_SOURCE + M_LATCH1, M_AUX_IO8); MsysIoControl(CmdListId, M_REFERENCE_LATCH_ACTIVATION + M_LATCH1, M_EDGE_RISING); MsysIoControl(CmdListId, M_REFERENCE_LATCH_STATE + M_LATCH1, M_ENABLE); // Hook a function to sensor's signal (M_AUX_IO8); hook-handler function reads and queues // latched value. See previous example for sample code. MsysControl(SysId, M_IO_INTERRUPT_ACTIVATION + M_AUX_IO8, M_EDGE_RISING); MsysHookFunction(SysId, M_IO_CHANGE, &amp;IoHookFunction, M_NULL); MsysControl(SysId, M_IO_INTERRUPT_STATE + M_AUX_IO8, M_ENABLE); // Start the grabbing and processing. // The processing function is called each time a frame is grabbed. MdigProcess(MilDigitizer, MilGrabBufferList, MilGrabBufferListSize, M_START, M_DEFAULT, ProcessingFunction, M_NULL); // Print a message and wait for a key press before stopping the processing. MosPrintf(MIL_TEXT(\"Press &lt;Enter&gt; to stop. \\n\\n\")); MosGetch(); MdigProcess(MilDigitizer, MilGrabBufferList, MilGrabBufferListSize, M_STOP, M_DEFAULT, ProcessingFunction, M_NULL); } // ... Where the function hooked to the I/O interrupt event (which queues the latch) is the same as the previous example and the processing function is: //Each time a new frame is grabbed in a buffer, this function is called. static MIL_INT MFTYPE ProcessingFunction(MIL_INT HookType, MIL_ID HookId, void* HookDataPtr) { BOOL ObjectTypeA, ObjectTypeB, ObjectTypeC = FALSE; MIL_INT64 RefStamp; MIL_ID ModifiedBufferId; /* Retrieve the MIL_ID of the grabbed buffer. */ MdigGetHookInfo(HookId, M_MODIFIED_BUFFER + M_BUFFER_ID, &amp;ModifiedBufferId); /* Execute the processing */ // ... PUT YOUR PROCESSING FUNCTION HERE AND SET ObjectTypeA/B/C ACCORDINGLY // Reference latch FIFO should not be empty, but just in case. while (ReferenceStamp.empty()) MosSleep(1); // Remove a latched value from the queue. EnterCriticalSection(&amp;FifoLock); RefStamp = ReferenceStamp.front(); ReferenceStamp.pop(); LeaveCriticalSection(&amp;FifoLock); // ObjectTypeA/B/C are boolean values that are set by the processing section of the code if (ObjectTypeA) MsysIoCommandRegister(CmdListId, M_IMPULSE, RefStamp, EJECTOR_OFFSET_A, M_DEFAULT, M_IO_COMMAND_BIT0, M_NULL); else if (ObjectTypeB) MsysIoCommandRegister(CmdListId, M_IMPULSE, RefStamp, EJECTOR_OFFSET_B, M_DEFAULT, M_IO_COMMAND_BIT1, M_NULL); else if (ObjectTypeC) MsysIoCommandRegister(CmdListId, M_IMPULSE, RefStamp, EJECTOR_OFFSET_C, M_DEFAULT, M_IO_COMMAND_BIT2, M_NULL); return 0; } Parts traveling along a conveyor belt that are not fixed in position example In this example, parts are moving along a conveyor belt, shifting in position as they move along after they are grabbed, but not moving ahead of any other part on the conveyor. The parts take a variable number of steps before reaching the ejector, which will discard the part if processing fails. Two sensors are placed along the conveyor belt. Sensor A is placed where the part is completely in the camera's field of view; while, sensor B is placed near the ejector such that when the part is no longer detected, it is completely in front of the ejector. The ejector requires a pulse of 10 msec (0.01 sec) to successfully discard a part. As in the previous examples, an I/O command list (I/O command list B) is used to schedule the ejection of a part; in this case, the signal from sensor B is used as the counter source of the I/O command list so that commands can be scheduled based on the number of parts that have passed sensor B. Another I/O command list (I/O command list A) is used to get a count of the number of parts that have triggered sensor A when a new part is detected; in this case, the signal from sensor A is used as both the counter source and the trigger that latches the internal counter's value. The grab is triggered and a hooked function is called each time there is a trigger signal from sensor A. The hooked function retrieves and queues the number of parts that have passed by sensor A (by inquiring the latched value of I/O command list A) and the number of parts that have passed by sensor B (by inquiring the latched value of I/O command list B) at this moment. When the grab is complete, some processing is performed and a decision is made to discard or keep the part. If the part must be discarded, a command is added to I/O command list B to discard the part after the number of parts between sensor A and sensor B have passed by sensor B since the part in question was grabbed. Since the signal from sensor B is the counter source of I/O command list B but the duration of the ejector pulse must be specified in time (10 msec), an M_IMPULSE command is added to the command list to affect an I/O command register bit that triggers a timer that outputs a signal with an appropriate pulse. // I/O assignment information: // M_AUX_IO0 (output): Sent to ejector from timer 1 // M_AUX_IO8 (input): Sensor A // M_AUX_IO9 (input): Sensor B // M_TIMER1: generate ejector pulse in time duration #define PULSE_WIDTH 10000000 // 10 ms static CRITICAL_SECTION FifoLock; static std::queue&lt;MIL_INT64&gt; SensorAQueue; static std::queue&lt;MIL_INT64&gt; SensorBQueue; static MIL_ID CmdListIdA, CmdListIdB; static MIL_ID SysId; // ... InitializeCriticalSection(&amp;FifoLock); //Initalizes mutex // Setup triggered grab. MdigControl(MilDigitizer, M_GRAB_TRIGGER_SOURCE, M_AUX_IO0); // camera/digitizer aux I/O (input) MdigControl(MilDigitizer, M_GRAB_TRIGGER_ACTIVATION, M_EDGE_RISING); MdigControl(MilDigitizer, M_GRAB_TRIGGER_STATE, M_ENABLE); //Setup ejector pulse. M_IO_COMMAND_LIST2 is I/O command list B. MsysControl(SysId, M_IO_SOURCE + M_AUX_IO0, M_TIMER1); MsysControl(SysId, M_TIMER_TRIGGER_SOURCE + M_TIMER1, M_IO_COMMAND_LIST2 + M_IO_COMMAND_BIT0); MsysControl(SysId, M_TIMER_TRIGGER_ACTIVATION + M_TIMER1, M_EDGE_RISING); MsysControl(SysId, M_TIMER_DELAY + M_TIMER1, 0); MsysControl(SysId, M_TIMER_DURATION + M_TIMER1, PULSE_WIDTH); // 10 msec MsysControl(SysId, M_TIMER_STATE + M_TIMER1, M_ENABLE); // Allocate the first command list (I/O command list A) based on sensor A (M_AUX_IO8) MsysIoAlloc(SysId, M_IO_COMMAND_LIST1, M_IO_COMMAND_LIST, M_AUX_IO8, &amp;CmdListIdA); // Allocate the second command list (I/O command list B) based on sensor B (M_AUX_IO9) MsysIoAlloc(SysId, M_IO_COMMAND_LIST2, M_IO_COMMAND_LIST, M_AUX_IO9, &amp;CmdListIdB); if (CmdListIdB != M_NULL) { // Latch the counter value of I/O command list A and B upon detection of a part at sensor A. // This corresponds to the total number of parts that have passed sensor A. MsysIoControl(CmdListIdA, M_REFERENCE_LATCH_TRIGGER_SOURCE + M_LATCH1, M_AUX_IO8); MsysIoControl(CmdListIdA, M_REFERENCE_LATCH_ACTIVATION + M_LATCH1, M_EDGE_RISING); MsysIoControl(CmdListIdA, M_REFERENCE_LATCH_STATE + M_LATCH1, M_ENABLE); // This corresponds to the number of parts that have passed // sensor B the moment sensor A detects a new part. MsysIoControl(CmdListIdB, M_REFERENCE_LATCH_TRIGGER_SOURCE + M_LATCH1, M_AUX_IO8); MsysIoControl(CmdListIdB, M_REFERENCE_LATCH_ACTIVATION + M_LATCH1, M_EDGE_RISING); MsysIoControl(CmdListIdB, M_REFERENCE_LATCH_STATE + M_LATCH1, M_ENABLE); // Hook a function to sensor A's signal (M_AUX_IO8); // hook-handler function reads and queues latched value of each I/O command list. MsysControl(SysId, M_IO_INTERRUPT_ACTIVATION + M_AUX_IO8, M_EDGE_RISING); MsysHookFunction(SysId, M_IO_CHANGE, IoHookFunction, M_NULL); MsysControl(SysId, M_IO_INTERRUPT_STATE + M_AUX_IO8, M_ENABLE); // Start the grabbing and processing. // The processing function is called with each time a frame is grabbed. MdigProcess(MilDigitizer, MilGrabBufferList, MilGrabBufferListSize, M_START, M_DEFAULT, ProcessingFunction, M_NULL); // Print a message and wait for a key press before stopping the processing. MosPrintf(MIL_TEXT(\"Press &lt;Enter&gt; to stop. \\n\\n\")); MosGetch(); MdigProcess(MilDigitizer, MilGrabBufferList, MilGrabBufferListSize, M_STOP, M_DEFAULT, ProcessingFunction, M_NULL); } // ... Where the function hooked to the I/O interrupt event and the processing function are: // IO interrupt hook function to read and queue latched values of I/O command list A and B so that // the two values can be used to schedule a command for the newly grabbed part if necessary. static MIL_INT MFTYPE IoHookFunction(MIL_INT HookType, MIL_ID EventId, void *UserDataPtr) { MIL_INT PinNb = 0; MIL_INT64 NumberOfSensorAObjects; MIL_INT64 NumberOfSensorBObjects; // If the signal that called the hooked function is M_AUX_IO8. MsysGetHookInfo(SysId, EventId, M_IO_INTERRUPT_SOURCE, &amp;PinNb); if (PinNb == M_AUX_IO8) { // Get and queue latched value of I/O command list A. // This is the total number of parts that have passed sensor A. MsysGetHookInfo(SysId, EventId, M_REFERENCE_LATCH_VALUE + M_IO_COMMAND_LIST1 + M_LATCH1, &amp;NumberOfSensorAObjects); // Get and queue latched value of I/O command list B. // This is the number of parts that have passed sensor B when a new part passes sensor A MsysGetHookInfo(SysId, EventId, M_REFERENCE_LATCH_VALUE + M_IO_COMMAND_LIST2 + M_LATCH1, &amp;NumberOfSensorBObjects); EnterCriticalSection(&amp;FifoLock); SensorAQueue.push(NumberOfSensorAObjects); SensorBQueue.push(NumberOfSensorBObjects); LeaveCriticalSection(&amp;FifoLock); } return M_NULL; } //Each time a new frame is grabbed in a buffer, this function is called. static MIL_INT MFTYPE ProcessingFunction(MIL_INT HookType, MIL_ID HookId, void* HookDataPtr) { BOOL ShouldRejectTheObject = FALSE; MIL_INT64 NumberOfSensorAObjects; MIL_INT64 NumberOfSensorBObjects; MIL_INT64 NumberOfObjectsBetweenSensors; MIL_ID ModifiedBufferId; /* Retrieve the MIL_ID of the grabbed buffer. */ MdigGetHookInfo(HookId, M_MODIFIED_BUFFER + M_BUFFER_ID, &amp;ModifiedBufferId); /* Execute the processing */ // ... PUT YOUR PROCESSING FUNCTION HERE AND SET ShouldRejectTheObject ACCORDINGLY // Reference latch FIFO should not be empty, but just in case. while (SensorAQueue.empty() || SensorBQueue.empty()) MosSleep(1); // Remove a latched value from the queue even if not ejecting. EnterCriticalSection(&amp;FifoLock); NumberOfSensorAObjects = SensorAQueue.front(); SensorAQueue.pop(); NumberOfSensorBObjects = SensorBQueue.front(); SensorBQueue.pop(); LeaveCriticalSection(&amp;FifoLock); // If required, insert an ejection pulse after the proper number of parts have passed sensor B. if (ShouldRejectTheObject) { // Establish number of parts between sensors A and B at the moment when the part was first grabbed. NumberOfObjectsBetweenSensors = NumberOfSensorAObjects - NumberOfSensorBObjects; // Insert ejection pulse after number of parts between the sensors have passed sensor B. MsysIoCommandRegister(CmdListIdB, M_IMPULSE, NumberOfSensorBObjects, (MIL_DOUBLE)NumberOfObjectsBetweenSensors, M_DEFAULT, M_IO_COMMAND_BIT0, M_NULL); } return 0; } Using I/O command lists Steps to use an I/O command list Scheduling I/O commands Commands that can be added to the I/O command list Using an I/O command list latch Examples Always grabbing an image when the conveyor belt is at a given position Parts traveling along a conveyor belt that are fixed in position example Different parts traveling along a conveyor belt that are ejected by different devices example Parts traveling along a conveyor belt that are not fixed in position example ",
      "wordCount": 5412,
      "subEntries": []
    }
  ]
}]
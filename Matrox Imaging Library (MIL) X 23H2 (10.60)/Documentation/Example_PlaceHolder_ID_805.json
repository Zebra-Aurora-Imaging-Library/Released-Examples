[{
  "id": "Example_PlaceHolder_ID",
  "version": "2024020714",
  "title": "Example_PlaceHolder_Title",
  "wordCount": 0,
  "subEntries": [
    {
      "id": "Examples_Processing_Ocr_DlocrTipsAndTricks_CPP_dlocrtipsandtricks_cpp",
      "version": "2024020714",
      "title": "dlocrtipsandtricks.cpp",
      "location": "Sample Code from MIL Examples",
      "text": " Top //**************************************************************************** /* * File name: DlocrTipsAndTricks.cpp * Location: See Matrox Example Launcher in the MIL Control Center * * * Synopsis: This program uses the dlocr module (Deep Learning OCR) * to read various strings, demonstrating useful controls that * can help you deal with problematic conditions. * * Copyright (C) Matrox Electronic Systems Ltd., 1992-2024. * All Rights Reserved */ #include &lt;mil.h&gt; #define EXAMPLE_IMAGE_ROOT M_IMAGE_PATH MIL_TEXT(\"DlocrTipsAndTricks/\") // Example functions. void ReadLicPlate(const MIL_UNIQUE_SYS_ID&amp; MilSystem, const MIL_UNIQUE_DISP_ID&amp; MilDisplay); void ReadKeyValue(const MIL_UNIQUE_SYS_ID&amp; MilSystem, const MIL_UNIQUE_DISP_ID&amp; MilDisplay); void ReadVariableString(const MIL_UNIQUE_SYS_ID&amp; MilSystem, const MIL_UNIQUE_DISP_ID&amp; MilDisplay); void ReadSpeedup(const MIL_UNIQUE_SYS_ID&amp; MilSystem, const MIL_UNIQUE_DISP_ID&amp; MilDisplay); // Utility functions. void Read(MIL_ID MilDisplay, MIL_ID MilDlocrContext, MIL_ID MilImage, MIL_ID MilOverlayImage, MIL_ID MilDlocrResult, MIL_INT StringMatchingMode, bool IsIndexDisplayed, MIL_DOUBLE* Time); void ReadSequencePath(MIL_ID MilSystem, MIL_ID MilDisplay, MIL_ID MilDlocrContext, const std::vector&lt;MIL_STRING&gt;&amp; ImagePaths, MIL_ID MilDlocrResult, MIL_INT StringMatchingMode, bool IsIndexDisplayed); void SetupFixturing( MIL_ID MilSystem, MIL_ID MilDisplay, MIL_ID MilImage, MIL_ID MilOverlayImage, MIL_ID MilPatCtx, MIL_ID MilDlocrCtx, MIL_ID MilDlocrRes, MIL_ID MilFixturingOffset, MIL_ID MilRegionGraphicList, MIL_DOUBLE ModelOffsetX, MIL_DOUBLE ModelOffsetY, MIL_DOUBLE ModelSizeX, MIL_DOUBLE ModelSizeY, MIL_DOUBLE StringOffsetX, MIL_DOUBLE StringOffsetY, MIL_DOUBLE StringWidth, MIL_DOUBLE StringHeight, bool IsIndexDisplayed); void ReadWithFixturing( MIL_ID MilSystem, MIL_ID MilDisplay, MIL_ID MilImage, MIL_ID MilOverlayImage, MIL_ID MilPatCtx, MIL_ID MilPatRes, MIL_ID MilDlocrCtx, MIL_ID MilDlocrRes, MIL_ID MilFixturingOffset, MIL_ID MilRegionGraphicList, MIL_DOUBLE TemplateWidth, MIL_DOUBLE TemplateHeight, bool IsIndexDisplayed, MIL_DOUBLE* Time); //**************************************************************************** void PrintHeader() { MosPrintf(MIL_TEXT(\"[EXAMPLE NAME]\\n\")); MosPrintf(MIL_TEXT(\"DlocrTipsAndTricks\\n\\n\")); MosPrintf(MIL_TEXT(\"[SYNOPSIS]\\n\")); MosPrintf(MIL_TEXT(\"This program uses the dlocr module (Deep Learning OCR)\\n\")); MosPrintf(MIL_TEXT(\"to read various strings, demonstrating useful controls that\\n\")); MosPrintf(MIL_TEXT(\"can help you deal with problematic conditions.\\n\\n\")); MosPrintf(MIL_TEXT(\"Defining an effective dlocr context typically involves two steps:\\n\")); MosPrintf(MIL_TEXT(\" 1. Setting up the context to ensure the target string is read.\\n\")); MosPrintf(MIL_TEXT(\" At this point, the reader may find more strings than necessary.\\n\")); MosPrintf(MIL_TEXT(\" 2. Defining string models to filter the results by size, dimensions,\\n\")); MosPrintf(MIL_TEXT(\" or other grammatical and string formatting constraints.\\n\\n\")); MosPrintf(MIL_TEXT(\"[MODULES USED]\\n\")); MosPrintf(MIL_TEXT(\"Modules used: application, buffer, display, deep learning ocr, graphics,\\n\")); MosPrintf(MIL_TEXT(\"pattern matching.\\n\")); } //**************************************************************************** int MosMain(void) { PrintHeader(); MosPrintf(MIL_TEXT(\"Press any key to continue.\\n\\n\")); MosGetch(); ///////////////////////// // Allocate MIL objects. ///////////////////////// // Allocate a MIL application. MIL_UNIQUE_APP_ID MilApplication = MappAlloc(M_NULL, M_DEFAULT, M_UNIQUE_ID); // Allocate a MIL system. MIL_UNIQUE_SYS_ID MilSystem = MsysAlloc(MilApplication, MIL_TEXT(\"M_SYSTEM_HOST\"), M_DEFAULT, M_DEFAULT, M_UNIQUE_ID); // Allocate a display. MIL_UNIQUE_DISP_ID MilDisplay = MdispAlloc(MilSystem, M_DEFAULT, MIL_TEXT(\"M_DEFAULT\"), M_WINDOWED, M_UNIQUE_ID); MosPrintf(MIL_TEXT(\"=================================================================\\n\")); MosPrintf(MIL_TEXT(\"Reading Quebec license plates.\\n\")); MosPrintf(MIL_TEXT(\"=================================================================\\n\\n\")); MosPrintf(MIL_TEXT(\"This section illustrates how to tune a context to read\\n\")); MosPrintf(MIL_TEXT(\"small characters and how to use constraints to compensate for\\n\")); MosPrintf(MIL_TEXT(\"mismatched characters.\\n\")); ReadLicPlate(MilSystem, MilDisplay); MosPrintf(MIL_TEXT(\"=================================================================\\n\")); MosPrintf(MIL_TEXT(\"Key-Value.\\n\")); MosPrintf(MIL_TEXT(\"=================================================================\\n\\n\")); MosPrintf(MIL_TEXT(\"This section illustrates the usage of anchors to read\\n\")); MosPrintf(MIL_TEXT(\"strings. It will also illustrate the usage of\\n\")); MosPrintf(MIL_TEXT(\"M_INTERCHAR_MAX_WIDTH to control the distance between strings.\\n\")); ReadKeyValue(MilSystem, MilDisplay); MosPrintf(MIL_TEXT(\"=================================================================\\n\")); MosPrintf(MIL_TEXT(\"Variable string length with optionals.\\n\")); MosPrintf(MIL_TEXT(\"=================================================================\\n\\n\")); MosPrintf(MIL_TEXT(\"This section shows how to set optionals in case of variable\\n\")); MosPrintf(MIL_TEXT(\"string length.\\n\")); ReadVariableString(MilSystem, MilDisplay); MosPrintf(MIL_TEXT(\"=================================================================\\n\")); MosPrintf(MIL_TEXT(\"Big image speedup.\\n\")); MosPrintf(MIL_TEXT(\"=================================================================\\n\")); MosPrintf(MIL_TEXT(\"This section shows a method to speed up reads using character\\n\")); MosPrintf(MIL_TEXT(\"height and fixturing.\\n\")); ReadSpeedup(MilSystem, MilDisplay); return 0; } //**************************************************************************** void ReadLicPlate(const MIL_UNIQUE_SYS_ID&amp; MilSystem, const MIL_UNIQUE_DISP_ID&amp; MilDisplay) { // MIL image file specifications. const MIL_STRING IMAGE_FILE_TO_READ = EXAMPLE_IMAGE_ROOT MIL_TEXT(\"LicPlateDlocr.mim\"); // Minimum height of an uppercase character. const MIL_INT CHAR_HEIGHT_MIN = 10; // Result number to define string model. const MIL_INT SECOND_READ_TARGET_INDEX = 0; // Restore the font definition image. MIL_UNIQUE_BUF_ID MilImage = MbufRestore(IMAGE_FILE_TO_READ, MilSystem, M_UNIQUE_ID); // Display the image and prepare for overlay annotations. MdispSelect(MilDisplay, MilImage); MdispControl(MilDisplay, M_OVERLAY, M_ENABLE); MIL_ID MilOverlayImage; MdispInquire(MilDisplay, M_OVERLAY_ID, &amp;MilOverlayImage); // Allocate a new dlocr context. MIL_UNIQUE_DLOCR_ID MilDlocrContext = MdlocrAlloc(MilSystem, M_OCR_NET1_BALANCED_V1, M_DEFAULT, M_UNIQUE_ID); // Allocate a new dlocr result buffer. MIL_UNIQUE_DLOCR_ID MilDlocrResult = MdlocrAllocResult(MilSystem, M_DLOCR_READ_RESULT, M_DEFAULT, M_UNIQUE_ID); // Set the context's target image max size X and Y. // Note that these dimensions can be superior to encompass several images. MIL_INT MaxSizeX; MIL_INT MaxSizeY; MbufInquire(MilImage, M_SIZE_X, &amp;MaxSizeX); MbufInquire(MilImage, M_SIZE_Y, &amp;MaxSizeY); MdlocrControl(MilDlocrContext, M_TARGET_MAX_SIZE_X, MaxSizeX); MdlocrControl(MilDlocrContext, M_TARGET_MAX_SIZE_Y, MaxSizeY); // Preprocess the dlocr context. MdlocrPreprocess(MilDlocrContext, M_DEFAULT); // First read. Read(MilDisplay, MilDlocrContext, MilImage, MilOverlayImage, MilDlocrResult, M_READ_ALL, false, nullptr); // Get the default minimum character height. MIL_DOUBLE DefaultCharHeightMin; MdlocrInquire(MilDlocrContext, M_DETECTION_CHAR_HEIGHT_MIN, &amp;DefaultCharHeightMin); // Pause to show results. MosPrintf(MIL_TEXT( \"First read with default context. The targeted string was not detected since\\n\")); MosPrintf(MIL_TEXT( \"the character height is lower than the default minimum supported height of %d.\\n\"), (MIL_INT)DefaultCharHeightMin); MosPrintf(MIL_TEXT(\"Press any key to continue.\\n\\n\")); MosGetch(); // Tune the context because the targeted string is small. MdlocrControl(MilDlocrContext, M_DETECTION_CHAR_HEIGHT_MIN, CHAR_HEIGHT_MIN); // This modification necessitates a new preprocess. MdlocrPreprocess(MilDlocrContext, M_DEFAULT); // Second read. Read(MilDisplay, MilDlocrContext, MilImage, MilOverlayImage, MilDlocrResult, M_READ_ALL, true, nullptr); // Pause to show results. MosPrintf(MIL_TEXT( \"Second read with tuned context: we set M_DETECTION_CHAR_HEIGHT_MIN to a lower\\n\")); MosPrintf(MIL_TEXT( \"value to detect small characters. The targeted string was detected with others\\n\")); MosPrintf(MIL_TEXT( \"strings.\\n\")); MosPrintf(MIL_TEXT( \"A string model is needed to filter results.\\n\")); MosPrintf(MIL_TEXT( \"We note the targeted string result index (in red). It will be used in the next\\n\")); MosPrintf(MIL_TEXT( \"step to filter out the targeted string.\\n\")); MosPrintf(MIL_TEXT(\"Press any key to continue.\\n\\n\")); MosGetch(); // Define a string model from the result. MdlocrDefineModelFromResult(MilDlocrContext, M_DEFAULT, MilDlocrResult, SECOND_READ_TARGET_INDEX, M_DEFAULT); // This modification necessitates a new preprocess. MdlocrPreprocess(MilDlocrContext, M_DEFAULT); // Third read. Read(MilDisplay, MilDlocrContext, MilImage, MilOverlayImage, MilDlocrResult, M_MODEL_BASED, false, nullptr); // Pause to show results. MosPrintf(MIL_TEXT( \"We defined a string model from the result to filter out based on string size\\n\")); MosPrintf(MIL_TEXT( \"and character dimensions.\\n\")); MosPrintf(MIL_TEXT( \"Third read with string model. The string read is ZEYB77 which is not\\n\")); MosPrintf(MIL_TEXT( \"possible for a Quebec licence plate. The 8 has been read as a B. We will\\n\")); MosPrintf(MIL_TEXT( \"constrain the read to 3 uppercase letters followed by 3 digits.\\n\")); MosPrintf(MIL_TEXT(\"Press any key to continue.\\n\\n\")); MosGetch(); // Add a constraint to the context (3 letters followed by 3 numbers). // Set default constraint to uppercase letters. MdlocrControlConstraint(MilDlocrContext, M_STRING_INDEX(0), M_DEFAULT, M_CONSTRAINT_TYPE, M_LETTERS_UPPERCASE, M_NULL); // Set constraint of last 3 characters to digits for the first string model. MdlocrControlConstraint( MilDlocrContext, M_STRING_INDEX(0), 3, M_CONSTRAINT_TYPE, M_DIGIT, M_NULL); MdlocrControlConstraint( MilDlocrContext, M_STRING_INDEX(0), 4, M_CONSTRAINT_TYPE, M_DIGIT, M_NULL); MdlocrControlConstraint( MilDlocrContext, M_STRING_INDEX(0), 5, M_CONSTRAINT_TYPE, M_DIGIT, M_NULL ); // This modification necessitates a new preprocess. MdlocrPreprocess(MilDlocrContext, M_DEFAULT); // Fourth read. Read(MilDisplay, MilDlocrContext, MilImage, MilOverlayImage, MilDlocrResult, M_MODEL_BASED, false, nullptr); // Pause to show results. MosPrintf(MIL_TEXT(\"Fourth read with a string model.\\n\")); MosPrintf(MIL_TEXT(\"As before, the read is filtered based on string size and dimensions; however, we\\n\")); MosPrintf(MIL_TEXT(\"now also check for the proper format of a license plate string.\\n\")); MosPrintf(MIL_TEXT(\"Press any key to continue.\\n\\n\")); MosGetch(); } //**************************************************************************** void ReadKeyValue(const MIL_UNIQUE_SYS_ID&amp; MilSystem, const MIL_UNIQUE_DISP_ID&amp; MilDisplay) { const MIL_STRING IMAGE_FILE = EXAMPLE_IMAGE_ROOT MIL_TEXT(\"USDotNumberDlocr.mim\"); const MIL_STRING ANCHOR1 = MIL_TEXT(\"USDOT\"); const MIL_STRING ANCHOR2 = MIL_TEXT(\"ICCMC\"); const MIL_INT STRING_SIZE = 6; const MIL_INT MIN_GAP = 100; // Set if the string index is displayed. const bool IsIndexDisplayed = false; // Image buffer identifier. MIL_UNIQUE_BUF_ID MilImage = MbufRestore(IMAGE_FILE, MilSystem, M_UNIQUE_ID); // Display the original image. MdispSelect(MilDisplay, MilImage); MdispControl(MilDisplay, M_OVERLAY, M_ENABLE); // Retrieve the overlay image. MIL_ID MilOverlayImage; MdispInquire(MilDisplay, M_OVERLAY_ID, &amp;MilOverlayImage); MosPrintf(MIL_TEXT(\"First, we read the USDOT number using the %s prefix anchor.\\n\"), ANCHOR1.c_str()); MosPrintf(MIL_TEXT(\"Press any key to continue.\\n\\n\")); MosGetch(); // Allocate a new dlocr context. MIL_UNIQUE_DLOCR_ID MilCtx = MdlocrAlloc(MilSystem, M_OCR_NET1_BALANCED_V1, M_DEFAULT, M_UNIQUE_ID); // Allocate a new dlocr result buffer. MIL_UNIQUE_DLOCR_ID MilRes = MdlocrAllocResult(MilSystem, M_DLOCR_READ_RESULT, M_DEFAULT, M_UNIQUE_ID); // Set the context target image max width and height. MIL_INT MaxSizeX, MaxSizeY; MbufInquire(MilImage, M_SIZE_X, &amp;MaxSizeX); MbufInquire(MilImage, M_SIZE_Y, &amp;MaxSizeY); MdlocrControl(MilCtx, M_TARGET_MAX_SIZE_X, MaxSizeX); MdlocrControl(MilCtx, M_TARGET_MAX_SIZE_Y, MaxSizeY); // Set the first anchor as the string being prefixed by a known substring. MdlocrDefineModel(MilCtx, M_DEFAULT, M_ADD, STRING_SIZE, STRING_SIZE); MdlocrControlStringModel(MilCtx, M_STRING_INDEX(0), M_TEXT_ANCHOR_MODE, M_TEXT_PREFIX); MdlocrControlStringModel(MilCtx, M_STRING_INDEX(0), M_TEXT_ANCHOR_VALUE, ANCHOR1); // Preprocess. MdlocrPreprocess(MilCtx, M_DEFAULT); // First read. Read(MilDisplay, MilCtx, MilImage, MilOverlayImage, MilRes, M_MODEL_BASED, IsIndexDisplayed, nullptr); MosPrintf(MIL_TEXT(\"We will now read using the %s prefix anchor.\\n\"), ANCHOR2.c_str()); MosPrintf(MIL_TEXT(\"Press any key to continue.\\n\\n\")); MosGetch(); // Update the text to be used as a textual anchor. MdlocrControlStringModel(MilCtx, M_STRING_INDEX(0), M_TEXT_ANCHOR_VALUE, ANCHOR2); // Preprocess MdlocrPreprocess(MilCtx, M_DEFAULT); // Second read. Read(MilDisplay, MilCtx, MilImage, MilOverlayImage, MilRes, M_MODEL_BASED, IsIndexDisplayed, nullptr); MosPrintf(MIL_TEXT(\"The target string was not read.\\n\"), ANCHOR1.c_str()); MosPrintf(MIL_TEXT(\"Let's understand why by looking at READ_ALL.\\n\")); MosPrintf(MIL_TEXT(\"Press any key to continue.\\n\\n\")); MosGetch(); // Third read: all. Read(MilDisplay, MilCtx, MilImage, MilOverlayImage, MilRes, M_READ_ALL, IsIndexDisplayed, nullptr); MosPrintf(MIL_TEXT(\"The target string is separated from the anchor, they need to be connected.\\n\")); MosPrintf(MIL_TEXT(\"We need to control the distance between two strings by setting\\n\")); MosPrintf(MIL_TEXT(\"M_INTERCHAR_MAX_WIDTH to an upper value.\\n\")); MosPrintf(MIL_TEXT(\"Note M was detected as a N, but the module tolerates some error for anchors.\\n\")); MosPrintf(MIL_TEXT(\"Press any key to continue.\\n\\n\")); MosGetch(); // Tune gap between two strings. MdlocrControl(MilCtx, M_INTERCHAR_MAX_WIDTH, MIN_GAP); // Preprocess. MdlocrPreprocess(MilCtx, M_DEFAULT); // Forth read, check. Read(MilDisplay, MilCtx, MilImage, MilOverlayImage, MilRes, M_READ_ALL, IsIndexDisplayed, nullptr); MosPrintf(MIL_TEXT(\"The new value seems to be correct in READ_ALL.\\n\")); MosPrintf(MIL_TEXT(\"We can use the previous string model with the anchor to get the targeted string.\\n\")); MosPrintf(MIL_TEXT(\"Press any key to continue.\\n\\n\")); MosGetch(); // No preprocess required since no parameters change. // Final read. Read(MilDisplay, MilCtx, MilImage, MilOverlayImage, MilRes, M_MODEL_BASED, IsIndexDisplayed, nullptr); MosPrintf(MIL_TEXT(\"%s is detected.\\n\"), ANCHOR2.c_str()); MosPrintf(MIL_TEXT(\"Press any key to continue.\\n\\n\")); MosGetch(); } //**************************************************************************** void ReadVariableString(const MIL_UNIQUE_SYS_ID&amp; MilSystem, const MIL_UNIQUE_DISP_ID&amp; MilDisplay) { const std::vector&lt;MIL_STRING&gt; IMAGE_PATHS { EXAMPLE_IMAGE_ROOT MIL_TEXT(\"VariableString1.mim\"), EXAMPLE_IMAGE_ROOT MIL_TEXT(\"VariableString2.mim\"), EXAMPLE_IMAGE_ROOT MIL_TEXT(\"VariableString3.mim\"), }; // String size. const MIL_INT STRING_SIZE_MIN = 13; const MIL_INT STRING_SIZE_MAX = 14; // Images max dimensions. const MIL_INT SIZE_X = 720; const MIL_INT SIZE_Y = 150; // Set if the string index is displayed. const bool IsIndexDisplayed = false; MosPrintf(MIL_TEXT(\"To filter out strings based on their size in an application where the size may\\n\")); MosPrintf(MIL_TEXT(\"be variable, we must specify in the string model the characters that may not\\n\")); MosPrintf(MIL_TEXT(\"be present using optionals. In the following example, we can miss the first\\n\")); MosPrintf(MIL_TEXT(\"character or the last one. We set the string length to [%d-%d] with the first\\n\"), STRING_SIZE_MIN, STRING_SIZE_MAX); MosPrintf(MIL_TEXT(\"and last position as optional constraints.\\n\")); MosPrintf(MIL_TEXT(\"Press any key to continue.\\n\\n\")); MosGetch(); // Allocate a new dlocr context. MIL_UNIQUE_DLOCR_ID MilCtx = MdlocrAlloc(MilSystem, M_OCR_NET1_BALANCED_V1, M_DEFAULT, M_UNIQUE_ID); // Allocate a new dlocr result buffer. MIL_UNIQUE_DLOCR_ID MilRes = MdlocrAllocResult(MilSystem, M_DLOCR_READ_RESULT, M_DEFAULT, M_UNIQUE_ID); // Set the context target image max width and height. MdlocrControl(MilCtx, M_TARGET_MAX_SIZE_X, SIZE_X); MdlocrControl(MilCtx, M_TARGET_MAX_SIZE_Y, SIZE_Y); // Target only strings inside a size range. MdlocrDefineModel(MilCtx, M_DEFAULT, M_ADD, STRING_SIZE_MIN, STRING_SIZE_MAX); // Apply a constraint to the first two characters, which should be digits. for(MIL_INT i = 0; i &lt; 2; ++i) MdlocrControlConstraint(MilCtx, M_STRING_INDEX(0), i, M_CONSTRAINT_TYPE, M_DIGIT, M_NULL); // Apply a constraint to the next two characters, which should be uppercase letters. for(MIL_INT i = 2; i &lt; 4; ++i) MdlocrControlConstraint(MilCtx, M_STRING_INDEX(0), i, M_CONSTRAINT_TYPE, M_LETTERS_UPPERCASE, M_NULL); // Apply a constraint to the next six characters, which should be digits. for(MIL_INT i = 4; i &lt; 10; ++i) MdlocrControlConstraint(MilCtx, M_STRING_INDEX(0), i, M_CONSTRAINT_TYPE, M_DIGITS, M_NULL); // Apply a constraint to the last four characters, which can be of any type. for(MIL_INT i = 10; i &lt; 14; ++i) MdlocrControlConstraint(MilCtx, M_STRING_INDEX(0), i, M_CONSTRAINT_TYPE, M_ANY, M_NULL); // Set optional constraints. for (MIL_INT i = 0; i &lt; (STRING_SIZE_MAX - STRING_SIZE_MIN); i++) { MdlocrControlConstraint(MilCtx, M_STRING_INDEX(0), i, M_IS_OPTIONAL, M_TRUE, M_NULL); MdlocrControlConstraint(MilCtx, M_STRING_INDEX(0), STRING_SIZE_MAX - i - 1, M_IS_OPTIONAL, M_TRUE, M_NULL); } // Preprocess. MdlocrPreprocess(MilCtx, M_DEFAULT); ReadSequencePath(MilSystem, MilDisplay, MilCtx, IMAGE_PATHS, MilRes, M_MODEL_BASED, IsIndexDisplayed); // Clear the display overlay. MdispControl(MilDisplay, M_OVERLAY_CLEAR, M_DEFAULT); } //**************************************************************************** void ReadSpeedup(const MIL_UNIQUE_SYS_ID&amp; MilSystem, const MIL_UNIQUE_DISP_ID&amp; MilDisplay) { const std::vector&lt;MIL_STRING&gt; IMAGE_PATHS { EXAMPLE_IMAGE_ROOT MIL_TEXT(\"Big0.mim\"), EXAMPLE_IMAGE_ROOT MIL_TEXT(\"Big1.mim\"), }; const MIL_DOUBLE ZOOM_FACTOR = 0.5; const MIL_INT MIN_GAP = 100; const MIL_INT STRING_SIZE = 12; const MIL_INT FIRST_READ_TARGET_INDEX = 0; const MIL_INT CHAR_HEIGHT_TOL = 10; const MIL_DOUBLE MODEL_OFFSET_X = 1430; const MIL_DOUBLE MODEL_OFFSET_Y = 800; const MIL_DOUBLE MODEL_WIDTH = 220; const MIL_DOUBLE MODEL_HEIGHT = 170; const MIL_DOUBLE STRING_OFFSET_X = 710; const MIL_DOUBLE STRING_OFFSET_Y = 880; const MIL_DOUBLE STRING_WIDTH = 1400; const MIL_DOUBLE STRING_HEIGHT = 200; // Set if the string index is displayed. const bool IsIndexDisplayed = false; // Restore an example image. const MIL_UNIQUE_BUF_ID MilImage0 = MbufRestore(IMAGE_PATHS[0], MilSystem, M_UNIQUE_ID); // Display the original image. MdispZoom(MilDisplay, ZOOM_FACTOR, ZOOM_FACTOR); MdispSelect(MilDisplay, MilImage0); MdispControl(MilDisplay, M_OVERLAY, M_ENABLE); MdispControl(MilDisplay, M_GRAPHIC_LIST_OPACITY, 20.0); // Setup the display such that it will display the region by // painting all the pixels outside the region. MdispControl(MilDisplay, M_REGION_OUTSIDE_SHOW, M_GRAPHIC_LIST_OPACITY); // Retrieve the overlay image. MIL_ID MilOverlayImage; MdispInquire(MilDisplay, M_OVERLAY_ID, &amp;MilOverlayImage); MIL_INT MaxSizeX, MaxSizeY; MbufInquire(MilImage0, M_SIZE_X, &amp;MaxSizeX); MbufInquire(MilImage0, M_SIZE_Y, &amp;MaxSizeY); MosPrintf(MIL_TEXT(\"This image is %dx%d and is displayed with a zoom factor of 0.5.\\n\"), MaxSizeX, MaxSizeY); MosPrintf(MIL_TEXT(\"This example will illustrate how to accelerate the reading process.\\n\")); MosPrintf(MIL_TEXT(\"The default character height will be used for the first reading.\\n\")); MosPrintf(MIL_TEXT(\"Press any key to continue.\\n\\n\")); MosGetch(); // Allocate a dlocr context. MIL_UNIQUE_DLOCR_ID MilDlocrCtx = MdlocrAlloc(MilSystem, M_OCR_NET1_BALANCED_V1, M_DEFAULT, M_UNIQUE_ID); // Allocate a new dlocr result buffer. MIL_UNIQUE_DLOCR_ID MilDlocrRes = MdlocrAllocResult(MilSystem, M_DLOCR_READ_RESULT, M_DEFAULT, M_UNIQUE_ID); // Set the context target image max width and height. MdlocrControl(MilDlocrCtx, M_TARGET_MAX_SIZE_X, MaxSizeX); MdlocrControl(MilDlocrCtx, M_TARGET_MAX_SIZE_Y, MaxSizeY); // Tune the gap between two strings (see the 'Read-Key' section of this example for more info). MdlocrControl(MilDlocrCtx, M_INTERCHAR_MAX_WIDTH, MIN_GAP); // Filter small strings, by adding a string model with a specified minimum and maximum size. MdlocrDefineModel(MilDlocrCtx, M_DEFAULT, M_ADD, STRING_SIZE, STRING_SIZE); // Preprocess. MdlocrPreprocess(MilDlocrCtx, M_DEFAULT); // First read. MIL_DOUBLE TimeOrig; Read(MilDisplay, MilDlocrCtx, MilImage0, MilOverlayImage, MilDlocrRes, M_MODEL_BASED, IsIndexDisplayed, &amp;TimeOrig); // Get default minimum and aximum character height. MIL_DOUBLE DefaultCharHeightMin; MdlocrInquire(MilDlocrCtx, M_DETECTION_CHAR_HEIGHT_MIN, &amp;DefaultCharHeightMin); MIL_DOUBLE DefaultCharHeightMax; MdlocrInquire(MilDlocrCtx, M_DETECTION_CHAR_HEIGHT_MAX, &amp;DefaultCharHeightMax); // Get the character height from the previous read. std::vector&lt;MIL_DOUBLE&gt; FirstReadCharHeight; MdlocrGetResult(MilDlocrRes, FIRST_READ_TARGET_INDEX, M_INDEX_IN_STRING(M_ALL), M_CHAR_HEIGHT, FirstReadCharHeight); const MIL_DOUBLE CharHeightMinMeas = *std::min_element(FirstReadCharHeight.begin(), FirstReadCharHeight.end()); const MIL_DOUBLE CharHeightMaxMeas = *std::max_element(FirstReadCharHeight.begin(), FirstReadCharHeight.end()); const MIL_DOUBLE CharHeightMin = CharHeightMinMeas - CHAR_HEIGHT_TOL; const MIL_DOUBLE CharHeightMax = CharHeightMaxMeas + CHAR_HEIGHT_TOL; // Stop to show the first read result. MosPrintf(MIL_TEXT(\"Reading time = % .3lf s\\n\\n\"), TimeOrig); ////////////////////////////////////////////////// // First trick : Smaller character height range. ////////////////////////////////////////////////// MosPrintf(MIL_TEXT(\"From read results we computed that the minimum and maximum character height are %.1lf \\n\"), CharHeightMinMeas); MosPrintf(MIL_TEXT(\"and %.1lf. To speed up reading and ensure supporting a character size variation we add a\\n\"), CharHeightMaxMeas); MosPrintf(MIL_TEXT(\"%d px tolerance and set the character height range to [%.1lf, %.1lf].\\n\"), CHAR_HEIGHT_TOL, CharHeightMin, CharHeightMax); MosPrintf(MIL_TEXT(\"Press any key to continue.\\n\\n\")); MosGetch(); // Tune context character height to speed up the next read. MdlocrControl(MilDlocrCtx, M_DETECTION_CHAR_HEIGHT_MIN, CharHeightMin); MdlocrControl(MilDlocrCtx, M_DETECTION_CHAR_HEIGHT_MAX, CharHeightMax); // Preprocess. MdlocrPreprocess(MilDlocrCtx, M_DEFAULT); // Second read. MIL_DOUBLE TimeCharHeight; Read(MilDisplay, MilDlocrCtx, MilImage0, MilOverlayImage, MilDlocrRes, M_MODEL_BASED, IsIndexDisplayed, &amp;TimeCharHeight); MosPrintf(MIL_TEXT(\"Default character height range = [%d, %d]\\n\"), (MIL_INT)DefaultCharHeightMin, (MIL_INT)DefaultCharHeightMax); MosPrintf(MIL_TEXT(\"Small character height range = [%.1lf, %.1lf]\\n\"), CharHeightMin, CharHeightMax); MosPrintf(MIL_TEXT(\"Read with default range = %.3lf s\\n\"), TimeOrig); MosPrintf(MIL_TEXT(\"Read with small range = %.3lf s\\n\"), TimeCharHeight); MosPrintf(MIL_TEXT(\"Speed-up factor = %.1lf\\n\"), TimeOrig / TimeCharHeight); MosPrintf(MIL_TEXT(\"Press any key to continue.\\n\\n\")); MosGetch(); ////////////////////////////////////////////////// // Second trick : Fixturing. ////////////////////////////////////////////////// MosPrintf(MIL_TEXT(\"Fixturing can also be used to accelerate reading.\\n\")); MosPrintf(MIL_TEXT(\"Press any key to continue.\\n\\n\")); MosGetch(); // Return the minimum and maximum character heights to their defaults. MdlocrControl(MilDlocrCtx, M_DETECTION_CHAR_HEIGHT_MIN, M_DEFAULT); MdlocrControl(MilDlocrCtx, M_DETECTION_CHAR_HEIGHT_MAX, M_DEFAULT); // Allocate a Pattern Matching context. MIL_UNIQUE_PAT_ID MilPatCtx = MpatAlloc(MilSystem, M_NORMALIZED, M_DEFAULT, M_UNIQUE_ID); // Allocate a Pattern Matching result buffer. MIL_UNIQUE_PAT_ID MilPatRes = MpatAllocResult(MilSystem, M_DEFAULT, M_UNIQUE_ID); // Allocate a fixturing offset object. MIL_UNIQUE_CAL_ID MilFixturingOffset = McalAlloc(MilSystem, M_FIXTURING_OFFSET, M_DEFAULT, M_UNIQUE_ID); // Allocate a read-region around the code. MIL_UNIQUE_GRA_ID MilRegionGraphicList = MgraAllocList(MilSystem, M_DEFAULT, M_UNIQUE_ID); // Setup fixturing. SetupFixturing(MilSystem, MilDisplay, MilImage0, MilOverlayImage, MilPatCtx, MilDlocrCtx, MilDlocrRes, MilFixturingOffset, MilRegionGraphicList, MODEL_OFFSET_X, MODEL_OFFSET_Y, MODEL_WIDTH, MODEL_HEIGHT, STRING_OFFSET_X, STRING_OFFSET_Y, STRING_WIDTH, STRING_HEIGHT, IsIndexDisplayed); MosPrintf(MIL_TEXT(\"Read the same image using the fixturing method.\\n\")); // Read with fixturing. MIL_DOUBLE TimeFixturing0; ReadWithFixturing(MilSystem, MilDisplay, MilImage0, MilOverlayImage, MilPatCtx, MilPatRes, MilDlocrCtx, MilDlocrRes, MilFixturingOffset, MilRegionGraphicList, MODEL_WIDTH, MODEL_HEIGHT, IsIndexDisplayed, &amp;TimeFixturing0); MosPrintf(MIL_TEXT(\"The smaller read-region accelerates reading.\\n\")); MosPrintf(MIL_TEXT(\"Read without fixturing = %.3lf s\\n\"), TimeOrig); MosPrintf(MIL_TEXT(\"Read with fixturing = %.3lf s\\n\"), TimeFixturing0); MosPrintf(MIL_TEXT(\"Speed-up factor = %.1lf\\n\"), TimeOrig / TimeFixturing0); MosPrintf(MIL_TEXT(\"\\n\")); MosPrintf(MIL_TEXT(\"Press any key to continue.\\n\\n\")); MosGetch(); MosPrintf(MIL_TEXT(\"Aside from accelerating reading, fixturing also provides an efficient way to\\n\")); MosPrintf(MIL_TEXT(\"use Deep Learning OCR with a diversity of orientations.\\n\")); // Clear the display overlay. MdispControl(MilDisplay, M_OVERLAY_CLEAR, M_DEFAULT); // Restore another example image. const MIL_UNIQUE_BUF_ID MilImage1 = MbufRestore(IMAGE_PATHS[1], MilSystem, M_UNIQUE_ID); // Display the original image. MdispZoom(MilDisplay, ZOOM_FACTOR, ZOOM_FACTOR); MdispSelect(MilDisplay, MilImage1); // Setup the display such that it will display the region by // painting all the pixels outside the region. MdispControl(MilDisplay, M_REGION_OUTSIDE_SHOW, M_GRAPHIC_LIST_OPACITY); MosPrintf(MIL_TEXT(\"Press any key to continue.\\n\\n\")); MosGetch(); // Read at an angle with fixturing. MIL_DOUBLE TimeFixturing1; ReadWithFixturing(MilSystem, MilDisplay, MilImage1, MilOverlayImage, MilPatCtx, MilPatRes, MilDlocrCtx, MilDlocrRes, MilFixturingOffset, MilRegionGraphicList, MODEL_WIDTH, MODEL_HEIGHT, IsIndexDisplayed, &amp;TimeFixturing1); MosPrintf(MIL_TEXT(\"Read with fixturing = %.3lf s\\n\"), TimeFixturing1); MosPrintf(MIL_TEXT(\"\\n\\n\")); MosPrintf(MIL_TEXT(\"Note that fixturing and reducing character height range techniques can be combined\\n\")); MosPrintf(MIL_TEXT(\"for optimal results.\\n\")); MosPrintf(MIL_TEXT(\"Press any key to end.\\n\\n\")); MosGetch(); } //**************************************************************************** void Read(MIL_ID MilDisplay, MIL_ID MilDlocrContext, MIL_ID MilImage, MIL_ID MilOverlayImage, MIL_ID MilDlocrResult, MIL_INT StringMatchingMode, bool IsIndexDisplayed, MIL_DOUBLE* Time) { // Reset the timer. if(Time) { MappTimer(M_DEFAULT, M_TIMER_RESET + M_SYNCHRONOUS, M_NULL); } // Perform the read operation on the specified target image. MdlocrRead(MilDlocrContext, MilImage, MilDlocrResult, StringMatchingMode); // Read the time. if(Time) { MappTimer(M_DEFAULT, M_TIMER_READ + M_SYNCHRONOUS, Time); } // Get the number of strings read and show the result. MIL_INT NumberOfStringRead; MdlocrGetResult(MilDlocrResult, M_GENERAL, M_GENERAL, M_STRING_NUMBER + M_TYPE_MIL_INT, &amp;NumberOfStringRead); // Clear the display overlay. MdispControl(MilDisplay, M_OVERLAY_CLEAR, M_DEFAULT); if(NumberOfStringRead &gt;= 1) { MosPrintf(MIL_TEXT(\"The image was read successfully.\")); MosPrintf(MIL_TEXT(\".\\n\\n\")); // Draw the read result. MgraControl(M_DEFAULT, M_COLOR, M_COLOR_CYAN); MdlocrDraw(M_DEFAULT, MilDlocrResult, MilOverlayImage, M_DRAW_STRING, M_ALL, M_DEFAULT, M_DEFAULT); MgraControl(M_DEFAULT, M_COLOR, M_COLOR_GREEN); MdlocrDraw(M_DEFAULT, MilDlocrResult, MilOverlayImage, M_DRAW_STRING_BOX, M_ALL, M_DEFAULT, M_DEFAULT); if(IsIndexDisplayed) { MgraControl(M_DEFAULT, M_COLOR, M_COLOR_RED); MdlocrDraw(M_DEFAULT, MilDlocrResult, MilOverlayImage, M_DRAW_STRING_INDEX, M_ALL, M_DEFAULT, M_DEFAULT); } // Print the read result. MosPrintf(MIL_TEXT(\" String\\n\") ); MosPrintf(MIL_TEXT(\" -----------------------------------\\n\") ); for(MIL_INT i = 0; i &lt; NumberOfStringRead; ++i) { MIL_STRING StringResult; MdlocrGetResult(MilDlocrResult, i, M_GENERAL, M_STRING, StringResult); MosPrintf(MIL_TEXT(\" %s\\n\"), StringResult.c_str()); } MosPrintf(MIL_TEXT(\"\\n\")); } else { MosPrintf(MIL_TEXT(\"Error: the image was not read.\\n\")); } } //**************************************************************************** void ReadSequencePath(MIL_ID MilSystem, MIL_ID MilDisplay, MIL_ID MilDlocrContext, const std::vector&lt;MIL_STRING&gt;&amp; ImagePaths, MIL_ID MilDlocrResult, MIL_INT StringMatchingMode, bool IsIndexDisplayed) { for(const MIL_STRING&amp; ImagePath : ImagePaths) { // Restore the image. MIL_UNIQUE_BUF_ID MilImage = MbufRestore(ImagePath, MilSystem, M_UNIQUE_ID); // Display the image. MdispSelect(MilDisplay, MilImage); MdispControl(MilDisplay, M_OVERLAY, M_ENABLE); // Retrieve the overlay image. MIL_ID MilOverlayImage; MdispInquire(MilDisplay, M_OVERLAY_ID, &amp;MilOverlayImage); // Perform a read. Read(MilDisplay, MilDlocrContext, MilImage, MilOverlayImage, MilDlocrResult, M_MODEL_BASED, IsIndexDisplayed, nullptr); MosPrintf(MIL_TEXT(\"Press any key to continue.\\n\\n\")); MosGetch(); } MosPrintf(MIL_TEXT(\"\\n\")); } //**************************************************************************** void SetupFixturing( MIL_ID MilSystem, MIL_ID MilDisplay, MIL_ID MilImage, MIL_ID MilOverlayImage, MIL_ID MilPatCtx, MIL_ID MilDlocrCtx, MIL_ID MilDlocrRes, MIL_ID MilFixturingOffset, MIL_ID MilRegionGraphicList, MIL_DOUBLE ModelOffsetX, MIL_DOUBLE ModelOffsetY, MIL_DOUBLE ModelSizeX, MIL_DOUBLE ModelSizeY, MIL_DOUBLE StringOffsetX, MIL_DOUBLE StringOffsetY, MIL_DOUBLE StringWidth, MIL_DOUBLE StringHeight, bool IsIndexDisplayed) { // Clear the display overlay. MdispControl(MilDisplay, M_OVERLAY_CLEAR, M_DEFAULT); // Clear the region. MbufSetRegion(MilImage, M_NULL, M_DEFAULT, M_DELETE, M_DEFAULT); ////////////////////////////////////////////////// // Define fixturing. ////////////////////////////////////////////////// // The image needs to be calibrated. McalUniform(MilImage, 0.0, 0.0, 1.0, 1.0, 0.0, M_DEFAULT); // Define the Pattern Matching model. MpatDefine(MilPatCtx, M_REGULAR_MODEL, MilImage, ModelOffsetX, ModelOffsetY, ModelSizeX, ModelSizeY, M_DEFAULT); // Set the search angle range for the Pattern Matching model. MpatControl(MilPatCtx, 0, M_SEARCH_ANGLE_MODE, M_ENABLE); MpatControl(MilPatCtx, 0, M_SEARCH_ANGLE_DELTA_NEG, 180.0); MpatControl(MilPatCtx, 0, M_SEARCH_ANGLE_DELTA_POS, 180.0); MpatControl(MilPatCtx, 0, M_SEARCH_ANGLE_ACCURACY, 0.5); // Preprocess the Pattern Matching model. MpatPreprocess(MilPatCtx, M_DEFAULT, M_NULL); // Draw the Pattern Matching model. MdispControl(MilDisplay, M_OVERLAY_CLEAR, M_DEFAULT); MgraColor(M_DEFAULT, M_COLOR_RED); MgraControl(M_DEFAULT, M_INPUT_UNITS, M_PIXEL); MpatDraw(M_DEFAULT, MilPatCtx, MilOverlayImage, M_DRAW_BOX+M_DRAW_POSITION, M_DEFAULT, M_ORIGINAL); MosPrintf(MIL_TEXT(\"First, a Pattern Matching model is defined in the source image.\\n\")); MosPrintf(MIL_TEXT(\"Press any key to continue.\\n\\n\")); MosGetch(); MosPrintf(MIL_TEXT(\"The offset, from the origin of the template image to the Pattern Patching\\n\")); MosPrintf(MIL_TEXT(\"model, is learned. \")); // Learn the offset of this Pattern Matching model. McalFixture(M_NULL, MilFixturingOffset, M_LEARN_OFFSET, M_MODEL_PAT, MilPatCtx, MilImage, 0, M_DEFAULT, M_DEFAULT); // Draw the relative coordinate system and the fixturing offset. MgraColor(M_DEFAULT, M_COLOR_LIGHT_BLUE); MgraBackColor(M_DEFAULT, M_COLOR_GRAY); McalDraw(M_DEFAULT, M_NULL, MilOverlayImage, M_DRAW_RELATIVE_COORDINATE_SYSTEM, M_DEFAULT, M_DEFAULT); MgraColor(M_DEFAULT, M_COLOR_GREEN); McalDraw(M_DEFAULT, MilFixturingOffset, MilOverlayImage, M_DRAW_FIXTURING_OFFSET, M_DEFAULT, M_DEFAULT); MosPrintf(MIL_TEXT(\"Then, a read-region is set.\\n\")); // Setup the read-region. MgraControl(M_DEFAULT, M_INPUT_UNITS, M_WORLD); MgraRectAngle(M_DEFAULT, MilRegionGraphicList, StringOffsetX, StringOffsetY, StringWidth, StringHeight, 0.0, M_CENTER_AND_DIMENSION + M_FILLED); MbufSetRegion(MilImage, MilRegionGraphicList, M_DEFAULT, M_NO_RASTERIZE, M_DEFAULT); MosPrintf(MIL_TEXT(\"Press any key to continue.\\n\\n\")); MosGetch(); // Set the context target image max width and height. MdlocrControl(MilDlocrCtx, M_TARGET_MAX_SIZE_X, StringWidth + 1); MdlocrControl(MilDlocrCtx, M_TARGET_MAX_SIZE_Y, StringHeight + 1); // Preprocess. MdlocrPreprocess(MilDlocrCtx, M_DEFAULT); } //**************************************************************************** void ReadWithFixturing( MIL_ID MilSystem, MIL_ID MilDisplay, MIL_ID MilImage, MIL_ID MilOverlayImage, MIL_ID MilPatCtx, MIL_ID MilPatRes, MIL_ID MilDlocrCtx, MIL_ID MilDlocrRes, MIL_ID MilFixturingOffset, MIL_ID MilRegionGraphicList, MIL_DOUBLE TemplateWidth, MIL_DOUBLE TemplateHeight, bool IsIndexDisplayed, MIL_DOUBLE* Time) { // Clear the display overlay. MdispControl(MilDisplay, M_OVERLAY_CLEAR, M_DEFAULT); // Clear the region. MbufSetRegion(MilImage, M_NULL, M_DEFAULT, M_DELETE, M_DEFAULT); ////////////////////////////////////////////////// // Define fixturing. ////////////////////////////////////////////////// // Reset the timer. MappTimer(M_DEFAULT, M_TIMER_RESET + M_SYNCHRONOUS, M_NULL); // Find the Pattern Matching model in the new source image. MpatFind(MilPatCtx, MilImage, MilPatRes); // Read the time. MIL_DOUBLE TimeFixturing; MappTimer(M_DEFAULT, M_TIMER_READ + M_SYNCHRONOUS, &amp;TimeFixturing); MIL_INT NbFound; MpatGetResult(MilPatRes, M_GENERAL, M_NUMBER+M_TYPE_MIL_INT, &amp;NbFound); if(NbFound == 1) { // Draw a box around the Pattern Matching model. MgraControl(M_DEFAULT, M_INPUT_UNITS, M_PIXEL); MgraColor(M_DEFAULT, M_COLOR_RED); MpatDraw(M_DEFAULT, MilPatRes, MilOverlayImage, M_DRAW_BOX + M_DRAW_POSITION, 0, M_DEFAULT); // Move the relative coordinate system of the image according to the location of the found Pattern Matching model. McalFixture(MilImage, MilFixturingOffset, M_MOVE_RELATIVE, M_RESULT_PAT, MilPatRes, 0, M_DEFAULT, M_DEFAULT, M_DEFAULT); // Draw the relative coordinate system and the fixturing offset. MgraColor(M_DEFAULT, M_COLOR_LIGHT_BLUE); MgraBackColor(M_DEFAULT, M_COLOR_GRAY); McalDraw(M_DEFAULT, M_NULL, MilOverlayImage, M_DRAW_RELATIVE_COORDINATE_SYSTEM, M_DEFAULT, M_DEFAULT); MgraColor(M_DEFAULT, M_COLOR_GREEN); McalDraw(M_DEFAULT, MilFixturingOffset, MilOverlayImage, M_DRAW_FIXTURING_OFFSET, M_DEFAULT, M_DEFAULT); MosPrintf(MIL_TEXT(\"The Pattern Matching model is found. \")); // Set the region of interest. MosPrintf(MIL_TEXT(\"Then, a limited read-region is defined.\\n\")); MbufSetRegion(MilImage, MilRegionGraphicList, M_DEFAULT, M_NO_RASTERIZE, M_DEFAULT); MosPrintf(MIL_TEXT(\"Press any key to continue.\\n\\n\")); MosGetch(); ////////////////////////////////////////////////// // Read fixtured image. ////////////////////////////////////////////////// MIL_DOUBLE TimeRead; Read(MilDisplay, MilDlocrCtx, MilImage, MilOverlayImage, MilDlocrRes, M_READ_ALL, IsIndexDisplayed, &amp;TimeRead); if(Time) { *Time = TimeFixturing + TimeRead; } } else { MosPrintf(MIL_TEXT(\"Unable to find the Pattern Matching model.\\n\\n\")); if(Time) { *Time = 0; } } } ",
      "wordCount": 3379
    }
  ]
}]
[{
  "id": "Example_PlaceHolder_ID",
  "version": "2024020714",
  "title": "Example_PlaceHolder_Title",
  "wordCount": 0,
  "subEntries": [
    {
      "id": "Examples_Processing_Classification_ClassSegmentationConfidenceThreshold_CPP_classsegmentationconfidencethreshold_cpp",
      "version": "2024020714",
      "title": "classsegmentationconfidencethreshold.cpp",
      "location": "Sample Code from MIL Examples",
      "text": " Top ///************************************************************************************* // // File name: ClassSegmentationConfidenceThreshold.cpp // Location: See Matrox Example Launcher in the MIL Control Center // // // Synopsis: This example shows how to segment an image by binarizing the confidence // score map of a prediction result generated by a pretrained segmentation network. // // Copyright (C) Matrox Electronic Systems Ltd., 1992-2024. // All Rights Reserved #include &lt;mil.h&gt; #include &lt;algorithm&gt; /**************************************************************************** Example description. ****************************************************************************/ void PrintHeader() { // Print the example synopsis. MosPrintf(MIL_TEXT(\"[EXAMPLE NAME]\\n\")); MosPrintf(MIL_TEXT(\"ClassSegmentationConfidenceThreshold\\n\\n\")); MosPrintf(MIL_TEXT(\"[SYNOPSIS]\\n\")); MosPrintf(MIL_TEXT(\"This example shows how to segment an image by binarizing the class\\n\")); MosPrintf(MIL_TEXT(\"score map of a prediction result generated by a pretrained segmentation\\n\")); MosPrintf(MIL_TEXT(\"classifier. You can adjust the resulting segmentation by modifying the\\n\")); MosPrintf(MIL_TEXT(\"binarization threshold.\\n\\n\")); MosPrintf(MIL_TEXT(\"[MODULES USED]\\n\")); MosPrintf(MIL_TEXT(\"Classification, Image processing, Buffer, Display, Graphics.\\n\\n\")); // Wait for user. MosPrintf(MIL_TEXT(\"Press any key to continue.\\n\")); MosGetch(); } //***************************************************************************** // Constants. //***************************************************************************** // Path definitions. #define TARGET_IMAGE_DIR_PATH M_IMAGE_PATH MIL_TEXT(\"Classification/Plywood2/Images\") #define EXAMPLE_CLASS_CTX_PATH M_IMAGE_PATH MIL_TEXT(\"Classification/Plywood2/TrainedPlywoodDatasetNetwork.mclass\") // Util constant. #define ZOOM_FACTOR 0.9 #define CONFIDENCE_SCORE_THRESHOLD1 65 #define CONFIDENCE_SCORE_THRESHOLD2 85 #define ALPHA_BLEND 100 #define OVERLAY_OPACITY 50 // Function declarations. struct ClassStruct { MIL_INT SourceSizeX, SourceSizeY, Counter; MIL_ID MilClassCtx, MilClassRes, MilDrawRes, MilBinarizedRes, MilDisplay, MilDisplay2, MilDispImage, MilDispImage2, MilOverlay; }; MIL_INT MFTYPE ClassificationFunc(MIL_INT HookType, MIL_ID EventId, void* pHookData); void PrintText(MIL_INT threshold, MIL_ID MilOverlay); ///**************************************************************************** // Main. ///**************************************************************************** int main(void) { PrintHeader(); MIL_ID MilOverlay; // MIL overlay identifier. MIL_INT SourceSizeX, // Target image Size X. SourceSizeY, // Target image Size Y. TransparentColor; // Variable to store the transparent color value. // Allocate MIL objects. MIL_UNIQUE_APP_ID MilApplication = MappAlloc(M_NULL, M_DEFAULT, M_UNIQUE_ID); MIL_UNIQUE_SYS_ID MilSystem = MsysAlloc(M_DEFAULT, M_SYSTEM_HOST, M_DEFAULT, M_DEFAULT, M_UNIQUE_ID); MIL_UNIQUE_DISP_ID MilDisplay = MdispAlloc(MilSystem, M_DEFAULT, MIL_TEXT(\"M_DEFAULT\"), M_DEFAULT, M_UNIQUE_ID); MIL_UNIQUE_DISP_ID MilDisplay2 = MdispAlloc(MilSystem, M_DEFAULT, MIL_TEXT(\"M_DEFAULT\"), M_DEFAULT, M_UNIQUE_ID); MIL_UNIQUE_DIG_ID MilDigitizer = MdigAlloc(MilSystem, M_DEFAULT, TARGET_IMAGE_DIR_PATH, M_DEFAULT, M_UNIQUE_ID); MosPrintf(MIL_TEXT(\"Restoring the pretrained segmentation context from file..\")); MIL_UNIQUE_CLASS_ID MilClassCtx = MclassRestore(EXAMPLE_CLASS_CTX_PATH, MilSystem, M_DEFAULT, M_UNIQUE_ID); MosPrintf(MIL_TEXT(\".\")); // Preprocess the context. MclassPreprocess(MilClassCtx, M_DEFAULT); MosPrintf(MIL_TEXT(\".Ready.\\n\\n\")); MclassInquire(MilClassCtx, M_DEFAULT_SOURCE_LAYER, M_SIZE_X + M_TYPE_MIL_INT, &amp;SourceSizeX); MclassInquire(MilClassCtx, M_DEFAULT_SOURCE_LAYER, M_SIZE_Y + M_TYPE_MIL_INT, &amp;SourceSizeY); // Inquire and print source layer information. MosPrintf(MIL_TEXT(\"The classifier was trained to segment (detect) knots on planks of wood.\\n\")); // Allocate a classification result buffer. MIL_UNIQUE_CLASS_ID MilClassRes = MclassAllocResult(MilSystem, M_PREDICT_SEG_RESULT, M_DEFAULT, M_UNIQUE_ID); // Allocate the displays. MIL_UNIQUE_BUF_ID MilDispImage = MbufAllocColor(MilSystem, 3, SourceSizeX, SourceSizeY, 8 + M_UNSIGNED, M_IMAGE + M_PROC + M_DISP, M_UNIQUE_ID); MbufClear(MilDispImage, 0); MIL_UNIQUE_BUF_ID MilDispImage2 = MbufAllocColor(MilSystem, 3, SourceSizeX, SourceSizeY, 8 + M_UNSIGNED, M_IMAGE + M_PROC + M_DISP, M_UNIQUE_ID); MbufClear(MilDispImage2, 0); // Reduce the zoom factor to have an appropriate display size for the images. MdispZoom(MilDisplay, ZOOM_FACTOR, ZOOM_FACTOR); MdispZoom(MilDisplay2, ZOOM_FACTOR, ZOOM_FACTOR); // Prepare the overlay for the first display. MdispSelect(MilDisplay, MilDispImage); MdispControl(MilDisplay, M_OVERLAY, M_ENABLE); MilOverlay = MdispInquire(MilDisplay, M_OVERLAY_ID, M_NULL); MdispInquire(MilDisplay, M_TRANSPARENT_COLOR, &amp;TransparentColor); MdispControl(MilDisplay, M_OVERLAY_CLEAR, TransparentColor); MdispControl(MilDisplay, M_OVERLAY_OPACITY, OVERLAY_OPACITY); // Move the second display to the right of the first one. MdispControl(MilDisplay2, M_WINDOW_INITIAL_POSITION_X, SourceSizeX * ZOOM_FACTOR); // Allocate Draw buffer. MIL_UNIQUE_BUF_ID MilDrawRes = MbufAllocColor(MilSystem, 3, SourceSizeX, SourceSizeY, M_FLOAT + 32, M_IMAGE + M_DISP + M_PROC, M_UNIQUE_ID); MIL_UNIQUE_BUF_ID MilBinarizedRes = MbufAllocColor(MilSystem, 3, SourceSizeX, SourceSizeY, M_UNSIGNED + 8, M_IMAGE + M_DISP + M_PROC, M_UNIQUE_ID); MbufClear(MilDrawRes, 0); MbufClear(MilBinarizedRes, 0); // Retrieve the number of frames in the source directory. MIL_INT NumberOfFrames; MdigInquire(MilDigitizer, M_SOURCE_NUMBER_OF_FRAMES, &amp;NumberOfFrames); // Prepare data for Hook Function. ClassStruct ClassificationData; ClassificationData.MilClassCtx = MilClassCtx; ClassificationData.MilClassRes = MilClassRes; ClassificationData.MilDrawRes = MilDrawRes; ClassificationData.MilBinarizedRes = MilBinarizedRes; ClassificationData.MilDisplay = MilDisplay; ClassificationData.MilDisplay2 = MilDisplay2; ClassificationData.MilDispImage = MilDispImage; ClassificationData.MilDispImage2 = MilDispImage2; ClassificationData.MilOverlay = MilOverlay; ClassificationData.SourceSizeX = SourceSizeX; ClassificationData.SourceSizeY = SourceSizeY; ClassificationData.Counter = 0; // Start the grab. MdigProcess(MilDigitizer, M_NULL, 1, M_SEQUENCE + M_COUNT(NumberOfFrames), M_SYNCHRONOUS, &amp;ClassificationFunc, &amp;ClassificationData); // Deselect diplay images. MdispSelect(MilDisplay, M_NULL); MdispSelect(MilDisplay2, M_NULL); // Ready to exit. MosPrintf(MIL_TEXT(\"\\nPress any key to exit.\\n\")); MosGetch(); return 0; } MIL_INT MFTYPE ClassificationFunc(MIL_INT /*HookType*/, MIL_ID EventId, void* DataPtr) { ClassStruct* data = static_cast&lt;ClassStruct*&gt;(DataPtr); // Get image from digitizer. MIL_ID MilImage; MdigGetHookInfo(EventId, M_MODIFIED_BUFFER + M_BUFFER_ID, &amp;MilImage); data-&gt;Counter++; MosPrintf(MIL_TEXT(\"\\nPredict results on image #%d:\\n\"), data-&gt;Counter); MosPrintf(MIL_TEXT(\"-----------------------------\\n\\n\")); MdispControl(data-&gt;MilDisplay, M_UPDATE, M_DISABLE); MdispControl(data-&gt;MilDisplay2, M_UPDATE, M_DISABLE); // Perform prediction on the grabbed image using the segmentation network. MclassPredict(data-&gt;MilClassCtx, MilImage, data-&gt;MilClassRes, M_DEFAULT); // Retrieve the score map of the defect class. MclassDraw(M_DEFAULT, data-&gt;MilClassRes, data-&gt;MilDrawRes, M_DRAW_CLASS_SCORES, M_CLASS_INDEX(1), M_DEFAULT); MIL_ID BlueChannel, GreenChannel; MbufChildColor(data-&gt;MilDrawRes, M_BLUE, &amp;BlueChannel); MbufChildColor(data-&gt;MilDrawRes, M_GREEN, &amp;GreenChannel); MbufClear(BlueChannel, 0); MbufClear(GreenChannel, 0); MbufCopy(MilImage, data-&gt;MilDispImage); MbufCopy(data-&gt;MilDrawRes, data-&gt;MilDispImage2); MdispSelect(data-&gt;MilDisplay2, data-&gt;MilDispImage2); // Update the displays. MdispControl(data-&gt;MilDisplay, M_UPDATE, M_ENABLE); MdispControl(data-&gt;MilDisplay2, M_UPDATE, M_ENABLE); MosPrintf(MIL_TEXT(\"The class score map of the prediction result is displayed.\\n\")); MosPrintf(MIL_TEXT(\"Press any key to threshold the score map.\\n\")); MosGetch(); // Draw and display the default segmentation results. MclassDraw(M_DEFAULT, data-&gt;MilClassRes, data-&gt;MilBinarizedRes, M_DRAW_BEST_INDEX_IMAGE + M_PSEUDO_COLOR, M_CLASS_INDEX(1), M_DEFAULT); MimArithMultiple(MilImage, ALPHA_BLEND, data-&gt;MilBinarizedRes, 256 - ALPHA_BLEND, 256, data-&gt;MilOverlay, M_MULTIPLY_ACCUMULATE_2, M_DEFAULT); MosPrintf(MIL_TEXT(\"The prediction result using the default score threshold (50%%) is\\n\")); MosPrintf(MIL_TEXT(\"displayed.\\n\")); MosPrintf(MIL_TEXT(\"Notice the dark areas falsely detected as knots. These are false\\n\")); MosPrintf(MIL_TEXT(\"positives.\\n\")); MosPrintf(MIL_TEXT(\"Press any key to continue.\\n\")); MosGetch(); // Binarize the score map using the first threshold and display results. MimBinarize(data-&gt;MilDrawRes, data-&gt;MilBinarizedRes, M_FIXED + M_GREATER_OR_EQUAL, CONFIDENCE_SCORE_THRESHOLD1, M_NULL); MimArithMultiple(MilImage, ALPHA_BLEND, data-&gt;MilBinarizedRes, 256 - ALPHA_BLEND, 256, data-&gt;MilOverlay, M_MULTIPLY_ACCUMULATE_2, M_DEFAULT); PrintText(CONFIDENCE_SCORE_THRESHOLD1, data-&gt;MilOverlay); // Binarize the score map using the second threshold and display results. MimBinarize(data-&gt;MilDrawRes, data-&gt;MilBinarizedRes, M_FIXED + M_GREATER_OR_EQUAL, CONFIDENCE_SCORE_THRESHOLD2, M_NULL); MimArithMultiple(MilImage, ALPHA_BLEND, data-&gt;MilBinarizedRes, 256 - ALPHA_BLEND, 256, data-&gt;MilOverlay, M_MULTIPLY_ACCUMULATE_2, M_DEFAULT); PrintText(CONFIDENCE_SCORE_THRESHOLD2, data-&gt;MilOverlay); MbufClear(data-&gt;MilBinarizedRes, 0); MbufClear(data-&gt;MilOverlay, 0); MbufFree(BlueChannel); MbufFree(GreenChannel); return 0; } void PrintText(MIL_INT threshold, MIL_ID MilOverlay) { MIL_TEXT_CHAR ThresholdString[256]; MosSprintf(ThresholdString, 256, MIL_TEXT(\"Threshold value: %i \"), threshold); MgraText(M_DEFAULT, MilOverlay, 25, 25, ThresholdString); MosPrintf(MIL_TEXT(\"The prediction result using a %d%% score threshold is displayed.\\n\"), threshold); MosPrintf(MIL_TEXT(\"Notice how false positives are eliminated as the threshold increases.\\n\")); MosPrintf(MIL_TEXT(\"Press any key to continue.\\n\")); MosGetch(); } ",
      "wordCount": 875
    }
  ]
}]
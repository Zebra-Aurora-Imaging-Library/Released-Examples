[{
  "id": "Example_PlaceHolder_ID",
  "version": "2024020714",
  "title": "Example_PlaceHolder_Title",
  "wordCount": 0,
  "subEntries": [
    {
      "id": "Examples_Processing_3dReconstruction_3dProfileMetrology_CPP_3dprofilemetrology_cpp",
      "version": "2024020714",
      "title": "3dprofilemetrology.cpp",
      "location": "Sample Code from MIL Examples",
      "text": " Top //*************************************************************************************** // // File name: 3dProfileMetrology.cpp // Location: See Matrox Example Launcher in the MIL Control Center // // // Synopsis: Demonstrates metrology operations along the 3D profile of a // the scanned 3D mechanical part. // // Copyright (C) Matrox Electronic Systems Ltd., 1992-2024. // All Rights Reserved //**************************************************************************** #include &lt;mil.h&gt; #include &lt;cstdlib&gt; #include \"InteractiveProfile.h\" //**************************************************************************** // Example description. //**************************************************************************** void PrintHeader() { MosPrintf(MIL_TEXT(\"[EXAMPLE NAME]\\n\")); MosPrintf(MIL_TEXT(\"3dProfileMetrology\\n\\n\")); MosPrintf(MIL_TEXT(\"[SYNOPSIS]\\n\")); MosPrintf(MIL_TEXT(\"This example demonstrates the validation of metrology measurements\\n\") MIL_TEXT(\"along a 3D profile of the 3d point cloud of a mechanical part.\")); MosPrintf(MIL_TEXT(\"\\n\\n\")); MosPrintf(MIL_TEXT(\"[MODULES USED]\\n\")); MosPrintf(MIL_TEXT(\"Modules used: Application, Display, Buffer, Graphics,\\n\") MIL_TEXT(\"Calibration, 3D Image Processing, Geometric Model Finder,\\n\") MIL_TEXT(\"3D Display, 3D Graphics, 3D Geometry, and Metrology.\\n\\n\")); } // Macro defining the example's filepath. #define EX_PATH(x) (M_IMAGE_PATH MIL_TEXT(\"MechanicalPartScan/\") MIL_TEXT(x)) #define METAL_PART_CLOUD_CONTAINER EX_PATH(\"MechanicalPart.ply\")// struct SProjectionBox { MIL_DOUBLE OffsetX; MIL_DOUBLE OffsetY; MIL_DOUBLE OffsetZ; MIL_DOUBLE Length; MIL_DOUBLE Thickness; MIL_DOUBLE Height; }; struct SRectRegion { MIL_DOUBLE OffsetX; MIL_DOUBLE OffsetY; MIL_DOUBLE Width; MIL_DOUBLE Height; MIL_DOUBLE Angle; }; struct SArcRegion { MIL_DOUBLE OffsetX; MIL_DOUBLE OffsetY; MIL_DOUBLE StartRadius; MIL_DOUBLE EndRadius; MIL_DOUBLE StartAngle; MIL_DOUBLE EndAngle; }; //**************************************************************************** // Functions' declarations. //**************************************************************************** MIL_UNIQUE_BUF_ID GenerateDepthMap(MIL_ID Container, MIL_DOUBLE PixelSize); void Analyze3DProfile(MIL_ID Container); MIL_UNIQUE_3DGEO_ID FixturePart(MIL_ID DepthMap, MIL_ID GraList); void DrawProfileMetrology(MIL_ID ProfileResult, const SProjectionBox&amp; ProjBox, MIL_DOUBLE PixelSize, MIL_ID Display, MIL_UNIQUE_BUF_ID&amp; DisplayBuf); bool CheckForRequiredMILFile(MIL_CONST_TEXT_PTR FileName); MIL_UNIQUE_3DDISP_ID Alloc3dDisplayId(MIL_ID System); bool CheckForRequiredMILFile(MIL_CONST_TEXT_PTR FileName); //***************************************************************************** // Main. //***************************************************************************** int MosMain(void) { PrintHeader(); // Allocate the MIL application. auto Application = MappAlloc(M_NULL, M_DEFAULT, M_UNIQUE_ID); //Check for required example files. if (!CheckForRequiredMILFile(METAL_PART_CLOUD_CONTAINER)) return EXIT_FAILURE; // Allocate a host system. auto System = MsysAlloc(M_DEFAULT, M_SYSTEM_HOST, M_DEFAULT, M_DEFAULT, M_UNIQUE_ID); MosPrintf(MIL_TEXT(\"Press any key to start.\\n\\n\")); MosGetch(); // Restore a 3D point cloud of the object. auto Container = MbufRestore(METAL_PART_CLOUD_CONTAINER, System, M_UNIQUE_ID); // Analyze. Analyze3DProfile(Container); return 0; } //******************************************************************************* // 3D profile analysis of the the scanned object. //******************************************************************************* void Analyze3DProfile(MIL_ID Container) { // Allocates the displays and graphic lists. MIL_ID GraList3d = M_NULL; auto System = MobjInquire(Container, M_OWNER_SYSTEM, M_NULL); auto Display3d = Alloc3dDisplayId(System); if(Display3d) { M3ddispInquire(Display3d, M_3D_GRAPHIC_LIST_ID, &amp;GraList3d); } auto DisplayProfile = MdispAlloc(System, M_DEFAULT, MIL_TEXT(\"M_DEFAULT\"), M_WINDOWED, M_UNIQUE_ID); auto GraListProfile = MgraAllocList(System, M_DEFAULT, M_UNIQUE_ID); MIL_UNIQUE_BUF_ID BufferProfile; MdispControl(DisplayProfile, M_ASSOCIATED_GRAPHIC_LIST_ID, GraListProfile); // Display the point cloud. if(Display3d) { M3ddispControl(Display3d, M_SIZE_X, DISPLAY_SIZE_X); M3ddispControl(Display3d, M_SIZE_Y, DISPLAY_SIZE_Y); M3ddispSetView(Display3d, M_AUTO , M_BOTTOM_TILTED, M_DEFAULT, M_DEFAULT, M_DEFAULT); // Set the display's rotation axis center. This will keep the // behaviour of auto rotate consistent as we move its interest point. M3ddispCopy(M_VIEW_INTEREST_POINT, Display3d, M_ROTATION_AXIS_CENTER, M_DEFAULT); M3ddispControl(Display3d, M_UPDATE, M_DISABLE); MIL_INT64 ContainerLabel = M3ddispSelect(Display3d, Container, M_SELECT, M_DEFAULT); M3dgraControl(GraList3d, ContainerLabel, M_COLOR_USE_LUT , M_TRUE); M3dgraControl(GraList3d, ContainerLabel, M_COLOR_COMPONENT , M_COMPONENT_RANGE); M3dgraControl(GraList3d, ContainerLabel, M_COLOR_COMPONENT_BAND, 2); // Set the display's rotation axis center. This will keep the // behaviour of auto rotate consistent as we move its interest point. M3ddispCopy(M_VIEW_INTEREST_POINT, Display3d, M_ROTATION_AXIS_CENTER, M_DEFAULT); // Generate a grayscale flipped LUT. M3dgraCopy(M_COLORMAP_GRAYSCALE + M_FLIP, M_DEFAULT, GraList3d, ContainerLabel, M_COLOR_LUT, M_DEFAULT); M3ddispControl(Display3d, M_UPDATE, M_ENABLE); M3dgraAxis(GraList3d, M_ROOT_NODE, M_DEFAULT, 100, MIL_TEXT(\"\"), M_DEFAULT, M_DEFAULT); MosPrintf(MIL_TEXT(\"A scan of a mechanical part was restored and displayed.\\n\") MIL_TEXT(\"Press any key to continue.\\n\\n\")); MosGetch(); } // Set the extraction box definition in world units and relative to the part fixture. // The extraction box is defined to retrieve a slice of 3D positions from the scanned object. SProjectionBox ProjBox; ProjBox.OffsetX = 41.0; ProjBox.OffsetY = 70.0; ProjBox.OffsetZ = -20.0; ProjBox.Length = 90.0; ProjBox.Height = 40.0; ProjBox.Thickness = 0.1; const MIL_DOUBLE PixelSize = 0.3; auto Depthmap = GenerateDepthMap(Container, PixelSize); // Allocate the necessary buffers for processing and display. auto DisplayDepthmap = MdispAlloc(System, M_DEFAULT, MIL_TEXT(\"M_DEFAULT\"), M_DEFAULT, M_UNIQUE_ID); auto GraListDepthmap = MgraAllocList(System, M_DEFAULT, M_UNIQUE_ID); MdispControl(DisplayDepthmap, M_ASSOCIATED_GRAPHIC_LIST_ID, GraListDepthmap); MdispControl(DisplayDepthmap, M_WINDOW_INITIAL_POSITION_X , DISPLAY_SIZE_X); // Display the depth map and its calibration. MgraClear(M_DEFAULT, GraListDepthmap); MgraControl(M_DEFAULT, M_COLOR, M_COLOR_LIGHT_BLUE); McalDraw(M_DEFAULT, Depthmap, GraListDepthmap, M_DRAW_RELATIVE_COORDINATE_SYSTEM, M_DEFAULT, M_DEFAULT); MdispSelect(DisplayDepthmap, Depthmap); MosPrintf(MIL_TEXT(\"A top view calibrated depth map of the mechanical part was generated.\\n\\n\") MIL_TEXT(\"Press any key to continue.\\n\\n\")); MosGetch(); // Locate the part and generate a fixturing matrix. auto FixtureMatrix = FixturePart(Depthmap, GraListDepthmap); if(FixtureMatrix == M_NULL) { MosPrintf(MIL_TEXT(\"Unable to find the part in the corrected depth map.\\n\") MIL_TEXT(\"Press any key to end.\\n\\n\")); MosGetch(); return; } // Fixture the point cloud with the model finding result. M3dimMatrixTransform(Container, Container, FixtureMatrix, M_DEFAULT); MosPrintf(MIL_TEXT(\"The mechanical part was located and fixtured using Model Finder in the\\ndepth map.\\n\") MIL_TEXT(\"Press any key to continue.\\n\\n\")); //Draw where the profile is considered. MgraControl(M_DEFAULT, M_COLOR, M_COLOR_YELLOW); MgraControl(M_DEFAULT, M_INPUT_UNITS, M_WORLD); MgraLine(M_DEFAULT, GraListDepthmap, ProjBox.OffsetX, ProjBox.OffsetY, ProjBox.OffsetX, ProjBox.OffsetY + ProjBox.Length); MIL_INT64 LineLabel = MgraInquireList(GraListDepthmap, M_LIST, M_DEFAULT, M_LAST_LABEL, M_NULL); MIL_INT64 PlaneLabel = M_NULL; if(Display3d) { // Draw a clipped plane equivalent to the yellow line drawn on the depth map. auto ClippingBox = M3dgeoAlloc(System, M_GEOMETRY, M_DEFAULT, M_UNIQUE_ID); M3dgeoBox (ClippingBox, M_CENTER_AND_DIMENSION, ProjBox.OffsetX, ProjBox.OffsetY + 0.5*ProjBox.Length, ProjBox.OffsetZ, ProjBox.Thickness , ProjBox.Length, ProjBox.Height, M_DEFAULT); M3dgraCopy(ClippingBox, M_DEFAULT, GraList3d, M_LIST, M_CLIPPING_BOX, M_DEFAULT); PlaneLabel = M3dgraPlane(GraList3d, M_DEFAULT, M_POINT_AND_NORMAL, ProjBox.OffsetX, ProjBox.OffsetY, ProjBox.OffsetZ, 1.0, 0.0, 0.0, M_DEFAULT, M_DEFAULT, M_DEFAULT, M_DEFAULT, M_DEFAULT); M3dgraControl(GraList3d, PlaneLabel, M_OPACITY, 80); M3dgraControl(GraList3d, PlaneLabel, M_COLOR , M_COLOR_YELLOW); MosPrintf(MIL_TEXT(\"The profile plane is set relative to the fixture in yellow.\\n\") MIL_TEXT(\"Press any key to continue.\\n\\n\")); MosGetch(); } M3dgeoMatrixSetWithAxes(FixtureMatrix, M_ZX_AXES + M_COORDINATE_SYSTEM_TRANSFORMATION, ProjBox.OffsetX , ProjBox.OffsetY, 0.0, ProjBox.Thickness, 0.0, 0.0, 0.0, ProjBox.Length, 0.0 , M_DEFAULT); auto ProfileResult = M3dimAllocResult(System, M_PROFILE_RESULT, M_DEFAULT, M_UNIQUE_ID); M3dimProfile(Container, ProfileResult, M_PROFILE_POINT_CLOUD, FixtureMatrix, PixelSize, PixelSize, ProjBox.Thickness, ProjBox.Length, M_DEFAULT); DrawProfileMetrology(ProfileResult, ProjBox, PixelSize, DisplayProfile, BufferProfile); MosPrintf(MIL_TEXT(\"The profile points are extracted from the point cloud using M3dimProfile.\\n\") MIL_TEXT(\"Metrology measurements and tolerances are calculated along the profile.\\n\") MIL_TEXT(\" - Profile positions are displayed in yellow (before denoising \\n\") MIL_TEXT(\" positions are darker).\\n\") MIL_TEXT(\" - Regions are displayed in green.\\n\") MIL_TEXT(\" - Active edgels are displayed in blue.\\n\") MIL_TEXT(\" - Fitted features are displayed in red.\\n\") MIL_TEXT(\" - Tolerances are displayed in magenta.\\n\\n\")); MosPrintf(MIL_TEXT(\"The display can be zoomed to observe the subpixel annotations.\\n\\n\") MIL_TEXT(\"Press any key to continue.\\n\\n\")); MosGetch(); auto ProfileContext = M3dimAlloc(System, M_PROFILE_CONTEXT, M_DEFAULT, M_UNIQUE_ID); M3dimControl(ProfileContext, M_PROFILE_THICKNESS, ProjBox.Thickness); M3dimProfileEx(ProfileContext, Depthmap, ProfileResult, M_WORLD, ProjBox.OffsetX, ProjBox.OffsetY, ProjBox.OffsetX, ProjBox.OffsetY + ProjBox.Length, M_DEFAULT); DrawProfileMetrology(ProfileResult, ProjBox, PixelSize, DisplayProfile, BufferProfile); MosPrintf(MIL_TEXT(\"Profiles can also be extracted directly from the depth map using M3dimProfileEx.\\n\") MIL_TEXT(\"Doing so gives additional options like specifying the interpolation and the thickness.\\n\") MIL_TEXT(\"These settings allow for similar results compared to extracting from the\\n\") MIL_TEXT(\"point cloud with a thick box and denoising it in the Metrology module.\\n\\n\")); std::unique_ptr&lt;CInteractiveDepthmapProfile&gt; pEditableProfile; auto ProfileDisplay = Alloc3dDisplayId(System); if(Display3d) { MosPrintf(MIL_TEXT(\"Press any key to continue.\\n\\n\")); MosGetch(); // Enable the interactive profile. MdispSelect(DisplayProfile, M_NULL); MosPrintf(MIL_TEXT(\"The profile is now interactive.\\n\") MIL_TEXT(\" - Move the yellow line in the top view display to edit the profile. \\n\") MIL_TEXT(\" - The 3d display and profile displays will update accordingly.\\n\\n\")); pEditableProfile = std::make_unique&lt;CInteractiveDepthmapProfile&gt;(DisplayDepthmap, LineLabel, Display3d, PlaneLabel, ProfileDisplay, M_NULL, ProjBox.Thickness); } MosPrintf(MIL_TEXT(\"Press any key to end.\\n\\n\")); MosGetch(); } //***************************************************************************** // Perform metrology measurements on profile points and display them. //***************************************************************************** void DrawProfileMetrology(MIL_ID ProfileResult, const SProjectionBox&amp; ProjBox, MIL_DOUBLE PixelSize, MIL_ID Display, MIL_UNIQUE_BUF_ID&amp; DisplayBuf) { auto System = MobjInquire(ProfileResult, M_OWNER_SYSTEM, M_NULL); auto GraList = MdispInquire(Display, M_ASSOCIATED_GRAPHIC_LIST_ID, M_NULL); // Get the profile points. MIL_INT NbExtractedPoints; M3dimGetResult(ProfileResult, M_NUMBER_OF_POINTS_VALID, &amp;NbExtractedPoints); std::vector&lt;MIL_DOUBLE&gt; XDouble; std::vector&lt;MIL_DOUBLE&gt; YDouble; M3dimGetResult(ProfileResult, M_PROFILE_PLANE_X, XDouble); M3dimGetResult(ProfileResult, M_PROFILE_PLANE_Y, YDouble); // Allocate the Metrology tool to perform measures along the 3D profile. auto MetContext = MmetAlloc(System, M_DEFAULT, M_UNIQUE_ID); auto MetResult = MmetAllocResult(System, M_DEFAULT, M_UNIQUE_ID); const SRectRegion UpperRect = {40, -25, 8, 15, 0}; const SRectRegion LowerRect = {55, -15, 20, 10, 0}; const SArcRegion UpperArc = {12, -30, 3, 8, 180, 270}; // Set the Metrology features and tolerances. const MIL_INT EdgelLabel[1] = {M_FEATURE_INDEX(1)}; MmetAddFeature(MetContext, M_CONSTRUCTED, M_EDGEL, M_DEFAULT, M_EXTERNAL_FEATURE, M_NULL, M_NULL, 0, M_DEFAULT); MmetPut(MetContext, M_FEATURE_INDEX(1), NbExtractedPoints, M_NULL, XDouble, YDouble, M_NULL, M_NULL, M_DEFAULT); if(M3dimGetResult(ProfileResult, M_PROFILE_TYPE, M_NULL) == M_PROFILE_POINT_CLOUD) { // Denoising of the previously entered edgels. For depthmap profiles, M3dimProfileEx already takes care of this. MmetControl(MetContext, M_FEATURE_LABEL(1), M_EDGEL_DENOISING_MODE, M_GAUSSIAN); MmetControl(MetContext, M_FEATURE_LABEL(1), M_EDGEL_DENOISING_RADIUS, 1.5); } MmetAddFeature(MetContext, M_CONSTRUCTED, M_SEGMENT, M_DEFAULT, M_FIT, EdgelLabel, M_NULL, 1, M_DEFAULT); MmetSetRegion(MetContext, M_FEATURE_INDEX(2), M_DEFAULT, M_RECTANGLE, UpperRect.OffsetX, UpperRect.OffsetY, UpperRect.Width, UpperRect.Height, UpperRect.Angle, M_NULL); MmetAddFeature(MetContext, M_CONSTRUCTED, M_SEGMENT, M_DEFAULT, M_FIT, EdgelLabel, M_NULL, 1, M_DEFAULT); MmetSetRegion(MetContext, M_FEATURE_INDEX(3), M_DEFAULT, M_RECTANGLE, LowerRect.OffsetX, LowerRect.OffsetY, LowerRect.Width, LowerRect.Height, LowerRect.Angle, M_NULL); const MIL_INT SegLabels[2] = {M_FEATURE_INDEX(2), M_FEATURE_INDEX(3)}; MmetAddTolerance(MetContext, M_PARALLELISM, M_DEFAULT, 0, 2, SegLabels, M_NULL, 2, M_DEFAULT); MmetAddFeature(MetContext, M_CONSTRUCTED, M_ARC, M_DEFAULT, M_FIT, EdgelLabel, M_NULL, 1, M_DEFAULT); MmetSetRegion(MetContext, M_FEATURE_INDEX(4), M_DEFAULT, M_RING_SECTOR, UpperArc.OffsetX, UpperArc.OffsetY, UpperArc.StartRadius, UpperArc.EndRadius, UpperArc.StartAngle, UpperArc.EndAngle); const MIL_INT ArcLabel[1] = {M_FEATURE_INDEX(4)}; MmetAddTolerance(MetContext, M_RADIUS, M_DEFAULT, 0, 2, ArcLabel, M_NULL, 1, M_DEFAULT); // Calculate the features and tolerances. MmetCalculate(MetContext, M_NULL, MetResult, M_DEFAULT); // Allocate a buffer to display the extracted 3D slice. const MIL_DOUBLE ZoomFactor = 3.0; DisplayBuf = MbufAlloc2d(System, (MIL_INT)(ZoomFactor * ProjBox.Length / PixelSize), (MIL_INT)(ZoomFactor * 2.0 * ProjBox.Height / PixelSize), 8 + M_UNSIGNED, M_IMAGE + M_PROC + M_DISP, M_UNIQUE_ID); MbufClear(DisplayBuf, 0.0); McalUniform(DisplayBuf, 0.0, ProjBox.OffsetZ - ProjBox.Height, PixelSize / ZoomFactor, PixelSize / ZoomFactor, 0.0, M_DEFAULT); MgraClear(M_DEFAULT, GraList); // Display the calibration system. MgraControl(M_DEFAULT, M_COLOR, M_COLOR_LIGHT_GRAY); McalDraw(M_DEFAULT, DisplayBuf, GraList, M_DRAW_RELATIVE_COORDINATE_SYSTEM, M_DEFAULT, M_DEFAULT); // Populate the slice with the extracted points. MgraControl(M_DEFAULT, M_INPUT_UNITS, M_WORLD); MgraControl(M_DEFAULT, M_COLOR, 96.0); // dark gray. MgraDots(M_DEFAULT, DisplayBuf, NbExtractedPoints, XDouble, YDouble, M_DEFAULT); // Display the Metrology results. MgraControl(M_DEFAULT, M_COLOR, M_RGB888(64, 240, 128)); // soft green. MmetDraw(M_DEFAULT, MetResult, GraList, M_DRAW_REGION, M_DEFAULT, M_DEFAULT); MgraControl(M_DEFAULT, M_COLOR, M_RGB888(164, 164, 0)); // dark yellow MmetDraw(M_DEFAULT, MetResult, GraList, M_DRAW_NOISY_EDGELS, M_FEATURE_INDEX(1), M_DEFAULT); MgraControl(M_DEFAULT, M_COLOR, M_COLOR_YELLOW); MmetDraw(M_DEFAULT, MetResult, GraList, M_DRAW_FEATURE, M_FEATURE_LABEL(1), M_DEFAULT); MgraControl(M_DEFAULT, M_COLOR, M_RGB888(32, 164, 240)); // light blue MmetDraw(M_DEFAULT, MetResult, GraList, M_DRAW_ACTIVE_EDGELS, M_FEATURE_INDEX(2), M_DEFAULT); MmetDraw(M_DEFAULT, MetResult, GraList, M_DRAW_ACTIVE_EDGELS, M_FEATURE_INDEX(3), M_DEFAULT); MmetDraw(M_DEFAULT, MetResult, GraList, M_DRAW_ACTIVE_EDGELS, M_FEATURE_INDEX(4), M_DEFAULT); MgraControl(M_DEFAULT, M_COLOR, M_COLOR_RED); MmetDraw(M_DEFAULT, MetResult, GraList, M_DRAW_FEATURE, M_FEATURE_INDEX(2), M_DEFAULT); MmetDraw(M_DEFAULT, MetResult, GraList, M_DRAW_FEATURE, M_FEATURE_INDEX(3), M_DEFAULT); MmetDraw(M_DEFAULT, MetResult, GraList, M_DRAW_FEATURE, M_FEATURE_INDEX(4), M_DEFAULT); MgraControl(M_DEFAULT, M_COLOR, M_COLOR_MAGENTA); MmetDraw(M_DEFAULT, MetResult, GraList, M_DRAW_TOLERANCE, M_ALL, M_DEFAULT); // Select the buffer to the display. MdispSelect(Display, DisplayBuf); } //************************************************************************************ // Finds the model, fixture a destination and draw the occurrence in the graphic list. //************************************************************************************ MIL_UNIQUE_3DGEO_ID FixturePart(MIL_ID Depthmap, MIL_ID GraList) { // Restore and setup the model used to fixture the part. MIL_CONST_TEXT_PTR MECHANICAL_PART_MODEL = EX_PATH(\"ModelFinderContext.mmf\"); auto System = MobjInquire(Depthmap, M_OWNER_SYSTEM, M_NULL); auto ModelCtx = MmodRestore(MECHANICAL_PART_MODEL, System, M_WITH_CALIBRATION, M_UNIQUE_ID); auto ModelRes = MmodAllocResult(System, M_DEFAULT, M_UNIQUE_ID); // Preprocess the model finder context. MmodPreprocess(ModelCtx, M_DEFAULT); // Create the fixturing offset. auto FixtureOffset = McalAlloc(System, M_FIXTURING_OFFSET, M_DEFAULT, M_UNIQUE_ID); McalFixture(M_NULL, FixtureOffset, M_LEARN_OFFSET, M_MODEL_MOD, ModelCtx, 0, M_DEFAULT, M_DEFAULT, M_DEFAULT); // Find the model. MmodFind(ModelCtx, Depthmap, ModelRes); // Retrieve the information. MIL_INT NumOfOccurences = 0; MmodGetResult(ModelRes, M_DEFAULT, M_NUMBER + M_TYPE_MIL_INT, &amp;NumOfOccurences); if(NumOfOccurences == 0) return MIL_UNIQUE_3DGEO_ID {}; // Fixture the depth map for display purposes. McalFixture(Depthmap, FixtureOffset, M_MOVE_RELATIVE, M_RESULT_MOD, ModelRes, 0, M_DEFAULT, M_DEFAULT, M_DEFAULT); // Draw the found occurrence. MgraControl(M_DEFAULT, M_COLOR, M_COLOR_RED); MmodDraw(M_DEFAULT, ModelRes, GraList, M_DRAW_EDGES + M_MODEL, M_DEFAULT, M_DEFAULT); MgraControl(M_DEFAULT, M_COLOR, M_COLOR_BLUE); MgraControl(M_DEFAULT, M_BACKCOLOR, M_COLOR_WHITE); McalDraw(M_DEFAULT, Depthmap, GraList, M_DRAW_RELATIVE_COORDINATE_SYSTEM + M_DRAW_FRAME, M_DEFAULT, M_DEFAULT); McalDraw(M_DEFAULT, FixtureOffset, GraList, M_DRAW_FIXTURING_OFFSET, M_DEFAULT, M_DEFAULT); // Get back the fixturing matrix from the model finder result. auto FixtureMatrix = M3dgeoAlloc(System, M_TRANSFORMATION_MATRIX, M_DEFAULT, M_UNIQUE_ID); McalFixture(FixtureMatrix, FixtureOffset, M_MOVE_RELATIVE, M_RESULT_MOD, ModelRes, 0, M_DEFAULT, M_DEFAULT, M_DEFAULT); // The returned matrix go from model to object. Inverse it to go from object to model. M3dgeoMatrixSetTransform(FixtureMatrix, M_INVERSE, FixtureMatrix, M_DEFAULT, M_DEFAULT, M_DEFAULT, M_DEFAULT); return FixtureMatrix; } //***************************************************************************** // Check for required files for running the example. //***************************************************************************** bool CheckForRequiredMILFile(MIL_CONST_TEXT_PTR FileName) { MIL_INT FilePresent; MappFileOperation(M_DEFAULT, FileName, M_NULL, M_NULL, M_FILE_EXISTS, M_DEFAULT, &amp;FilePresent); if (FilePresent == M_NO) { MosPrintf(MIL_TEXT(\"\\n\") MIL_TEXT(\"The files needed to run this example are missing. You need \\n\") MIL_TEXT(\"to obtain and apply a separate specific update to have it.\\n\\n\")); MosPrintf(MIL_TEXT(\"Press any key to end.\\n\\n\")); MosGetch(); } return (FilePresent == M_YES); } //***************************************************************************** // Projects the point cloud into a depth map. //***************************************************************************** MIL_UNIQUE_BUF_ID GenerateDepthMap(MIL_ID Container, MIL_DOUBLE PixelSize) { // Set the volume information. SProjectionBox Box; Box.OffsetX = 5.00; Box.OffsetY = -160.00; Box.OffsetZ = -4.00; Box.Length = 120.00; Box.Height = 410.00; Box.Thickness = -30.00; auto System = MobjInquire(Container, M_OWNER_SYSTEM, M_NULL); auto CroppingBox = M3dgeoAlloc(System, M_GEOMETRY, M_DEFAULT, M_UNIQUE_ID); M3dgeoBox(CroppingBox, M_CORNER_AND_DIMENSION, Box.OffsetX, Box.OffsetY, Box.OffsetZ, Box.Length, Box.Height, Box.Thickness, M_DEFAULT); M3dimCrop(Container, Container, CroppingBox, M_NULL, M_UNORGANIZED, M_DEFAULT); // Calculate the size required for the depth map. auto MapSizeContext = M3dimAlloc(System, M_CALCULATE_MAP_SIZE_CONTEXT, M_DEFAULT, M_UNIQUE_ID); M3dimControl(MapSizeContext, M_PIXEL_SIZE_X, PixelSize); M3dimControl(MapSizeContext, M_PIXEL_SIZE_Y, PixelSize); M3dimControl(MapSizeContext, M_PIXEL_ASPECT_RATIO, M_NULL); MIL_INT DepthMapSizeX, DepthMapSizeY; M3dimCalculateMapSize(MapSizeContext, Container, M_NULL, M_DEFAULT, &amp;DepthMapSizeX, &amp;DepthMapSizeY); // Allocate and calibrate the depth map. auto OutDepthmap = MbufAlloc2d(System, DepthMapSizeX, DepthMapSizeY, M_UNSIGNED + 8, M_IMAGE + M_PROC + M_DISP, M_UNIQUE_ID); M3dimCalibrateDepthMap(Container, OutDepthmap, M_NULL, M_NULL, M_DEFAULT, M_NEGATIVE, M_DEFAULT); // Project the point cloud on the depth map. M3dimProject(Container, OutDepthmap, M_NULL, M_POINT_BASED, M_MAX_Z, M_DEFAULT, M_DEFAULT); // Fill gaps if there is any. auto FillGapsContext = M3dimAlloc(System, M_FILL_GAPS_CONTEXT, M_DEFAULT, M_UNIQUE_ID); M3dimControl(FillGapsContext, M_FILL_MODE , M_X_THEN_Y); M3dimControl(FillGapsContext, M_FILL_SHARP_ELEVATION, M_DISABLE); M3dimControl(FillGapsContext, M_FILL_THRESHOLD_X , 1.0); M3dimControl(FillGapsContext, M_FILL_THRESHOLD_Y , 1.0); M3dimFillGaps(FillGapsContext, OutDepthmap, M_NULL, M_DEFAULT); return OutDepthmap; } //***************************************************************************** // Allocates a 3D display and returns its MIL identifier. //***************************************************************************** MIL_UNIQUE_3DDISP_ID Alloc3dDisplayId(MIL_ID System) { MappControl(M_DEFAULT, M_ERROR, M_PRINT_DISABLE); auto Display3d = M3ddispAlloc(System, M_DEFAULT, MIL_TEXT(\"M_DEFAULT\"), M_DEFAULT, M_UNIQUE_ID); MappControl(M_DEFAULT, M_ERROR, M_PRINT_ENABLE); if(!Display3d) { MosPrintf(MIL_TEXT(\"\\n\") MIL_TEXT(\"The current system does not support the 3D display.\\n\")); } return Display3d; } ",
      "wordCount": 2046
    },
    {
      "id": "Examples_Processing_3dReconstruction_3dProfileMetrology_CPP_interactiveprofile_cpp",
      "version": "2024020714",
      "title": "interactiveprofile.cpp",
      "location": "Sample Code from MIL Examples",
      "text": " Top //*************************************************************************************** // // File name: InteractiveProfile.cpp // Location: See Matrox Example Launcher in the MIL Control Center // // // Synopsis: Definition for CInteractiveDepthmapProfile. // // Copyright (C) Matrox Electronic Systems Ltd., 1992-2024. // All Rights Reserved //**************************************************************************** #include \"InteractiveProfile.h\" #include &lt;cmath&gt; //***************************************************************************** // Constructor. //***************************************************************************** CInteractiveDepthmapProfile::CInteractiveDepthmapProfile(MIL_ID DisplayTop, MIL_INT LabelTop, MIL_ID Display3d, MIL_INT Label3d, MIL_ID DisplayProfile, MIL_INT LabelProfile, MIL_DOUBLE Thickness) { auto Sys = MobjInquire(DisplayTop, M_OWNER_SYSTEM, M_NULL); // Copy the data. m_Top.Display = DisplayTop; m_Top.Label = LabelTop; m_Top.GraList = MdispInquire(m_Top.Display, M_ASSOCIATED_GRAPHIC_LIST_ID, M_NULL); m_Proc.Depthmap = MdispInquire(m_Top.Display, M_SELECTED, M_NULL); m_Proc.Context = M3dimAlloc(Sys, M_PROFILE_CONTEXT, M_DEFAULT, M_UNIQUE_ID); m_Proc.Result = M3dimAllocResult(Sys, M_PROFILE_RESULT, M_DEFAULT, M_UNIQUE_ID); m_Proc.Matrix = M3dgeoAlloc(Sys, M_TRANSFORMATION_MATRIX, M_DEFAULT, M_UNIQUE_ID); m_3d.Display = Display3d; m_3d.GraList = M3ddispInquire(m_3d.Display, M_3D_GRAPHIC_LIST_ID, M_NULL); m_3d.Label = Label3d; m_Profile.Display = DisplayProfile; m_Profile.GraList = M3ddispInquire(m_Profile.Display, M_3D_GRAPHIC_LIST_ID, M_NULL); m_Profile.Label = LabelProfile; // Verify the depth map. if(m_Proc.Depthmap == M_NULL || !McalInquire(m_Proc.Depthmap, M_DEPTH_MAP, M_NULL)) { MosPrintf(MIL_TEXT(\"The depth map should already be selected on the display.\\n\")); return; } // Get the depth map bounds. MIL_INT MaxPixel = MbufInquire(m_Proc.Depthmap, M_MAX, M_NULL) - 1; MIL_DOUBLE GrayLevelSizeZ = 0; McalInquire(m_Proc.Depthmap, M_GRAY_LEVEL_SIZE_Z + M_TYPE_MIL_DOUBLE, &amp;GrayLevelSizeZ); McalInquire(m_Proc.Depthmap, M_WORLD_POS_Z + M_TYPE_MIL_DOUBLE, &amp;m_Proc.MinZ); m_Proc.MaxZ = m_Proc.MinZ + GrayLevelSizeZ * MaxPixel; // Enable interactivity. MdispControl(m_Top.Display, M_GRAPHIC_LIST_INTERACTIVE, M_ENABLE); MgraControlList(m_Top.GraList, M_GRAPHIC_LABEL(m_Top.Label), M_DEFAULT, M_SELECTABLE, M_ENABLE); MgraControlList(m_Top.GraList, M_GRAPHIC_LABEL(m_Top.Label), M_DEFAULT, M_EDITABLE, M_ENABLE); MIL_INT LineColor = MgraInquireList(m_Top.GraList, M_GRAPHIC_LABEL(m_Top.Label), M_DEFAULT, M_COLOR, M_NULL); MgraControlList(m_Top.GraList, M_LIST, M_DEFAULT, M_INTERACTIVE_ANNOTATIONS_COLOR, LineColor); MgraControlList(m_Top.GraList, M_LIST, M_DEFAULT, M_SELECTED_COLOR, LineColor); // Setup the profile context. M3dimControl(m_Proc.Context, M_PROFILE_THICKNESS_MODE, M_WORLD); M3dimControl(m_Proc.Context, M_PROFILE_THICKNESS, Thickness); // Setup the 3D display. M3dgraControl(m_3d.GraList, M_DEFAULT_SETTINGS, M_COLOR_COMPONENT, M_COMPONENT_RANGE); M3dgraControl(m_3d.GraList, M_DEFAULT_SETTINGS, M_COLOR_COMPONENT_BAND, 2); M3dgraControl(m_3d.GraList, M_DEFAULT_SETTINGS, M_COLOR_USE_LUT, M_TRUE); M3dgraCopy(M_COLORMAP_GRAYSCALE + (GrayLevelSizeZ &gt; 0 ? 0 : M_FLIP), M_DEFAULT, m_3d.GraList, M_DEFAULT_SETTINGS, M_COLOR_LUT, M_DEFAULT); M3ddispSetView(m_3d.Display, M_AUTO, M_BOTTOM_TILTED, M_DEFAULT, M_DEFAULT, M_DEFAULT); // Set the display's rotation axis center. This will keep the // behaviour of auto rotate consistent as we move its interest point. M3ddispCopy(M_VIEW_INTEREST_POINT, Display3d, M_ROTATION_AXIS_CENTER, M_DEFAULT); M3ddispSelect(m_3d.Display, m_Proc.Depthmap, M_DEFAULT, M_DEFAULT); // Setup the profile display. M3ddispControl(m_Profile.Display, M_BACKGROUND_MODE, M_SINGLE_COLOR); M3ddispControl(m_Profile.Display, M_BACKGROUND_COLOR, M_COLOR_BLACK); M3ddispControl(m_Profile.Display, M_ROTATION_INDICATOR, M_DISABLE); M3ddispControl(m_Profile.Display, M_KEYBOARD_USE, M_DISABLE); M3ddispControl(m_Profile.Display, M_MOUSE_USE, M_DISABLE); M3ddispControl(m_Profile.Display, M_PROJECTION_MODE, M_PARALLEL_PRECISE); UpdateProfile(true); M3ddispSelect(m_Profile.Display, M_NULL, M_OPEN, M_DEFAULT); // Create a profile once to avoid displaying nothing. StartHook(); } //***************************************************************************** // Static hook interface for MgraHookFunction. //***************************************************************************** MIL_INT CInteractiveDepthmapProfile::HookFunc(MIL_INT HookType, MIL_ID EventId, void* UserDataPtr) { auto pThis = static_cast&lt;CInteractiveDepthmapProfile*&gt;(UserDataPtr); MIL_INT Label; MgraGetHookInfo(EventId, M_GRAPHIC_LABEL_VALUE, &amp;Label); if(HookType == M_GRAPHIC_MODIFIED &amp;&amp; Label == pThis-&gt;m_Top.Label) pThis-&gt;UpdateProfile(false); return 0; } //***************************************************************************** // Actual hook function. // Gets the editable line info, creates the profile, and draws it in the 3d and graph displays. //***************************************************************************** void CInteractiveDepthmapProfile::UpdateProfile(bool Initial) { // Get the line info. MIL_DOUBLE StartX, StartY, EndX, EndY; MgraInquireList(m_Top.GraList, M_GRAPHIC_LABEL(m_Top.Label), 0, M_POSITION_X, &amp;StartX); MgraInquireList(m_Top.GraList, M_GRAPHIC_LABEL(m_Top.Label), 0, M_POSITION_Y, &amp;StartY); MgraInquireList(m_Top.GraList, M_GRAPHIC_LABEL(m_Top.Label), 1, M_POSITION_X, &amp;EndX); MgraInquireList(m_Top.GraList, M_GRAPHIC_LABEL(m_Top.Label), 1, M_POSITION_Y, &amp;EndY); // Get the profile points. M3dimProfileEx(m_Proc.Context, m_Proc.Depthmap, m_Proc.Result, M_WORLD, StartX, StartY, EndX, EndY, M_DEFAULT); MIL_INT Status; M3dimGetResult(m_Proc.Result, M_STATUS, &amp;Status); M3dimCopyResult(m_Proc.Result, m_Proc.Matrix, M_MATRIX_PROFILE_PLANE_TO_WORLD, M_DEFAULT); M3dgeoMatrixSetTransform(m_Proc.Matrix, M_TRANSLATION, 0, 0, m_Proc.MaxZ, M_DEFAULT, M_COMPOSE_WITH_CURRENT); M3dimGetResult(m_Proc.Result, M_PROFILE_PLANE_X, m_Proc.PointsX); M3dimGetResult(m_Proc.Result, M_PROFILE_PLANE_Y, m_Proc.PointsY); m_Proc.PointsZ.resize(m_Proc.PointsX.size(), 0); // Get the profile bounds. MIL_DOUBLE PolygonX[4] = {StartX, StartX, EndX, EndX}; MIL_DOUBLE PolygonY[4] = {StartY, StartY, EndY, EndY}; MIL_DOUBLE PolygonZ[4] = {m_Proc.MinZ, m_Proc.MaxZ, m_Proc.MaxZ, m_Proc.MinZ}; // World draw. M3ddispControl(m_3d.Display, M_UPDATE, M_DISABLE); if(m_3d.Label) M3dgraRemove(m_3d.GraList, m_3d.Label, M_DEFAULT); m_3d.Label = M3dgraNode(m_3d.GraList, M_ROOT_NODE, M_DEFAULT, M_DEFAULT); // Draw the region. auto WorldRegionLabel = M3dgraPolygon(m_3d.GraList, m_3d.Label, M_DEFAULT, 4, PolygonX, PolygonY, PolygonZ, M_NULL, M_NULL, M_NULL, M_DEFAULT); M3dgraControl(m_3d.GraList, WorldRegionLabel, M_COLOR, M_COLOR_YELLOW); M3dgraControl(m_3d.GraList, WorldRegionLabel, M_OPACITY, 80); // Draw the axes. MIL_DOUBLE WorldSizeX = std::hypot(StartX - EndX, StartY - EndY); MIL_DOUBLE WorldSizeY = abs(m_Proc.MaxZ - m_Proc.MinZ); MIL_DOUBLE AxisLength = 0.5 * std::min(WorldSizeX, WorldSizeY); M3dgraAxis(m_3d.GraList, m_3d.Label, m_Proc.Matrix, AxisLength, MIL_TEXT(\"\"), M_DEFAULT, M_DEFAULT); M3ddispControl(m_3d.Display, M_UPDATE, M_ENABLE); // Profile draw. M3dimCopyResult(m_Proc.Result, m_Proc.Matrix, M_MATRIX_WORLD_TO_PROFILE_PLANE, M_DEFAULT); M3dimMatrixTransformList(m_Proc.Matrix, 4, PolygonX, PolygonY, PolygonZ, PolygonX, PolygonY, PolygonZ, M_DEFAULT); M3ddispControl(m_Profile.Display, M_UPDATE, M_DISABLE); if(m_Profile.Label) M3dgraRemove(m_Profile.GraList, m_Profile.Label, M_DEFAULT); m_Profile.Label = M3dgraNode(m_Profile.GraList, M_ROOT_NODE, M_DEFAULT, M_DEFAULT); // Draw the region. auto ProfileRegionLabel = M3dgraPolygon(m_Profile.GraList, m_Profile.Label, M_DEFAULT, 4, PolygonX, PolygonY, PolygonZ, M_NULL, M_NULL, M_NULL, M_DEFAULT); M3dgraControl(m_Profile.GraList, ProfileRegionLabel, M_COLOR, M_COLOR_WHITE); M3dgraControl(m_Profile.GraList, ProfileRegionLabel, M_APPEARANCE, M_WIREFRAME); // Draw the axes. M3dgeoMatrixSetTransform(m_Proc.Matrix, M_TRANSLATION, 0, m_Proc.MaxZ, 0, M_DEFAULT, M_DEFAULT); M3dgraAxis(m_Profile.GraList, m_Profile.Label, m_Proc.Matrix, AxisLength, MIL_TEXT(\"\"), M_DEFAULT, M_DEFAULT); // Draw the points. if(!m_Proc.PointsX.empty()) { auto ProfileDotsLabel = M3dgraDots(m_Profile.GraList, m_Profile.Label, M_DEFAULT, m_Proc.PointsX, m_Proc.PointsY, m_Proc.PointsZ, M_NULL, M_NULL, M_NULL, M_DEFAULT); M3dgraControl(m_Profile.GraList, ProfileDotsLabel, M_THICKNESS, 3); M3dgraControl(m_Profile.GraList, ProfileDotsLabel, M_COLOR, M_COLOR_YELLOW); } // Resize the display. if(Initial) { M3ddispSetView(m_Profile.Display, M_VIEW_ORIENTATION, M_BOTTOM_VIEW, M_DEFAULT, M_DEFAULT, M_DEFAULT); // Set the display's rotation axis center. This will keep the // behaviour of auto rotate consistent as we move its interest point. M3ddispCopy(M_VIEW_INTEREST_POINT, m_Profile.Display, M_ROTATION_AXIS_CENTER, M_DEFAULT); M3ddispControl(m_Profile.Display, M_PARALLEL_SCALE, DISPLAY_PROFILE_ZOOM_FACTOR * std::max(WorldSizeX, WorldSizeY) / DISPLAY_PROFILE_INITIAL_SIZE_MAX); } MIL_DOUBLE ParallelScale; M3ddispInquire(m_Profile.Display, M_PARALLEL_SCALE, &amp;ParallelScale); MIL_INT CurrentSizeX = M3ddispInquire(m_Profile.Display, M_SIZE_X, M_NULL); MIL_INT CurrentSizeY = M3ddispInquire(m_Profile.Display, M_SIZE_Y, M_NULL); MIL_INT NewSizeX = (MIL_INT)(DISPLAY_PROFILE_ZOOM_FACTOR * WorldSizeX / ParallelScale); MIL_INT NewSizeY = (MIL_INT)(DISPLAY_PROFILE_ZOOM_FACTOR * WorldSizeY / ParallelScale); if(Initial || NewSizeX &gt; CurrentSizeX || NewSizeY &gt; CurrentSizeY) { M3ddispControl(m_Profile.Display, M_WINDOW_RESIZE, M_ENABLE); M3ddispControl(m_Profile.Display, M_SIZE_X, NewSizeX); M3ddispControl(m_Profile.Display, M_SIZE_Y, NewSizeY); M3ddispControl(m_Profile.Display, M_WINDOW_RESIZE, M_DISABLE); if(!Initial) { M3ddispSetView(m_Profile.Display, M_TRANSLATE, ParallelScale * (NewSizeX - CurrentSizeX) / 2, ParallelScale * (NewSizeY - CurrentSizeY) / 2, 0, M_DEFAULT); // Set the display's rotation axis center. This will keep the // behaviour of auto rotate consistent as we move its interest point. M3ddispCopy(M_VIEW_INTEREST_POINT, m_Profile.Display, M_ROTATION_AXIS_CENTER, M_DEFAULT); } } M3ddispControl(m_Profile.Display, M_UPDATE, M_ENABLE); } ",
      "wordCount": 835
    }
  ]
}]
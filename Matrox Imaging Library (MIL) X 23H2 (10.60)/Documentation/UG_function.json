[{
  "id": "UG_function",
  "version": "2024020714",
  "title": "The MIL function development module",
  "subTitles": null,
  "location": "MIL UG P11: Miscellaneous",
  "pageURL": "content\\UserGuide\\function\\ChapterInformation.htm",
  "text": " Chapter 67: The MIL function development module This chapter discusses the purpose of the MIL Function Development module and how to integrate your own functions into MIL. MIL Function Development module Steps to create a user-defined MIL function Basic concepts for the MIL Function Development module Characteristics of a user-defined MIL function Remote and local functions Asynchronous and synchronous functions Modules, opcodes, and error handling Error handling in slave functions Current and global errors Accessing errors in slave functions from the main thread Logging errors Print error settings Parameter registration and return values MfuncParam and MfuncParamValue Return values Master/slave dynamics on a remote system Compilation Executing the slave function on a remote system Using a Library file in a Distributed MIL cluster Associating a MIL identifier with a user-defined object Script-based user-defined MIL function ",
  "wordCount": 136,
  "subEntries": [
    {
      "id": "UG_function_The_MIL_function_development_module",
      "version": null,
      "title": "MIL Function Development module",
      "subTitles": null,
      "location": "MIL UG P11: Miscellaneous",
      "pageURL": "content\\UserGuide\\function\\The_MIL_function_development_module.htm",
      "text": " MIL Function Development module The MIL Function Development module allows programmers to define custom (user-defined) MIL functions to extend MIL's functionality. Using this module, you can implement functions or scripts, and integrate them directly into MIL, where they behave like standard MIL functions (for example, respecting error handling and tracing). The MIL Function Development module also allows programmers to group related user-defined MIL functions together into user-defined modules. This is useful to create high-level packages on top of MIL and to extend MIL's function set (for example, by adding new functions with specialized algorithms). Using a user-defined MIL function, you can integrate functions or scripts written in C, C++, C#, or Python into MIL. You can also integrate functions/scripts written in other .NET languages or language versions (for Python) but you will need to develop an additional DLL to use these other languages. User-defined MIL functions based on C or C++ functions (embedded in a DLL) are referred to as C-based user-defined MIL functions. User-defined MIL functions based on a function or script that require an interpreter or the Microsoft .NET framework to be present at runtime are referred to as script-based user-defined MIL functions. To allow for the remote execution of user-defined MIL functions and the ability to run scripts, user-defined MIL functions are composed of two parts: a master function and a slave function/script. The master function performs the parameter registration and transfers the information to the slave function/script. The slave function/script receives the parameter information and performs the data processing operations of the user-defined MIL function. When a remote processor is available, the slave function/script of a user-defined MIL function that meets certain criteria can be executed remotely. For the purposes of this chapter, the processor that executes the master function is referred to as the master processor and the processor which executes the slave function/script is referred to as the slave processor. When no remote processor is available, the master and slave processors are the Host processor. The MIL Function Development module also provides a framework in which you can define your own objects and associate them with MIL identifiers. Such associations can be useful when designing objects, within a user-defined MIL function, whose data members should not be accessed directly and whose data structure has specific requirements. When designing a function, or set of functions, the MIL Function Development module puts at your disposal all the tools necessary to create custom error codes and error messages that are treated as regular MIL errors which can in turn be managed using the Mapp...() functions. MIL Function Development module ",
      "wordCount": 434,
      "subEntries": []
    },
    {
      "id": "UG_function_Steps_to_create_a_userdefined_function",
      "version": null,
      "title": "Steps to create a user-defined MIL function",
      "subTitles": null,
      "location": "MIL UG P11: Miscellaneous",
      "pageURL": "content\\UserGuide\\function\\Steps_to_create_a_userdefined_function.htm",
      "text": " Steps to create a user-defined MIL function The following steps provide a basic methodology for using the MIL Function Development module to create a C-based user-defined function: Create a master function. The name that you will use to call the user-defined MIL function from an application is the same as the name of the master function. Allocate a function context for the new function using MfuncAlloc(). The MfuncAlloc() function should be the first MIL function called in the master function. The allocated function context provides a MIL identifier for your user-defined MIL function, and allows this function to be treated as a regular MIL function (for example, error checking and tracing will be performed). Register the parameters of the master function in the function context using MfuncParam() with the appropriate data type or using one of the type-specific versions of this function (for example, MfuncParamMILInt()). Registering the parameters gives the slave function access to the parameter values. Call the slave function from the master function, using MfuncCall(). The slave function must be created as a separate function. Note that you must call MfuncCall() from the same thread as MfuncAlloc(). Free the function context. At the end of the master function, the created function context must be freed, using the MfuncFree() function. This should be the last MIL function called in the master function. Note that you must call MfuncFree() from the same thread as MfuncAlloc() and MfuncCall(). Create the slave function. This function must accept the MIL identifier of the function context as its only parameter. See the description of MfuncCall() for a prototype of a slave function. In the slave function, you must retrieve the values of the parameters registered in the master function, using MfuncParamValue(), and develop the code that will produce the required results. You can make calls to other MIL functions from the slave function. Once you have performed the steps listed above, the user-defined MIL function is created, and you can use it in an application. The steps required to create a script-based user-defined function are similar to creating a C-based user-defined function. So with the exception of one section, the remainder of this chapter will discuss creating a C-based MIL user-defined function. Then, the differences between the two sets of steps are examined in the Script-based user-defined MIL function section later in this chapter. The following example shows how to create a C-based user-defined MIL function. mfunc.cpp Steps to create a user-defined MIL function ",
      "wordCount": 412,
      "subEntries": []
    },
    {
      "id": "UG_function_Basic_concepts",
      "version": null,
      "title": "Basic concepts for the MIL Function Development module",
      "subTitles": null,
      "location": "MIL UG P11: Miscellaneous",
      "pageURL": "content\\UserGuide\\function\\Basic_concepts.htm",
      "text": " Basic concepts for the MIL Function Development module The basic concepts and vocabulary conventions for the MIL Function Development module are: Asynchronous function. A function that returns control to the calling thread before it has finished executing. C-based user-defined MIL function. A user-defined function written in C or C++, compiled into a DLL, and integrated into a MIL application using the MIL function development module. Distributed processing. Distributed processing is a processing method which involves using more than one processor to perform the required operations. Execution of a function by a remote processor requires special consideration during compilation. Master function. In a user-defined MIL function, the master function provides the user interface. The slave function is called from within the master function. Master processor. The master processor is the processor on which the master function is executed. Opcode. All MIL functions, including user-defined functions, are associated with a unique operation code. Operation codes are, in turn, associated with pointers to their corresponding functions. The operation code is then used to refer to the function indirectly. For simplicity, operation codes are referred to as opcodes. Opcode table. The opcode table is a table in which on-board processors store the associations between opcodes and pointers to MIL functions. Remote processor. A remote processor is any available processor which is separate from the Host processor. Script-based user-defined MIL function. A user-defined function written in a language requiring an interpreter or based on the .NET framework, and integrated into a MIL application using the MIL function development module. Slave function. In a user-defined MIL function, the slave function is called by the master function. The slave function performs the data processing operations of the user-defined MIL function. Slave processor. The slave processor is the processor on which the slave function will be executed. The slave processor can be either the same processor as the master processor or a remote processor. Synchronous function. A function that returns control to the calling thread only after it has finished executing. Basic concepts for the MIL Function Development module ",
      "wordCount": 343,
      "subEntries": []
    },
    {
      "id": "UG_function_Characteristics_of_a_userdefined_MIL_function",
      "version": null,
      "title": "Characteristics of a user-defined MIL function",
      "subTitles": [
        "Remote and local functions",
        "Asynchronous and synchronous functions"
      ],
      "location": "MIL UG P11: Miscellaneous",
      "pageURL": "content\\UserGuide\\function\\Characteristics_of_a_userdefined_MIL_function.htm",
      "text": " Characteristics of a user-defined MIL function Each user-defined MIL function consists of a master and a slave function. The master function provides the user interface and sets up the MIL function context for the new function. In the master function, you must allocate the function context for the new function, register the parameters declared by the master function as parameters of the user-defined MIL function, call the slave function, and, in the end, free the allocated MIL identifier of the function. The slave function is a separate function that actually performs the required operations when the user-defined MIL function is called. The slave function must be implemented as a separate function because it can be executed remotely by a slave node in a Distributed MIL application. The only parameter that is passed to the slave function is the MIL identifier of the function context. The slave function uses this identifier to access the MIL function context and retrieve the parameters from the context using the MfuncParamValue() function. You can also make calls to other MIL functions from the slave function. Note that to increase efficiency, parameter checking is not performed for user-defined MIL functions. Remote and local functions When allocating your function context using MfuncAlloc() in the master function, you must specify whether your user-defined MIL function will be executed on the master computer or the remote computer with M_LOCAL or M_REMOTE. User-defined MIL functions allocated as M_LOCAL will be executed by the Host processor, whereas user-defined MIL functions allocated as M_REMOTE will be executed by a remote processor, if one is available. Asynchronous and synchronous functions When allocating your function context using MfuncAlloc() in the master function, you must specify whether your user-defined MIL function will run asynchronously or synchronously (M_ASYNCHRONOUS_FUNCTION or M_SYNCHRONOUS_FUNCTION) with respect to the calling thread. User-defined MIL functions allocated to run asynchronously will return control to the calling thread immediately after being called. One advantage of running functions asynchronously is that they allow the master function to immediately proceed to the next statement, while the slave processor executes the slave function. Note that an asynchronous function can modify MIL buffers and parameters passed by reference, but cannot actually return a value. For more information on return values, see the Return values subsection of the Parameter registration and return values section later in this chapter. Note that user-defined MIL functions allocated to run on the Host processor must be run synchronously and user-defined MIL functions allocated to run on the remote processor can be run asynchronously or synchronously. Characteristics of a user-defined MIL function Remote and local functions Asynchronous and synchronous functions ",
      "wordCount": 438,
      "subEntries": []
    },
    {
      "id": "UG_function_Modules_opcodes_and_error_messages",
      "version": null,
      "title": "Modules, opcodes, and error handling",
      "subTitles": [
        "Error handling in slave functions",
        "Current and global errors",
        "Accessing errors in slave functions from the main thread",
        "Logging errors",
        "Print error settings"
      ],
      "location": "MIL UG P11: Miscellaneous",
      "pageURL": "content\\UserGuide\\function\\Modules_opcodes_and_error_messages.htm",
      "text": " Modules, opcodes, and error handling User-defined MIL functions can be associated with a user-defined module; related functions are typically grouped into the same user-defined module. You can group your functions into a maximum of 7 user-defined modules, each of which can contain up to 128 user-defined MIL functions. A function's opcode indicates both its module and its offset within the module. When allocating the function context using MfuncAlloc(), the opcode is specified as M_USER_MODULE_n + m, where n specifies the user-defined module and m specifies the function's offset within the module. User-defined MIL functions don't need to be grouped into a module. In this case, specify the function's opcode using M_USER_FUNCTION + m, where m is a value between 0 to 127 that has not already been assigned to another ungrouped function. This means that to generate an opcode, you can have up to 128 ungrouped user-defined functions. A function's opcode must be unique. The uniqueness of the function's opcode is particularly important when retrieving error codes since the function that returned an error is identified by its opcode. The uniqueness is also critical when executing the slave function remotely; see the Master/slave dynamics on a remote system section later in this chapter. Error handling in slave functions A MIL application has specific functionality and settings for error handling. Typically, the settings apply to the entire application. However, a slave function has its own error handling settings. For general information about error handling in MIL, see the MIL errors section of Chapter 64: Development and debugging tools and techniques. Current and global errors An application has a place to store its current error and global error, if any exist. Any errors that come from a function within a slave function, however, are stored in a separate place reserved for the slave function's current and global error. To inquire or clear the slave function's errors, call MappGetError() or MappControl() with M_CLEAR_ERROR, respectively, within the slave function itself. Calling these functions within the slave function will have no effect on the error settings of the application. When a slave function ends, its global error, if any, is transferred to the current error of the main application. If the slave function's errors were cleared prior to it ending, nothing is transferred. Each time your user-defined MIL function is called, its slave function starts with cleared errors. Its current and global errors are not retained across multiple calls. Accessing errors in slave functions from the main thread Within the thread that calls a slave function, you can retrieve information about the error reported by the function using MappGetError() with M_CURRENT after the slave function has completed. The error reported is the first error that was generated in the slave function, unless it was cleared using MappControl() with M_CLEAR_ERROR within the slave function (in which case the first error generated after the error was cleared is reported). Note that if you have specified that your MIL function executes asynchronously (MfuncAlloc() with M_ASYNCHRONOUS_FUNCTION) or calls a MIL function that executes asynchronously (and therefore might complete after the slave function returns), there are additional considerations for error checking. For more information, see the Asynchronous MIL functions subsection of the MIL errors section of Chapter 64: Development and debugging tools and techniques. Alternatively, within the thread that calls the main function, you can hook to MIL errors generated within the slave function using MappHookFunction() with M_SLAVE_ERROR_CURRENT. In this case, the hook function will be called immediately for every error that is generated (before the slave function has the opportunity to clear the error using MappControl() with M_CLEAR_ERROR). Note that, within a slave function, you can call MappHookFunction() to hook a user-defined function to an event. However, the HookType cannot be M_ERROR_CURRENT. Specifying this event type will generate an error. Logging errors When developing user-defined MIL functions, MfuncErrorReport() allows you to create custom error codes and error messages which are treated as normal MIL errors. MfuncErrorReport() also allows you to associate each error code with an error message; up to one hundred such custom error code associations can be defined within MIL. Any error logged by calling MfuncErrorReport() from within a slave function will be stored as the slave function's new global error. If you set ErrorCode to M_NULL, the slave function's global error is reset, resulting in no error being returned after the slave function has ended. Print error settings Each slave function has its own print error setting, which controls whether an error is printed to the screen, independent of the master function's setting. The default value for a slave function's print error setting is different from most other types of functions. The default for a slave function is M_PRINT_DISABLE, while it is M_PRINT_ENABLE for the rest. This setting can be changed using MappControl() set to M_ERROR + M_THREAD_CURRENT. Whatever the setting, you can always check for an error using MappGetError(). Modules, opcodes, and error handling Error handling in slave functions Current and global errors Accessing errors in slave functions from the main thread Logging errors Print error settings ",
      "wordCount": 844,
      "subEntries": []
    },
    {
      "id": "UG_function_Parameter_registration_and_return_values",
      "version": null,
      "title": "Parameter registration and return values",
      "subTitles": [
        "MfuncParam and MfuncParamValue",
        "Return values"
      ],
      "location": "MIL UG P11: Miscellaneous",
      "pageURL": "content\\UserGuide\\function\\Parameter_registration_and_return_values.htm",
      "text": " Parameter registration and return values Parameters must be registered in the master function with the MfuncParam...() function that matches the data type of the parameter (for example, a parameter of type MIL_INT should be registered using MfuncParamMilInt()); the values of the parameters passed to the master function must then be retrieved from within the slave function using the corresponding MfuncParamValue...(). You can alternatively use the general form of the above functions, MfuncParam() and MfuncParamValue(), respectively. Certain parameter registration functions require additional details about the parameter being registered: When registering parameters of type MIL_ID (using MfuncParamMilId(), MfuncParamArrayMilId(), or MfuncParamConstArrayMilId()), you must specify the type of MIL object. When registering parameters that accept pointers (using MfuncParamDataPointer() or MfuncParamConstDataPointer()), you must specify the size of the data, in bytes. When registering parameters that accept strings (using MfuncParamMilText(), MfuncParamConstMilText(), or MfuncParamFilename()), you must specify the number of characters in the string, including the null terminator. When registering parameters of type MIL_ID (using MfuncParamMilId(), MfuncParamArrayMilId(), or MfuncParamConstArrayMilId()) or parameters that accept strings or pointers, you must specify whether the parameter will serve as input (M_IN), output (M_OUT), or both (M_IN + M_OUT) for your function. Your slave function should use output parameters to return results (for example, the destination buffer of an operation should be passed as an output parameter). The M_IN and M_OUT attributes of the MfuncParam...() functions do not serve to limit the slave function's ability to modify variables; rather, the M_OUT attribute serves to indicate to MIL that when the slave function finishes, MIL must synchronize the slave function's data for that parameter with the rest of the application. Identifying output parameters is particularly important when the slave function is being executed by a remote processor which does not have direct access to the Host's address space. In this case, when the slave function terminates, MIL will internally pass the new values for the output type parameters to the Host. If the content of a buffer is modified in a slave function executed by a remote processor, and the buffer was not registered as an output parameter, your changes will be lost when the slave function finishes. From within the slave function, you must declare a new variable for each parameter registered in the master function; the data type of each new variable must match the data type of its associated parameter. For example, a parameter of type MIL_ID must be registered using MfuncParamMilId() in the master function; then, in the slave function, you must declare a new variable of type MIL_ID and use MfuncParamValueMilId() to associate the new variable with the value passed as a parameter to the master function. Note that, if you are using an output pointer parameter, your function context must be allocated to run synchronously. MfuncParam and MfuncParamValue When registering a parameter, you can call the general function MfuncParam(), which you can use to register any type of parameter, or you can call a data-type specific MfuncParam...() function, such as MfuncParamMilId() and MfuncParamMilInt(). MfuncParam() will internally call the appropriate data-type specific version based on the values you specify in the function. Similarly to MfuncParam(), when reading the value of a parameter registered in the master function, you can call the general function MfuncParamValue(), or you can call a data-type specific MfuncParamValue...() function, such as MfuncParamValueMilId() and MfuncParamValueMilInt(). Return values Only synchronous user-defined MIL functions (MfuncAlloc() with M_SYNCHRONOUS_FUNCTION) can have a return value. To have a user-defined MIL function return a value, the return value must be generated in the slave function and returned by the master function. However, the slave function of a user-defined MIL function must be declared as being of type void MFTYPE; therefore, slave functions can't directly return a value. To return a value, the master function must declare a variable (the return variable) and register a pointer to it as if it was a real M_OUT parameter of the master function. The slave function should treat the return variable as a regular M_OUT parameter. Note that the number of parameters specified during context allocation in a user-defined MIL function (MfuncAlloc()) limits the number of parameters that the slave function can retrieve. If a user-defined MIL function has a return value, the number of parameters must be set to one greater than is actually passed to the master function. The address of the return variable must be registered as a pointer parameter in the master function (MfuncParamDataPointer() or MfuncParamArrayMilId() with Attribute set to M_OUT). Then, in the slave function, you must declare a pointer variable of the same type as the return variable and associate the pointer with the address of the return variable using MfuncParamValue(). Recall that, the slave function does not actually store the return value at the memory address provided by the master function; it provides the master function with the new value to be written to memory. The following portion of MIL code shows the master function of a user-defined MIL function with a return value: int MyFunc( MIL_ID SrcImage ) { MIL_ID MyFunctionContext; int ReturnValue = 0; MfuncAlloc( MIL_TEXT(\"MyFunc\"), 2, MyFuncSlave, M_NULL, M_NULL, M_USER_MODULE_1+1, M_SYNCHRONOUS_FUNCTION+M_LOCAL, &amp;MyFunctionContext ); MfuncParamMilId ( MyFunctionContext, 1, SrcImage, M_IMAGE, M_IN+M_PROC ); MfuncParamDataPointer ( MyFunctionContext, 2, &amp;ReturnValue, sizeof(ReturnValue), M_OUT ); MfuncCall( MyFunctionContext ); MfuncFree( MyFunctionContext ); return ReturnValue; } The following portion of MIL code shows how to retrieve the address of the return variable and use it to store the return value (in the slave function): void MFTYPE MyFuncSlave( MIL_ID Func ){ MIL_ID SrcImage; int *ReturnValuePtr; int ValueToReturn = 0; MfuncParamValue( Func, 1, &amp;SrcImage ); MfuncParamValue( Func, 2, &amp;ReturnValuePtr ); /* Calculate the return value */ // ValueToReturn = ... *ReturnValuePtr = ValueToReturn; } Parameter registration and return values MfuncParam and MfuncParamValue Return values ",
      "wordCount": 951,
      "subEntries": []
    },
    {
      "id": "UG_function_Master_slave_dynamics_on_a_remote_system",
      "version": null,
      "title": "Master/slave dynamics on a remote system",
      "subTitles": [
        "Compilation",
        "Executing the slave function on a remote system",
        "Using a Library file in a Distributed MIL cluster"
      ],
      "location": "MIL UG P11: Miscellaneous",
      "pageURL": "content\\UserGuide\\function\\Master_slave_dynamics_on_a_remote_system.htm",
      "text": " Master/slave dynamics on a remote system When you allocate your function context in the master function (MfuncAlloc()), you must provide an opcode for the slave function. If the slave function will be executed on the master computer, you must provide a pointer to the function using MfuncAlloc() with SlaveFunctionPtr, but if your slave function will be executed by the remote system in a Distributed MIL application you must provide the name of the library file and the name of the function within the library file using MfuncAlloc() with SlaveFunctionDLLName and SlaveFunctionName, respectively. You must also specify, using the InitFlag parameter, if the slave function must be run on the master computer (M_LOCAL) or, when possible, on the remote computer (M_REMOTE). MfuncCall() uses the pointer to call the slave function when it is to be executed on the master computer, and uses either the opcode or the library file to call the slave function when it is to be executed on the remote computer. Even if the slave function will be executed on the master computer, the opcode is still required for error reporting purposes. For more information about Distributed MIL and its applications, see Chapter 62: Distributed MIL. Compilation Depending on the scope requirements of your user-defined function, its master function and its slave function will need to be compiled differently, according to how they will be called and how you want them to be executed. Every user-defined MIL function will have different scope requirements depending on the application in which it is being used. There are 5 possible execution scenarios for a user-defined MIL function: The user-defined MIL function will be called and executed by the Host. The user-defined MIL function will be called by the Host and executed by the remote system. In this scenario, the master function should be compiled for the Host and the slave function should be compiled for the slave processor or into a library file, depending on the type of remote system executing the slave function. The user-defined MIL function will be called and executed by the remote system. In this scenario, the master and slave functions should be compiled for the slave processor or into a library file, depending on the type of remote system executing the slave function. The user-defined MIL function might be called from either the Host or remote system, and is executed by the remote system. In this scenario, the master function should be compiled for both the Host and remote system, and the slave function should be compiled for the slave processor or into a library file, depending on the type of remote system executing the slave function. The recommended way to compile the master and slave functions of a user-defined MIL function is to compile both master and slave functions for both the Host and remote systems. Compiling the function in this way ensures that your MIL application will be portable to computers that might or might not have access to remote systems. Function contexts allocated to run on the remote computer (MfuncAlloc() with InitFlag set to M_REMOTE) will, in the absence of a remote processor, be executed on the master computer and function contexts allocated using the default execution type (MfuncAlloc() with InitFlag set to M_DEFAULT) will make use of the remote system when one is available. Compiling a master and/or slave function for the Host processor is typically the same as compiling any other function of your application. Executing the slave function on a remote system Typically, MIL automatically determines whether to have the slave function executed by the Host processor or by the remote processor. To determine where to execute the slave function, MIL looks to the values of the user-defined MIL function parameters, registered in the master function. When all of the MIL objects passed as parameters to the function are allocated on the same system, or if one of the parameters is a MIL system identifier, the slave function is executed by the processor associated with that system. If the master function has multiple MIL object parameters, and the MIL objects passed to these parameters are allocated on different systems, an error message is returned. When a user-defined MIL function has a user-defined MIL object as one of its parameters, and you want the slave function to be executed by a remote processor, you must allocate this object on the system with the remote processor. For more information, see the Associating a MIL identifier with a user-defined object section later in this chapter. Note that when the slave function is executed by the remote processor, operations that use other systems cannot be executed. For example, when a slave function is executed on a remote system using a Matrox Radient, and there is a call in the slave function to an MdigGrab() function that performs a grab on Matrox Morphis, this grab operation will cause an error. Using a Library file in a Distributed MIL cluster When compiling a new user-defined MIL function for a remote system in a Distributed MIL cluster, you must compile your user-defined function into a library file. In the master function, located in your application running on the Host-type system, you must provide the name of the library file containing the slave function and the name of the slave function, using MfuncAlloc() with SlaveFunctionDLLName and SlaveFunctionName, respectively. If your function will be called from a remote computer, the library file should also contain the master function of your user-defined function. In the master function, located in the library file, you can provide a pointer to your slave function using MfuncAlloc() using SlaveFunctionPtr, or provide the name of the library file and the name of the slave function, as above. From within the library file, it is faster to provide a pointer to the slave function than it is to provide the name of the library file and the name of the function. Master/slave dynamics on a remote system Compilation Executing the slave function on a remote system Using a Library file in a Distributed MIL cluster ",
      "wordCount": 1011,
      "subEntries": []
    },
    {
      "id": "UG_function_Associating_a_MIL_identifier_with_a_userdefined_object",
      "version": null,
      "title": "Associating a MIL identifier with a user-defined object",
      "subTitles": null,
      "location": "MIL UG P11: Miscellaneous",
      "pageURL": "content\\UserGuide\\function\\Associating_a_MIL_identifier_with_a_userdefined_object.htm",
      "text": " Associating a MIL identifier with a user-defined object The MIL Function Development module allows you to associate a MIL identifier with an object so that this object can be treated as a standard MIL object. Use the MfuncAllocId() function to associate a MIL identifier with any array or custom data structure. Defining your own user-defined MIL objects allows you to create data objects whose exact internal structure has specific requirements and whose data members should not be accessed directly. Once you have associated the user-defined object with a MIL identifier, it is known as a user-defined MIL object, and it will be subject to error checking and tracing as any other MIL object. Typically, you would create user-defined MIL objects in a user-defined MIL function. In this case, it is recommended that you create a user-defined MIL function whose sole purpose is to allocate the user-defined object and associate it with a MIL identifier. That is, the slave function of the user-defined MIL function only declares the object and associates it with a MIL identifier. This type of function is called a user-defined MIL allocation function. User-defined MIL allocation functions should be allocated using MfuncAlloc() with M_ALLOC. It is recommended that you register a MIL system identifier as a parameter of your user-defined MIL allocation function (MfuncParamMilId() with MilObjectType set to M_SYSTEM); this allows you to easily control which system your function will be executed on at runtime, and, by extension, on which system your user-defined object will be allocated. The MIL identifier associated with your newly allocated user-defined object can be retrieved by having your allocation function return it, or by storing it in a pointer parameter of type MIL_ID (MfuncParamArrayMilId()). Note that user-defined objects stored in the memory of a remote processor are not accessible from the Host processor, and vice versa, unless they are stored in shared memory. To refer to user-defined MIL objects, use their MIL identifiers. To refer to the actual data grouped in this user-defined MIL object, use a pointer to the object. You can retrieve the address of the object using the MfuncInquire() function with M_OBJECT_PTR. For example, for an object with this structure: /* Define the user-defined object's structure */ struct MyStruct { int MyData1; int MyData2; int MyData3; }; The following portion of MIL code shows how to allocate a custom object and associate it with a MIL identifier; this type of code would typically be found in a user-defined allocation function. MIL_ID MyObjectId; struct MyStruct MyObject = { 0 , 0 , 0 }; MyObjectId = MfuncAllocId( M_DEFAULT, M_USER_OBJECT_1+0x0001, &amp;MyObject ); The following portion of MIL code shows how to retrieve the address of the user-defined MIL object, allocated above, and use it to store data using a pointer; this type of code would typically be found in a user-defined MIL processing function which accepts the MIL object as a parameter. struct MyStruct *MyObjectPtr = M_NULL; int Result1 = 0; int Result2 = 0; int Result3 = 0; MfuncInquire( MyObjectId, M_OBJECT_PTR, &amp;MyObjectPtr ); /* Perform the calculations */ /* Result1 = ... */ /* Result2 = ... */ /* Result3 = ... */ /* The user-defined object's data can now be accessed using the pointer retrieved by MfuncInquire */ MyObjectPtr-&gt;MyData1 = Result1 ; MyObjectPtr-&gt;MyData2 = Result2 ; MyObjectPtr-&gt;MyData3 = Result3 ; When creating a user-defined MIL object, you must specify the MIL type of your object. MIL provides two object type groups (M_USER_OBJECT_1 and M_USER_OBJECT_2), permitting you to distinguish between categories of custom created objects. Each user-defined object group can contain up to 16 user-defined object types (M_USER_OBJECT_n + m , where n is 1 or 2, and m specifies the offset within the group). To inquire about the type of a user-defined MIL object, use the MobjInquire() function with M_OBJECT_TYPE. Once you have finished using a user-defined MIL object, you must free the MIL identifier associated with this object, using the MfuncFreeId() function. Note that you need not free the MIL identifier in the same function where it was associated with the object (MfuncAllocId()). It is recommended that you create a user-defined MIL function whose sole purpose is to free the user-defined object and its MIL identifier. This type of function should be allocated using MfuncAlloc() with M_FREE, and must accept the MIL identifier to be freed as its only parameter. Associating a MIL identifier with a user-defined object ",
      "wordCount": 732,
      "subEntries": []
    },
    {
      "id": "UG_function_Scriptbased_userdefined_MIL_function",
      "version": null,
      "title": "Script-based user-defined MIL function",
      "subTitles": null,
      "location": "MIL UG P11: Miscellaneous",
      "pageURL": "content\\UserGuide\\function\\Scriptbased_userdefined_MIL_function.htm",
      "text": " Script-based user-defined MIL function Besides C-based user-defined functions, the MIL Function Development module also allows you to create user-defined MIL functions based on functions/scripts that require an interpreter (for example, written in Python) or the .NET framework (for example, written in C#) to be present at runtime. These are referred to as script-based user-defined functions. Script-based and C-based user-defined MIL functions have many similarities with regards to their implementation and manner of use. The following table gives a brief overview of the differences encountered: Feature C-based user-defined functions Script-based user-defined functions Parameter limitation 16 parameters 15 parameters Compilation step Compiled when the MIL application is compiled Compiled at runtime Function grouping within MIL 7 modules 64 functions per module 2 modules 64 functions per module Supported languages C, C++ C#, Python 3.6 or later Modifiable during runtime No Yes Much like the C-based user-defined functions, each script-based user-defined MIL function has a master and slave component to it. However, unlike a C-based user-defined function, you must allocate a MIL function context using MfuncAllocScript() instead of MfuncAlloc(). The slave portion of the script-based user-defined MIL function is the script you provide. Similar to C-based user-defined functions, you must register the parameters using MfuncParam(). By passing the function context identifier to MfuncCall(), you will execute the function specified in the call to MfuncAllocScript(). The script/function can be written in any of the languages (and language versions) listed below. Note that MIL includes the interpreter interface DLLs for these languages (and language versions). CPython 3.6. CPython 3.7. CPython 3.8. CPython 3.9. C#. If you are using a language (or language version) for which an interpreter interface DLL is not provided, you will be required to develop your own interpreter interface DLL from the provided code, along with ensuring the presence of an appropriate MIL wrapper to unpack parameters in the slave script/function. This wrapper is required to associate objects in that language with MIL, and make other MIL calls such as unpacking your parameters. Notable differences between the two types of user-defined functions are that you can register a maximum of 15 parameters for script-based user-defined functions, whereas you can register up to 16 parameters for C-based user-defined functions. Furthermore, you can organize your script-based user-defined functions into only two modules (M_SCRIPT_MODULE...); whereas, you can organize your C-based user-defined functions into 7 modules. However, like C-based user-defined MIL functions, you can store up to 64 functions per module. If your script/function requires other DLLs to run, such as C# dependencies, use the M_ADD_SCRIPT_REFERENCE control type to specify a path to the file name of the DLL(s) that you need to include. Furthermore, using the M_COMPILE control type, you can set when to recompile .NET languages (into byte-code); this allows you to modify the script's code without having to stop the entire MIL application. You can set whether your script should be compiled once (M_ONCE) or if the script should be recompiled whenever the file on disk has been changed (M_MODIFIED). For languages within the .NET framework, it is possible to specify whether debug information should be generated, using the M_DEBUG_INFORMATION control type. If you choose to have debug information generated, you need to set a path to the directory where the compiled version of the script (assembly file) will be created when the script/function is run. You must pass this path to the M_DEBUG_INFORMATION_PATH control type. Much like with MfuncAlloc(), MIL function contexts allocated using MfuncAllocScript() can be set to have the slave function execute either locally or remotely. If the function can be executed remotely, it is important to include a copy of the DLL(s) and script file(s) on the remote computers in the cluster. The following example shows how to create a script-based user-defined MIL function. scriptpreprocessing.cpp Script-based user-defined MIL function ",
      "wordCount": 632,
      "subEntries": []
    }
  ]
}]
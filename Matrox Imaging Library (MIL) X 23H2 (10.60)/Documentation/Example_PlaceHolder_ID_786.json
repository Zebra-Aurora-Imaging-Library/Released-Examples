[{
  "id": "Example_PlaceHolder_ID",
  "version": "2024020714",
  "title": "Example_PlaceHolder_Title",
  "wordCount": 0,
  "subEntries": [
    {
      "id": "Examples_Core_Full_Multi3dDisplaySharedGraphicsList_CS_display3dlinker_cs",
      "version": "2024020714",
      "title": "display3dlinker.cs",
      "location": "Sample Code from MIL Examples",
      "text": " Top //***************************************************************************************/ // // File name: CDisplayLinker.cs // Location: See Matrox Example Launcher in the MIL Control Center // // // Synopsis: This file contains a class that links 3d displays together so that // moving the view in one of the displays also moves all the others. // // Copyright (C) Matrox Electronic Systems Ltd., 1992-2024. // All Rights Reserved //***************************************************************************************/ using System; using System.Collections.Generic; using System.Runtime.InteropServices; using Matrox.MatroxImagingLibrary; enum EDisplayType { eSourceDisplay, eDestinationDisplay, eDisplay }; enum ELinkType { eFullLink, eDistanceLink }; //----------------------------------------------------------------------------- // Class that links 3d displays together, and unlinks them on destruction. //----------------------------------------------------------------------------- class CDisplayLinker { private List&lt;MIL_ID&gt; m_SrcDisplays; // List of linked displays. private List&lt;MIL_ID&gt; m_DstDisplays; // List of linked displays. ELinkType m_LinkType; //----------------------------------------------------------------------------- // Links the provided displays together. //----------------------------------------------------------------------------- public CDisplayLinker(List&lt;MIL_ID&gt; Displays, ELinkType LinkType = ELinkType.eFullLink) : this(Displays, Displays, LinkType) { } public CDisplayLinker(List&lt;MIL_ID&gt; SrcDisplays, List&lt;MIL_ID&gt; DstDisplays, ELinkType LinkType = ELinkType.eFullLink) { m_SrcDisplays = SrcDisplays; m_DstDisplays = DstDisplays; m_LinkType = LinkType; StartLink(); } //----------------------------------------------------------------------------- // Updates linked displays to share a auto rotate axis. //----------------------------------------------------------------------------- public void SyncAutoRotates() { // Save auto rotate status and disable. Dictionary&lt;MIL_INT, MIL_INT&gt; DisplayAuroStatus = new Dictionary&lt;MIL_INT, MIL_INT&gt;(); foreach (var SrcDisplay in m_SrcDisplays) { DisplayAuroStatus[SrcDisplay] = MIL.M3ddispInquire(SrcDisplay, MIL.M_AUTO_ROTATE, MIL.M_NULL); MIL.M3ddispControl(SrcDisplay, MIL.M_AUTO_ROTATE, MIL.M_DISABLE); MIL.M3ddispControl(SrcDisplay, MIL.M_UPDATE, MIL.M_NOW); MIL.M3ddispControl(SrcDisplay, MIL.M_UPDATE, MIL.M_DISABLE); } foreach (var DstDisplay in m_DstDisplays) { if (!DisplayAuroStatus.ContainsKey(DstDisplay)) { DisplayAuroStatus[DstDisplay] = MIL.M3ddispInquire(DstDisplay, MIL.M_AUTO_ROTATE, MIL.M_NULL); MIL.M3ddispControl(DstDisplay, MIL.M_AUTO_ROTATE, MIL.M_DISABLE); MIL.M3ddispControl(DstDisplay, MIL.M_UPDATE, MIL.M_NOW); MIL.M3ddispControl(DstDisplay, MIL.M_UPDATE, MIL.M_DISABLE); } } // Use first disp as template. MIL_ID TemplateDisp = m_SrcDisplays[0]; // Get its view matrix. MIL_ID TemplateMatrix = MIL.M_NULL; MIL.M3dgeoAlloc(MIL.M_DEFAULT, MIL.M_TRANSFORMATION_MATRIX, MIL.M_DEFAULT, ref TemplateMatrix); MIL.M3ddispCopy(TemplateDisp, TemplateMatrix, MIL.M_VIEW_MATRIX, MIL.M_DEFAULT); // Get its interest point. MIL_ID TemplateInterestPoint = MIL.M_NULL; MIL.M3dgeoAlloc(MIL.M_DEFAULT, MIL.M_GEOMETRY, MIL.M_DEFAULT, ref TemplateInterestPoint); MIL.M3ddispCopy(MIL.M_VIEW_INTEREST_POINT, TemplateDisp, MIL.M_ROTATION_AXIS_CENTER, MIL.M_DEFAULT); MIL.M3ddispCopy(TemplateDisp, TemplateInterestPoint, MIL.M_ROTATION_AXIS_CENTER, MIL.M_DEFAULT); // Update view matrixes and interest points. foreach (var DstDisplay in m_DstDisplays) { MIL.M3ddispCopy(TemplateInterestPoint, DstDisplay, MIL.M_ROTATION_AXIS_CENTER, MIL.M_DEFAULT); MIL.M3ddispCopy(TemplateMatrix, DstDisplay, MIL.M_VIEW_MATRIX, MIL.M_NO_HOOK); MIL.M3ddispControl(DstDisplay, MIL.M_UPDATE, MIL.M_NOW); } // Reset auto rotates. foreach (var SrcDisplay in m_SrcDisplays) { MIL.M3ddispControl(SrcDisplay, MIL.M_AUTO_ROTATE, DisplayAuroStatus[SrcDisplay]); MIL.M3ddispControl(SrcDisplay, MIL.M_UPDATE, MIL.M_ENABLE); DisplayAuroStatus.Remove(SrcDisplay); } foreach (var DstDisplay in m_DstDisplays) { if (DisplayAuroStatus.ContainsKey(DstDisplay)) { MIL.M3ddispControl(DstDisplay, MIL.M_AUTO_ROTATE, DisplayAuroStatus[DstDisplay]); MIL.M3ddispControl(DstDisplay, MIL.M_UPDATE, MIL.M_ENABLE); DisplayAuroStatus.Remove(DstDisplay); } } MIL.M3dgeoFree(TemplateMatrix); MIL.M3dgeoFree(TemplateInterestPoint); } //----------------------------------------------------------------------------- // Registers to be notified of a view change for all displays. //----------------------------------------------------------------------------- public void StartLink() { if (m_LinkType == ELinkType.eFullLink) { SyncAutoRotates(); } GCHandle hUserData = GCHandle.Alloc(this); MIL_3DDISP_HOOK_FUNCTION_PTR HandlerFunctionPtr = new MIL_3DDISP_HOOK_FUNCTION_PTR(ViewChangeCallback); foreach (MIL_ID DisplayId in m_SrcDisplays) { MIL.M3ddispHookFunction(DisplayId, MIL.M_VIEW_CHANGE, HandlerFunctionPtr, GCHandle.ToIntPtr(hUserData)); } } //----------------------------------------------------------------------------- // Registers not to be notified of a view change for all displays. //----------------------------------------------------------------------------- public void StopLink() { GCHandle hUserData = GCHandle.Alloc(this); MIL_3DDISP_HOOK_FUNCTION_PTR HandlerFunctionPtr = new MIL_3DDISP_HOOK_FUNCTION_PTR(ViewChangeCallback); foreach (MIL_ID DisplayId in m_SrcDisplays) { MIL.M3ddispHookFunction(DisplayId, MIL.M_VIEW_CHANGE + MIL.M_UNHOOK, HandlerFunctionPtr, GCHandle.ToIntPtr(hUserData)); } } //----------------------------------------------------------------------------- // Update displays. //----------------------------------------------------------------------------- public void Update() { StopLink(); StartLink(); } //----------------------------------------------------------------------------- // Adds a display. //----------------------------------------------------------------------------- public void AddDisplay(MIL_ID Display, EDisplayType DisplayType) { StopLink(); switch (DisplayType) { case EDisplayType.eSourceDisplay: m_SrcDisplays.Add(Display); break; case EDisplayType.eDestinationDisplay: m_DstDisplays.Add(Display); break; default: m_SrcDisplays.Add(Display); m_DstDisplays.Add(Display); break; } StartLink(); } //----------------------------------------------------------------------------- // Sets the displays. //----------------------------------------------------------------------------- public void SetDisplays(List&lt;MIL_ID&gt; Displays, EDisplayType DisplayType) { StopLink(); switch (DisplayType) { case EDisplayType.eSourceDisplay: m_SrcDisplays = Displays; break; case EDisplayType.eDestinationDisplay: m_DstDisplays = Displays; break; default: m_SrcDisplays = Displays; m_DstDisplays = Displays; break; } StartLink(); } //----------------------------------------------------------------------------- // Updates all displays when a view changes. //----------------------------------------------------------------------------- static public MIL_INT ViewChangeCallback(MIL_INT HookType, MIL_ID EventId, IntPtr UserDataPtr) { GCHandle hUserData = GCHandle.FromIntPtr(UserDataPtr); CDisplayLinker LinkerPtr = hUserData.Target as CDisplayLinker; MIL_ID SrcDisplayId = MIL.M_NULL; MIL.M3ddispGetHookInfo(EventId, MIL.M_DISPLAY, ref SrcDisplayId); switch (LinkerPtr.m_LinkType) { case ELinkType.eFullLink: MIL_ID SrcMatrix = MIL.M_NULL; MIL.M3dgeoAlloc(MIL.M_DEFAULT_HOST, MIL.M_TRANSFORMATION_MATRIX, MIL.M_DEFAULT, ref SrcMatrix); MIL.M3ddispCopy(SrcDisplayId, SrcMatrix, MIL.M_VIEW_MATRIX, MIL.M_DEFAULT); foreach (MIL_ID DstDisplayId in LinkerPtr.m_DstDisplays) { MIL.M3ddispCopy(SrcMatrix, DstDisplayId, MIL.M_VIEW_MATRIX, MIL.M_NO_HOOK); } MIL.M3dgeoFree(SrcMatrix); break; case ELinkType.eDistanceLink: double Value = MIL.M_NULL; MIL.M3ddispGetView(SrcDisplayId, MIL.M_DISTANCE, ref Value, MIL.M_NULL, MIL.M_NULL, MIL.M_DEFAULT); foreach (MIL_ID DstDisplayId in LinkerPtr.m_DstDisplays) { if (DstDisplayId != SrcDisplayId) { MIL.M3ddispSetView(DstDisplayId, MIL.M_DISTANCE, Value, MIL.M_DEFAULT, MIL.M_DEFAULT, MIL.M_DEFAULT); } } break; } return 0; } } ",
      "wordCount": 631
    },
    {
      "id": "Examples_Core_Full_Multi3dDisplaySharedGraphicsList_CS_multi3ddisplaysharedgraphicslist_cs",
      "version": "2024020714",
      "title": "multi3ddisplaysharedgraphicslist.cs",
      "location": "Sample Code from MIL Examples",
      "text": " Top //---------------------------------------------------------------------------- // // File name: Multi3dDisplaySharedGraphicsList.cs // Location: See Matrox Example Launcher in the MIL Control Center // // // Synopsis: This example demonstrates an application using multiple // displays with shared 3D graphics lists. It also demonstrates // display linking, point picking, handles graphics and display // view limiting controls. // // Copyright (C) Matrox Electronic Systems Ltd., 1992-2024. // All Rights Reserved //---------------------------------------------------------------------------- using System; using System.Collections.Generic; using System.Drawing; using System.Runtime.InteropServices; using Matrox.MatroxImagingLibrary; namespace Multi3dDisplaySharedGraphicsList { class Program { //----------------------------------------------------------------------------- // Constants. //----------------------------------------------------------------------------- private static readonly MIL_INT DISP_SIZE = 400, DISP_PADDING_X = 0, DISP_PADDING_Y = 30, FONT_SIZE = 12, FONT_SIZE_SMALL = FONT_SIZE / 2, ROT_90 = 90, AZIMUTH = 180, HIGH_RENDER_L = 2, GRAPHIC_OPACITY = 25, GRAPHIC_THICKNESS = 3; private static readonly List&lt;double&gt; SHIFT_0 = new List&lt;double&gt; {50.0, 45.0 , 0.0 }, SHIFT_1 = new List&lt;double&gt; {65.0, -20.0, 0.0 }, SHIFT_2 = new List&lt;double&gt; {20.0, 0.0 , 50.0}; private static readonly string PT_CLD_FILE = MIL.M_IMAGE_PATH + \"M3dgra/MaskOrganized.mbufc\"; static double [] PointX = {MIL.M_NULL, MIL.M_NULL}; static double [] PointY = {MIL.M_NULL, MIL.M_NULL}; static double [] PointZ = {MIL.M_NULL, MIL.M_NULL}; static byte [] ColorR = {255 , 255 }; static byte [] ColorG = {0 , 0 }; static byte [] ColorB = {255 , 255 }; static MIL_INT DotsLabel = MIL.M_NULL; static MIL_INT LineLabel = MIL.M_NULL; static MIL_INT Index = MIL.M_NULL; //---------------------------------------------------------------------------- public class SHandleStruct { public MIL_INT BoxLabel; public MIL_ID Box; public MIL_ID Gralist; public MIL_ID OriginalContainer; public MIL_ID CroppedContainer; }; public class SPickStruct { public MIL_ID Gralist; public MIL_ID PickContext; public MIL_ID PickResult; }; //----------------------------------------------------------------------------* // Main. //----------------------------------------------------------------------------* static void Main(string[] args) { Console.Write( \"[EXAMPLE NAME]\\n\" + \"Multi3dDisplaySharedGraphicsList\\n\\n\" + \"[SYNOPSIS]\\n\" + \"This example demonstrates an application using multiple \\n\" + \"displays with shared 3D graphics lists, display linking, \\n\" + \"point picking, graphic handling and display view limiting controls. \\n\\n\" + \"[MODULES USED]\\n\" + \"Modules used: application, system, buffer, 3D display, 3D graphics.\\n\\n\" ); // Allocate defaults. var MilApplication = MIL.MappAlloc(\"M_DEFAULT\", MIL.M_DEFAULT, MIL.M_NULL); var MilSystem = MIL.MsysAlloc(MIL.M_DEFAULT, MIL.M_SYSTEM_DEFAULT, MIL.M_DEFAULT, MIL.M_DEFAULT, MIL.M_NULL); // Check for required example files. if (!CheckForRequiredMILFile(PT_CLD_FILE)) { MIL.MappFreeDefault(MilApplication, MilSystem, MIL.M_NULL, MIL.M_NULL, MIL.M_NULL); return; } var MilCropDisplay = Alloc3dDisplayId(MilSystem); var MilTopViewDisplay = Alloc3dDisplayId(MilSystem); var MilPickDisplay = Alloc3dDisplayId(MilSystem); var MilSideViewDisplay = Alloc3dDisplayId(MilSystem); // Ensure proper allocation of 3D Displays. if (MilCropDisplay == MIL.M_NULL || MilTopViewDisplay == MIL.M_NULL || MilPickDisplay == MIL.M_NULL || MilSideViewDisplay == MIL.M_NULL) { if (MilCropDisplay != MIL.M_NULL) { MIL.M3ddispFree(MilCropDisplay); } if (MilTopViewDisplay != MIL.M_NULL) { MIL.M3ddispFree(MilTopViewDisplay); } if (MilPickDisplay != MIL.M_NULL) { MIL.M3ddispFree(MilPickDisplay); } if (MilSideViewDisplay != MIL.M_NULL) { MIL.M3ddispFree(MilSideViewDisplay); } Console.Write(\"The current system does not support the 3D display.\\n\" + \"Press any key to exit.\\n\"); return; } var MilCropGraList = MIL.M3ddispInquire(MilCropDisplay, MIL.M_3D_GRAPHIC_LIST_ID, MIL.M_NULL); var MilTopViewGraList = MIL.M3ddispInquire(MilTopViewDisplay, MIL.M_3D_GRAPHIC_LIST_ID, MIL.M_NULL); var MilPickGraList = MIL.M3ddispInquire(MilPickDisplay, MIL.M_3D_GRAPHIC_LIST_ID, MIL.M_NULL); var MilSideViewGraList = MIL.M3ddispInquire(MilSideViewDisplay, MIL.M_3D_GRAPHIC_LIST_ID, MIL.M_NULL); // Set display titles. MIL.M3ddispControl(MilCropDisplay , MIL.M_TITLE, \"Cropping Display\" ); MIL.M3ddispControl(MilTopViewDisplay , MIL.M_TITLE, \"Top View Display\" ); MIL.M3ddispControl(MilPickDisplay , MIL.M_TITLE, \"Picking Display\" ); MIL.M3ddispControl(MilSideViewDisplay, MIL.M_TITLE, \"Side View Display\"); // Set all display's sizes and initial positions so that // all are visible and don't overlap. MIL.M3ddispControl(MilCropDisplay , MIL.M_SIZE_X, DISP_SIZE); MIL.M3ddispControl(MilCropDisplay , MIL.M_SIZE_Y, DISP_SIZE); MIL.M3ddispControl(MilTopViewDisplay , MIL.M_SIZE_X, DISP_SIZE); MIL.M3ddispControl(MilTopViewDisplay , MIL.M_SIZE_Y, DISP_SIZE); MIL.M3ddispControl(MilPickDisplay , MIL.M_SIZE_X, DISP_SIZE); MIL.M3ddispControl(MilPickDisplay , MIL.M_SIZE_Y, DISP_SIZE); MIL.M3ddispControl(MilSideViewDisplay, MIL.M_SIZE_X, DISP_SIZE); MIL.M3ddispControl(MilSideViewDisplay, MIL.M_SIZE_Y, DISP_SIZE); MIL.M3ddispControl(MilTopViewDisplay , MIL.M_WINDOW_INITIAL_POSITION_X, DISP_SIZE + DISP_PADDING_X); MIL.M3ddispControl(MilPickDisplay , MIL.M_WINDOW_INITIAL_POSITION_Y, DISP_SIZE + DISP_PADDING_Y); MIL.M3ddispControl(MilSideViewDisplay, MIL.M_WINDOW_INITIAL_POSITION_Y, DISP_SIZE + DISP_PADDING_Y); MIL.M3ddispControl(MilSideViewDisplay, MIL.M_WINDOW_INITIAL_POSITION_X, DISP_SIZE + DISP_PADDING_X); // Set views for the top and side displays. MIL.M3ddispSetView(MilTopViewDisplay, MIL.M_AUTO, MIL.M_TOP_VIEW, MIL.M_DEFAULT, MIL.M_DEFAULT, MIL.M_DEFAULT); MIL.M3ddispSetView(MilSideViewDisplay, MIL.M_AUTO, MIL.M_FRONT_VIEW, MIL.M_DEFAULT, MIL.M_DEFAULT, MIL.M_DEFAULT); MIL.M3ddispSetView(MilTopViewDisplay, MIL.M_AZIMUTH, AZIMUTH, MIL.M_DEFAULT, MIL.M_DEFAULT, MIL.M_DEFAULT); // Disable mouse rotations for these 2 displays // to keep their view on the given side. MIL.M3ddispControl(MilTopViewDisplay, MIL.M_MOUSE_ROTATION, MIL.M_DISABLE); MIL.M3ddispControl(MilSideViewDisplay, MIL.M_MOUSE_ROTATION, MIL.M_DISABLE); // Set the prjection mode to parallel, // this will make a better view from the side when translating. MIL.M3ddispControl(MilSideViewDisplay, MIL.M_PROJECTION_MODE, MIL.M_PARALLEL); var Mil3dSharedGraList = MIL.M3dgraAlloc(MilSystem, MIL.M_DEFAULT, MIL.M_NULL); // Restore the point cloud from a file. var MilOriginalContainer = MIL.MbufImport(PT_CLD_FILE, MIL.M_DEFAULT, MIL.M_RESTORE, MilSystem, MIL.M_NULL); // Create a cropped copy of the point cloud and add it to the shared graphics list. var MilCroppedContainer = MIL.MbufAllocContainer(MilSystem, MIL.M_PROC + MIL.M_DISP, MIL.M_DEFAULT, MIL.M_NULL); var PointCloudLabel = MIL.M3dgraAdd(Mil3dSharedGraList, MIL.M_ROOT_NODE, MilCroppedContainer, MIL.M_DEFAULT); MIL.M3dgraControl(Mil3dSharedGraList, PointCloudLabel, MIL.M_COLOR_USE_LUT, MIL.M_TRUE); MIL.M3dgraControl(Mil3dSharedGraList, PointCloudLabel, MIL.M_COLOR_COMPONENT, MIL.M_COMPONENT_RANGE); MIL.M3dgraControl(Mil3dSharedGraList, PointCloudLabel, MIL.M_COLOR_COMPONENT_BAND, 2); MIL.M3dgraCopy(MIL.M_COLORMAP_TURBO + MIL.M_FLIP, MIL.M_DEFAULT, Mil3dSharedGraList, PointCloudLabel, MIL.M_COLOR_LUT, MIL.M_DEFAULT); // Create an editable box in the graphics list. // Initialize the size of the box to a fraction of the original point cloud's size. var MilBoundingBox = MIL.M3dgeoAlloc(MilSystem, MIL.M_GEOMETRY, MIL.M_DEFAULT, MIL.M_NULL); MIL.M3dimStat(MIL.M_STAT_CONTEXT_BOUNDING_BOX, MilOriginalContainer, MilBoundingBox, MIL.M_DEFAULT); MIL.M3dgeoBox(MilBoundingBox, MIL.M_CENTER_AND_DIMENSION, MIL.M_UNCHANGED, MIL.M_UNCHANGED, MIL.M_UNCHANGED, MIL.M3dgeoInquire(MilBoundingBox, MIL.M_SIZE_X, MIL.M_NULL) * 0.5, MIL.M3dgeoInquire(MilBoundingBox, MIL.M_SIZE_Y, MIL.M_NULL) * 0.5, MIL.M_UNCHANGED, MIL.M_DEFAULT); // Draw the cropping box inside the cropping display's graphics list. MIL_ID MilCroppingBox = MIL.M_NULL; var BoxLabel = MIL.M3dgeoDraw3d(MIL.M_DEFAULT, MilBoundingBox, MilCropGraList, MIL.M_ROOT_NODE, MIL.M_DEFAULT); MIL.M3dgeoAlloc(MilSystem, MIL.M_GEOMETRY, MIL.M_DEFAULT, ref MilCroppingBox); MIL.M3dgraControl(MilCropGraList, BoxLabel, MIL.M_OPACITY, GRAPHIC_OPACITY); // Set it to be translatable accross the X axis by setting its handle type. MIL.M3dgraControl(MilCropGraList, BoxLabel, MIL.M_HANDLE_TYPE, MIL.M_HANDLE_TRANSLATION_X); // Setup the picking context for click handler. MIL_ID MilPickContext = MIL.M_NULL, MilPickResult = MIL.M_NULL; MIL.M3ddispAlloc(MIL.M_DEFAULT_HOST, MIL.M_DEFAULT, \"M_DEFAULT\", MIL.M_PICKING_CONTEXT, ref MilPickContext); MIL.M3ddispAllocResult(MIL.M_DEFAULT_HOST, MIL.M_PICKING_RESULT, MIL.M_DEFAULT, ref MilPickResult); MIL.M3ddispControl(MilPickContext, MIL.M_GRAPHIC_TYPE , MIL.M_GRAPHIC_TYPE_POINT_CLOUD); MIL.M3ddispControl(MilPickContext, MIL.M_FACES_AND_LINES, MIL.M_DISABLE); // Create a hook to crop the container when // the box is modified in the graphics list. SHandleStruct HandleStruct = new SHandleStruct { Box = MilCroppingBox, BoxLabel = BoxLabel, Gralist = MilCropGraList, OriginalContainer = MilOriginalContainer, CroppedContainer = MilCroppedContainer }; GCHandle hUserData = GCHandle.Alloc(HandleStruct); MIL_3DGRA_HOOK_FUNCTION_PTR HandlerFunctionPtr = new MIL_3DGRA_HOOK_FUNCTION_PTR(BoxModifiedHandler); MIL.M3dgraHookFunction(MilCropGraList, MIL.M_HANDLE_GRAPHIC_TRANSLATED, HandlerFunctionPtr, GCHandle.ToIntPtr(hUserData)); SPickStruct PickStruct = new SPickStruct { Gralist = Mil3dSharedGraList, PickContext = MilPickContext, PickResult = MilPickResult }; GCHandle hPickUserData = GCHandle.Alloc(PickStruct); MIL_3DDISP_HOOK_FUNCTION_PTR PickHandlerFunctionPtr = new MIL_3DDISP_HOOK_FUNCTION_PTR(ClickHandler); MIL.M3ddispHookFunction(MilPickDisplay, MIL.M_MOUSE_LEFT_BUTTON_DOWN, PickHandlerFunctionPtr, GCHandle.ToIntPtr(hPickUserData)); // Crop a first time before starting the interactivity. RetrieveBoxAndCrop(ref HandleStruct); // Setup the text labels in each display. var MilMatrix = MIL.M3dgeoAlloc(MilSystem, MIL.M_TRANSFORMATION_MATRIX, MIL.M_DEFAULT, MIL.M_NULL); MIL.M3dgeoMatrixSetTransform(MilMatrix, MIL.M_TRANSLATION, SHIFT_0[0], SHIFT_0[1], SHIFT_0[2], MIL.M_DEFAULT, MIL.M_DEFAULT); var TextLabel = MIL.M3dgraText(MilCropGraList, MIL.M_ROOT_NODE, \"Cropping Display\", MilMatrix, MIL.M_DEFAULT, MIL.M_DEFAULT); MIL.M3dgraControl(MilCropGraList, TextLabel, MIL.M_RENDER_LAYER, HIGH_RENDER_L); MIL.M3dgraControl(MilCropGraList, TextLabel, MIL.M_COLOR, MIL.M_COLOR_MAGENTA); MIL.M3dgraControl(MilCropGraList, TextLabel, MIL.M_FONT_SIZE, FONT_SIZE); TextLabel = MIL.M3dgraText(MilPickGraList, MIL.M_ROOT_NODE, \"Picking Display\", MilMatrix, MIL.M_DEFAULT, MIL.M_DEFAULT); MIL.M3dgraControl(MilPickGraList, TextLabel, MIL.M_RENDER_LAYER, HIGH_RENDER_L); MIL.M3dgraControl(MilPickGraList, TextLabel, MIL.M_COLOR, MIL.M_COLOR_DARK_YELLOW); MIL.M3dgraControl(MilPickGraList, TextLabel, MIL.M_FONT_SIZE, FONT_SIZE); MIL.M3dgeoMatrixSetTransform(MilMatrix, MIL.M_ROTATION_Z, ROT_90, MIL.M_DEFAULT, MIL.M_DEFAULT, MIL.M_DEFAULT, MIL.M_COMPOSE_WITH_CURRENT); MIL.M3dgeoMatrixSetTransform(MilMatrix, MIL.M_TRANSLATION, SHIFT_1[0], SHIFT_1[1], SHIFT_1[2], MIL.M_DEFAULT, MIL.M_COMPOSE_WITH_CURRENT); TextLabel = MIL.M3dgraText(MilTopViewGraList, MIL.M_ROOT_NODE, \"Top View Display\", MilMatrix, MIL.M_DEFAULT, MIL.M_DEFAULT); MIL.M3dgraControl(MilTopViewGraList, TextLabel, MIL.M_RENDER_LAYER, HIGH_RENDER_L); MIL.M3dgraControl(MilTopViewGraList, TextLabel, MIL.M_COLOR, MIL.M_COLOR_CYAN); MIL.M3dgraControl(MilTopViewGraList, TextLabel, MIL.M_FONT_SIZE, FONT_SIZE); MIL.M3dgeoMatrixSetTransform(MilMatrix, MIL.M_ROTATION_X, ROT_90, MIL.M_DEFAULT, MIL.M_DEFAULT, MIL.M_DEFAULT, MIL.M_COMPOSE_WITH_CURRENT); MIL.M3dgeoMatrixSetTransform(MilMatrix, MIL.M_ROTATION_Y, ROT_90, MIL.M_DEFAULT, MIL.M_DEFAULT, MIL.M_DEFAULT, MIL.M_COMPOSE_WITH_CURRENT); MIL.M3dgeoMatrixSetTransform(MilMatrix, MIL.M_TRANSLATION, SHIFT_2[0], SHIFT_2[1], SHIFT_2[2], MIL.M_DEFAULT, MIL.M_COMPOSE_WITH_CURRENT); TextLabel = MIL.M3dgraText(MilSideViewGraList, MIL.M_ROOT_NODE, \"Side View Display\", MilMatrix, MIL.M_DEFAULT, MIL.M_DEFAULT); MIL.M3dgraControl(MilSideViewGraList, TextLabel, MIL.M_RENDER_LAYER, HIGH_RENDER_L); MIL.M3dgraControl(MilSideViewGraList, TextLabel, MIL.M_COLOR, MIL.M_COLOR_GREEN); MIL.M3dgraControl(MilSideViewGraList, TextLabel, MIL.M_FONT_SIZE, FONT_SIZE_SMALL); MIL.M3ddispSelect(MilCropDisplay , Mil3dSharedGraList, MIL.M_SELECT, MIL.M_DEFAULT); MIL.M3ddispSelect(MilTopViewDisplay , Mil3dSharedGraList, MIL.M_SELECT, MIL.M_DEFAULT); MIL.M3ddispSelect(MilPickDisplay , Mil3dSharedGraList, MIL.M_SELECT, MIL.M_DEFAULT); MIL.M3ddispSelect(MilSideViewDisplay, Mil3dSharedGraList, MIL.M_SELECT, MIL.M_DEFAULT); Console.Write( \"In order from top left to bottom right the displays perform the following:\\n\" + \" 1: Crops the shared point cloud based on the editable box.\\n\" + \" - Move the box (mouse drag) to see the point cloud cropped \" + \"in all displays.\\n\" + \" 2: Shows the top view of the point cloud. Rotation disabled.\\n\" + \" 3: Calculates the distance of 2 picked \" + \"points and draws a line in the shared list.\\n\" + \" - Click on the point cloud to pick a point.\\n\" + \" 4: Shows the side view of the point cloud. Rotation disabled.\\n\\n\" ); Console.Write( \"Cropping display and picking display are fully linked meaning they will\\n\" + \"have the same view when modified. The top view and side view displays\\n\" + \"are linked in terms of zoom. \\n\\n\" ); Console.Write( \"Text graphics, lines and dots have a higher render layer meaning they \\n\" + \"will always appear \\\"above\\\" graphics which have a lower render layer. \\n\\n\" ); MIL.M3ddispSelect(MilCropDisplay , MIL.M_NULL, MIL.M_OPEN, MIL.M_DEFAULT); MIL.M3ddispSelect(MilTopViewDisplay , MIL.M_NULL, MIL.M_OPEN, MIL.M_DEFAULT); MIL.M3ddispSelect(MilPickDisplay , MIL.M_NULL, MIL.M_OPEN, MIL.M_DEFAULT); MIL.M3ddispSelect(MilSideViewDisplay, MIL.M_NULL, MIL.M_OPEN, MIL.M_DEFAULT); List&lt;MIL_ID&gt; LinkedLists = new List&lt;MIL_ID&gt; { MilCropDisplay, MilPickDisplay }; CDisplayLinker Linker = new CDisplayLinker(LinkedLists, ELinkType.eFullLink); List&lt;MIL_ID&gt; ZoomLinkedLists = new List&lt;MIL_ID&gt; { MilTopViewDisplay, MilSideViewDisplay }; CDisplayLinker ZoomLinker = new CDisplayLinker(ZoomLinkedLists, ELinkType.eDistanceLink); Console.Write(\"Press 0 in the console to swap editability of the cropping box.\\n\" + \"Press &lt;Enter&gt; to exit. \\n\\n\"); bool done = false, isvisible = true; while (!done) { int Choice = Console.ReadKey(true).KeyChar; if (Choice == '\\r') { done = true; } else { Choice -= ('0' + 0); if (Choice == 0) { MIL.M3dgraControl(MilCropGraList, BoxLabel, MIL.M_VISIBLE, isvisible ? MIL.M_FALSE : MIL.M_TRUE); isvisible = !isvisible; } } } // Unhook functions. MIL.M3dgraHookFunction(MilCropGraList, MIL.M_HANDLE_GRAPHIC_TRANSLATED + MIL.M_UNHOOK, HandlerFunctionPtr, GCHandle.ToIntPtr(hUserData)); MIL.M3ddispHookFunction(MilPickDisplay, MIL.M_MOUSE_LEFT_BUTTON_DOWN + MIL.M_UNHOOK, PickHandlerFunctionPtr, GCHandle.ToIntPtr(hPickUserData)); // Free allocated ressources. MIL.MbufFree(MilOriginalContainer); MIL.MbufFree(MilCroppedContainer); MIL.M3dgeoFree(MilMatrix); MIL.M3dgeoFree(MilCroppingBox); MIL.M3dgeoFree(MilBoundingBox); MIL.M3dgraFree(Mil3dSharedGraList); MIL.M3ddispFree(MilPickContext); MIL.M3ddispFree(MilPickResult); MIL.M3ddispFree(MilCropDisplay); MIL.M3ddispFree(MilTopViewDisplay); MIL.M3ddispFree(MilPickDisplay); MIL.M3ddispFree(MilSideViewDisplay); MIL.MsysFree(MilSystem); MIL.MappFree(MilApplication); } //---------------------------------------------------------------------------- // Handler call for modifying the editable box. //---------------------------------------------------------------------------- static public MIL_INT BoxModifiedHandler(MIL_INT HookType, MIL_ID EventId, IntPtr UserDataPtr) { GCHandle hUserData = GCHandle.FromIntPtr(UserDataPtr); SHandleStruct HandleStruct = hUserData.Target as SHandleStruct; RetrieveBoxAndCrop(ref HandleStruct); return 0; } //---------------------------------------------------------------------------- // Click handler which adds dots and line. //---------------------------------------------------------------------------- static public MIL_INT ClickHandler(MIL_INT HookType, MIL_ID EventId, IntPtr UserDataPtr) { GCHandle hUserData = GCHandle.FromIntPtr(UserDataPtr); SPickStruct PickStruct = hUserData.Target as SPickStruct; MIL_ID MilDisp3d = MIL.M_NULL; MIL.M3ddispGetHookInfo(EventId, MIL.M_DISPLAY, ref MilDisp3d); MIL_INT MouseX = MIL.M_NULL, MouseY = MIL.M_NULL; MIL.M3ddispGetHookInfo(EventId, MIL.M_MOUSE_POSITION_X, ref MouseX); MIL.M3ddispGetHookInfo(EventId, MIL.M_MOUSE_POSITION_Y, ref MouseY); MIL.M3ddispPick(PickStruct.PickContext, MilDisp3d, PickStruct.PickResult, MouseX, MouseY, MIL.M_DEFAULT); MIL_INT Results = -1; MIL.M3ddispGetResult(PickStruct.PickResult, MIL.M_DEFAULT, MIL.M_NUMBER, ref Results); if(Results &gt; 0) { if (DotsLabel != MIL.M_NULL) { MIL.M3dgraRemove(PickStruct.Gralist, DotsLabel, MIL.M_DEFAULT); } if (LineLabel != MIL.M_NULL) { MIL.M3dgraRemove(PickStruct.Gralist, LineLabel, MIL.M_DEFAULT); } // Prevents the Display from interpreting this as a rotation interaction to // permit rotation, but prevent the gyro from appearing on the initial click, // set M_CONSUMED to M_NO_CLEAR instead MIL.M3ddispSetHookInfo(EventId, MIL.M_CONSUMED, MIL.M_TRUE); MIL.M3ddispGetResult(PickStruct.PickResult, MIL.M_PICKING_INDEX(0), MIL.M_PICKED_POSITION_3D_X, ref PointX[Index]); MIL.M3ddispGetResult(PickStruct.PickResult, MIL.M_PICKING_INDEX(0), MIL.M_PICKED_POSITION_3D_Y, ref PointY[Index]); MIL.M3ddispGetResult(PickStruct.PickResult, MIL.M_PICKING_INDEX(0), MIL.M_PICKED_POSITION_3D_Z, ref PointZ[Index]); DotsLabel = MIL.M3dgraDots(PickStruct.Gralist, MIL.M_ROOT_NODE, LineLabel != MIL.M_NULL || Index == 1 ? 2 : 1, PointX, PointY, PointZ, ColorR, ColorG, ColorB, MIL.M_DEFAULT); MIL.M3dgraControl(PickStruct.Gralist, DotsLabel, MIL.M_COLOR, MIL.M_COLOR_BLUE); MIL.M3dgraControl(PickStruct.Gralist, DotsLabel, MIL.M_OPACITY, GRAPHIC_OPACITY); MIL.M3dgraControl(PickStruct.Gralist, DotsLabel, MIL.M_RENDER_LAYER, HIGH_RENDER_L); if (LineLabel != MIL.M_NULL || Index == 1) //We have 2 points now. { if (LineLabel == MIL.M_NULL) { Console.Write(\"Point1\\t\\t\\t\\tPoint2\\t\\t\\t\\tDistance \\n\"); } LineLabel = MIL.M3dgraLine(PickStruct.Gralist, MIL.M_ROOT_NODE, MIL.M_TWO_POINTS, MIL.M_DEFAULT, PointX[0], PointY[0], PointZ[0], PointX[1], PointY[1], PointZ[1], MIL.M_DEFAULT, MIL.M_DEFAULT); MIL.M3dgraControl(PickStruct.Gralist, LineLabel, MIL.M_COLOR, MIL.M_RGB888(ColorR[0], ColorG[0], ColorB[0])); MIL.M3dgraControl(PickStruct.Gralist, LineLabel, MIL.M_THICKNESS, GRAPHIC_THICKNESS); MIL.M3dgraControl(PickStruct.Gralist, LineLabel, MIL.M_RENDER_LAYER, HIGH_RENDER_L); double Size = -1; MIL_INT PrevIndex = (Index + 1) % 2; MIL.M3dgraInquire(PickStruct.Gralist, LineLabel, MIL.M_LENGTH, ref Size); Console.Write(\"{{{0: 00.00}, {1: 00.00}, {2: 00.00}}}\\t{{{3: 00.00},\" + \"{4: 00.00}, {5: 00.00}}}\\t{6:0.00} \\r\", PointX[PrevIndex], PointY[PrevIndex], PointZ[PrevIndex], PointX[Index], PointY[Index], PointZ[Index], Size); } } Index = ++Index % 2; return 0; } //---------------------------------------------------------------------------- // Crops container based on associated box. //---------------------------------------------------------------------------- static public void RetrieveBoxAndCrop(ref SHandleStruct HandleStruct) { // Retrieve the edited box from the graphics list. MIL.M3dgraCopy(HandleStruct.Gralist, HandleStruct.BoxLabel, HandleStruct.Box, MIL.M_DEFAULT, MIL.M_GEOMETRY, MIL.M_DEFAULT); // Crop the point cloud using the retrieved box. MIL.M3dimCrop(HandleStruct.OriginalContainer, HandleStruct.CroppedContainer, HandleStruct.Box, MIL.M_NULL, MIL.M_SAME, MIL.M_DEFAULT); } //---------------------------------------------------------------------------- // Check for required files to run the example. //---------------------------------------------------------------------------- static bool CheckForRequiredMILFile(string FileName) { MIL_INT FilePresent = MIL.M_NO; MIL.MappFileOperation(MIL.M_DEFAULT, FileName, MIL.M_NULL, MIL.M_NULL, MIL.M_FILE_EXISTS, MIL.M_DEFAULT, ref FilePresent); if (FilePresent == MIL.M_NO) { Console.Write(\"The footage needed to run this example is missing. You need\\n\"); Console.Write(\"to obtain and apply a separate specific \" + \"update to have it.\\n\\n\"); Console.Write(\"Press any key to end.\\n\\n\"); Console.ReadKey(); } return (FilePresent == MIL.M_YES); } //---------------------------------------------------------------------------- // Allocates a 3D display and returns its MIL identifier. //---------------------------------------------------------------------------- static MIL_ID Alloc3dDisplayId(MIL_ID MilSystem) { MIL.MappControl(MIL.M_DEFAULT, MIL.M_ERROR, MIL.M_PRINT_DISABLE); MIL_ID MilDisplay3D = MIL.M3ddispAlloc(MilSystem, MIL.M_DEFAULT, \"M_DEFAULT\", MIL.M_DEFAULT, MIL.M_NULL); MIL.MappControl(MIL.M_DEFAULT, MIL.M_ERROR, MIL.M_PRINT_ENABLE); return MilDisplay3D; } } } ",
      "wordCount": 1874
    }
  ]
}]
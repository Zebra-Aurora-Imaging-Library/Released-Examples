[{
  "id": "Readme_milRadientCXP",
  "version": "2023100322",
  "title": "milRadientCXP",
  "wordCount": 0,
  "subEntries": [
    {
      "id": "Readme_milRadientCXP_milRadientCXP",
      "title": "milRadientCXP",
      "location": "MIL Release Notes",
      "pageURL": "\\milRadientCXP\\milRadientCXP.htm",
      "text": " Matrox Imaging Library (MIL) 10 Update 73 Matrox Radient eV-CXP release notes November 2018 ?(c) Copyright Matrox Electronic Systems Ltd., 1992-2018. &nbsp; This document outlines what is new with the MIL 10 driver for Matrox Radient eV-CXP and explains the current limitations and particularities. It also presents last-minute information that did not make it into the manual or on-line help. Note that this help file serves to complement your manual. The information found in this file overrides your formally documented material. Contents 1.???? MIL 10 Driver for Matrox Radient eV-CXP 1.1???????? What?s new in MIL 10 Update 73 1.1.1????? Standards compliance 1.1.2????? Software bug fixes 1.1.3????? Known limitations and particularities 1.2???????? What?s new in MIL 10 Update 29 1.2.1????? Standards compliance 1.2.2????? Summary of new features 1.2.3????? API enhancements 1.2.4????? MimLocatePeak1d code snippet using multi-frame buffer 1.2.5????? Known limitations and particularities 1.2.6????? Software bug fixes 1.2.7????? Firmware new features and bug fixes 1.3???????? What?s new in MIL 10 Update 17 1.3.1????? Standards compliance 1.3.2????? Summary of new features 1.3.3????? API enhancements 1.3.4????? Software bug fixes 1.3.5????? Firmware bug fixes 1.4???????? What?s new in MIL 10 Update 15 1.4.1????? API enhancements 1.4.2????? Software bug fixes 1.4.3????? Firmware bug fixes 1.4.4????? Matrox Intellicam bug fixes 1.5???????? What?s new in MIL 10 2.???? Location of examples (in the help file) &nbsp; 1.&nbsp;&nbsp; MIL 10 Driver for Matrox Radient eV-CXP 1.1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; What?s new in MIL 10 Update 73 ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Note that MIL 10 Update 73 is a cumulative update, including all content from MIL 10 Update 29, 17 and 15. ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Added support for firmware updates on Version &gt;= 300 boards (PCB Y7420-03). ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Improved speed of camera discovery. ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Ability to set a specific equalizer gain value for every link number. This is done in a custom DCF. 1.1.1&nbsp;&nbsp;&nbsp; Standards compliance Matrox Radient eV-CXP supports the following standards: ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; JIIA CoaXPress Standard version 1.0 and 1.1.1. ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GenICamTM Standard Version 3.1. ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GenICamTM? GenTL Standard version 1.5 producer: ?&nbsp; System, Interface and Device modules are supported. ?&nbsp; Data Stream and Buffer modules are not supported. ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GenICamTM Standard Feature Naming Convention (SFNC) Version 2.0. 1.1.2&nbsp;&nbsp;&nbsp; Software bug fixes ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Fixed issue when setting MdigControl(M_IO_SOURCE) to M_DISABLE. ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Fixed issue when allocating a digitizer with a large area scan camera where the image size is more than one third of the available on-board memory. ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Fixed issue when setting MdigControl(M_ROTARY_ENCODER_POSITION_TRIGGER_DOUBLE) with M_ROTARY_ENCODERn (where n is a number between 1 and 4). ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Fixed precision issue when using quadrature encoders with fractional values. ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Fixed possible crash issue when using boards with 4GB of on-board memory. ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Fixed possible crash when using data latch when internal buffer could not be allocated. 1.1.3&nbsp;&nbsp;&nbsp; Known limitations and particularities ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Installing this update removes Matrox Intellicam?s support for the Matrox CronosPlus, Matrox Vio and IEEE 1394 IIDC devices. ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Building the MIL examples using Visual Studio 2015 or 2017 also requires the presence of Windows SDK version 8.1, which is installed from the Visual Studio setup. ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; The MIL update requires a Windows installation that supports device drivers with SHA-2 digital certificates. Consequently, some Windows 7 installations will require that a Windows Monthly Rollup be applied before the MIL update can be installed. 1.2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; What?s new in MIL 10 Update 29 1.2.1&nbsp;&nbsp;&nbsp; Standards compliance The MIL 10 driver for Matrox Radient eV-CXP supports the following standards: ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; JIIA CoaXPress Standard version 1.0 and version 1.1.1. ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GenICamTM Standard Version 3.01. ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GenICamTM? GenTL Standard version 1.5 producer: ?&nbsp; System, Interface and Device modules are supported. ?&nbsp; Data Stream and Buffer modules are not supported. ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GenICamTM Standard Feature Naming Convention (SFNC) Version 2.0. 1.2.2&nbsp;&nbsp;&nbsp; Summary of new features The following features are new for this release: ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Added support for the Matrox Radient eV-CXP for 3D profiling, which features hardware-based extraction of ?light peaks. Matrox Radient eV-CXP for 3D profiling supports: ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vertical scan-lane direction. ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Up to 3 peaks per column. ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Maximum frame size of 8192 columns and 512 rows. ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Minimum frame size of 128 columns and 16 rows. ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Maximum peak width (M_PEAK_WIDTH_NOMINAL + M_PEAK_WIDTH_DELTA) of 30*. ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Maximum intensity range (M_PEAK_INTENSITY_RANGE) of 31*. ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Minimum peak width (M_PEAK_WIDTH_NOMINAL ? M_PEAK_WIDTH_DELTA) from 1 to 15. ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Maximum burst size of up to 512 frames. &nbsp; * ?The maximum peak width and intensity range diminishes when the number of columns is higher than 2640: o&nbsp;&nbsp;&nbsp; Maximum peak width? = (40960 / number of columns) * 2 o&nbsp;&nbsp;&nbsp; Maximum intensity range = (40960 / number of columns) * 2 &nbsp; ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Added support for hardware gain and offset per pixel, see M_SHADING_CORRECTION below. ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Added new control types to deal with triggers that happen while the grab and timers are active; see M_GRAB_TRIGGER_OVERLAP and M_TIMER_TRIGGER_OVERLAP below. ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Added new control values for M_TIMER_TRIGGER_SOURCE: M_HSYNC and M_VSYNC. ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Added new control values for M_TIMER_CLOCK_SOURCE: M_HSYNC and M_VSYNC. ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Added support for routing auxiliary input signals (M_AUX_IO) to auxiliary output signals (M_AUX_IO); see M_IO_SOURCE below. ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Added new control types that allow the rotary decoder to start generating triggers only upon reaching a set counter value and then to generate a trigger at a set interval (change) in counter value; see M_ROTARY_ENCODER_* below. ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Added support for 12-bit Bayer cameras. ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Added a feature to the Radient eV-CXP page of the MILConfig utility that allows you to change the amount of shared or PCI mapped on-board memory (PCIe BAR size). ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Improved the version of Matrox Feature Browser displayed using MdigControl() with M_GC_FEATURE_BROWSER. ?This version is now equivalent to the one that can be accessed using Matrox Intellicam. It displays the MIL system and digitizer settings, in addition to the camera settings. 1.2.3&nbsp;&nbsp;&nbsp; API enhancements 1.2.3.1&nbsp;&nbsp; New MimLocatePeak1d() functionalities MimLocatePeak1d() is offloaded onto a Matrox Radient eV-CXP for 3D profiling when using an on-board image buffer. In addition, MimLocatePeak1d() now supports the extraction of the peaks from a multi-frame buffer grabbed using frame burst technology. A multi-frame buffer is an image buffer that is composed of multiple adjacent frames from which to extract the peaks. Ex.: A multi-frame buffer composed of 3 frames: &nbsp; ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Additions to the MimControl() ControlType and ControlValue parameters: M_NUMBER_OF_FRAMES Sets the number of frames. This control type applies to a M_LOCATE_PEAK_1D_CONTEXT context only. This control type must be set before preprocessing the context. &nbsp; M_DEFAULT The default value is 1. Value Specifies the number of frames. M_FRAME_SIZE Sets the Y-size of the frames. This control type applies to a M_LOCATE_PEAK_1D_CONTEXT context only. The control type must be set before preprocessing the context. &nbsp; M_DEFAULT Same as M_FULL_FRAME. M_FULL_FRAME Specifies to use the buffer as a single frame. M_NUMBER_OF_FRAMES is ignored. Value Specifies the Y-size of the frames. &nbsp; ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Additions to the MimLocatePeak1d() ControlFlag and ControlValue parameters: M_FRAME_INDEX Sets the current frame index for accumulating extractions in the M_LOCATE_PEAK_1D_RESULT result buffer. &nbsp; M_DEFAULT The default value is 1. Value Specifies the current frame index. &nbsp; ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Additions to the MimGetResultSingle() Index1 parameter: M_SELECT_PEAK( ??? MIL_INT Frame, ??? MIL_INT Rank ) Specifies the frame(s) and rank of the peak(s) for which to return the requested information (for the lane(s) specified with the Index2 parameter). This macro applies to a M_LOCATE_PEAK_1D_RESULT result buffer only. Parameters &nbsp; Frame &nbsp; M_ALL Specifies all frames. Value Specifies the index of the specific frame. Rank &nbsp; M_ALL Specifies all peaks in the lane(s). Value Specifies the rank of the specific peak in the lane(s). &nbsp; &nbsp; 1.2.3.2&nbsp;&nbsp; Additions to MdigControl()/MdigInquire(): M_SHADING_CORRECTION Sets whether to perform a gain and offset correction per pixel. When grabbing to a buffer in Host memory, your digitizer performs the shading correction operation using following equation: (Grab Image x M_SHADING_CORRECTION_GAIN_ID) + M_SHADING_CORRECTION_OFFSET_ID Each row of gain and offset values is applied to the equivalent row of the grabbed image. To set the gain and provide an offset for shading correction, use M_SHADING_CORRECTION_OFFSET_ID and M_SHADING_CORRECTION_GAIN_ID, respectively. &nbsp; M_ENABLE Enables shading correction. M_DISABLE Disables shading correction. M_SHADING_CORRECTION_GAIN_ID Sets the buffer containing the gain values that your digitizer should use when it performs a shading correction. To enable on-board shading correction and provide an offset, use M_SHADING_CORRECTION and M_SHADING_CORRECTION_OFFSET_ID, respectively. &nbsp; M_NULL Specifies to not apply a gain when performing a shading correction. ShadingCorrectionGainID Specifies the identifier of an M_IMAGE buffer containing the gain values. The buffer must be allocated as a single-band unsigned 8-bit or unsigned 16-bit buffer. It is interpreted as a fixed point buffer with 2-bits for the numerical part. Use M_SHADING_CORRECTION_GAIN_FIXED_POINT to set the number of bits for the fractional part. It can have an X-size of up to 16384 pixels and a Y-size equal to the size of the DCF. M_SHADING_CORRECTION_GAIN_FIXED_POINT Sets the number of bits for the fraction part of the fixed point gain value that your digitizer should use when it performs a shading correction. To enable on-board shading correction and provide an offset, use M_SHADING_CORRECTION, M_SHADING_CORRECTION_GAIN_ID, and M_SHADING_CORRECTION_OFFSET_ID, respectively. &nbsp; 0&lt;= Value &lt;16 Specifies the fractional part of the fixed point gain value. M_SHADING_CORRECTION_OFFSET_ID Sets the buffer containing the offset values that your digitizer should use when it performs a shading correction. To enable on-board shading correction and provide a gain, use M_SHADING_CORRECTION and M_SHADING_CORRECTION_GAIN_ID, respectively. &nbsp; M_NULL Specifies to not apply an offset when performing a shading correction. ShadingCorrectionOffsetID Specifies the identifier of an M_IMAGE buffer containing the offset values. The buffer must be allocated as a signed 8-bit or signed 16-bit buffer. M_GRAB_TRIGGER_OVERLAP Sets how to deal with a new trigger that occurs while a grab is in progress. &nbsp; M_DEFAULT Same as M_RESET or value specified in DCF. M_PREVIOUS_FRAME Specifies that a trigger received, while the grab is in progress, will be latched (stored). As soon as the current grab finishes, a new grab will be started. M_OFF Specifies that a new trigger is ignored. M_RESET Specifies that the current grab will be immediately stopped and a new grab will be started. M_ROTARY_ENCODER_POSITION_START_TRIGGER ?(+ M_ROTARY_ENCODERn) Sets the rotary decoder's counter value upon which to start generating triggers, when M_ROTARY_ENCODER_OUTPUT_MODE is set to M_POSITION_TRIGGER_MULTIPLE. If it is not set to this value, then M_ROTARY_ENCODER_POSITION_START_TRIGGER is ignored. &nbsp; 0 &lt; Value &lt;= 0xFFFFFFFF Specifies the value of the counter upon which to start generating triggers. M_ROTARY_ENCODER_OUTPUT_MODE (+ M_ROTARY_ENCODERn) Sets the rotary decoder's counter value and/or the direction of movement upon which the rotary decoder should output a pulse. additional control values found in references M_POSITION_TRIGGER_MULTIPLE Specifies to start triggering only when the counter value set with M_ROTARY_ENCODER_POSITION_START_TRIGGER is reached and then to generate a trigger at a set interval (change) in counter value. Set the interval with M_ROTARY_ENCODER_POSITION_TRIGGER. M_ROTARY_ENCODER_POSITION_TRIGGER (+ M_ROTARY_ENCODERn) Sets the rotary decoder's counter value at which a trigger is generated. &nbsp; 0 &lt; Value &lt;= 0xFFFFFFFF Specifies the counter value or change in counter value at which to generate a trigger. If M_ROTARY_ENCODER_OUTPUT_MODE is set to M_POSITION_TRIGGER_MULTIPLE, this will specify the change in counter value at which to generate a trigger, beginning at the counter value specified by M_ROTARY_ENCODER_POSITION_START_TRIGGER. If M_ROTARY_ENCODER_OUTPUT_MODE is set to M_POSITION_TRIGGER, this will specify the counter value at which to generate a trigger each time this value is reached. If M_POSITION_TRIGGER is set to any other control value, this value will be ignored. M_ROTARY_ENCODER_BIT0_SOURCE (+ M_ROTARY_ENCODERn) Sets the auxiliary input signal on which to receive bit 0 of the 2-bit Gray code. The value can be set and inquired. &nbsp; M_AUX_IO2? M_AUX_IO10 M_AUX_IO18 M_AUX_IO26 Specifies the auxiliary input signal to use. M_ROTARY_ENCODER_BIT1_SOURCE (+ M_ROTARY_ENCODERn) Sets the auxiliary input signal on which to receive bit 1 of the 2-bit Gray code. The value can be set and inquired. &nbsp; M_AUX_IO3? M_AUX_IO11 M_AUX_IO19 M_AUX_IO27 Specifies the auxiliary input signal to use. M_TIMER_CLOCK_SOURCE + M_TIMERn Sets the source of the clock that drives the specified timer additional control values found in references M_HSYNC Specifies to use the horizontal synchronization signal (start of line) as the clock source. M_VSYNC Specifies to use the vertical synchronization signal (start of frame) as the clock source. M_TIMER_TRIGGER_SOURCE + M_TIMERn Sets the trigger source for the specified timer when there are multiple sources available. additional control values found in references M_HSYNC Specifies to use the horizontal synchronization signal (start of line) as the clock source. M_VSYNC Specifies to use the vertical synchronization signal (start of frame) as the clock source. M_TIMER_TRIGGER_OVERLAP + M_TIMERn Sets how to deal with a new trigger that occurs while the associated timer has not yet expired (both its delay and duration). &nbsp; M_DEFAULT Same as M_RESET or value specified in DCF. M_LATCH Specifies that a trigger received, while the associated timer has not expired, will be latched (stored). As soon as the current timer expires, a new trigger is issued. M_OFF Specifies that a new trigger is ignored. M_RESET Specifies that a new trigger automatically resets the timer (regardless of whether it is in its delay or active period) and then restarts the timer. This process will repeat for each new trigger received. M_TIMER_TRIGGER_RATE_DIVIDER Sets the frequency to accept trigger pulses (for example, if set to 2, the first trigger pulse is ignored and the second is accepted). &nbsp; M_DEFAULT Specifies the default value; the default value is 1. &nbsp; 1 &lt;= Value &lt;= 255 Specifies the frequency with which to accept a trigger out of a series of trigger pulses. Note that, if set to 1, all trigger pulses are accepted. ? M_IO_SOURCE + M_AUX_IOn Sets to reroute auxiliary input signal m to the output signal n. additional control values found in references M_AUX_IOm Specifies the input signal to be routed to M_AUX_IOn. Example 1 In the following code snippet, an encoder is used to trigger a grab when a certain position is reached. 20 frames of 1000 lines each, or 20000 lines, are grabbed, at which point the grab moves slightly to the right and repeats the process in reverse. The LinearEncoderScan animation, found on the RadienteVCXPAnimation page in this section of the help file, illustrates this example. /* The camera must be set to trigger the acquisition of a line on the rising edge of the timer output signal. */ /* On a Radient eV-CXP the timer is sent to the camera with this control: */ MdigControl(MilDigitizer, M_TL_TRIGGER + M_IO_SOURCE, M_TIMER1); &nbsp; /* Reset the decoder counter to 0. */ MdigControl(MilDigitizer, M_ROTARY_ENCODER_POSITION, 0); &nbsp; /* Program the timer to trigger on a decoder signal. */ MdigControl(MilDigitizer, M_TIMER_CLOCK_SOURCE, M_SYSCLK); MdigControl(MilDigitizer, M_TIMER_DELAY, timerDelayInUs); MdigControl(MilDigitizer, M_TIMER_DURATION, timerDurationInUs); MdigControl(MilDigitizer, M_TIMER_TRIGGER_SOURCE, M_ROTARY_ENCODER); MdigControl(MilDigitizer, M_TIMER_STATE, M_ENABLE); &nbsp; /* Program the decoder to start triggering when position 1000 is reached ?? then continue triggering at a multiple of '1'. */ MdigControl(MilDigitizer, M_ROTARY_ENCODER_OUTPUT_MODE, M_POSITION_TRIGGER_MULTIPLE); MdigControl(MilDigitizer, M_ROTARY_ENCODER_POSITION_START_TRIGGER, 1000); MdigControl(MilDigitizer, M_ROTARY_ENCODER_POSITION_TRIGGER, 1); &nbsp; /* Start MdigProcess to grab a sequence (strip) of 20 frames of 1000 lines each for &nbsp;&nbsp;&nbsp;a total of 20000 lines (bufferingSize == 20). */ MdigProcess(MilDigitizer, MilGrabBufferList, bufferingSize, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; M_SEQUENCE, M_SYNCHRONOUS, ProcessingFunction, &amp;UserHookData); &nbsp; /* Once the end of sequence is reached, the stage will start scanning in the &nbsp;&nbsp;&nbsp;other direction (the decoder counter will decrement). */ /* Program the decoder to start triggering when counter value 21000 is reached &nbsp;&nbsp;&nbsp;then continue triggering at a multiple of '1'. */ MdigControl(MilDigitizer, M_ROTARY_ENCODER_POSITION_START_TRIGGER, 21000); &nbsp; /* Start MdigProcess to grab a sequence of 20 frames of 1000 lines each for &nbsp;&nbsp;&nbsp;a total of 20000 lines (bufferingSize == 20). */ MdigProcess(MilDigitizer, MilGrabBufferList, bufferingSize, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;M_SEQUENCE, M_SYNCHRONOUS, ProcessingFunction, &amp;UserHookData); &nbsp; Example 2 &nbsp; In the following code snippet, the board?s decoder is set to trigger a pulse only when a linear stage is moving forward. The counter decrements when the stage moves in reverse. The grab is only triggered when the counter hits a new positive value; as such, no line that was already grabbed will be grabbed again. The RotaryLogScan animation, found on the RadienteVCXPAnimation2 page in this section of the help file, illustrates this example. /* The camera must be set to trigger the acquisition of a line on the rising edge of the timer output signal. */ /* On a Radient eV-CXP the timer is sent to the camera with this control: */ MdigControl(MilDigitizer, M_TL_TRIGGER + M_IO_SOURCE, M_TIMER1); &nbsp; /* Set the rotary decoder to send a trigger only when the stage is moving forward. */ MdigControl(MilDigitizer, M_ROTARY_ENCODER_DIRECTION, M_FORWARD); &nbsp; /* Specifies to set the counter to 0xFFFFFFFF upon a decrement. */ MdigControl(MilDigitizer, M_ROTARY_ENCODER_FORCE_VALUE_SOURCE, M_STEP_BACKWARD_WHILE_POSITIVE); &nbsp; /* Specifies to output a pulse upon a rotary decoder counter increment, only if the counter value is in the range of 0x0 to 0x7FFFFFFF ?? before the increment occurs; when interpreting the counter value as signed, this would be the positive counter value range. */ MdigControl(MilDigitizer, M_ROTARY_ENCODER_OUTPUT_MODE, M_STEP_FORWARD_WHILE_POSITIVE); &nbsp; /* Set the rotary decoder counter to 0. */ MdigControl(MilDigitizer, M_ROTARY_ENCODER_POSITION_TRIGGER, 0); &nbsp; /* Set the signal that the timer should output at every rotary decoder trigger. */ MdigControl(MilDigitizer, M_TIMER_DELAY, timerDelayInUs); MdigControl(MilDigitizer, M_TIMER_DURATION, timerDelayInUs); &nbsp; /* Specifies to use the output (set with M_ROTARY_ENCODER_OUTPUT_MODE) of the default rotary decoder as the trigger source. */ MdigControl(MilDigitizer, M_TIMER_TRIGGER_SOURCE, M_ROTARY_ENCODER); &nbsp; /* The trigger rate divider can be used to reduce the trigger rate. */ MdigControl(MilDigitizer, M_TIMER_TRIGGER_RATE_DIVIDER, 1); /* Enable the timer. */ MdigControl(MilDigitizer, M_TIMER_STATE, M_ENABLE); &nbsp; /* Start the processing. The processing function is called with every frame grabbed. */ MdigProcess(MilDigitizer, MilGrabBufferList, MilGrabBufferListSize, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; M_START, M_DEFAULT, ProcessingFunction, &amp;UserHookData); &nbsp; 1.2.4&nbsp;&nbsp;&nbsp; MimLocatePeak1d code snippet using multi-frame buffer &nbsp; /* Allocate an on-board grab buffer with a Y-size large enough for the frame bursts (see FrameBurst example). */ MbufAlloc2d(MilSystemId, SizeX, SizeY * FrameBurstSize, 8 + M_UNSIGNED, ??????????????????? M_IMAGE + M_ON_BOARD + M_PROC, &amp;GrabbedImage); &nbsp; /* Locate peak 1d context allocation. */ MIL_ID LocatePeakContextId = MimAlloc(MilSystemId, M_LOCATE_PEAK_1D_CONTEXT, ???????????????????????????????? ?????M_DEFAULT, M_NULL); &nbsp; /* Locate peak 1d result allocation. */ MIL_ID LocatePeakResultId = MimAllocResult(MilSystemId, M_DEFAULT, ????????????????????????????????????????? ?M_LOCATE_PEAK_1D_RESULT, M_NULL); &nbsp; /* ... */ &nbsp; /* Set the maximum number of frames to store in the result. */ MimControl(LocatePeakContextId, M_NUMBER_OF_FRAMES, FrameBurstSize); &nbsp; /* Set the size of each frame in the image. */ MimControl(LocatePeakContextId, M_FRAME_SIZE, SizeY); &nbsp; /* Set the minimum contrast for extraction. */ MimControl(LocatePeakContextId, M_MINIMUM_CONTRAST, 50); &nbsp; /* Set the nominal peak width for extraction. */ MimControl(LocatePeakContextId, M_PEAK_WIDTH_NOMINAL, 10); &nbsp; /* Set the peak width delta for extraction. */ MimControl(LocatePeakContextId, M_PEAK_WIDTH_DELTA, 10); &nbsp; /* Set the number of pixels used to calculate the average peak intensity. The pixels are chosen around the peak intensity pixel. */ MimControl(LocatePeakContextId, M_PEAK_INTENSITY_RANGE, 5); &nbsp; /* Set the maximum number of peaks per scan-lane to extract per frame. */ MimControl(LocatePeakContextId, M_NUMBER_OF_PEAKS, 2); &nbsp; /* Set the direction of the extraction process. */ MimControl(LocatePeakContextId, M_SCAN_LANE_DIRECTION, M_VERTICAL); &nbsp; /* ... */ &nbsp; /* Set how to sort peaks extracted from the same lane. In this case, sort peaks so that the peak with the highest intensity (strongest peak) is returned first. */ MimControl(LocatePeakResultId, M_SORT_CRITERION, M_PEAK_INTENSITY + M_SORT_DOWN); &nbsp; /* ... */ &nbsp; /* Preprocess the locate peak 1d context. */ MimLocatePeak1d(LocatePeakContextId, M_NULL, LocatePeakResultId, M_NULL, M_NULL, M_NULL, M_PREPROCESS, M_NULL); &nbsp; &nbsp; /* ... */ /* Call MdigProcess with on-board buffers. */ /* ... */ &nbsp; &nbsp; /* from MdigProcess callback. */ ?? { ?? /* ... */ ?? MdigGetHookInfo(HookId, M_MODIFIED_BUFFER + M_BUFFER_ID, &amp;ModifiedBufferId); &nbsp; ?? /* Detect the peaks in the multi-frame buffer. */ ?? MimLocatePeak1d(LocatePeakContextId, ModifiedBufferId, LocatePeakResultId, M_DEFAULT, M_DEFAULT, M_DEFAULT, M_DEFAULT, M_DEFAULT); &nbsp; ?? /* Extract the best peaks in all scan lanes of all frames. */ ?? MimGetResultSingle(ResultId, M_SELECT_PEAK(M_ALL, 0), M_ALL, ResultType, &amp;UserPtr); &nbsp; ?? /* ... */ ?? } /* ... */ &nbsp; /* Release the locate peak 1d resources. */ MimFree(LocatePeakResultId); MimFree(LocatePeakContextId); &nbsp; 1.2.5&nbsp;&nbsp;&nbsp; Known limitations and particularities ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; The Bayer conversion hardware supports a maximum line width of 8196 bytes. 1.2.6&nbsp;&nbsp;&nbsp; Software bug fixes ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Fixed the default value of M_GRAB_FRAME_BURST_MAX_TIME; it is now M_INFINITE. ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Fixed an issue when the grab direction is set to reverse with an RGB or Bayer camera. ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Fixed an issue with M_SOURCE_OFFSET_X/Y when the grab direction is set to reverse. ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Fixed an issue with the returned value of M_GRAB_PERIOD and M_SELECTED_FRAME_RATE with line-scan cameras. ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Fixed a sign extension issue under 32-bit operating systems when M_ROTARY_ENCODER_POSITION_TRIGGER is set to 0x10000000 or higher. ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Fixed an issue with M_TIMER_TRIGGER_SOURCE when it is set to a rotary decoder that is not the default one for the current acquisition path. ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Improved error messages generated by MdigControl() with M_LUT_ID. ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Fixed an issue when grabbing in frame burst mode from a camera simulator DCF. ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Fixed an issue when grabbing a single frame (MdigGrab()) in frame burst mode. ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Fixed an issue with the returned value of M_TIMER_TRIGGER_MISSED. ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Fixed an issue when setting a camera to use fewer CXP lanes than the amount that are physically connected. 1.2.7&nbsp;&nbsp;&nbsp; Firmware new features and bug fixes ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Added support for routing auxiliary input signals to auxiliary output signals. ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Added support for frame burst technology with camera simulator DCFs. ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Added programmable, PCIe, on-board memory BAR size. ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Increased camera, DMA, and memory bandwidth on Radient eV-CXP RADEV1G4C6* SKU. ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Improved CoaXPress bus protocol bit error detection and recovery. ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Improved CXP communication channel robustness. ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Fixed an issue when grabbing in level sensitive trigger mode with a line-scan camera. ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Fixed a camera plug/unplug image corruption issue when grabbing from multiple cameras. ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Fixed a system dependent interrupt missing issue. 1.3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; What?s new in MIL 10 Update 17 1.3.1&nbsp;&nbsp;&nbsp; Standards compliance The MIL 10 driver for Matrox Radient eV-CXP supports the following standards: ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; JIIA CoaXPress Standard Version 1.0 and 1.1. ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GenICamTM Standard Version 2.3.1. ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GenICamTM? GenTL Standard Version 1.4 Producer. ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GenICamTM Standard Feature Naming Convention (SFNC) Version 2.0. 1.3.2&nbsp;&nbsp;&nbsp; Summary of new features The following features are new for this release: ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Added GenICam GenTL 1.4 producer. This allows camera manufacturers to update the firmware on their cameras. Stream and buffer modules and GenTL events are not implemented. ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; New API to latch information for each grabbed frame. See M_DATA_LATCH_*. ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; New API to grab multiple frames for each grab command. This is useful when grabbing at very high frame rates. See M_GRAB_FRAME_BURST. ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Added a second pulse for timer output signals. See M_TIMER_DURATION2 and M_TIMER_DELAY2. ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Added support of 10- and 12-bit LUTs. ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Added the following MIL hardware-specific example: o&nbsp;&nbsp;&nbsp; DataLatch.cpp. This example is located in ...\\examples\\board-specific\\DataLatch\\c++. It demonstrates how the Data Latch API latches information at each grabbed frame (such as, timestamps and quadrature encoder positions). o&nbsp;&nbsp;&nbsp; FrameBurst.cpp. This example is located in ?\\examples\\board-specific\\FrameBurst\\c++. It demonstrates how the frame burst API can be used to aggregate multiple frames into each grab command. o&nbsp;&nbsp;&nbsp; Enumfeatures.cpp. This is a GenICam-specific example. It demonstrates how to enumerate all the features in your GenICam compliant device in a MIL application. The example is located in ...\\examples\\board-specific\\enumfeatures\\c++. 1.3.3&nbsp;&nbsp;&nbsp; API enhancements ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Additions to MdigControlFeature()/MdigInquireFeature(): o&nbsp;&nbsp;&nbsp; The FeatureType parameter has been changed to UserVarType. This was done to simplify writing code with MdigControl/InquireFeature(). UserVarType must always reflect the type of the pointer passed to the UserVarPtr parameter. Legacy code is transparently supported, but we recommend you update your code. Note that M_TYPE_REGISTER now becomes M_TYPE_UINT8, M_TYPE_ENUMERATION now becomes M_TYPE_INT64 or M_TYPE_STRING, and M_TYPE_COMMAND now becomes M_DEFAULT. Data type conversions are made, whenever possible, in cases where the feature?s ?native? data type is different than the UserVarType supplied. Regardless of a feature?s ?native? data type it can always be read as a string. See Board-specific examples for details. The following is a list of example calls using the new UserVatType: ?&nbsp; MdigControlFeature(MilDigitizer, M_FEATURE_VALUE, MIL_TEXT(?Width?), M_TYPE_INT64, &amp;Int64Var) ?&nbsp; MdigControlFeature(MilDigitizer, M_FEATURE_VALUE, MIL_TEXT(?Gain?), M_TYPE_DOUBLE, &amp;DoubleVar) ?&nbsp; MdigControlFeature(MilDigitizer, M_FEATURE_VALUE, MIL_TEXT(?ReverseX?), M_TYPE_BOOLEAN, &amp;BoolVar) ?&nbsp; MdigControlFeature(MilDigitizer, M_FEATURE_VALUE, MIL_TEXT(?PixelFormat?), M_TYPE_STRING, MIL_TEXT(?Mono8?)) ?&nbsp; MdigControlFeature(MilDigitizer, M_FEATURE_VALUE, MIL_TEXT(?LUTValueAll?), M_TYPE_UINT8, Uint8Array) ?&nbsp; MdigControlFeature(MilDigitizer, M_FEATURE_VALUE, MIL_TEXT(?AcquisitionStart?), M_DEFAULT, M_NULL) ?&nbsp; MdigInquireFeature(MilDigitizer, M_FEATURE_VALUE, MIL_TEXT(?Width?), M_TYPE_INT64, &amp;Int64Var) ?&nbsp; MdigInquireFeature(MilDigitizer, M_FEATURE_VALUE, MIL_TEXT(?Gain?), M_TYPE_DOUBLE, &amp;DoubleVar) ?&nbsp; MdigInquireFeature(MilDigitizer, M_FEATURE_VALUE, MIL_TEXT(?ReverseX?), M_TYPE_BOOLEAN, &amp;BoolVar) ?&nbsp; MdigInquireFeature(MilDigitizer, M_FEATURE_VALUE + M_STRING_SIZE, MIL_TEXT(?PixelFormat?), M_TYPE_MIL_INT, &amp;MilIntVar) ?&nbsp; MdigInquireFeature(MilDigitizer, M_FEATURE_VALUE, MIL_TEXT(?PixelFormat?), M_TYPE_STRING, MilTextCharArray) ?&nbsp; MdigInquireFeature(MilDigitizer, M_FEATURE_VALUE, MIL_TEXT(?LUTValueAll?), M_TYPE_UINT8, Uint8Array) o&nbsp;&nbsp;&nbsp; M_FEATURE_USER_ARRAY_SIZE() can now be used with MdigInquireFeature when the data type returned is a string or an array of bytes (register). The M_FEATURE_USER_ARRAY_SIZE() macro is used to pass the size of the user-allocated buffer passed to MdigInquireFeature's UserVarPtr parameter. M_FEATURE_USER_ARRAY_SIZE() is passed using the UserVarType parameter. See MilGigE board specific example for sample usage. The following is a list of example calls using M_FEATURE_USER_ARRAY_SIZE(): ?&nbsp; MdigInquireFeature(MilDigitizer, M_FEATURE_VALUE, MIL_TEXT(?PixelFormat?), M_TYPE_STRING + M_FEATURE_USER_ARRAY_SIZE(N), MilTextCharArray); N being equal to the number of MIL_TEXT_CHAR in the MilTextCharArray. ?&nbsp; MdigInquireFeature(MilDigitizer, M_FEATURE_VALUE, MIL_TEXT(?LUTValueAll?), M_TYPE_UINT8 + M_FEATURE_USER_ARRAY_SIZE(N), Uint8Array); N being equal to the number of Uint8 in the Uint8Array. o&nbsp;&nbsp;&nbsp; M_FEATURE_ENUM_ENTRY_DISPLAY_NAME can now be used to inquire possible enumeration string entry to use for display purposes. See M_FEATURE_ENUM_ENTRY_NAME in the MIL documentation. o&nbsp;&nbsp;&nbsp; M_FEATURE_VALUE_AS_STRING is now deprecated. ?&nbsp; To read a feature?s value as a string and get the required string length use: ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MdigInquireFeature(MilDigitizer, M_FEATURE_VALUE + M_STRING_SIZE, MIL_TEXT(?Width?), M_TYPE_MIL_INT, &amp;MilIntVar); ?&nbsp; To read a feature?s value as a string use: ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MdigInquireFeature(MilDigitizer, M_FEATURE_VALUE, MIL_TEXT(?Width?), M_TYPE_STRING+M_FEATURE_USER_ARRAY_SIZE(ArraySize), MilTextCharArray); ?&nbsp; To write a feature?s value from a string use: ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MdigControlFeature(MilDigitizer, M_FEATURE_VALUE, MIL_TEXT(?Width?), M_TYPE_STRING, MIL_TEXT(?1024?)); o&nbsp;&nbsp;&nbsp; M_FEATURE_CHANGE_HOOK. Identifies the specified FeatureName to trigger the M_FEATURE_CHANGE hook callback. You must be hooked to the M_FEATURE_CHANGE hook type using MdigHookFunction(). ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Additions to MdigControl()/MdigInquire(): v&nbsp; Note that the following ControlTypes that must have + M_TIMERn are marked below. For information about M_TIMERn, refer to MdigControl() /MdigInquire(). M_TIMER_DELAY2 + M_TIMERn Sets the delay between the end of the first active portion of the timer output signal and the start of the second pulse. &nbsp; M_DEFAULT Specifies the default value. This is the same as specified in the DFC or, if not specified in the DCF, 0. Value &gt; 0 Specifies the delay, in nsecs. M_TIMER_DURATION2 + M_TIMERn Sets the duration for the active portion of the second pulse of the timer output signal. &nbsp; M_DEFAULT Specifies the default value.? This is the same as specified in the DFC or, if not specified in the DCF, 0. Value &gt; 0 Specifies the duration of the active portion of the second pulse of the timer output signal, in nsecs. M_TL_TRIGGER_ACTIVATION Sets the signal variation upon which to generate a trigger signal to the camera through the transport layer interface. &nbsp; M_DEFAULT Same as M_ANY_EDGE. M_ANY_EDGE Specifies that a trigger will be generated both upon a high-to-low and a low-to-high signal transition. M_EDGE_RISING Specifies that a trigger will be generated upon a low-to-high signal transition. M_GRAB_FRAME_BURST_SIZE Sets the number of frames grabbed into the same buffer at each grab command. The size Y of the grab buffer must be equal to (height of the frame * M_GRAB_FRAME_BURST_SIZE). &nbsp; M_DEFAULT Same as 1. 1 &lt;= Value &lt;= 1023 Specifies the number of frames grabbed. M_GRAB_FRAME_BURST_MAX_TIME Sets the maximum amount of time to wait for all the frames to be grabbed in the multi-frame buffer. The timer starts when the first frame is grabbed. The number of frames in the buffer can be inquired using MdigGetHookInfo() with M_GRAB_FRAME_BURST_COUNT. This is useful when the camera stops sending frames and the multi-frame buffer is only partially full. &nbsp; M_DEFAULT Same as M_INFINITE. 0.000008 &lt;= Value &lt;= 1.000000 Specifies the maximum amount of time to wait, in secs. M_INFINITE Specifies to wait indefinitely. M_GRAB_FRAME_BURST_END_TRIGGER_SOURCE &nbsp; Sets the signal from which a rising edge signals the end of a multi-frame sequence. This is useful to force a partially completed multi-frame buffer to complete. &nbsp; M_DEFAULT Same as M_AUX_IO0. M_AUX_IOn Specifies to use auxiliary input signal n as the trigger source, where n is the number of the auxiliary signal. Note that the specified auxiliary signal can also be a bidirectional signal set to input (using M_IO_MODE set to M_INPUT). M_GRAB_FRAME_BURST_END_TRIGGER_STATE Specifies M_GRAB_FRAME_BURST_END_TRIGGER_SOURCE as the source. &nbsp; M_DEFAULT Same as M_DISABLE. M_DISABLE Sets the grab frame burst end trigger source to disabled. M_ENABLE Sets the grab frame burst end trigger source to enabled. &nbsp; The following control types allow you to control the settings for one of the data latches of your installed MIL board. Data latches store information specific to a grabbed frame when the latch is triggered; the data latch is reset at the end of every grabbed frame. To retrieve information from a data latch, use MdigGetHookInfo() with M_DATA_LATCH.... Note that data latch information is only available when MdigGetHookInfo() is called from a function hooked to an end of grabbed frame event using MdigHookFunction() with M_GRAB_FRAME_END or from the hook-handler function (callback function) of MdigProcess(). v&nbsp; Note that you can only use data latches in association with the MIL digitizer allocated using MdigAlloc() with M_DEV0. v&nbsp; Note that M_DATA_LATCH ControlTypes must have + M_LATCHn added to them. M_LATCHn specifies the data latch from which to retrieve information, where n is a value from 0 to 15. M_DATA_LATCH_MODE + M_LATCHn Specifies to latch data from the point when the grab is queued until the start of the first frame of a series of queued grabs or sequence. If calls to MdigGrab() occur while no other grab is currently being performed and M_DATA_LATCH_MODE is set to M_PREFETCH, events that occur, from the moment the grab command is issued until the start of the grabbed frame, can also trigger a data latch and be retrieved at the end of the grabbed frame, for each MdigGrab() call. &nbsp; M_DEFAULT Same as M_NORMAL. M_NORMAL Sets the latch to not engage before the start of the first grabbed frame. M_PREFETCH Sets the latch to engage before the start of the first grab frame. M_DATA_LATCH_STATE + M_LATCHn Specifies the state of the data latch. &nbsp; M_DEFAULT Same as M_DISABLE. M_DISABLE Sets the data latch to disabled. M_ENABLE Sets the data latch to enabled. M_DATA_LATCH_TRIGGER_ACTIVATION + M_LATCHn Specifies the trigger signal transition upon which to store information to the data latch. Note that this is only useful when M_DATA_LATCH_TRIGGER_SOURCE is set to M_AUX_IOn or M_TIMER_ACTIVE. To set the signal with which to trigger the data latch, use M_DATA_LATCH_TRIGGER_SOURCE. &nbsp; M_DEFAULT Same as M_EDGE_RISING. M_EDGE_RISING Sets the specified information to be stored to the data latch upon a high-to-low signal transition. M_EDGE_FALLING Sets the specified information to be stored to the data latch upon a low-to-high signal transition. M_DATA_LATCH_TRIGGER_SOURCE + M_LATCHn Specifies what triggers store information to the data latch. Use M_DATA_LATCH_TYPE to specify the type of information to store. &nbsp; M_DEFAULT Same as M_GRAB_FRAME_END. M_AUX_IOn Sets to use auxiliary signal n as the trigger source, where n is the auxiliary signal number. Note that the specified auxiliary signal can also be a bidirectional signal set to input (using M_IO_MODE set to M_INPUT). For a list of the available auxiliary I/O signals, see the Connectors and signal names section of the MIL Hardware-specific Notes chapter for your Matrox imaging board or MIL 10 driver. To specify the signal transition, use M_DATA_LATCH_TRIGGER_ACTIVATION. M_GRAB_FRAME_END Sets the data latch to trigger on the event that occurs at the end of each grabbed frame on your frame grabber; this event occurs when the frame grabber receives the last pixels (or packet) of a frame from the camera. Note that, in this case, the grabbed data might not be completely transferred to the Host. M_GRAB_FRAME_START Sets the the data latch to trigger on the event that occurs at the start of each grabbed frame. M_GRAB_LINE Sets the data latch to trigger on the event that occurs at the end of each grabbed line on your frame grabber; this event occurs when the frame grabber receives the last pixels (or packet) of a line from the camera. Note that, in this case, the grabbed data might not be completely transferred to the Host. M_ROTARY_ENCODERn Sets the rotary decoder n as the trigger source, where n is the rotary decoder number. To configure the rotary decoder, use the M_ROTARY_ENCODER... control types. To establish when the rotary decoder issues a trigger, use M_ROTARY_ENCODER_POSITION_TRIGGER. M_TIMER_ACTIVE + M_TIMERn Sets the data latch to trigger on the event that occurs when the specified timer is active. This can be at the start of the active period or the end of the active period, depending on how you set M_DATA_LATCH_TRIGGER_ACTIVATION. M_DATA_LATCH_TYPE + M_LATCHn Specifies the type of information to store in the data latch. Note that each type of information can only be associated with one data latch, except for timestamp, which can be associated with up to four data latches. MIL returns an error when this limitation is not respected. &nbsp; M_IO_STATUS_ALL Sets that the status of all the auxiliary I/O signals is stored. M_ROTARY_ENCODERn Sets that the value of the counter of rotary decoder n is stored, where n is a number between 1 and 4. To configure the rotary decoder, use the M_ROTARY_ENCODER... control types. M_TIME_STAMP Sets the timestamp upon which the data latch is triggered is stored, in ticks. Up to four separate data latches can store a timestamp. To convert a timestamp from clock ticks to seconds, use the following equation: Timestamp * ( TimestampFrequencyInHz). To inquire the clock frequency, use MdigInquire() with M_DATA_LATCH_CLOCK_FREQUENCY. M_DATA_LATCH_CLOCK_FREQUENCY Inquires the frequency of the clock when retrieving a timestamp in a data latch. &nbsp; Value Specifies the frequency of the clock when retrieving a timestamp in a data latch, in Hz. &nbsp; ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Additions to MdigHookFunction(): o&nbsp;&nbsp;&nbsp; You can now hook to a GenICam feature change event. o&nbsp;&nbsp;&nbsp; M_FEATURE_CHANGE. Hooks a feature change callback that will get triggered when identified features change state. Features to participate in M_FEATURE_CHANGE events must be specified using MdigControlFeature() with M_FEATURE_CHANGE_HOOK. ?&nbsp; M_ALL. HookType combination constant. Specifies the M_FEATURE_CHANGE event will get triggered by any feature. ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Additions to MdigGetHookInfo(): The following allows you to retrieve information about a GenICam SFNC-compliant event. The following information types are only available if MdigGetHookInfo() was called from a function hooked to a GenICam event using M_GC_EVENT + M_GC_FEATURE_CHANGE. In addition, the GenICam event must be enabled using MdigControlFeature(), and the message channel must be supported by your camera. o&nbsp;&nbsp;&nbsp; M_GC_FEATURE_CHANGE_NAME. Retrieves the name of the GenICam feature that changed. The UserVarPtr must point to a user allocated array of type MIL_TEXT_CHAR. o&nbsp;&nbsp;&nbsp; M_GC_FEATURE_CHANGE_NAME_SIZE. Retrieves the size of the name of the GenICam feature that changed. The UserVarPtr must point to a MIL_INT that is the required string length +1. The following allows you to retrieve information about grab frame burst events. Unless otherwise specified, you can retrieve these information types if you call this function from within a function hooked to any digitizer event using MdigHookFunction() or MdigProcess(). M_GRAB_FRAME_BURST_COUNT Retrieves the number of frames grabbed in the multi-frame buffer. &nbsp; Value &gt; 0 Specifies the number of frames grabbed. M_GRAB_FRAME_BURST_END_SOURCE Retrieves the type of event that generated the end of the frame burst. Multiple events can be set at the same time. Bitwise operators must be used to verify the presence of a specific returned value. Possible return values are: &nbsp; M_BURST_TRIGGER Specifies that trigger signal generates the end of the burst sequence. To specify the source signal, use MdigControl() with? M_GRAB_FRAME_BURST_END_TRIGGER_SOURCE. M_BURST_MAX_TIME Specifies that the frame burst has taken as much time to complete as the maximum frame burst time. To specify the maximum time for a frame burst to complete, use MdigControl with M_GRAB_FRAME_BURST_MAX_TIME. M_BURST_COUNT Specifies the number of frames that have been grabbed. To specify the number of frames in a frame burst, use MdigControl() with M_GRAB_FRAME_BURST_SIZE. The following allows you to retrieve information from a data latch. These information types are only available if MdigGetHookInfo() was called from a function hooked to an end of grabbed frame event using MdigHookFunction() with M_GRAB_FRAME_END or from the hook-handler function (callback function) of MdigProcess(). In addition, you must have enabled the data latch to store this information, using MdigControl() with M_DATA_LATCH_STATE. v&nbsp; Note that you can only use data latches in association with the MIL digitizer allocated using MdigAlloc() with M_DEV0. The following values require that you pass the UserVarPtr parameter the address of a MIL_INT64. M_DATA_LATCH_VALUE + M_LATCHn + M_VALUE_INDEX(i) Retrieves the stored data of the specified data latch. If there are multiple instances of this data (for example, your data latch is triggered at the end of each grabbed line), use + M_VALUE_INDEX(i). &nbsp; Value Specifies the stored data. M_DATA_LATCH_VALUE_ALL Retrieves all the stored data of the specified data latch. &nbsp; Value Specifies all the stored data. M_DATA_LATCH_VALUE_COUNT Counts the number of items stored inside a data latch. Note that a data latch is reset at every frame event. &nbsp; Value Specifies the number of instances. Note that a data latch is reset at every frame event. &nbsp; Combination constant for M_DATA_LATCH_VALUE. You can add the following value to the above-mentioned value to specify the instance of the stored information to retrieve. M_VALUE_INDEX( ??? MIL_INT64 IndexValue ) Specifies the instance of stored information to retrieve. IndexValue: Sets the instance of stored information. For example, to read the information latched when the last line finishes being grabbed for a frame, with 1024 lines, the instance would be 1023. &nbsp; 1.3.4&nbsp;&nbsp;&nbsp; Software bug fixes ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Fixed the issue that occurs when grabbing simultaneously from multiple CXP cameras (on a single Matrox Radient eV-CXP board); potentially causing frames to be dropped from one camera when stopping the other (MIL-6901). ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Fixed a memory leak that occurs where a small object was not freed when MdigFree() is called (r209877). ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Fixed an issue that could lead to a system freeze while grabbing in a monochrome buffer with a Bayer camera (r210399). ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Fixed an issue where the camera could not be locked properly at CXP-1 speed (r210400). ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Fixed an issue that occurred when you do not reset current link while using a camera simulator DCF (r213413). ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Optimized GTX locking (r213416). ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Improved the precision of the value returned by MdigInquire() with M_GRAB_PERIOD and M_SELECTED_FRAME_RATE (r214216). ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Fixed the value returned by the timer delay and timer value when the clock frequency is unknown (r214226). ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Fixed an issue where CXP triggers were still being sent to the camera after a call to MdigFree() (219406). ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Fixed a series of LUT issues. ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Fixed an image issue when grabbing from a color camera using a monochrome buffer (221487). ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Fixed the M_GC_MANIFEST_ENTRY() macro; it could not receive a variable as a parameter. Previously, only integer literals were working. ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Matrox Intellicam now accepts adding GenICam commands for the DCF while in recording mode. 1.3.5&nbsp;&nbsp;&nbsp; Firmware bug fixes ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Fixed an issue with hardware Bayer conversion. ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Fixed an issue with 8k CXP packets. ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Fixed an issue with grabbing simultaneously from multiple CXP cameras. ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Fixed a series of grab abort issues. ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Added support for 10- and 12-bit raw modes (without pixel expansion). ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Added support for data latch functionality. ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Improved memory arbitration. 1.4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; What?s new in MIL 10 Update 15 1.4.1&nbsp;&nbsp;&nbsp; API enhancements The following additions were made to MsysInquire(): M_PCIE_SPEED_MAX Inquires the maximum supported PCIe speed of the Matrox product. &nbsp; M_GENn Specifies the PCIe generation, where n is a value from 1 to 3. M_INVALID Specifies that the PCIe generation cannot be returned. M_PCIE_SPEED Inquires the current PCIe speed. &nbsp; M_GENn Specifies the PCIe generation, where n is a value from 1 to 3. M_INVALID Specifies that this is not a PCIe device. M_PCIE_NUMBER_OF_LANES_MAX Inquires the maximum supported number of PCIe lanes that is supported by the Matrox product. &nbsp; 1, 2, 4, 8 Specifies the maximum number of lanes. M_PCIE_NUMBER_OF_LANES Inquires the current number of active PCIe lanes used by the Matrox product. &nbsp; 1, 2, 4, 8 Specifies the total number of active lanes. &nbsp; 1.4.2&nbsp;&nbsp;&nbsp; Software bug fixes ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Fixed an issue where, in some cases, the DMA performance was not optimal (r199060). ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Fixed a possible exception that could occur in low memory situations when starting MdigProcess() (r200457). ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Fixed ab issue where a timer would stop when allocating a second digitizer (r200832). ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Fixed a possible system crash when freeing a buffer while grabbing into it (r200835). ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Fixed a camera simulator DCFs where the frame rate was not properly reported (r201771, r201773). ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Fixed a memory leak that could occur when allocating an invalid DCF (r202304). ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Fixed a possible exception that could occur when loading a DCF with a large amount of features (r203877). ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MdigHookFunction with M_FRAME_START and M_FIELD_START are not supported. These will now generate an error (r201239). ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MdigControl(M_USER_BIT_STATE) will now be executed immediately, instead of being queued with the grab (r203533). ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MdigControl(M_LUT_ID): Fixed an issue when using the LUT with 10- and 12-bit input sources (r200752, r201750). 1.4.3&nbsp;&nbsp;&nbsp; Firmware bug fixes ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Fixed a possible color corruption occurring in images when using an RGB camera and CXP trigger. 1.4.4&nbsp;&nbsp;&nbsp; Matrox Intellicam bug fixes ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; In Matrox Intellicam, you can now modify a DCF while the feature browser is open while working with a Camera Link camera accessed using the GenICam CLProtocol. However, the feature browser will no longer work with Teledyne DALSA Camera Link cameras using the GenICam CLProtocol and Sapera software version 7.3 or lower. In this case, update the Sapera software to version 7.4 or higher. ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Fixed a possible Matrox Intellicam crash when clicking on &quot;Dump state to DCF&quot; in the camera configuration tab, when the camera contains a LUT. ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Fixed an issue where error messages would not be displayed when starting the feature browser. ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Fixed possible Matrox Intellicam crash when aborting a grab from a triggered camera that is not receiving any triggers. 1.5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; What?s new in MIL 10 ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Support for Microsoft? Windows? 8. ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Matrox Radient eV-CXP supports JIIA (Japan Industrial Imaging Association) CoaXPress standard version 1.0. ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Improvements in Matrox Intellicam's Feature Browser. It can display and control settings for cameras, MIL systems, and MIL digitizers. Code snippets for the selected control are displayed at the bottom pane of the feature browser. ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; New MIL I/O API available in Matrox Intellicam's Feature Browser. ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Support for automatic hardware Bayer conversion when the camera's pixel format is set to Bayer. 2.&nbsp;&nbsp; Location of examples (in the help file) In the help file, the location information written at the top of examples might not be up-to-date. Use MIL Example Launcher to find an example on disk. ",
      "wordCount": 6980,
      "subEntries": []
    },
    {
      "id": "Readme_milRadientCXP_RadienteVCXPAnimation",
      "title": "RadienteVCXPAnimation",
      "location": "MIL Release Notes",
      "pageURL": "\\milRadientCXP\\RadienteVCXPAnimation.htm",
      "text": " Matrox Imaging Library (MIL) 10 Update 29 Matrox Radient eV-CXP Release Notes September 2017 &nbsp;(c) Copyright Matrox Electronic Systems Ltd., 1992-2017. In the following animation, an encoder is used to trigger a grab when a certain position is reached. 20 frames of 1000 lines each, or 20000 lines, are grabbed, at which point the grab moves slightly to the right and repeats the process in reverse. For more information, see the Example 1 code snippet, found on the milRadientCXP page in this section of the help file. ",
      "wordCount": 89,
      "subEntries": []
    },
    {
      "id": "Readme_milRadientCXP_RadienteVCXPAnimation2",
      "title": "RadienteVCXPAnimation2",
      "location": "MIL Release Notes",
      "pageURL": "\\milRadientCXP\\RadienteVCXPAnimation2.htm",
      "text": " Matrox Imaging Library (MIL) 10 Update 29 Matrox Radient eV-CXP Release Notes September 2017 &nbsp;(c) Copyright Matrox Electronic Systems Ltd., 1992-2017. In the following animation, the board's decoder is set to trigger a pulse only when a linear stage is moving forward. The counter decrements when the stage moves in reverse. The grab is only triggered when the counter hits a new positive value; as such, no line that was already grabbed will be grabbed again. For more information, see the Example 2 code snippet, found on the milRadientCXP page in this section of the help file. ",
      "wordCount": 99,
      "subEntries": []
    },
    {
      "id": "milRadientCXP_files",
      "wordCount": 0
    }
  ]
}]
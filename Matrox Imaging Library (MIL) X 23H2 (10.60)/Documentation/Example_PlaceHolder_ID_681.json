[{
  "id": "Example_PlaceHolder_ID",
  "version": "2024020714",
  "title": "Example_PlaceHolder_Title",
  "wordCount": 0,
  "subEntries": [
    {
      "id": "Examples_Processing_3dReconstruction_AlignLaserScans_CPP_alignlaserscans_cpp",
      "version": "2024020714",
      "title": "alignlaserscans.cpp",
      "location": "Sample Code from MIL Examples",
      "text": " Top //**************************************************************************** // // File name: AlignLaserScans.cpp // Location: See Matrox Example Launcher in the MIL Control Center // // // Synopsis: This program contains an example showing how to align and fixture // laser scans represented as 3D point clouds. // // Copyright (C) Matrox Electronic Systems Ltd., 1992-2024. // All Rights Reserved //**************************************************************************** #include &lt;mil.h&gt; //***************************************************************************** // Enumeration definition. //***************************************************************************** enum class EViews { eSide = 0, eBottom }; //***************************************************************************** // File paths. //***************************************************************************** static const MIL_CONST_TEXT_PTR DISK_SCAN_FILE_PATH = M_IMAGE_PATH MIL_TEXT(\"AlignLaserScans/ScannedDisk.mbufc\"); static const MIL_CONST_TEXT_PTR PYRAMID_SCAN_FILE_PATH = M_IMAGE_PATH MIL_TEXT(\"AlignLaserScans/ScannedPyramid.mbufc\"); static const MIL_CONST_TEXT_PTR DISK_SCAN_ILLUSTRATION_FILE_PATH = M_IMAGE_PATH MIL_TEXT(\"AlignLaserScans/ScanDisk.png\"); static const MIL_CONST_TEXT_PTR PYRAMID_SCAN_ILLUSTRATION_FILE_PATH = M_IMAGE_PATH MIL_TEXT(\"AlignLaserScans/ScanPyramid.png\"); static const MIL_CONST_TEXT_PTR CORR_ILLUSTRATION_FILE_PATH = M_IMAGE_PATH MIL_TEXT(\"AlignLaserScans/ScanCorrections.png\"); //***************************************************************************** // Constants. //***************************************************************************** static const MIL_INT NUM_DISPLAYS = 2; static const MIL_INT DISPLAY_2D_SIZE_X = 320; static const MIL_INT DISPLAY_2D_SIZE_Y = 320; static const MIL_INT DISPLAY_3D_SIZE_X = 420; static const MIL_INT DISPLAY_3D_SIZE_Y = 420; static const MIL_DOUBLE DISK_DIAMETER = 70.0; // in mm static const MIL_DOUBLE DISK_HEIGHT = 50.0; // in mm static const MIL_DOUBLE PYRAMID_BOTTOM_BASE_LENGTH = 44.0; // in mm static const MIL_DOUBLE PYRAMID_TOP_BASE_LENGTH = 22.0; // in mm static const MIL_DOUBLE PYRAMID_HEIGHT = 11.0; // in mm static const MIL_DOUBLE ZOOM_FACTOR_LOW = 1.4; static const MIL_DOUBLE ZOOM_FACTOR_MID = 1.8; static const MIL_DOUBLE ZOOM_FACTOR_HIGH = 2.0; static const MIL_INT POINT_THICKNESS = 8; static const MIL_INT FONT_SIZE = 15; static const MIL_INT NB_TILES = 6; static const MIL_DOUBLE TILES_RATIO = 0.2; static const MIL_DOUBLE OPACITY_PERCENTAGE = 30; // in % static const MIL_INT AXIS_THICKNESS = 3; static const MIL_INT AXIS_TYPES[NUM_DISPLAYS] = {M_XY_AXES, M_XZ_AXES}; MIL_CONST_TEXT_PTR DISK_GUIDELINES = MIL_TEXT(\"Disk scanning guidelines.\\n\\n\") MIL_TEXT(\"1 - The alignment disk must cover at least 50%% of the\\n\") MIL_TEXT(\" scanned width (X direction).\\n\") MIL_TEXT(\"2 - The alignment disk's edge must be fully visible in the scan.\\n\") MIL_TEXT(\"3 - The alignment disk must cover at least 30%% of the\\n\") MIL_TEXT(\" scanned length (Y direction).\\n\") MIL_TEXT(\"4 - The alignment disk's holes must be at least \\n\") MIL_TEXT(\" 30 scan lines (Y-direction) and 30 points (X-direction).\\n\") MIL_TEXT(\" The radii of the holes must be within 5 to 10%% of the disk's radius.\\n\") MIL_TEXT(\" The depth of the holes must be at least 20%% of the total disk's height.\\n\") MIL_TEXT(\"5 - A floor (background plane) must be present in the scan.\\n\") MIL_TEXT(\"6 - Ensure the alignment disk's surface is parallel to the plane of motion.\\n\\n\"); MIL_CONST_TEXT_PTR PYRAMID_GUIDELINES = MIL_TEXT(\"Pyramid scanning guidelines.\\n\\n\") MIL_TEXT(\"1 - The alignment pyramid's top and bottom faces must be squares.\\n\") MIL_TEXT(\"2 - The angle between the top and side faces must be between 35 to 55 degrees.\\n\") MIL_TEXT(\"3 - The top face's length must be approximately 50%% of the bottom face's length.\\n\") MIL_TEXT(\"4 - The base must be approximately 25%% wider and 50%% longer than the bottom face.\\n\") MIL_TEXT(\"5 - The alignment pyramid must cover at least 50%% of the scanned width (X-direction).\\n\") MIL_TEXT(\"6 - The alignment pyramid must cover at least 30%% of the scanned height (Y-direction).\\n\") MIL_TEXT(\"7 - The pyramid's faces and the top of the base must each be composed of at least\\n\") MIL_TEXT(\" 2000 points.\\n\") MIL_TEXT(\"8 - The base must have a chamfer at its top left corner (as seen in subfigure (2))\\n\") MIL_TEXT(\" of a length of at least 30%% of the pyramid's top face at an approximate angle of 45 degrees.\\n\\n\"); //**************************************************************************** // Function declaration. //**************************************************************************** void PrintHeader(); void PrintScanningGuidelines(MIL_ID MilSystem, MIL_CONST_TEXT_PTR GuidelinesText, MIL_CONST_TEXT_PTR IllustrationPath); bool CheckForRequiredMILFile(const MIL_STRING&amp; FileName); MIL_UNIQUE_3DDISP_ID Alloc3dDisplayId(MIL_ID MilSystem); void DisplayContainer(MIL_ID MilContainer, MIL_ID MilDisplay3D, MIL_INT ViewOrientation, MIL_DOUBLE Zoom); void ShowDifferentViews(MIL_ID MilContainer, const MIL_UNIQUE_DISP_ID MilDisplayArray[NUM_DISPLAYS], const MIL_UNIQUE_BUF_ID MilDepthMapArray[NUM_DISPLAYS]); void DrawAxis(MIL_ID GraList, MIL_INT AxisType); void PrintAlignmentCorrections(MIL_ID MilResult); void ApplyShearBufferCorrection(MIL_ID MilSrcContainer, MIL_ID MilDstContainer, MIL_ID MilResult); bool DiskExample(MIL_ID MilSystem, MIL_ID MilDisplay3D, const MIL_UNIQUE_DISP_ID MilDisplayArray[NUM_DISPLAYS], const MIL_UNIQUE_BUF_ID MilDisplayImageArray[NUM_DISPLAYS]); bool PyramidExample(MIL_ID MilSystem, MIL_ID MilDisplay3D, const MIL_UNIQUE_DISP_ID MilDisplayArray[NUM_DISPLAYS], const MIL_UNIQUE_BUF_ID MilDisplayImageArray[NUM_DISPLAYS]); //**************************************************************************** // Example description. //**************************************************************************** void PrintHeader() { MosPrintf(MIL_TEXT(\"[EXAMPLE NAME]\\n\")); MosPrintf(MIL_TEXT(\"AlignLaserScans\\n\\n\")); MosPrintf(MIL_TEXT(\"[SYNOPSIS]\\n\")); MosPrintf(MIL_TEXT(\"This example shows how to correct scans with a misaligned 3D profile sensor,\\n\")); MosPrintf(MIL_TEXT(\"using a disk and a truncated pyramid alignment object.\\n\")); MosPrintf(MIL_TEXT(\"It also shows how to perform fixturing. \\n\\n\")); MosPrintf(MIL_TEXT(\"[MODULES USED]\\n\")); MosPrintf(MIL_TEXT(\"Modules used: Application, System, Display, Graphics, Calibration, Buffer, \\n\") MIL_TEXT(\"3D Map, 3D Geometry, 3D Image Processing, 3D Display, and 3D Graphics. \\n\\n\")); } //**************************************************************************** // Scanning guidelines. void PrintScanningGuidelines(MIL_ID MilSystem, MIL_CONST_TEXT_PTR GuidelinesText, MIL_CONST_TEXT_PTR IllustrationPath) { auto IllustrationDispId = MdispAlloc(MilSystem, M_DEFAULT, MIL_TEXT(\"M_DEFAULT\"), M_WINDOWED, M_UNIQUE_ID); auto MilIllustrationImage = MbufRestore(IllustrationPath, MilSystem, M_UNIQUE_ID); MdispControl(IllustrationDispId, M_TITLE, MIL_TEXT(\"Scanning the calibration object.\")); MdispSelect(IllustrationDispId, MilIllustrationImage); MosPrintf(GuidelinesText); MosPrintf(MIL_TEXT(\"Press any key to continue.\\n\\n\")); MosGetch(); } //******************************************************************************* // Checks the required file exist. //***************************************************************************** bool CheckForRequiredMILFile(const MIL_STRING&amp; FileName) { MIL_INT FilePresent = M_NO; MappFileOperation(M_DEFAULT, FileName, M_NULL, M_NULL, M_FILE_EXISTS, M_DEFAULT, &amp;FilePresent); if(FilePresent == M_NO) { MosPrintf(MIL_TEXT(\"\\n\") MIL_TEXT(\"The footage needed to run this example is missing. You need \\n\") MIL_TEXT(\"to obtain and apply a separate specific update to have it.\\n\\n\")); MosPrintf(MIL_TEXT(\"Press any key to end.\\n\\n\")); MosGetch(); } return (FilePresent == M_YES); } //***************************************************************************** // Allocates a 3D display and returns its MIL identifier. //***************************************************************************** MIL_UNIQUE_3DDISP_ID Alloc3dDisplayId(MIL_ID MilSystem) { MappControl(M_DEFAULT, M_ERROR, M_PRINT_DISABLE); auto MilDisplay = M3ddispAlloc(MilSystem, M_DEFAULT, MIL_TEXT(\"M_DEFAULT\"), M_DEFAULT, M_UNIQUE_ID); MappControl(M_DEFAULT, M_ERROR, M_PRINT_ENABLE); if(!MilDisplay) { MosPrintf(MIL_TEXT(\"\\n\") MIL_TEXT(\"The current system does not support the 3D display.\\n\") MIL_TEXT(\"Press any key to continue.\\n\")); MosGetch(); } return MilDisplay; } //***************************************************************************** // Display a 3D container. //***************************************************************************** void DisplayContainer(MIL_ID MilContainer, MIL_ID MilDisplay3D, MIL_INT ViewOrientation, MIL_DOUBLE Zoom) { if(MilDisplay3D) { M3ddispControl(MilDisplay3D, M_UPDATE, M_DISABLE); auto GraList3D = (MIL_ID)M3ddispInquire(MilDisplay3D, M_3D_GRAPHIC_LIST_ID, M_NULL); M3dgraRemove(GraList3D, M_ALL, M_DEFAULT); auto ContainerLabel = M3ddispSelect(MilDisplay3D, MilContainer, M_DEFAULT, M_DEFAULT); M3dgraControl(GraList3D, ContainerLabel, M_COLOR_USE_LUT, M_TRUE); M3dgraControl(GraList3D, ContainerLabel, M_COLOR_COMPONENT, M_COMPONENT_RANGE); M3dgraControl(GraList3D, ContainerLabel, M_COLOR_COMPONENT_BAND, 2); auto MilSystem = MbufInquire(MilContainer, M_OWNER_SYSTEM, M_NULL); auto MilBoundingBox = M3dgeoAlloc(MilSystem, M_GEOMETRY, M_DEFAULT, M_UNIQUE_ID); M3dimStat(M_STAT_CONTEXT_BOUNDING_BOX, MilContainer, MilBoundingBox, M_DEFAULT); const auto BoundingBoxSizeX = M3dgeoInquire(MilBoundingBox, M_SIZE_X, M_NULL); const auto BoundingBoxSizeY = M3dgeoInquire(MilBoundingBox, M_SIZE_Y, M_NULL); const auto BoundingBoxSize = std::max(BoundingBoxSizeX, BoundingBoxSizeY); auto GridLabel = M3dgraGrid(GraList3D, M_ROOT_NODE, M_TILES_AND_SPACING, M_DEFAULT, NB_TILES, NB_TILES, TILES_RATIO * BoundingBoxSize, TILES_RATIO * BoundingBoxSize, M_DEFAULT); M3dgraControl(GraList3D, GridLabel, M_APPEARANCE, M_WIREFRAME); M3dgraControl(GraList3D, GridLabel, M_OPACITY, OPACITY_PERCENTAGE); // Draw the axis at the origin. auto AxisLabel = M3dgraAxis(GraList3D, M_DEFAULT, M_IDENTITY_MATRIX, 0.5 * BoundingBoxSize, M_NULL, M_DEFAULT, M_DEFAULT); M3dgraControl(GraList3D, AxisLabel, M_THICKNESS, AXIS_THICKNESS); M3dgraControl(GraList3D, AxisLabel, M_OPACITY, OPACITY_PERCENTAGE); // Adjust the view of the 3D displays. M3ddispSetView(MilDisplay3D, M_AUTO, ViewOrientation, M_DEFAULT, M_DEFAULT, M_DEFAULT); M3ddispSetView(MilDisplay3D, M_ZOOM, Zoom, M_DEFAULT, M_DEFAULT, M_DEFAULT); // Set the display's rotation axis center. This will keep the // behaviour of auto rotate consistent as we move its interest point. M3ddispCopy(M_VIEW_INTEREST_POINT, MilDisplay3D, M_ROTATION_AXIS_CENTER, M_DEFAULT); // Set the display's rotation axis center. This will keep the // behaviour of auto rotate consistent as we move its interest point. M3ddispCopy(M_VIEW_INTEREST_POINT, MilDisplay3D, M_ROTATION_AXIS_CENTER, M_DEFAULT); M3ddispControl(MilDisplay3D, M_UPDATE, M_ENABLE); } } //***************************************************************************** // Show different views of a container in 2D display. //***************************************************************************** void ShowDifferentViews(MIL_ID MilContainer, const MIL_UNIQUE_DISP_ID MilDisplayArray[NUM_DISPLAYS], const MIL_UNIQUE_BUF_ID MilDepthMapArray[NUM_DISPLAYS]) { auto MilSystem = MbufInquire(MilContainer, M_OWNER_SYSTEM, M_NULL); auto MilRotatedContainer = MbufAllocContainer(MilSystem, M_PROC, M_DEFAULT, M_UNIQUE_ID); // Rotate the point cloud container to be in the xy plane before projecting. M3dimRotate(MilContainer, MilRotatedContainer, M_ROTATION_XYZ, 90, 0, 0, M_DEFAULT, M_DEFAULT, M_DEFAULT, M_DEFAULT, M_DEFAULT); std::vector&lt;MIL_ID&gt; DispContainers = {MilContainer, MilRotatedContainer}; for(MIL_INT i = 0; i &lt; NUM_DISPLAYS; ++i) { auto MilGra = MgraAlloc(MilSystem, M_UNIQUE_ID); MgraControl(MilGra, M_COLOR, M_COLOR_LIGHT_BLUE); M3dimCalibrateDepthMap(DispContainers[i], MilDepthMapArray[i], M_NULL, M_NULL, M_DEFAULT, M_DEFAULT, M_CENTER); M3dimProject(DispContainers[i], MilDepthMapArray[i], M_NULL, M_DEFAULT, M_DEFAULT, M_DEFAULT, M_DEFAULT); auto GraList = MdispInquire(MilDisplayArray[i], M_ASSOCIATED_GRAPHIC_LIST_ID, M_NULL); MgraClear(MilGra, GraList); DrawAxis(GraList, AXIS_TYPES[i]); McalDraw(MilGra, MilDepthMapArray[i], MilDepthMapArray[i], M_DRAW_RELATIVE_COORDINATE_SYSTEM + M_DRAW_MAJOR_MARKS, M_DEFAULT, M_DEFAULT); MIL_DOUBLE XOrigin = 0; MIL_DOUBLE YOrigin = 0; McalTransformCoordinate(MilDepthMapArray[i], M_WORLD_TO_PIXEL, 0, 0, &amp;XOrigin, &amp;YOrigin); MgraControl(MilGra, M_COLOR, M_COLOR_BLACK); MgraLine(MilGra, GraList, XOrigin, 0, XOrigin, DISPLAY_2D_SIZE_Y); MgraLine(MilGra, GraList, 0, YOrigin, DISPLAY_2D_SIZE_X, YOrigin); MdispSelect(MilDisplayArray[i], MilDepthMapArray[i]); } } //***************************************************************************** // Draws the 2D axis in the 2D display. //***************************************************************************** void DrawAxis(MIL_ID GraList, MIL_INT AxisType) { auto MilSystem = MgraInquireList(GraList, M_LIST, M_DEFAULT, M_OWNER_SYSTEM, M_NULL); auto MilGraContext = MgraAlloc(MilSystem, M_UNIQUE_ID); MgraControl(MilGraContext, M_DRAW_DIRECTION, M_PRIMARY_DIRECTION); MgraControl(MilGraContext, M_BACKGROUND_MODE, M_TRANSPARENT); MgraControl(MilGraContext, M_COLOR, M_COLOR_BLACK); MgraControl(MilGraContext, M_INPUT_UNITS, M_DISPLAY); if(AxisType == M_XY_AXES) { MgraLine(MilGraContext, GraList, 5, 5, 40, 5); // Horizontal line. MgraLine(MilGraContext, GraList, 5, 5, 5, 48); // Vertical line. MgraText(MilGraContext, GraList, 20, 8, MIL_TEXT(\"X\")); MgraText(MilGraContext, GraList, 8, 25, MIL_TEXT(\"Y\")); } else //M_XZ_AXES { MgraLine(MilGraContext, GraList, 5, 40, 40, 40); // Horizontal line. MgraLine(MilGraContext, GraList, 5, 40, 5, 5); // Vertical line. MgraText(MilGraContext, GraList, 20, 42, MIL_TEXT(\"X\")); MgraText(MilGraContext, GraList, 8, 15, MIL_TEXT(\"Z\")); } } //***************************************************************************** // Prints the shear corrections in the x- and z-directions and the scale // correction in the y-direction. //***************************************************************************** void PrintAlignmentCorrections(MIL_ID MilResult) { MIL_DOUBLE ShearZ, ShearX, ScaleY; M3dmapGetResult(MilResult, M_DEFAULT, M_3D_SHEAR_Z, &amp;ShearZ); M3dmapGetResult(MilResult, M_DEFAULT, M_3D_SHEAR_X, &amp;ShearX); M3dmapGetResult(MilResult, M_DEFAULT, M_3D_SCALE_Y, &amp;ScaleY); MosPrintf(MIL_TEXT(\"M3dmapAlignScan found the following corrections: \\n\"), ShearZ); MosPrintf(MIL_TEXT(\"The correction in the z-direction between consecutive scan lines (SHEAR_Z): %f mm \\n\"), ShearZ); MosPrintf(MIL_TEXT(\"The correction in the x-direction between consecutive scan lines (SHEAR_X): %f mm \\n\"), ShearX); MosPrintf(MIL_TEXT(\"The scale correction in the y-direction (SCALE_Y) : %f \\n\\n\"), ScaleY); } //***************************************************************************** // Correct for the shape deformations due to shear and scales. //***************************************************************************** void ApplyShearBufferCorrection(MIL_ID MilSrcContainer, MIL_ID MilDstContainer, MIL_ID MilResult) { auto MilSystem = MbufInquire(MilSrcContainer, M_OWNER_SYSTEM, M_NULL); MbufCopyComponent(MilSrcContainer, MilDstContainer, M_COMPONENT_ALL, M_REPLACE, M_DEFAULT); MosPrintf(MIL_TEXT(\"MbufConvert3d is used to correct the scan.\\n\\n\")); auto MilIllustrationDisp = MdispAlloc(MilSystem, M_DEFAULT, MIL_TEXT(\"M_DEFAULT\"), M_WINDOWED, M_UNIQUE_ID); MdispControl(MilIllustrationDisp, M_TITLE, MIL_TEXT(\"Scan corrections.\")); auto MilIllustrationImage = MbufRestore(CORR_ILLUSTRATION_FILE_PATH, MilSystem, M_UNIQUE_ID); MdispControl(MilIllustrationDisp, M_WINDOW_INITIAL_POSITION_Y, DISPLAY_3D_SIZE_Y); MdispSelect(MilIllustrationDisp, MilIllustrationImage); MosPrintf(MIL_TEXT(\"Press any key to correct the scan.\\n\\n\")); MosGetch(); MIL_DOUBLE ShearZ, ShearX, ScaleY; M3dmapGetResult(MilResult, M_DEFAULT, M_3D_SHEAR_Z, &amp;ShearZ); M3dmapGetResult(MilResult, M_DEFAULT, M_3D_SHEAR_X, &amp;ShearX); M3dmapGetResult(MilResult, M_DEFAULT, M_3D_SCALE_Y, &amp;ScaleY); auto RangeId = MbufInquireContainer(MilDstContainer, M_COMPONENT_RANGE, M_COMPONENT_ID, M_NULL); MbufControl(RangeId, M_3D_SHEAR_Z, ShearZ); MbufControl(RangeId, M_3D_SCALE_Y, ScaleY); MbufControl(RangeId, M_3D_SHEAR_X, ShearX); MbufConvert3d(MilDstContainer, MilDstContainer, M_NULL, M_DEFAULT, M_DEFAULT); } //**************************************************************************** // Disk alignment example. //**************************************************************************** bool DiskExample(MIL_ID MilSystem, MIL_ID MilDisplay3D, const MIL_UNIQUE_DISP_ID MilDisplayArray[NUM_DISPLAYS], const MIL_UNIQUE_BUF_ID MilDisplayImageArray[NUM_DISPLAYS]) { MosPrintf(MIL_TEXT(\"================================ Disk ===============================\\n\\n\")); if(!CheckForRequiredMILFile(DISK_SCAN_FILE_PATH)) { return false; } PrintScanningGuidelines(MilSystem, DISK_GUIDELINES, DISK_SCAN_ILLUSTRATION_FILE_PATH); // Allocate MIL objects. auto MilContext = M3dmapAlloc(MilSystem, M_ALIGN_CONTEXT, M_DEFAULT, M_UNIQUE_ID); auto MilResult = M3dmapAllocResult(MilSystem, M_ALIGN_RESULT, M_DEFAULT, M_UNIQUE_ID); auto MilContainer = MbufAllocContainer(MilSystem, M_PROC + M_DISP, M_DEFAULT, M_UNIQUE_ID); // Restore the 3D data. MosPrintf(MIL_TEXT(\"A scan of the calibration object is restored from file (.mbufc) and displayed.\\n\")); auto MilCalibrationContainer = MbufRestore(DISK_SCAN_FILE_PATH, MilSystem, M_UNIQUE_ID); // Convert to 3d processable container. MbufConvert3d(MilCalibrationContainer, MilCalibrationContainer, M_NULL, M_DEFAULT, M_DEFAULT); // Display the point cloud. DisplayContainer(MilCalibrationContainer, MilDisplay3D, M_TOP_TILTED, ZOOM_FACTOR_MID); MosPrintf(MIL_TEXT(\"The scan of the object is deformed and misaligned.\\n\\n\")); ShowDifferentViews(MilCalibrationContainer, MilDisplayArray, MilDisplayImageArray); MosPrintf(MIL_TEXT(\"Press any key to continue.\\n\\n\")); MosGetch(); MosPrintf(MIL_TEXT(\"Running M3dmapAlignScan...\\n\\n\")); // Set the controls based on the specifications of the calibration disk. M3dmapControl(MilContext, M_DEFAULT, M_OBJECT_SHAPE, M_DISK); M3dmapControl(MilContext, M_DEFAULT, M_DIAMETER, DISK_DIAMETER); M3dmapControl(MilContext, M_DEFAULT, M_HEIGHT, DISK_HEIGHT); M3dmapAlignScan(MilContext, MilCalibrationContainer, MilResult, M_DEFAULT); MIL_INT Status; M3dmapGetResult(MilResult, M_DEFAULT, M_STATUS + M_TYPE_MIL_INT, &amp;Status); if(Status != M_COMPLETE) { MosPrintf(MIL_TEXT(\"The alignment did not complete successfully.\\n\\n\")); return true; } PrintAlignmentCorrections(MilResult); ApplyShearBufferCorrection(MilCalibrationContainer, MilContainer, MilResult); DisplayContainer(MilContainer, MilDisplay3D, M_TOP_TILTED, ZOOM_FACTOR_MID); ShowDifferentViews(MilContainer, MilDisplayArray, MilDisplayImageArray); MosPrintf(MIL_TEXT(\"M3dmapAlignScan can also be used to fixture the scan.\\n\")); MosPrintf(MIL_TEXT(\"The origin of the Z-axis (Z = 0) will be set to the floor.\\n\\n\")); MosPrintf(MIL_TEXT(\"Press any key to continue.\\n\\n\")); MosGetch(); // Apply full transformation matrix. auto MilCorrectionMatrix = M3dgeoAlloc(MilSystem, M_TRANSFORMATION_MATRIX, M_DEFAULT, M_UNIQUE_ID); M3dmapCopyResult(MilResult, M_DEFAULT, MilCorrectionMatrix, M_TRANSFORMATION_MATRIX, M_DEFAULT); M3dimMatrixTransform(MilCalibrationContainer, MilContainer, MilCorrectionMatrix, M_DEFAULT); ShowDifferentViews(MilContainer, MilDisplayArray, MilDisplayImageArray); MosPrintf(MIL_TEXT(\"The origin of the Z-axis (Z = 0) will be set at the top of the disk.\\n\\n\")); MosPrintf(MIL_TEXT(\"Press any key to continue.\\n\\n\")); MosGetch(); MosPrintf(MIL_TEXT(\"Running M3dmapAlignScan...\\n\\n\")); M3dmapControl(MilContext, M_CONTEXT, M_ALIGN_Z_POSITION, M_OBJECT_TOP); M3dmapAlignScan(MilContext, MilCalibrationContainer, MilResult, M_DEFAULT); // Apply full transformation matrix. M3dmapCopyResult(MilResult, M_DEFAULT, MilCorrectionMatrix, M_TRANSFORMATION_MATRIX, M_DEFAULT); M3dimMatrixTransform(MilCalibrationContainer, MilContainer, MilCorrectionMatrix, M_DEFAULT); ShowDifferentViews(MilContainer, MilDisplayArray, MilDisplayImageArray); MosPrintf(MIL_TEXT(\"The origin of the X-axis (X = 0) will be set at the disk's center.\\n\\n\")); MosPrintf(MIL_TEXT(\"Press any key to continue.\\n\\n\")); MosGetch(); MosPrintf(MIL_TEXT(\"Running M3dmapAlignScan...\\n\\n\")); M3dmapControl(MilContext, M_CONTEXT, M_ALIGN_X_POSITION, M_OBJECT_CENTER); M3dmapAlignScan(MilContext, MilCalibrationContainer, MilResult, M_DEFAULT); // Apply full transformation matrix. M3dmapCopyResult(MilResult, M_DEFAULT, MilCorrectionMatrix, M_TRANSFORMATION_MATRIX, M_DEFAULT); M3dimMatrixTransform(MilCalibrationContainer, MilContainer, MilCorrectionMatrix, M_DEFAULT); ShowDifferentViews(MilContainer, MilDisplayArray, MilDisplayImageArray); MosPrintf(MIL_TEXT(\"The Z-axis direction will be set to point downwards.\\n\\n\")); MosPrintf(MIL_TEXT(\"Press any key to continue.\\n\\n\")); MosGetch(); MosPrintf(MIL_TEXT(\"Running M3dmapAlignScan...\\n\\n\")); M3dmapControl(MilContext, M_CONTEXT, M_ALIGN_Z_DIRECTION, M_Z_DOWN); M3dmapAlignScan(MilContext, MilCalibrationContainer, MilResult, M_DEFAULT); // Apply full transformation matrix. M3dmapCopyResult(MilResult, M_DEFAULT, MilCorrectionMatrix, M_TRANSFORMATION_MATRIX, M_DEFAULT); M3dimMatrixTransform(MilCalibrationContainer, MilContainer, MilCorrectionMatrix, M_DEFAULT); if(MilDisplay3D) { M3ddispSetView(MilDisplay3D, M_AUTO, M_TOP_TILTED, M_DEFAULT, M_DEFAULT, M_DEFAULT); M3ddispSetView(MilDisplay3D, M_ZOOM, ZOOM_FACTOR_HIGH, M_DEFAULT, M_DEFAULT, M_DEFAULT); // Set the display's rotation axis center. This will keep the // behaviour of auto rotate consistent as we move its interest point. M3ddispCopy(M_VIEW_INTEREST_POINT, MilDisplay3D, M_ROTATION_AXIS_CENTER, M_DEFAULT); } ShowDifferentViews(MilContainer, MilDisplayArray, MilDisplayImageArray); MosPrintf(MIL_TEXT(\"The Z-axis direction is pointing downwards.\\n\\n\")); MosPrintf(MIL_TEXT(\"Press any key to continue.\\n\\n\")); MosGetch(); MdispSelect(MilDisplayArray[(MIL_INT)EViews::eBottom], M_NULL); MdispSelect(MilDisplayArray[(MIL_INT)EViews::eSide], M_NULL); M3ddispSelect(MilDisplay3D, M_NULL, M_CLOSE, M_DEFAULT); if(MilDisplay3D) { M3ddispSelect(MilDisplay3D, M_NULL, M_CLOSE, M_DEFAULT); } MosPrintf(MIL_TEXT(\"=====================================================================\\n\\n\")); return true; } //**************************************************************************** // Pyramid alignment example. //**************************************************************************** bool PyramidExample(MIL_ID MilSystem, MIL_ID MilDisplay3D, const MIL_UNIQUE_DISP_ID MilDisplayArray[NUM_DISPLAYS], const MIL_UNIQUE_BUF_ID MilDisplayImageArray[NUM_DISPLAYS]) { MosPrintf(MIL_TEXT(\"============================== Pyramid ==============================\\n\\n\")); if(!CheckForRequiredMILFile(PYRAMID_SCAN_FILE_PATH)) { return false; } PrintScanningGuidelines(MilSystem, PYRAMID_GUIDELINES, PYRAMID_SCAN_ILLUSTRATION_FILE_PATH); // Allocate MIL objects. auto MilContext = M3dmapAlloc(MilSystem, M_ALIGN_CONTEXT, M_DEFAULT, M_UNIQUE_ID); auto MilResult = M3dmapAllocResult(MilSystem, M_ALIGN_RESULT, M_DEFAULT, M_UNIQUE_ID); auto MilContainer = MbufAllocContainer(MilSystem, M_PROC + M_DISP, M_DEFAULT, M_UNIQUE_ID); // Restore the 3D data. MosPrintf(MIL_TEXT(\"A scan of the calibration object is restored from file (.mbufc) and displayed.\\n\")); auto MilCalibrationContainer = MbufRestore(PYRAMID_SCAN_FILE_PATH, MilSystem, M_UNIQUE_ID); // Convert to 3d processable container. MbufConvert3d(MilCalibrationContainer, MilCalibrationContainer, M_NULL, M_DEFAULT, M_DEFAULT); // Display the point clouds. DisplayContainer(MilCalibrationContainer, MilDisplay3D, M_BOTTOM_TILTED, ZOOM_FACTOR_HIGH); auto GraList3D = (MIL_ID)M3ddispInquire(MilDisplay3D, M_3D_GRAPHIC_LIST_ID, M_NULL); MosPrintf(MIL_TEXT(\"The scan of the object is deformed and misaligned.\\n\\n\")); ShowDifferentViews(MilCalibrationContainer, MilDisplayArray, MilDisplayImageArray); MosPrintf(MIL_TEXT(\"Press any key to continue.\\n\\n\")); MosGetch(); MosPrintf(MIL_TEXT(\"Running M3dmapAlignScan...\\n\\n\")); // Set the controls based on the specifications of the calibration pyramid. M3dmapControl(MilContext, M_DEFAULT, M_OBJECT_SHAPE, M_PYRAMID); M3dmapControl(MilContext, M_DEFAULT, M_HEIGHT, PYRAMID_HEIGHT); M3dmapControl(MilContext, M_DEFAULT, M_PYRAMID_BOTTOM_BASE_LENGTH, PYRAMID_BOTTOM_BASE_LENGTH); M3dmapControl(MilContext, M_DEFAULT, M_PYRAMID_TOP_BASE_LENGTH, PYRAMID_TOP_BASE_LENGTH); M3dmapControl(MilContext, M_DEFAULT, M_ALIGN_Y_POSITION, M_OBJECT_CENTER); M3dmapControl(MilContext, M_DEFAULT, M_ALIGN_X_POSITION, M_OBJECT_CENTER); M3dmapControl(MilContext, M_DEFAULT, M_ALIGN_Z_POSITION, M_OBJECT_BOTTOM); M3dmapAlignScan(MilContext, MilCalibrationContainer, MilResult, M_DEFAULT); MIL_INT Status; M3dmapGetResult(MilResult, M_DEFAULT, M_STATUS + M_TYPE_MIL_INT, &amp;Status); if(Status != M_COMPLETE) { MosPrintf(MIL_TEXT(\"The alignment did not complete successfully.\\n\\n\")); return true; } std::vector&lt;MIL_DOUBLE&gt; CornersX, CornersY, CornersZ; M3dmapGetResult(MilResult, M_DEFAULT, M_PYRAMID_CORNERS_X, CornersX); M3dmapGetResult(MilResult, M_DEFAULT, M_PYRAMID_CORNERS_Y, CornersY); M3dmapGetResult(MilResult, M_DEFAULT, M_PYRAMID_CORNERS_Z, CornersZ); auto SrcPtsLabel = M3dgraDots(GraList3D, M_DEFAULT, M_DEFAULT, CornersX, CornersY, CornersZ, M_NULL, M_NULL, M_NULL, M_DEFAULT); M3dgraControl(GraList3D, SrcPtsLabel, M_COLOR, M_COLOR_MAGENTA); M3dgraControl(GraList3D, SrcPtsLabel, M_THICKNESS, POINT_THICKNESS); MosPrintf(MIL_TEXT(\"The corners of the pyramid (used for the alignment) are displayed in magenta.\\n\\n\")); MosPrintf(MIL_TEXT(\"Press any key to continue.\\n\\n\")); MosGetch(); M3dgraRemove(GraList3D, SrcPtsLabel, M_DEFAULT); PrintAlignmentCorrections(MilResult); MosPrintf(MIL_TEXT(\"M3dimMatrixTransform is used to correct the scan.\\n\\n\")); auto MilCorrectionMatrix = M3dgeoAlloc(MilSystem, M_TRANSFORMATION_MATRIX, M_DEFAULT, M_UNIQUE_ID); M3dmapCopyResult(MilResult, M_DEFAULT, MilCorrectionMatrix, M_SHEAR_MATRIX, M_DEFAULT); M3dimMatrixTransform(MilCalibrationContainer, MilContainer, MilCorrectionMatrix, M_DEFAULT); DisplayContainer(MilContainer, MilDisplay3D, M_BOTTOM_TILTED, ZOOM_FACTOR_LOW); ShowDifferentViews(MilContainer, MilDisplayArray, MilDisplayImageArray); MIL_DOUBLE RMSError; M3dmapGetResult(MilResult, M_DEFAULT, M_RMS_ERROR, &amp;RMSError); MosPrintf(MIL_TEXT(\"The RMS error of the alignment is %.3f mm.\\n\\n\"), RMSError); MosPrintf(MIL_TEXT(\"Press any key to continue.\\n\\n\")); MosGetch(); MosPrintf(MIL_TEXT(\"M3dmapAlignScan can also be used to fixture the scan.\\n\")); MosPrintf(MIL_TEXT(\"The origin of the Z-axis (Z = 0) will be set to the bottom of the pyramid.\\n\")); MosPrintf(MIL_TEXT(\"The origin of the X- and Y-axes (X = 0, Y = 0) \")); MosPrintf(MIL_TEXT(\"will be set to the center of the pyramid.\\n\\n\")); MosPrintf(MIL_TEXT(\"Press any key to continue.\\n\\n\")); MosGetch(); // Apply full transformation matrix. M3dmapCopyResult(MilResult, M_DEFAULT, MilCorrectionMatrix, M_TRANSFORMATION_MATRIX, M_DEFAULT); M3dimMatrixTransform(MilCalibrationContainer, MilContainer, MilCorrectionMatrix, M_DEFAULT); M3ddispSetView(MilDisplay3D, M_ZOOM, ZOOM_FACTOR_LOW, M_DEFAULT, M_DEFAULT, M_DEFAULT); ShowDifferentViews(MilContainer, MilDisplayArray, MilDisplayImageArray); MosPrintf(MIL_TEXT(\"The Z-axis direction of the scan will be pointing upwards,\\n\")); MosPrintf(MIL_TEXT(\"while the rotation around the Z-axis will not be applied.\\n\\n\")); MosPrintf(MIL_TEXT(\"Press any key to continue.\\n\\n\")); MosGetch(); MosPrintf(MIL_TEXT(\"Running M3dmapAlignScan...\\n\\n\")); M3dmapControl(MilContext, M_DEFAULT, M_ALIGN_Z_DIRECTION, M_Z_UP); M3dmapAlignScan(MilContext, MilCalibrationContainer, MilResult, M_DEFAULT); // Apply full transformation matrix, except for rotation around Z-axis. M3dmapCopyResult(MilResult, M_DEFAULT, MilCorrectionMatrix, M_XY_TRANSFORMATION_MATRIX, M_DEFAULT); M3dimMatrixTransform(MilCalibrationContainer, MilContainer, MilCorrectionMatrix, M_DEFAULT); M3ddispSetView(MilDisplay3D, M_AUTO, M_TOP_TILTED, M_DEFAULT, M_DEFAULT, M_DEFAULT); M3ddispSetView(MilDisplay3D, M_ZOOM, 2, M_DEFAULT, M_DEFAULT, M_DEFAULT); // Set the display's rotation axis center. This will keep the // behaviour of auto rotate consistent as we move its interest point. M3ddispCopy(M_VIEW_INTEREST_POINT, MilDisplay3D, M_ROTATION_AXIS_CENTER, M_DEFAULT); ShowDifferentViews(MilContainer, MilDisplayArray, MilDisplayImageArray); MosPrintf(MIL_TEXT(\"The Z-axis direction is pointing upwards.\\n\\n\")); MosPrintf(MIL_TEXT(\"Press any key to continue.\\n\\n\")); MosGetch(); MdispSelect(MilDisplayArray[(MIL_INT)EViews::eBottom], M_NULL); MdispSelect(MilDisplayArray[(MIL_INT)EViews::eSide], M_NULL); if(MilDisplay3D) { M3ddispSelect(MilDisplay3D, M_NULL, M_CLOSE, M_DEFAULT); } MosPrintf(MIL_TEXT(\"=====================================================================\\n\\n\")); return true; } //***************************************************************************** // Main. //***************************************************************************** int MosMain() { PrintHeader(); auto MilApplication = MappAlloc(M_NULL, M_DEFAULT, M_UNIQUE_ID); auto MilSystem = MsysAlloc(M_DEFAULT, M_SYSTEM_HOST, M_DEFAULT, M_DEFAULT, M_UNIQUE_ID); MIL_UNIQUE_BUF_ID MilDisplayImageArray[NUM_DISPLAYS]; // Image buffers used for 2D display. MIL_UNIQUE_DISP_ID MilDisplayArray[NUM_DISPLAYS]; // 2D Mil Display of the scanned object. MIL_UNIQUE_GRA_ID MilGraListArray[NUM_DISPLAYS]; // 2D Graphic lists. // Prepare the 3D display. auto MilDisplay3D = Alloc3dDisplayId(MilSystem); if(MilDisplay3D) { auto GraList3D = (MIL_ID)M3ddispInquire(MilDisplay3D, M_3D_GRAPHIC_LIST_ID, M_NULL); M3dgraControl(GraList3D, M_DEFAULT_SETTINGS, M_FONT_SIZE, FONT_SIZE); M3ddispControl(MilDisplay3D, M_SIZE_X, DISPLAY_3D_SIZE_X); M3ddispControl(MilDisplay3D, M_SIZE_Y, DISPLAY_3D_SIZE_Y); M3ddispControl(MilDisplay3D, M_TITLE, MIL_TEXT(\"Tilted 3D View\")); M3ddispControl(MilDisplay3D, M_BACKGROUND_COLOR, M_COLOR_BLACK); M3ddispControl(MilDisplay3D, M_BACKGROUND_COLOR_GRADIENT, M_COLOR_BLACK); } auto MilLut = MbufAllocColor(MilSystem, 3, 255 + 1, 1, 8 + M_UNSIGNED, M_LUT, M_UNIQUE_ID); MgenLutFunction(MilLut, M_COLORMAP_TURBO + M_LAST_GRAY, M_DEFAULT, M_RGB888(250, 250, 250), M_DEFAULT, M_DEFAULT, M_DEFAULT, M_DEFAULT); // Prepare the 2D displays. for(MIL_INT i = 0; i &lt; NUM_DISPLAYS; ++i) { MilDisplayImageArray[i] = MbufAlloc2d(MilSystem, DISPLAY_2D_SIZE_X, DISPLAY_2D_SIZE_Y, M_UNSIGNED + 8, M_IMAGE | M_PROC | M_DISP, M_UNIQUE_ID); MilDisplayArray[i] = MdispAlloc(MilSystem, M_DEFAULT, MIL_TEXT(\"M_DEFAULT\"), M_DEFAULT, M_UNIQUE_ID); MilGraListArray[i] = MgraAllocList(MilSystem, M_DEFAULT, M_UNIQUE_ID); MdispLut(MilDisplayArray[i], MilLut); MdispControl(MilDisplayArray[i], M_ASSOCIATED_GRAPHIC_LIST_ID, MilGraListArray[i]); } MdispControl(MilDisplayArray[(MIL_INT)EViews::eBottom], M_WINDOW_INITIAL_POSITION_X, DISPLAY_3D_SIZE_X); MdispControl(MilDisplayArray[(MIL_INT)EViews::eBottom], M_TITLE, MIL_TEXT(\"Bottom 2D View (XY)\")); MdispControl(MilDisplayArray[(MIL_INT)EViews::eSide], M_WINDOW_INITIAL_POSITION_X, DISPLAY_3D_SIZE_X + DISPLAY_2D_SIZE_X); MdispControl(MilDisplayArray[(MIL_INT)EViews::eSide], M_TITLE, MIL_TEXT(\"Side 2D View (XZ)\")); // Run the examples. MIL_INT KeyOption = 0; while(!(KeyOption == 1 || KeyOption == 2 || KeyOption == 3)) { MosPrintf(MIL_TEXT(\"Press '1' for the alignment example using a disk calibration object, \\n\") MIL_TEXT(\"'2' a pyramid calibration object, and '3' for both.\\n\\n\")); KeyOption = MosGetch() - '0'; } switch(KeyOption) { case 1: { if(!DiskExample(MilSystem, MilDisplay3D, MilDisplayArray, MilDisplayImageArray)) return EXIT_FAILURE; } break; case 2: { if(!PyramidExample(MilSystem, MilDisplay3D, MilDisplayArray, MilDisplayImageArray)) return EXIT_FAILURE; } break; default: { if(!DiskExample(MilSystem, MilDisplay3D, MilDisplayArray, MilDisplayImageArray)) return EXIT_FAILURE; if(!PyramidExample(MilSystem, MilDisplay3D, MilDisplayArray, MilDisplayImageArray)) return EXIT_FAILURE; } break; } MosPrintf(MIL_TEXT(\"Press any key to end.\\n\\n\")); MosGetch(); } ",
      "wordCount": 2734
    }
  ]
}]
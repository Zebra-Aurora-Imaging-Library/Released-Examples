[{
  "id": "Example_PlaceHolder_ID",
  "version": "2024020714",
  "title": "Example_PlaceHolder_Title",
  "wordCount": 0,
  "subEntries": [
    {
      "id": "Examples_Processing_Classification_PredictEngineSelection_CPP_predictengineselection_cpp",
      "version": "2024020714",
      "title": "predictengineselection.cpp",
      "location": "Sample Code from MIL Examples",
      "text": " Top //************************************************************************************* // // File name: PredictEngineSelection.cpp // Location: See Matrox Example Launcher in the MIL Control Center // // // Synopsis: This program goes through all available predict engines on the // current machine to compare their performance. // // Copyright (C) Matrox Electronic Systems Ltd., 1992-2024. // All Rights Reserved #include \"mil.h\" #include &lt;vector&gt; #include &lt;fstream&gt; #include &lt;iterator&gt; #include &lt;set&gt; #include &lt;algorithm&gt; #include &lt;iostream&gt; // =========================================================================== // Example description. // =========================================================================== void PrintHeader() { MosPrintf(MIL_TEXT(\"[EXAMPLE NAME]\\n\") MIL_TEXT(\"PredictEngineSelection\\n\\n\") MIL_TEXT(\"[SYNOPSIS]\\n\") MIL_TEXT(\"This example will compare the benches of all available predict engines on \\nthe machine.\\n\") MIL_TEXT(\"[MODULES USED]\\n\") MIL_TEXT(\"Modules used: application, system, buffer, classification.\\n\\n\")); } #define CLASSIFIER_FOLDER M_IMAGE_PATH MIL_TEXT(\"Classification/PredictEngineSelection/\") MIL_STRING NETWORK = MIL_TEXT(\"ICNET\"); MIL_INT NUMBER_OF_BANDS = 3; MIL_INT SIZE_X = 640; MIL_INT SIZE_Y = 480; MIL_INT NUMBER_OF_PREDICTIONS = 100; MIL_INT TYPE = 8 + M_UNSIGNED; const MIL_STRING ICNET_S = MIL_TEXT(\"ICNET_S\"); const MIL_STRING ICNET_M = MIL_TEXT(\"ICNET_M\"); const MIL_STRING ICNET_XL = MIL_TEXT(\"ICNET_XL\"); const MIL_STRING CSNET_S = MIL_TEXT(\"CSNET_S\"); const MIL_STRING CSNET_M = MIL_TEXT(\"CSNET_M\"); const MIL_STRING CSNET_XL = MIL_TEXT(\"CSNET_XL\"); const MIL_STRING ODNET = MIL_TEXT(\"ODNET\"); const MIL_STRING ADNET = MIL_TEXT(\"ADNET\"); const MIL_STRING USER_ONNX = MIL_TEXT(\"USER_ONNX\"); void EvaluatePredictEngines(MIL_ID MilApplication, MIL_ID Classifier, MIL_ID PredictResult, MIL_ID TestBuffer); MIL_UNIQUE_CLASS_ID SelectClassifierAndImageSize(MIL_ID MilSystem); MIL_UNIQUE_CLASS_ID GetUserClassifier(MIL_ID MilSystem); MIL_INT GetResultType(MIL_ID Classifier); // **************************************************************************** // Main. // **************************************************************************** int MosMain() { PrintHeader(); MIL_UNIQUE_APP_ID MilApplication = MappAlloc(M_NULL, M_DEFAULT, M_UNIQUE_ID); MIL_UNIQUE_SYS_ID MilSystem = MsysAlloc(M_DEFAULT, M_SYSTEM_HOST, M_DEFAULT, M_DEFAULT, M_UNIQUE_ID); MosPrintf(MIL_TEXT(\"Press any key to continue.\\n\\n\")); MosGetch(); MIL_UNIQUE_CLASS_ID Classifier = SelectClassifierAndImageSize(MilSystem); if(!Classifier) { MosPrintf(MIL_TEXT(\"Press any key to end.\\n\")); MosGetch(); return EXIT_FAILURE; } const MIL_INT ResultType = GetResultType(Classifier); if(ResultType == M_NULL) { MosPrintf(MIL_TEXT(\"Press any key to end.\\n\")); MosGetch(); return EXIT_FAILURE; } MIL_UNIQUE_CLASS_ID PredictResult = MclassAllocResult(MilSystem, ResultType, M_DEFAULT, M_UNIQUE_ID); MIL_UNIQUE_BUF_ID TestBuffer = MbufAllocColor(MilSystem, NUMBER_OF_BANDS, SIZE_X, SIZE_Y, TYPE, M_IMAGE + M_PROC, M_UNIQUE_ID); MosPrintf(MIL_TEXT(\"Beginning predict engine benchmarking...\\n\")); EvaluatePredictEngines(MilApplication, Classifier, PredictResult, TestBuffer); return 0; } MIL_INT GetResultType(MIL_ID Classifier) { MIL_INT ClassifierPredefinedType = M_NULL; MclassInquire(Classifier, M_DEFAULT, M_CLASSIFIER_PREDEFINED_TYPE + M_TYPE_MIL_INT, &amp;ClassifierPredefinedType); MIL_INT ResultType = M_NULL; switch(ClassifierPredefinedType) { case M_ADNET: ResultType = M_PREDICT_ANO_RESULT; break; case M_CSNET_COLOR_XL: case M_CSNET_M: case M_CSNET_MONO_XL: case M_CSNET_S: case M_CSNET_XL: ResultType = M_PREDICT_SEG_RESULT; break; case M_ICNET_COLOR_XL: case M_ICNET_M: case M_ICNET_MONO_XL: case M_ICNET_S: case M_ICNET_XL: ResultType = M_PREDICT_CNN_RESULT; break; case M_ODNET: ResultType = M_PREDICT_DET_RESULT; break; case M_USER_ONNX: ResultType = M_PREDICT_ONNX_RESULT; break; default: case M_FCNET_COLOR_XL: case M_FCNET_M: case M_FCNET_MONO_XL: case M_FCNET_S: case M_FCNET_XL: case M_CUSTOM: case M_UNDEFINED: MosPrintf(MIL_TEXT(\"Unsupported classifier type!.\\n\")); break; } return ResultType; } void SetNetworkType(MIL_ID Classifier) { MIL_INT ClassifierPredefinedType = M_NULL; MclassInquire(Classifier, M_DEFAULT, M_CLASSIFIER_PREDEFINED_TYPE + M_TYPE_MIL_INT, &amp;ClassifierPredefinedType); switch(ClassifierPredefinedType) { case M_ADNET: NETWORK = ADNET; break; case M_CSNET_MONO_XL: case M_CSNET_COLOR_XL: case M_CSNET_XL: NETWORK = CSNET_XL; break; case M_CSNET_M: NETWORK = CSNET_M; break; case M_CSNET_S: NETWORK = CSNET_S; break; case M_ICNET_COLOR_XL: case M_ICNET_MONO_XL: case M_ICNET_XL: NETWORK = ICNET_XL; break; case M_ICNET_M: NETWORK = ICNET_M; break; case M_ICNET_S: NETWORK = ICNET_S; break; case M_ODNET: NETWORK = ODNET; break; case M_USER_ONNX: NETWORK = USER_ONNX; break; default: case M_FCNET_COLOR_XL: case M_FCNET_MONO_XL: case M_FCNET_XL: case M_FCNET_M: case M_FCNET_S: case M_CUSTOM: case M_UNDEFINED: MosPrintf(MIL_TEXT(\"Unsupported classifier type!.\\n\")); break; } } MIL_UNIQUE_CLASS_ID GetUserClassifier(MIL_ID MilSystem) { MosPrintf(MIL_TEXT(\"Please enter a path to a valid trained classifier:\\n\")); MIL_STRING Path; #if M_MIL_UNICODE_API std::getline(std::wcin, Path); #else std::getline(std::cin, Path); #endif // If path is surrounded by quotations, remove them if(!Path.empty() &amp;&amp; Path.front() == MIL_TEXT_CHAR('\\\"') &amp;&amp; Path.back() == MIL_TEXT_CHAR('\\\"')) { Path = Path.substr(1, Path.size() - 2); } MIL_UNIQUE_CLASS_ID Classifier; if(Path.find(MIL_TEXT(\".mclass\")) != MIL_STRING::npos) { Classifier = MclassRestore(Path, MilSystem, M_DEFAULT, M_UNIQUE_ID); MIL_INT ClassifierStatusSupported = M_NULL; MclassInquire(Classifier, M_DEFAULT, M_CLASSIFIER_STATUS + M_TYPE_MIL_INT + M_SUPPORTED, &amp;ClassifierStatusSupported); if(ClassifierStatusSupported == M_FALSE) { MosPrintf(MIL_TEXT(\"\\n!!!Context was not a classifer!!!\\n\\n\")); Classifier.reset(M_NULL); return Classifier; } MIL_INT ClassifierStatus = M_NULL; MclassInquire(Classifier, M_DEFAULT, M_CLASSIFIER_STATUS + M_TYPE_MIL_INT, &amp;ClassifierStatus); if(ClassifierStatus != M_USER_TRAINED) { MosPrintf(MIL_TEXT(\"\\n!!!User classifier must be trained!!!\\n\\n\")); Classifier.reset(M_NULL); return Classifier; } } else if(Path.find(MIL_TEXT(\".onnx\")) != MIL_STRING::npos) { Classifier = MclassAlloc(MilSystem, M_CLASSIFIER_ONNX, M_DEFAULT, M_UNIQUE_ID); MclassImport(Path, M_ONNX_FILE, Classifier, M_DEFAULT, M_DEFAULT, M_DEFAULT); MIL_INT ClassifierStatus = M_NULL; MclassInquire(Classifier, M_DEFAULT, M_CLASSIFIER_STATUS + M_TYPE_MIL_INT, &amp;ClassifierStatus); if(ClassifierStatus != M_IMPORTED_ONNX) { MosPrintf(MIL_TEXT(\"\\n!!!Invalid ONNX Model!!!\\n\\n\")); Classifier.reset(M_NULL); return Classifier; } } else { MosPrintf(MIL_TEXT(\"Unsupported file extension!\\n\")); MosPrintf(MIL_TEXT(\"Please provide a trained MIL classifier with the extension .mclass\\n\")); MosPrintf(MIL_TEXT(\"Or, provide a trained ONNX classifier with the extension .onnx!\\n\")); return Classifier; } SetNetworkType(Classifier); MclassInquire(Classifier, M_DEFAULT_SOURCE_LAYER, M_TYPE + M_TYPE_MIL_INT, &amp;TYPE); MclassInquire(Classifier, M_DEFAULT_SOURCE_LAYER, M_SIZE_BAND + M_TYPE_MIL_INT, &amp;NUMBER_OF_BANDS); MclassInquire(Classifier, M_DEFAULT_SOURCE_LAYER, M_SIZE_X + M_TYPE_MIL_INT, &amp;SIZE_X); MclassInquire(Classifier, M_DEFAULT_SOURCE_LAYER, M_SIZE_Y + M_TYPE_MIL_INT, &amp;SIZE_Y); NUMBER_OF_PREDICTIONS = 15; return Classifier; } MIL_UNIQUE_CLASS_ID SelectClassifierAndImageSize(MIL_ID MilSystem) { MosPrintf(MIL_TEXT(\"Please select a desired network architecture.\\n\")); MosPrintf(MIL_TEXT(\"1) M_ICNET_S\\n\")); MosPrintf(MIL_TEXT(\"2) M_ICNET_M (default)\\n\")); MosPrintf(MIL_TEXT(\"3) M_ICNET_XL\\n\")); MosPrintf(MIL_TEXT(\"4) M_CSNET_S\\n\")); MosPrintf(MIL_TEXT(\"5) M_CSNET_M\\n\")); MosPrintf(MIL_TEXT(\"6) M_CSNET_XL\\n\")); MosPrintf(MIL_TEXT(\"7) M_ODNET\\n\")); MosPrintf(MIL_TEXT(\"8) M_ADNET\\n\")); MosPrintf(MIL_TEXT(\"9) User trained MIL or ONNX classifier\\n\")); MosPrintf(MIL_TEXT(\"Press any key to continue with the default.\\n\\n\")); MIL_INT NbSizesAvailable {}; char KeyVal = (char)MosGetch(); switch(KeyVal) { default: case '2': NbSizesAvailable = 4; NETWORK = ICNET_M; break; case '1': NbSizesAvailable = 4; NETWORK = ICNET_S; break; case '3': NbSizesAvailable = 2; NETWORK = ICNET_XL; break; case '4': NbSizesAvailable = 6; NETWORK = CSNET_S; break; case '5': NbSizesAvailable = 6; NETWORK = CSNET_M; break; case '6': NbSizesAvailable = 6; NETWORK = CSNET_XL; break; case '7': NbSizesAvailable = 4; NETWORK = ODNET; break; case '8': NbSizesAvailable = 2; NETWORK = ADNET; break; case '9': return GetUserClassifier(MilSystem); break; } MosPrintf(MIL_TEXT(\"M_%s selected.\\n\\n\"), NETWORK.c_str()); MosPrintf(MIL_TEXT(\"Please select a desired target image number of bands.\\n\")); MosPrintf(MIL_TEXT(\"1) 1 Band\\n\")); MosPrintf(MIL_TEXT(\"2) 3 Bands (default)\\n\\n\")); MosPrintf(MIL_TEXT(\"Press any key to continue with the default.\\n\\n\")); KeyVal = (char)MosGetch(); if(KeyVal == '1') { NUMBER_OF_BANDS = 1; } MosPrintf(MIL_TEXT(\"%d band selected.\\n\\n\"), NUMBER_OF_BANDS); MosPrintf(MIL_TEXT(\"Please select a desired target image size.\\n\")); MosPrintf(MIL_TEXT(\"1) 128x96 (MMS Small)\\n\")); MosPrintf(MIL_TEXT(\"2) 640x480 (SD) (default)\\n\")); if(NbSizesAvailable &gt; 2) { MosPrintf(MIL_TEXT(\"3) 1920x1080 (HD)\\n\")); } if(NbSizesAvailable &gt; 3) { MosPrintf(MIL_TEXT(\"4) 3840x2160 (4K)\\n\")); } if(NbSizesAvailable &gt; 4) { MosPrintf(MIL_TEXT(\"5) 7680x4320 (8K)\\n\")); } if(NbSizesAvailable &gt; 5) { MosPrintf(MIL_TEXT(\"6) Custom\\n\")); } MosPrintf(MIL_TEXT(\"\\nPress any key to continue with the default.\\n\\n\")); KeyVal = (char)MosGetch(); if(KeyVal == '1') { SIZE_X = 128; SIZE_Y = 96; NUMBER_OF_PREDICTIONS = 1000; } else if(KeyVal == '3' &amp;&amp; NbSizesAvailable &gt; 2) { SIZE_X = 1920; SIZE_Y = 1080; NUMBER_OF_PREDICTIONS = 35; } else if(KeyVal == '4' &amp;&amp; NbSizesAvailable &gt; 3) { SIZE_X = 3840; SIZE_Y = 2160; NUMBER_OF_PREDICTIONS = 15; } else if(KeyVal == '5' &amp;&amp; NbSizesAvailable &gt; 4) { SIZE_X = 7680; SIZE_Y = 4320; NUMBER_OF_PREDICTIONS = 5; } else if(KeyVal == '6' &amp;&amp; NbSizesAvailable &gt; 5) { MosPrintf(MIL_TEXT(\"Please enter your desired size x:\\n\")); MOs_scanf_s(MIL_TEXT(\"%d\"), (int*)&amp;SIZE_X); MosPrintf(MIL_TEXT(\"Please enter your desired size y:\\n\")); MOs_scanf_s(MIL_TEXT(\"%d\"), (int*)&amp;SIZE_Y); NUMBER_OF_PREDICTIONS = 100; } MosPrintf(MIL_TEXT(\"%dx%d image size selected.\\n\\n\"), SIZE_X, SIZE_Y); MIL_STRING FullClassifierPath; if(NETWORK.find(MIL_TEXT(\"CSNET\")) != MIL_STRING::npos) { FullClassifierPath = CLASSIFIER_FOLDER + NETWORK + MIL_TEXT(\"_\") + M_TO_STRING(NUMBER_OF_BANDS) + MIL_TEXT(\"BAND\") + MIL_TEXT(\".mclass\"); } else { FullClassifierPath = CLASSIFIER_FOLDER + NETWORK + MIL_TEXT(\"_\") + M_TO_STRING(NUMBER_OF_BANDS) + MIL_TEXT(\"x\") + M_TO_STRING(SIZE_X) + MIL_TEXT(\"x\") + M_TO_STRING(SIZE_Y) + MIL_TEXT(\".mclass\"); } return MclassRestore(FullClassifierPath, MilSystem, M_DEFAULT, M_UNIQUE_ID); } void GetPredictEngineInfo(MIL_ID Classifier, MIL_INT PredictEngineIndex, MIL_STRING* pProviderString, MIL_STRING* pDescription, MIL_STRING* pPrecisionString) { MIL_INT Provider = 0; MIL_INT Precision = 0; MclassInquire(Classifier, M_PREDICT_ENGINE_INDEX(PredictEngineIndex), M_PREDICT_ENGINE_PROVIDER + M_TYPE_MIL_INT, &amp;Provider); MclassInquire(Classifier, M_PREDICT_ENGINE_INDEX(PredictEngineIndex), M_PREDICT_ENGINE_DESCRIPTION, *pDescription); MclassInquire(Classifier, M_PREDICT_ENGINE_INDEX(PredictEngineIndex), M_PREDICT_ENGINE_PRECISION + M_TYPE_MIL_INT, &amp;Precision); switch(Provider) { default: case M_DEFAULT_CPU: *pProviderString = MIL_TEXT(\"DefaultCPU\"); break; case M_OPENVINO: *pProviderString = MIL_TEXT(\"OpenVINO\"); break; case M_CUDA: *pProviderString = MIL_TEXT(\"CUDA\"); break; } switch(Precision) { default: case M_FP32: *pPrecisionString = MIL_TEXT(\"FP32\"); break; case M_FP16: *pPrecisionString = MIL_TEXT(\"FP16\"); break; } } struct SPredictEngine { SPredictEngine(MIL_INT PredictEngineIndex, MIL_STRING ProviderString, MIL_STRING Description, MIL_STRING PrecisionString, MIL_INT NbCores, MIL_DOUBLE AveragePredictTime): m_PredictEngineIndex(PredictEngineIndex), m_ProviderString(ProviderString), m_Description(Description), m_PrecisionString(PrecisionString), m_NbCores(NbCores), m_AveragePredictTime(AveragePredictTime) {}; void PrintInfo() const; MIL_INT m_PredictEngineIndex {}; MIL_STRING m_ProviderString {}; MIL_STRING m_Description {}; MIL_STRING m_PrecisionString {}; MIL_INT m_NbCores {}; MIL_DOUBLE m_AveragePredictTime {}; }; void SPredictEngine::PrintInfo() const { MosPrintf(MIL_TEXT(\"%3d|\"), m_PredictEngineIndex); MosPrintf(MIL_TEXT(\"%10.10s|\"), m_ProviderString.c_str()); MosPrintf(MIL_TEXT(\"%42.42s|\"), m_Description.c_str()); MosPrintf(MIL_TEXT(\"%4.4s|\"), m_PrecisionString.c_str()); MosPrintf(MIL_TEXT(\"%5d|\"), m_NbCores); if(m_AveragePredictTime != -1.0) { MosPrintf(MIL_TEXT(\"%9.3f\"), m_AveragePredictTime); } MosPrintf(MIL_TEXT(\"\\n\")); } std::set&lt;MIL_INT&gt; GetNbCoreSet(bool IncludeLowCores) { std::set&lt;MIL_INT&gt; CoreSet {}; MthrControlMp(M_DEFAULT, M_CORE_SHARING, M_DEFAULT, M_ENABLE, M_NULL); MIL_INT NbCoresAvailable = 0; MthrInquireMp(M_DEFAULT, M_CORE_NUM_EFFECTIVE, M_DEFAULT, M_DEFAULT, &amp;NbCoresAvailable); CoreSet.insert(NbCoresAvailable); MthrControlMp(M_DEFAULT, M_CORE_SHARING, M_DEFAULT, M_DISABLE, M_NULL); MthrInquireMp(M_DEFAULT, M_CORE_NUM_EFFECTIVE, M_DEFAULT, M_DEFAULT, &amp;NbCoresAvailable); CoreSet.insert(NbCoresAvailable); if(NbCoresAvailable &gt; 1) { CoreSet.insert(NbCoresAvailable - 1); } int TestCores = 1; while(IncludeLowCores &amp;&amp; TestCores &lt; NbCoresAvailable) { CoreSet.insert(TestCores); TestCores = TestCores &lt;&lt; 1; } MthrControlMp(M_DEFAULT, M_CORE_SHARING, M_DEFAULT, M_ENABLE, M_NULL); return CoreSet; } template&lt;typename Cmp&gt; bool CompAveragePredictTime(const SPredictEngine&amp; Engine1, const SPredictEngine&amp; Engine2) { return Cmp()(Engine1.m_AveragePredictTime, Engine2.m_AveragePredictTime); } template&lt;typename Cmp&gt; bool CompIndex(const SPredictEngine&amp; Engine1, const SPredictEngine&amp; Engine2) { if(Engine1.m_PredictEngineIndex != Engine2.m_PredictEngineIndex) { return Cmp()(Engine1.m_PredictEngineIndex, Engine2.m_PredictEngineIndex); } return CompAveragePredictTime&lt;std::less&lt;MIL_DOUBLE&gt;&gt;(Engine1, Engine2); } template&lt;typename Cmp&gt; bool CompProvider(const SPredictEngine&amp; Engine1, const SPredictEngine&amp; Engine2) { if(Engine1.m_ProviderString != Engine2.m_ProviderString) { return Cmp()(Engine1.m_ProviderString, Engine2.m_ProviderString); } return CompAveragePredictTime&lt;std::less&lt;MIL_DOUBLE&gt;&gt;(Engine1, Engine2); } template&lt;typename Cmp&gt; bool CompDescription(const SPredictEngine&amp; Engine1, const SPredictEngine&amp; Engine2) { if(Engine1.m_Description != Engine2.m_Description) { return Cmp()(Engine1.m_Description, Engine2.m_Description); } return CompAveragePredictTime&lt;std::less&lt;MIL_DOUBLE&gt;&gt;(Engine1, Engine2); } template&lt;typename Cmp&gt; bool CompPrecision(const SPredictEngine&amp; Engine1, const SPredictEngine&amp; Engine2) { if(Engine1.m_PrecisionString != Engine2.m_PrecisionString) { return Cmp()(Engine1.m_PrecisionString, Engine2.m_PrecisionString); } return CompAveragePredictTime&lt;std::less&lt;MIL_DOUBLE&gt;&gt;(Engine1, Engine2); } template&lt;typename Cmp&gt; bool CompNbCores(const SPredictEngine&amp; Engine1, const SPredictEngine&amp; Engine2) { if(Engine1.m_NbCores != Engine2.m_NbCores) { return Cmp()(Engine1.m_NbCores, Engine2.m_NbCores); } return CompAveragePredictTime&lt;std::less&lt;MIL_DOUBLE&gt;&gt;(Engine1, Engine2); } MIL_INT GetAveragePredictTime(MIL_INT NbPredictions, MIL_ID Classifier, MIL_ID TestBuffer, MIL_ID PredictResult, MIL_DOUBLE* pAveragePredictTime) { MIL_INT Status = M_COMPLETE; MIL_DOUBLE Millisec = 0.0; for(MIL_INT i = 0; i &lt; NbPredictions &amp;&amp; Status == M_COMPLETE; ++i) { MappTimer(M_DEFAULT, M_TIMER_RESET, M_NULL); MclassPredict(Classifier, TestBuffer, PredictResult, M_DEFAULT); const MIL_DOUBLE PredictTime = MappTimer(M_DEFAULT, M_TIMER_READ, M_NULL); MclassGetResult(PredictResult, M_DEFAULT, M_STATUS + M_TYPE_MIL_INT, &amp;Status); Millisec += 1000.0 * PredictTime; } if(Status == M_COMPLETE) { *pAveragePredictTime = Millisec / NbPredictions; } else { *pAveragePredictTime = -1.0; } return Status; } void PrintStatus(MIL_INT Status) { if(Status != M_COMPLETE) { MosPrintf(MIL_TEXT(\"The average predict time for the previous configuration is unavailable.\\n\")); MosPrintf(MIL_TEXT(\"The status returned was: \")); switch(Status) { default: case M_INTERNAL_ERROR: MosPrintf(MIL_TEXT(\"M_INTERNAL_ERROR\\n\")); break; case M_PREDICT_NOT_PERFORMED: MosPrintf(MIL_TEXT(\"M_PREDICT_NOT_PERFORMED\\n\")); break; case M_CURRENTLY_PREDICTING: MosPrintf(MIL_TEXT(\"M_CURRENTLY_PREDICTING\\n\")); break; case M_STOPPED_BY_REQUEST: MosPrintf(MIL_TEXT(\"M_STOPPED_BY_REQUEST\\n\")); break; case M_TIMEOUT_REACHED: MosPrintf(MIL_TEXT(\"M_TIMEOUT_REACHED\\n\")); break; case M_NOT_ENOUGH_MEMORY: MosPrintf(MIL_TEXT(\"M_NOT_ENOUGH_MEMORY\\n\")); break; case M_INVALID_REGION_BUFFER: MosPrintf(MIL_TEXT(\"M_INVALID_REGION_BUFFER\\n\")); break; } } } void EvaluatePredictEngines(MIL_ID MilApplication, MIL_ID Classifier, MIL_ID PredictResult, MIL_ID TestBuffer) { if(NETWORK.find(MIL_TEXT(\"CSNET\")) != MIL_STRING::npos) { MclassControl(Classifier, M_DEFAULT, M_TARGET_IMAGE_SIZE_X, SIZE_X); MclassControl(Classifier, M_DEFAULT, M_TARGET_IMAGE_SIZE_Y, SIZE_Y); } MIL_STRING Description {}; MIL_STRING ProviderString {}; MIL_STRING PrecisionString {}; // Default predict engine defined in MILConfig MIL_INT DefaultProviderIndex = 0; MclassInquire(Classifier, M_DEFAULT, M_PREDICT_ENGINE_USED + M_TYPE_MIL_INT + M_DEFAULT, &amp;DefaultProviderIndex); GetPredictEngineInfo(Classifier, DefaultProviderIndex, &amp;ProviderString, &amp;Description, &amp;PrecisionString); MosPrintf(MIL_TEXT(\"\\n*******************************************************\\n\")); MosPrintf(MIL_TEXT(\"Default Predict Engine:\\n\")); MosPrintf(MIL_TEXT(\"*******************************************************\\n\")); if(DefaultProviderIndex == M_INVALID) { MosPrintf(MIL_TEXT(\"\\nDefault predict engine index cannot be found, \\nplease select a new one in MIL Config.\\n\")); } else { MosPrintf(MIL_TEXT(\"\\nIdx| Provider | Description |Prec\\n\")); MosPrintf(MIL_TEXT(\"---+----------+--------------------------------------------+----\\n\")); MosPrintf(MIL_TEXT(\"%3d|\"), DefaultProviderIndex); MosPrintf(MIL_TEXT(\"%10.10s|\"), ProviderString.c_str()); MosPrintf(MIL_TEXT(\"%44.44s|\"), Description.c_str()); MosPrintf(MIL_TEXT(\"%4.4s|\"), PrecisionString.c_str()); } MosPrintf(MIL_TEXT(\"\\n\\n*******************************************************\\n\")); MosPrintf(MIL_TEXT(\"Available Predict Engines:\\n\")); MosPrintf(MIL_TEXT(\"*******************************************************\\n\")); MosPrintf(MIL_TEXT(\"\\nPredicting with M_%s on images of size: %dx%dx%d\\n\"), NETWORK.c_str(), NUMBER_OF_BANDS, SIZE_X, SIZE_Y); MosPrintf(MIL_TEXT(\"\\nTo also predict on low number of cores press &lt;y&gt;.\\n\")); MosPrintf(MIL_TEXT(\"Press any other key to continue.\\n\\n\")); char KeyVal = (char)MosGetch(); bool IncludeLowCores = false; switch (KeyVal) { case 'Y': case 'y': IncludeLowCores = true; break; } MIL_STRING TableHeader = MIL_TEXT(\"Idx| Provider | Description |Prec|Cores|Time (ms)\"); MIL_STRING TableSeperator = MIL_TEXT(\"---+----------+------------------------------------------+----+-----+---------\"); MosPrintf(MIL_TEXT(\"\\n%s\"), TableHeader.c_str()); MosPrintf(MIL_TEXT(\"\\n%s\\n\"), TableSeperator.c_str()); std::set&lt;MIL_INT&gt; NbCores = GetNbCoreSet(IncludeLowCores); std::vector&lt;SPredictEngine&gt; PredictEngines {}; MIL_INT NbPredEngines = 0; MclassInquire(Classifier, M_DEFAULT, M_NUMBER_OF_PREDICT_ENGINES + M_TYPE_MIL_INT, &amp;NbPredEngines); for(MIL_INT PredictEngineIndex = 0; PredictEngineIndex &lt; NbPredEngines; ++PredictEngineIndex) { GetPredictEngineInfo(Classifier, PredictEngineIndex, &amp;ProviderString, &amp;Description, &amp;PrecisionString); for(const auto&amp; NbCore : NbCores) { if(NbCore == 1) { MappControlMp(MilApplication, M_MP_USE, M_DEFAULT, M_DISABLE, M_NULL); } else { MappControlMp(MilApplication, M_MP_USE, M_DEFAULT, M_ENABLE, M_NULL); MappControlMp(MilApplication, M_CORE_MAX, M_DEFAULT, NbCore, M_NULL); } // On GPU and iGPU number of cores will have a minimal affect so we can skip looping through the different // number of cores if(NbCore != *NbCores.rbegin() &amp;&amp; (ProviderString == MIL_TEXT(\"CUDA\") || (ProviderString == MIL_TEXT(\"OpenVINO\") &amp;&amp; Description.find(MIL_TEXT(\"iGPU\")) != MIL_STRING::npos))) { continue; } MclassControl(Classifier, M_DEFAULT, M_PREDICT_ENGINE, PredictEngineIndex); MclassPreprocess(Classifier, M_DEFAULT); MIL_INT WarmUpPredictions = NUMBER_OF_PREDICTIONS / 10; MIL_DOUBLE AveragePredictTime = 0; MIL_INT Status = GetAveragePredictTime(WarmUpPredictions, Classifier, TestBuffer, PredictResult, &amp;AveragePredictTime); if(Status == M_COMPLETE) { Status = GetAveragePredictTime(NUMBER_OF_PREDICTIONS - WarmUpPredictions, Classifier, TestBuffer, PredictResult, &amp;AveragePredictTime); } SPredictEngine PredictEngine = SPredictEngine(PredictEngineIndex, ProviderString, Description, PrecisionString, NbCore, AveragePredictTime); PredictEngine.PrintInfo(); if(Status == M_COMPLETE) { PredictEngines.push_back(PredictEngine); } PrintStatus(Status); } MclassPreprocess(Classifier, M_RESET); } MosPrintf(MIL_TEXT(\"%s\\n\\n\"), TableSeperator.c_str()); MosPrintf(MIL_TEXT(\"Press any key to continue.\\n\\n\")); MosGetch(); KeyVal = '6'; char OldKeyVal {}; bool UseGreaterComparison {}; while(KeyVal == '1' || KeyVal == '2' || KeyVal == '3' || KeyVal == '4' || KeyVal == '5' || KeyVal == '6') { MosPrintf(MIL_TEXT(\"Predicting with M_%s on images of size: %dx%dx%d\\n\\n\"), NETWORK.c_str(), NUMBER_OF_BANDS, SIZE_X, SIZE_Y); MosPrintf(MIL_TEXT(\"You can now sort the table by the desired column:\\n\")); MosPrintf(MIL_TEXT(\"1) Index\\n\")); MosPrintf(MIL_TEXT(\"2) Provider\\n\")); MosPrintf(MIL_TEXT(\"3) Description\\n\")); MosPrintf(MIL_TEXT(\"4) Precision\\n\")); MosPrintf(MIL_TEXT(\"5) Number of Cores\\n\")); MosPrintf(MIL_TEXT(\"6) Average Predict Time (default)\\n\\n\")); MosPrintf(MIL_TEXT(\"\\n%s\"), TableHeader.c_str()); MosPrintf(MIL_TEXT(\"\\n%s\\n\"), TableSeperator.c_str()); if(OldKeyVal == KeyVal) { UseGreaterComparison = !UseGreaterComparison; } else { UseGreaterComparison = false; } switch(KeyVal) { default: case '6': if(UseGreaterComparison) std::sort(PredictEngines.begin(), PredictEngines.end(), CompAveragePredictTime&lt;std::greater&lt;MIL_DOUBLE&gt;&gt;); else std::sort(PredictEngines.begin(), PredictEngines.end(), CompAveragePredictTime&lt;std::less&lt;MIL_DOUBLE&gt;&gt;); break; case '1': if(UseGreaterComparison) std::sort(PredictEngines.begin(), PredictEngines.end(), CompIndex&lt;std::greater&lt;MIL_INT&gt;&gt;); else std::sort(PredictEngines.begin(), PredictEngines.end(), CompIndex&lt;std::less&lt;MIL_INT&gt;&gt;); break; case '2': if(UseGreaterComparison) std::sort(PredictEngines.begin(), PredictEngines.end(), CompProvider&lt;std::greater&lt;MIL_STRING&gt;&gt;); else std::sort(PredictEngines.begin(), PredictEngines.end(), CompProvider&lt;std::less&lt;MIL_STRING&gt;&gt;); break; case '3': if(UseGreaterComparison) std::sort(PredictEngines.begin(), PredictEngines.end(), CompDescription&lt;std::greater&lt;MIL_STRING&gt;&gt;); else std::sort(PredictEngines.begin(), PredictEngines.end(), CompDescription&lt;std::less&lt;MIL_STRING&gt;&gt;); break; case '4': if(UseGreaterComparison) std::sort(PredictEngines.begin(), PredictEngines.end(), CompPrecision&lt;std::greater&lt;MIL_STRING&gt;&gt;); else std::sort(PredictEngines.begin(), PredictEngines.end(), CompPrecision&lt;std::less&lt;MIL_STRING&gt;&gt;); break; case '5': if(UseGreaterComparison) std::sort(PredictEngines.begin(), PredictEngines.end(), CompNbCores&lt;std::greater&lt;MIL_INT&gt;&gt;); else std::sort(PredictEngines.begin(), PredictEngines.end(), CompNbCores&lt;std::less&lt;MIL_INT&gt;&gt;); break; } for(const auto&amp; PredictEngine : PredictEngines) { PredictEngine.PrintInfo(); } MosPrintf(MIL_TEXT(\"%s\\n\\n\"), TableSeperator.c_str()); MosPrintf(MIL_TEXT(\"Press any key to exit.\\n\\n\")); OldKeyVal = KeyVal; KeyVal = (char)MosGetch(); } } ",
      "wordCount": 2058
    }
  ]
}]